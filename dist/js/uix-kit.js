/*!
 * 
 * DO NOT OVERRIDE THIS FILE.
 * Generated with "npm run build"
 *
 * ## Project Name        :  Uix Kit
 * ## Project Description :  A free web kits for fast web design and development, compatible with Bootstrap v5.
 * ## Project URL         :  https://uiux.cc
 * ## Version             :  4.7.2
 * ## Based on            :  Uix Kit (https://github.com/xizon/uix-kit)
 * ## Last Update         :  November 28, 2022
 * ## Created by          :  UIUX Lab (https://uiux.cc) (uiuxlab@gmail.com)
 * ## Released under the MIT license.
 *
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 696:
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ML": () => (/* binding */ _gsScope)
/* harmony export */ });
/* unused harmony exports TweenLite, globals, default, SimpleTimeline, Animation, Ease, Linear, Power0, Power1, Power2, Power3, Power4, TweenPlugin, EventDispatcher */
/* harmony import */ var _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* module decorator */ module = __webpack_require__.hmd(module);


/*!
 * VERSION: 2.1.3
 * DATE: 2019-05-17
 * UPDATES AND DOCS AT: http://greensock.com
 *
 * @license Copyright (c) 2008-2019, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 *
 * @author: Jack Doyle, jack@greensock.com
 */

/* eslint-disable */

/* ES6 changes:
	- declare and export _gsScope at top.
	- set var TweenLite = the result of the main function
	- export default TweenLite at the bottom
	- return TweenLite at the bottom of the main function
	- pass in _gsScope as the first parameter of the main function (which is actually at the bottom)
	- remove the "export to multiple environments" in Definition().
 */
var _gsScope = typeof window !== "undefined" ? window :  true && module.exports && typeof __webpack_require__.g !== "undefined" ? __webpack_require__.g : undefined || {};
var TweenLite = function (window) {
  "use strict";

  var _exports = {},
      _doc = window.document,
      _globals = window.GreenSockGlobals = window.GreenSockGlobals || window;

  if (_globals.TweenLite) {
    return _globals.TweenLite; //in case the core set of classes is already loaded, don't instantiate twice.
  }

  var _namespace = function _namespace(ns) {
    var a = ns.split("."),
        p = _globals,
        i;

    for (i = 0; i < a.length; i++) {
      p[a[i]] = p = p[a[i]] || {};
    }

    return p;
  },
      gs = _namespace("com.greensock"),
      _tinyNum = 0.00000001,
      _slice = function _slice(a) {
    //don't use Array.prototype.slice.call(target, 0) because that doesn't work in IE8 with a NodeList that's returned by querySelectorAll()
    var b = [],
        l = a.length,
        i;

    for (i = 0; i !== l; b.push(a[i++])) {}

    return b;
  },
      _emptyFunc = function _emptyFunc() {},
      _isArray = function () {
    //works around issues in iframe environments where the Array global isn't shared, thus if the object originates in a different window/iframe, "(obj instanceof Array)" will evaluate false. We added some speed optimizations to avoid Object.prototype.toString.call() unless it's absolutely necessary because it's VERY slow (like 20x slower)
    var toString = Object.prototype.toString,
        array = toString.call([]);
    return function (obj) {
      return obj != null && (obj instanceof Array || (0,_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(obj) === "object" && !!obj.push && toString.call(obj) === array);
    };
  }(),
      a,
      i,
      p,
      _ticker,
      _tickerActive,
      _defLookup = {},

  /**
   * @constructor
   * Defines a GreenSock class, optionally with an array of dependencies that must be instantiated first and passed into the definition.
   * This allows users to load GreenSock JS files in any order even if they have interdependencies (like CSSPlugin extends TweenPlugin which is
   * inside TweenLite.js, but if CSSPlugin is loaded first, it should wait to run its code until TweenLite.js loads and instantiates TweenPlugin
   * and then pass TweenPlugin to CSSPlugin's definition). This is all done automatically and internally.
   *
   * Every definition will be added to a "com.greensock" global object (typically window, but if a window.GreenSockGlobals object is found,
   * it will go there as of v1.7). For example, TweenLite will be found at window.com.greensock.TweenLite and since it's a global class that should be available anywhere,
   * it is ALSO referenced at window.TweenLite. However some classes aren't considered global, like the base com.greensock.core.Animation class, so
   * those will only be at the package like window.com.greensock.core.Animation. Again, if you define a GreenSockGlobals object on the window, everything
   * gets tucked neatly inside there instead of on the window directly. This allows you to do advanced things like load multiple versions of GreenSock
   * files and put them into distinct objects (imagine a banner ad uses a newer version but the main site uses an older one). In that case, you could
   * sandbox the banner one like:
   *
   * <script>
   *     var gs = window.GreenSockGlobals = {}; //the newer version we're about to load could now be referenced in a "gs" object, like gs.TweenLite.to(...). Use whatever alias you want as long as it's unique, "gs" or "banner" or whatever.
   * </script>
   * <script src="js/greensock/v1.7/TweenMax.js"></script>
   * <script>
   *     window.GreenSockGlobals = window._gsQueue = window._gsDefine = null; //reset it back to null (along with the special _gsQueue variable) so that the next load of TweenMax affects the window and we can reference things directly like TweenLite.to(...)
   * </script>
   * <script src="js/greensock/v1.6/TweenMax.js"></script>
   * <script>
   *     gs.TweenLite.to(...); //would use v1.7
   *     TweenLite.to(...); //would use v1.6
   * </script>
   *
   * @param {!string} ns The namespace of the class definition, leaving off "com.greensock." as that's assumed. For example, "TweenLite" or "plugins.CSSPlugin" or "easing.Back".
   * @param {!Array.<string>} dependencies An array of dependencies (described as their namespaces minus "com.greensock." prefix). For example ["TweenLite","plugins.TweenPlugin","core.Animation"]
   * @param {!function():Object} func The function that should be called and passed the resolved dependencies which will return the actual class for this definition.
   * @param {boolean=} global If true, the class will be added to the global scope (typically window unless you define a window.GreenSockGlobals object)
   */
  Definition = function Definition(ns, dependencies, func, global) {
    this.sc = _defLookup[ns] ? _defLookup[ns].sc : []; //subclasses

    _defLookup[ns] = this;
    this.gsClass = null;
    this.func = func;
    var _classes = [];

    this.check = function (init) {
      var i = dependencies.length,
          missing = i,
          cur,
          a,
          n,
          cl;

      while (--i > -1) {
        if ((cur = _defLookup[dependencies[i]] || new Definition(dependencies[i], [])).gsClass) {
          _classes[i] = cur.gsClass;
          missing--;
        } else if (init) {
          cur.sc.push(this);
        }
      }

      if (missing === 0 && func) {
        a = ("com.greensock." + ns).split(".");
        n = a.pop();
        cl = _namespace(a.join("."))[n] = this.gsClass = func.apply(func, _classes); //exports to multiple environments

        if (global) {
          _globals[n] = _exports[n] = cl; //provides a way to avoid global namespace pollution. By default, the main classes like TweenLite, Power1, Strong, etc. are added to window unless a GreenSockGlobals is defined. So if you want to have things added to a custom object instead, just do something like window.GreenSockGlobals = {} before loading any GreenSock files. You can even set up an alias like window.GreenSockGlobals = windows.gs = {} so that you can access everything like gs.TweenLite. Also remember that ALL classes are added to the window.com.greensock object (in their respective packages, like com.greensock.easing.Power1, com.greensock.TweenLite, etc.)

          /*
          if (typeof(module) !== "undefined" && module.exports) { //node
          	if (ns === moduleName) {
          		module.exports = _exports[moduleName] = cl;
          		for (i in _exports) {
          			cl[i] = _exports[i];
          		}
          	} else if (_exports[moduleName]) {
          		_exports[moduleName][n] = cl;
          	}
          } else if (typeof(define) === "function" && define.amd){ //AMD
          	define((window.GreenSockAMDPath ? window.GreenSockAMDPath + "/" : "") + ns.split(".").pop(), [], function() { return cl; });
          }
          */
        }

        for (i = 0; i < this.sc.length; i++) {
          this.sc[i].check();
        }
      }
    };

    this.check(true);
  },
      //used to create Definition instances (which basically registers a class that has dependencies).
  _gsDefine = window._gsDefine = function (ns, dependencies, func, global) {
    return new Definition(ns, dependencies, func, global);
  },
      //a quick way to create a class that doesn't have any dependencies. Returns the class, but first registers it in the GreenSock namespace so that other classes can grab it (other classes might be dependent on the class).
  _class = gs._class = function (ns, func, global) {
    func = func || function () {};

    _gsDefine(ns, [], function () {
      return func;
    }, global);

    return func;
  };

  _gsDefine.globals = _globals;
  /*
   * ----------------------------------------------------------------
   * Ease
   * ----------------------------------------------------------------
   */

  var _baseParams = [0, 0, 1, 1],
      Ease = _class("easing.Ease", function (func, extraParams, type, power) {
    this._func = func;
    this._type = type || 0;
    this._power = power || 0;
    this._params = extraParams ? _baseParams.concat(extraParams) : _baseParams;
  }, true),
      _easeMap = Ease.map = {},
      _easeReg = Ease.register = function (ease, names, types, create) {
    var na = names.split(","),
        i = na.length,
        ta = (types || "easeIn,easeOut,easeInOut").split(","),
        e,
        name,
        j,
        type;

    while (--i > -1) {
      name = na[i];
      e = create ? _class("easing." + name, null, true) : gs.easing[name] || {};
      j = ta.length;

      while (--j > -1) {
        type = ta[j];
        _easeMap[name + "." + type] = _easeMap[type + name] = e[type] = ease.getRatio ? ease : ease[type] || new ease();
      }
    }
  };

  p = Ease.prototype;
  p._calcEnd = false;

  p.getRatio = function (p) {
    if (this._func) {
      this._params[0] = p;
      return this._func.apply(null, this._params);
    }

    var t = this._type,
        pw = this._power,
        r = t === 1 ? 1 - p : t === 2 ? p : p < 0.5 ? p * 2 : (1 - p) * 2;

    if (pw === 1) {
      r *= r;
    } else if (pw === 2) {
      r *= r * r;
    } else if (pw === 3) {
      r *= r * r * r;
    } else if (pw === 4) {
      r *= r * r * r * r;
    }

    return t === 1 ? 1 - r : t === 2 ? r : p < 0.5 ? r / 2 : 1 - r / 2;
  }; //create all the standard eases like Linear, Quad, Cubic, Quart, Quint, Strong, Power0, Power1, Power2, Power3, and Power4 (each with easeIn, easeOut, and easeInOut)


  a = ["Linear", "Quad", "Cubic", "Quart", "Quint,Strong"];
  i = a.length;

  while (--i > -1) {
    p = a[i] + ",Power" + i;

    _easeReg(new Ease(null, null, 1, i), p, "easeOut", true);

    _easeReg(new Ease(null, null, 2, i), p, "easeIn" + (i === 0 ? ",easeNone" : ""));

    _easeReg(new Ease(null, null, 3, i), p, "easeInOut");
  }

  _easeMap.linear = gs.easing.Linear.easeIn;
  _easeMap.swing = gs.easing.Quad.easeInOut; //for jQuery folks

  /*
   * ----------------------------------------------------------------
   * EventDispatcher
   * ----------------------------------------------------------------
   */

  var EventDispatcher = _class("events.EventDispatcher", function (target) {
    this._listeners = {};
    this._eventTarget = target || this;
  });

  p = EventDispatcher.prototype;

  p.addEventListener = function (type, callback, scope, useParam, priority) {
    priority = priority || 0;
    var list = this._listeners[type],
        index = 0,
        listener,
        i;

    if (this === _ticker && !_tickerActive) {
      _ticker.wake();
    }

    if (list == null) {
      this._listeners[type] = list = [];
    }

    i = list.length;

    while (--i > -1) {
      listener = list[i];

      if (listener.c === callback && listener.s === scope) {
        list.splice(i, 1);
      } else if (index === 0 && listener.pr < priority) {
        index = i + 1;
      }
    }

    list.splice(index, 0, {
      c: callback,
      s: scope,
      up: useParam,
      pr: priority
    });
  };

  p.removeEventListener = function (type, callback) {
    var list = this._listeners[type],
        i;

    if (list) {
      i = list.length;

      while (--i > -1) {
        if (list[i].c === callback) {
          list.splice(i, 1);
          return;
        }
      }
    }
  };

  p.dispatchEvent = function (type) {
    var list = this._listeners[type],
        i,
        t,
        listener;

    if (list) {
      i = list.length;

      if (i > 1) {
        list = list.slice(0); //in case addEventListener() is called from within a listener/callback (otherwise the index could change, resulting in a skip)
      }

      t = this._eventTarget;

      while (--i > -1) {
        listener = list[i];

        if (listener) {
          if (listener.up) {
            listener.c.call(listener.s || t, {
              type: type,
              target: t
            });
          } else {
            listener.c.call(listener.s || t);
          }
        }
      }
    }
  };
  /*
   * ----------------------------------------------------------------
   * Ticker
   * ----------------------------------------------------------------
   */


  var _reqAnimFrame = window.requestAnimationFrame,
      _cancelAnimFrame = window.cancelAnimationFrame,
      _getTime = Date.now || function () {
    return new Date().getTime();
  },
      _lastUpdate = _getTime(); //now try to determine the requestAnimationFrame and cancelAnimationFrame functions and if none are found, we'll use a setTimeout()/clearTimeout() polyfill.


  a = ["ms", "moz", "webkit", "o"];
  i = a.length;

  while (--i > -1 && !_reqAnimFrame) {
    _reqAnimFrame = window[a[i] + "RequestAnimationFrame"];
    _cancelAnimFrame = window[a[i] + "CancelAnimationFrame"] || window[a[i] + "CancelRequestAnimationFrame"];
  }

  _class("Ticker", function (fps, useRAF) {
    var _self = this,
        _startTime = _getTime(),
        _useRAF = useRAF !== false && _reqAnimFrame ? "auto" : false,
        _lagThreshold = 500,
        _adjustedLag = 33,
        _tickWord = "tick",
        //helps reduce gc burden
    _fps,
        _req,
        _id,
        _gap,
        _nextTime,
        _tick = function _tick(manual) {
      var elapsed = _getTime() - _lastUpdate,
          overlap,
          dispatch;

      if (elapsed > _lagThreshold) {
        _startTime += elapsed - _adjustedLag;
      }

      _lastUpdate += elapsed;
      _self.time = (_lastUpdate - _startTime) / 1000;
      overlap = _self.time - _nextTime;

      if (!_fps || overlap > 0 || manual === true) {
        _self.frame++;
        _nextTime += overlap + (overlap >= _gap ? 0.004 : _gap - overlap);
        dispatch = true;
      }

      if (manual !== true) {
        //make sure the request is made before we dispatch the "tick" event so that timing is maintained. Otherwise, if processing the "tick" requires a bunch of time (like 15ms) and we're using a setTimeout() that's based on 16.7ms, it'd technically take 31.7ms between frames otherwise.
        _id = _req(_tick);
      }

      if (dispatch) {
        _self.dispatchEvent(_tickWord);
      }
    };

    EventDispatcher.call(_self);
    _self.time = _self.frame = 0;

    _self.tick = function () {
      _tick(true);
    };

    _self.lagSmoothing = function (threshold, adjustedLag) {
      if (!arguments.length) {
        //if lagSmoothing() is called with no arguments, treat it like a getter that returns a boolean indicating if it's enabled or not. This is purposely undocumented and is for internal use.
        return _lagThreshold < 1 / _tinyNum;
      }

      _lagThreshold = threshold || 1 / _tinyNum; //zero should be interpreted as basically unlimited

      _adjustedLag = Math.min(adjustedLag, _lagThreshold, 0);
    };

    _self.sleep = function () {
      if (_id == null) {
        return;
      }

      if (!_useRAF || !_cancelAnimFrame) {
        clearTimeout(_id);
      } else {
        _cancelAnimFrame(_id);
      }

      _req = _emptyFunc;
      _id = null;

      if (_self === _ticker) {
        _tickerActive = false;
      }
    };

    _self.wake = function (seamless) {
      if (_id !== null) {
        _self.sleep();
      } else if (seamless) {
        _startTime += -_lastUpdate + (_lastUpdate = _getTime());
      } else if (_self.frame > 10) {
        //don't trigger lagSmoothing if we're just waking up, and make sure that at least 10 frames have elapsed because of the iOS bug that we work around below with the 1.5-second setTimout().
        _lastUpdate = _getTime() - _lagThreshold + 5;
      }

      _req = _fps === 0 ? _emptyFunc : !_useRAF || !_reqAnimFrame ? function (f) {
        return setTimeout(f, (_nextTime - _self.time) * 1000 + 1 | 0);
      } : _reqAnimFrame;

      if (_self === _ticker) {
        _tickerActive = true;
      }

      _tick(2);
    };

    _self.fps = function (value) {
      if (!arguments.length) {
        return _fps;
      }

      _fps = value;
      _gap = 1 / (_fps || 60);
      _nextTime = this.time + _gap;

      _self.wake();
    };

    _self.useRAF = function (value) {
      if (!arguments.length) {
        return _useRAF;
      }

      _self.sleep();

      _useRAF = value;

      _self.fps(_fps);
    };

    _self.fps(fps); //a bug in iOS 6 Safari occasionally prevents the requestAnimationFrame from working initially, so we use a 1.5-second timeout that automatically falls back to setTimeout() if it senses this condition.


    setTimeout(function () {
      if (_useRAF === "auto" && _self.frame < 5 && (_doc || {}).visibilityState !== "hidden") {
        _self.useRAF(false);
      }
    }, 1500);
  });

  p = gs.Ticker.prototype = new gs.events.EventDispatcher();
  p.constructor = gs.Ticker;
  /*
   * ----------------------------------------------------------------
   * Animation
   * ----------------------------------------------------------------
   */

  var Animation = _class("core.Animation", function (duration, vars) {
    this.vars = vars = vars || {};
    this._duration = this._totalDuration = duration || 0;
    this._delay = Number(vars.delay) || 0;
    this._timeScale = 1;
    this._active = !!vars.immediateRender;
    this.data = vars.data;
    this._reversed = !!vars.reversed;

    if (!_rootTimeline) {
      return;
    }

    if (!_tickerActive) {
      //some browsers (like iOS 6 Safari) shut down JavaScript execution when the tab is disabled and they [occasionally] neglect to start up requestAnimationFrame again when returning - this code ensures that the engine starts up again properly.
      _ticker.wake();
    }

    var tl = this.vars.useFrames ? _rootFramesTimeline : _rootTimeline;
    tl.add(this, tl._time);

    if (this.vars.paused) {
      this.paused(true);
    }
  });

  _ticker = Animation.ticker = new gs.Ticker();
  p = Animation.prototype;
  p._dirty = p._gc = p._initted = p._paused = false;
  p._totalTime = p._time = 0;
  p._rawPrevTime = -1;
  p._next = p._last = p._onUpdate = p._timeline = p.timeline = null;
  p._paused = false; //some browsers (like iOS) occasionally drop the requestAnimationFrame event when the user switches to a different tab and then comes back again, so we use a 2-second setTimeout() to sense if/when that condition occurs and then wake() the ticker.

  var _checkTimeout = function _checkTimeout() {
    if (_tickerActive && _getTime() - _lastUpdate > 2000 && ((_doc || {}).visibilityState !== "hidden" || !_ticker.lagSmoothing())) {
      //note: if the tab is hidden, we should still wake if lagSmoothing has been disabled.
      _ticker.wake();
    }

    var t = setTimeout(_checkTimeout, 2000);

    if (t.unref) {
      // allows a node process to exit even if the timeout’s callback hasn't been invoked. Without it, the node process could hang as this function is called every two seconds.
      t.unref();
    }
  };

  _checkTimeout();

  p.play = function (from, suppressEvents) {
    if (from != null) {
      this.seek(from, suppressEvents);
    }

    return this.reversed(false).paused(false);
  };

  p.pause = function (atTime, suppressEvents) {
    if (atTime != null) {
      this.seek(atTime, suppressEvents);
    }

    return this.paused(true);
  };

  p.resume = function (from, suppressEvents) {
    if (from != null) {
      this.seek(from, suppressEvents);
    }

    return this.paused(false);
  };

  p.seek = function (time, suppressEvents) {
    return this.totalTime(Number(time), suppressEvents !== false);
  };

  p.restart = function (includeDelay, suppressEvents) {
    return this.reversed(false).paused(false).totalTime(includeDelay ? -this._delay : 0, suppressEvents !== false, true);
  };

  p.reverse = function (from, suppressEvents) {
    if (from != null) {
      this.seek(from || this.totalDuration(), suppressEvents);
    }

    return this.reversed(true).paused(false);
  };

  p.render = function (time, suppressEvents, force) {//stub - we override this method in subclasses.
  };

  p.invalidate = function () {
    this._time = this._totalTime = 0;
    this._initted = this._gc = false;
    this._rawPrevTime = -1;

    if (this._gc || !this.timeline) {
      this._enabled(true);
    }

    return this;
  };

  p.isActive = function () {
    var tl = this._timeline,
        //the 2 root timelines won't have a _timeline; they're always active.
    startTime = this._startTime,
        rawTime;
    return !tl || !this._gc && !this._paused && tl.isActive() && (rawTime = tl.rawTime(true)) >= startTime && rawTime < startTime + this.totalDuration() / this._timeScale - _tinyNum;
  };

  p._enabled = function (enabled, ignoreTimeline) {
    if (!_tickerActive) {
      _ticker.wake();
    }

    this._gc = !enabled;
    this._active = this.isActive();

    if (ignoreTimeline !== true) {
      if (enabled && !this.timeline) {
        this._timeline.add(this, this._startTime - this._delay);
      } else if (!enabled && this.timeline) {
        this._timeline._remove(this, true);
      }
    }

    return false;
  };

  p._kill = function (vars, target) {
    return this._enabled(false, false);
  };

  p.kill = function (vars, target) {
    this._kill(vars, target);

    return this;
  };

  p._uncache = function (includeSelf) {
    var tween = includeSelf ? this : this.timeline;

    while (tween) {
      tween._dirty = true;
      tween = tween.timeline;
    }

    return this;
  };

  p._swapSelfInParams = function (params) {
    var i = params.length,
        copy = params.concat();

    while (--i > -1) {
      if (params[i] === "{self}") {
        copy[i] = this;
      }
    }

    return copy;
  };

  p._callback = function (type) {
    var v = this.vars,
        callback = v[type],
        params = v[type + "Params"],
        scope = v[type + "Scope"] || v.callbackScope || this,
        l = params ? params.length : 0;

    switch (l) {
      //speed optimization; call() is faster than apply() so use it when there are only a few parameters (which is by far most common). Previously we simply did var v = this.vars; v[type].apply(v[type + "Scope"] || v.callbackScope || this, v[type + "Params"] || _blankArray);
      case 0:
        callback.call(scope);
        break;

      case 1:
        callback.call(scope, params[0]);
        break;

      case 2:
        callback.call(scope, params[0], params[1]);
        break;

      default:
        callback.apply(scope, params);
    }
  }; //----Animation getters/setters --------------------------------------------------------


  p.eventCallback = function (type, callback, params, scope) {
    if ((type || "").substr(0, 2) === "on") {
      var v = this.vars;

      if (arguments.length === 1) {
        return v[type];
      }

      if (callback == null) {
        delete v[type];
      } else {
        v[type] = callback;
        v[type + "Params"] = _isArray(params) && params.join("").indexOf("{self}") !== -1 ? this._swapSelfInParams(params) : params;
        v[type + "Scope"] = scope;
      }

      if (type === "onUpdate") {
        this._onUpdate = callback;
      }
    }

    return this;
  };

  p.delay = function (value) {
    if (!arguments.length) {
      return this._delay;
    }

    if (this._timeline.smoothChildTiming) {
      this.startTime(this._startTime + value - this._delay);
    }

    this._delay = value;
    return this;
  };

  p.duration = function (value) {
    if (!arguments.length) {
      this._dirty = false;
      return this._duration;
    }

    this._duration = this._totalDuration = value;

    this._uncache(true); //true in case it's a TweenMax or TimelineMax that has a repeat - we'll need to refresh the totalDuration.


    if (this._timeline.smoothChildTiming) if (this._time > 0) if (this._time < this._duration) if (value !== 0) {
      this.totalTime(this._totalTime * (value / this._duration), true);
    }
    return this;
  };

  p.totalDuration = function (value) {
    this._dirty = false;
    return !arguments.length ? this._totalDuration : this.duration(value);
  };

  p.time = function (value, suppressEvents) {
    if (!arguments.length) {
      return this._time;
    }

    if (this._dirty) {
      this.totalDuration();
    }

    return this.totalTime(value > this._duration ? this._duration : value, suppressEvents);
  };

  p.totalTime = function (time, suppressEvents, uncapped) {
    if (!_tickerActive) {
      _ticker.wake();
    }

    if (!arguments.length) {
      return this._totalTime;
    }

    if (this._timeline) {
      if (time < 0 && !uncapped) {
        time += this.totalDuration();
      }

      if (this._timeline.smoothChildTiming) {
        if (this._dirty) {
          this.totalDuration();
        }

        var totalDuration = this._totalDuration,
            tl = this._timeline;

        if (time > totalDuration && !uncapped) {
          time = totalDuration;
        }

        this._startTime = (this._paused ? this._pauseTime : tl._time) - (!this._reversed ? time : totalDuration - time) / this._timeScale;

        if (!tl._dirty) {
          //for performance improvement. If the parent's cache is already dirty, it already took care of marking the ancestors as dirty too, so skip the function call here.
          this._uncache(false);
        } //in case any of the ancestor timelines had completed but should now be enabled, we should reset their totalTime() which will also ensure that they're lined up properly and enabled. Skip for animations that are on the root (wasteful). Example: a TimelineLite.exportRoot() is performed when there's a paused tween on the root, the export will not complete until that tween is unpaused, but imagine a child gets restarted later, after all [unpaused] tweens have completed. The startTime of that child would get pushed out, but one of the ancestors may have completed.


        if (tl._timeline) {
          while (tl._timeline) {
            if (tl._timeline._time !== (tl._startTime + tl._totalTime) / tl._timeScale) {
              tl.totalTime(tl._totalTime, true);
            }

            tl = tl._timeline;
          }
        }
      }

      if (this._gc) {
        this._enabled(true, false);
      }

      if (this._totalTime !== time || this._duration === 0) {
        if (_lazyTweens.length) {
          _lazyRender();
        }

        this.render(time, suppressEvents, false);

        if (_lazyTweens.length) {
          //in case rendering caused any tweens to lazy-init, we should render them because typically when someone calls seek() or time() or progress(), they expect an immediate render.
          _lazyRender();
        }
      }
    }

    return this;
  };

  p.progress = p.totalProgress = function (value, suppressEvents) {
    var duration = this.duration();
    return !arguments.length ? duration ? this._time / duration : this.ratio : this.totalTime(duration * value, suppressEvents);
  };

  p.startTime = function (value) {
    if (!arguments.length) {
      return this._startTime;
    }

    if (value !== this._startTime) {
      this._startTime = value;
      if (this.timeline) if (this.timeline._sortChildren) {
        this.timeline.add(this, value - this._delay); //ensures that any necessary re-sequencing of Animations in the timeline occurs to make sure the rendering order is correct.
      }
    }

    return this;
  };

  p.endTime = function (includeRepeats) {
    return this._startTime + (includeRepeats != false ? this.totalDuration() : this.duration()) / this._timeScale;
  };

  p.timeScale = function (value) {
    if (!arguments.length) {
      return this._timeScale;
    }

    var pauseTime, t;
    value = value || _tinyNum; //can't allow zero because it'll throw the math off

    if (this._timeline && this._timeline.smoothChildTiming) {
      pauseTime = this._pauseTime;
      t = pauseTime || pauseTime === 0 ? pauseTime : this._timeline.totalTime();
      this._startTime = t - (t - this._startTime) * this._timeScale / value;
    }

    this._timeScale = value;
    t = this.timeline;

    while (t && t.timeline) {
      //must update the duration/totalDuration of all ancestor timelines immediately in case in the middle of a render loop, one tween alters another tween's timeScale which shoves its startTime before 0, forcing the parent timeline to shift around and shiftChildren() which could affect that next tween's render (startTime). Doesn't matter for the root timeline though.
      t._dirty = true;
      t.totalDuration();
      t = t.timeline;
    }

    return this;
  };

  p.reversed = function (value) {
    if (!arguments.length) {
      return this._reversed;
    }

    if (value != this._reversed) {
      this._reversed = value;
      this.totalTime(this._timeline && !this._timeline.smoothChildTiming ? this.totalDuration() - this._totalTime : this._totalTime, true);
    }

    return this;
  };

  p.paused = function (value) {
    if (!arguments.length) {
      return this._paused;
    }

    var tl = this._timeline,
        raw,
        elapsed;
    if (value != this._paused) if (tl) {
      if (!_tickerActive && !value) {
        _ticker.wake();
      }

      raw = tl.rawTime();
      elapsed = raw - this._pauseTime;

      if (!value && tl.smoothChildTiming) {
        this._startTime += elapsed;

        this._uncache(false);
      }

      this._pauseTime = value ? raw : null;
      this._paused = value;
      this._active = this.isActive();

      if (!value && elapsed !== 0 && this._initted && this.duration()) {
        raw = tl.smoothChildTiming ? this._totalTime : (raw - this._startTime) / this._timeScale;
        this.render(raw, raw === this._totalTime, true); //in case the target's properties changed via some other tween or manual update by the user, we should force a render.
      }
    }

    if (this._gc && !value) {
      this._enabled(true, false);
    }

    return this;
  };
  /*
   * ----------------------------------------------------------------
   * SimpleTimeline
   * ----------------------------------------------------------------
   */


  var SimpleTimeline = _class("core.SimpleTimeline", function (vars) {
    Animation.call(this, 0, vars);
    this.autoRemoveChildren = this.smoothChildTiming = true;
  });

  p = SimpleTimeline.prototype = new Animation();
  p.constructor = SimpleTimeline;
  p.kill()._gc = false;
  p._first = p._last = p._recent = null;
  p._sortChildren = false;

  p.add = p.insert = function (child, position, align, stagger) {
    var prevTween, st;
    child._startTime = Number(position || 0) + child._delay;
    if (child._paused) if (this !== child._timeline) {
      //we only adjust the _pauseTime if it wasn't in this timeline already. Remember, sometimes a tween will be inserted again into the same timeline when its startTime is changed so that the tweens in the TimelineLite/Max are re-ordered properly in the linked list (so everything renders in the proper order).
      child._pauseTime = this.rawTime() - (child._timeline.rawTime() - child._pauseTime);
    }

    if (child.timeline) {
      child.timeline._remove(child, true); //removes from existing timeline so that it can be properly added to this one.

    }

    child.timeline = child._timeline = this;

    if (child._gc) {
      child._enabled(true, true);
    }

    prevTween = this._last;

    if (this._sortChildren) {
      st = child._startTime;

      while (prevTween && prevTween._startTime > st) {
        prevTween = prevTween._prev;
      }
    }

    if (prevTween) {
      child._next = prevTween._next;
      prevTween._next = child;
    } else {
      child._next = this._first;
      this._first = child;
    }

    if (child._next) {
      child._next._prev = child;
    } else {
      this._last = child;
    }

    child._prev = prevTween;
    this._recent = child;

    if (this._timeline) {
      this._uncache(true);
    }

    return this;
  };

  p._remove = function (tween, skipDisable) {
    if (tween.timeline === this) {
      if (!skipDisable) {
        tween._enabled(false, true);
      }

      if (tween._prev) {
        tween._prev._next = tween._next;
      } else if (this._first === tween) {
        this._first = tween._next;
      }

      if (tween._next) {
        tween._next._prev = tween._prev;
      } else if (this._last === tween) {
        this._last = tween._prev;
      }

      tween._next = tween._prev = tween.timeline = null;

      if (tween === this._recent) {
        this._recent = this._last;
      }

      if (this._timeline) {
        this._uncache(true);
      }
    }

    return this;
  };

  p.render = function (time, suppressEvents, force) {
    var tween = this._first,
        next;
    this._totalTime = this._time = this._rawPrevTime = time;

    while (tween) {
      next = tween._next; //record it here because the value could change after rendering...

      if (tween._active || time >= tween._startTime && !tween._paused && !tween._gc) {
        if (!tween._reversed) {
          tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
        } else {
          tween.render((!tween._dirty ? tween._totalDuration : tween.totalDuration()) - (time - tween._startTime) * tween._timeScale, suppressEvents, force);
        }
      }

      tween = next;
    }
  };

  p.rawTime = function () {
    if (!_tickerActive) {
      _ticker.wake();
    }

    return this._totalTime;
  };
  /*
   * ----------------------------------------------------------------
   * TweenLite
   * ----------------------------------------------------------------
   */


  var TweenLite = _class("TweenLite", function (target, duration, vars) {
    Animation.call(this, duration, vars);
    this.render = TweenLite.prototype.render; //speed optimization (avoid prototype lookup on this "hot" method)

    if (target == null) {
      throw "Cannot tween a null target.";
    }

    this.target = target = typeof target !== "string" ? target : TweenLite.selector(target) || target;
    var isSelector = target.jquery || target.length && target !== window && target[0] && (target[0] === window || target[0].nodeType && target[0].style && !target.nodeType),
        overwrite = this.vars.overwrite,
        i,
        targ,
        targets;
    this._overwrite = overwrite = overwrite == null ? _overwriteLookup[TweenLite.defaultOverwrite] : typeof overwrite === "number" ? overwrite >> 0 : _overwriteLookup[overwrite];

    if ((isSelector || target instanceof Array || target.push && _isArray(target)) && typeof target[0] !== "number") {
      this._targets = targets = _slice(target); //don't use Array.prototype.slice.call(target, 0) because that doesn't work in IE8 with a NodeList that's returned by querySelectorAll()

      this._propLookup = [];
      this._siblings = [];

      for (i = 0; i < targets.length; i++) {
        targ = targets[i];

        if (!targ) {
          targets.splice(i--, 1);
          continue;
        } else if (typeof targ === "string") {
          targ = targets[i--] = TweenLite.selector(targ); //in case it's an array of strings

          if (typeof targ === "string") {
            targets.splice(i + 1, 1); //to avoid an endless loop (can't imagine why the selector would return a string, but just in case)
          }

          continue;
        } else if (targ.length && targ !== window && targ[0] && (targ[0] === window || targ[0].nodeType && targ[0].style && !targ.nodeType)) {
          //in case the user is passing in an array of selector objects (like jQuery objects), we need to check one more level and pull things out if necessary. Also note that <select> elements pass all the criteria regarding length and the first child having style, so we must also check to ensure the target isn't an HTML node itself.
          targets.splice(i--, 1);
          this._targets = targets = targets.concat(_slice(targ));
          continue;
        }

        this._siblings[i] = _register(targ, this, false);
        if (overwrite === 1) if (this._siblings[i].length > 1) {
          _applyOverwrite(targ, this, null, 1, this._siblings[i]);
        }
      }
    } else {
      this._propLookup = {};
      this._siblings = _register(target, this, false);
      if (overwrite === 1) if (this._siblings.length > 1) {
        _applyOverwrite(target, this, null, 1, this._siblings);
      }
    }

    if (this.vars.immediateRender || duration === 0 && this._delay === 0 && this.vars.immediateRender !== false) {
      this._time = -_tinyNum; //forces a render without having to set the render() "force" parameter to true because we want to allow lazying by default (using the "force" parameter always forces an immediate full render)

      this.render(Math.min(0, -this._delay)); //in case delay is negative
    }
  }, true),
      _isSelector = function _isSelector(v) {
    return v && v.length && v !== window && v[0] && (v[0] === window || v[0].nodeType && v[0].style && !v.nodeType); //we cannot check "nodeType" if the target is window from within an iframe, otherwise it will trigger a security error in some browsers like Firefox.
  },
      _autoCSS = function _autoCSS(vars, target) {
    var css = {},
        p;

    for (p in vars) {
      if (!_reservedProps[p] && (!(p in target) || p === "transform" || p === "x" || p === "y" || p === "width" || p === "height" || p === "className" || p === "border") && (!_plugins[p] || _plugins[p] && _plugins[p]._autoCSS)) {
        //note: <img> elements contain read-only "x" and "y" properties. We should also prioritize editing css width/height rather than the element's properties.
        css[p] = vars[p];
        delete vars[p];
      }
    }

    vars.css = css;
  };

  p = TweenLite.prototype = new Animation();
  p.constructor = TweenLite;
  p.kill()._gc = false; //----TweenLite defaults, overwrite management, and root updates ----------------------------------------------------

  p.ratio = 0;
  p._firstPT = p._targets = p._overwrittenProps = p._startAt = null;
  p._notifyPluginsOfEnabled = p._lazy = false;
  TweenLite.version = "2.1.3";
  TweenLite.defaultEase = p._ease = new Ease(null, null, 1, 1);
  TweenLite.defaultOverwrite = "auto";
  TweenLite.ticker = _ticker;
  TweenLite.autoSleep = 120;

  TweenLite.lagSmoothing = function (threshold, adjustedLag) {
    _ticker.lagSmoothing(threshold, adjustedLag);
  };

  TweenLite.selector = window.$ || window.jQuery || function (e) {
    var selector = window.$ || window.jQuery;

    if (selector) {
      TweenLite.selector = selector;
      return selector(e);
    }

    if (!_doc) {
      //in some dev environments (like Angular 6), GSAP gets loaded before the document is defined! So re-query it here if/when necessary.
      _doc = window.document;
    }

    return !_doc ? e : _doc.querySelectorAll ? _doc.querySelectorAll(e) : _doc.getElementById(e.charAt(0) === "#" ? e.substr(1) : e);
  };

  var _lazyTweens = [],
      _lazyLookup = {},
      _numbersExp = /(?:(-|-=|\+=)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/ig,
      _relExp = /[\+-]=-?[\.\d]/,
      //_nonNumbersExp = /(?:([\-+](?!(\d|=)))|[^\d\-+=e]|(e(?![\-+][\d])))+/ig,
  _setRatio = function _setRatio(v) {
    var pt = this._firstPT,
        min = 0.000001,
        val;

    while (pt) {
      val = !pt.blob ? pt.c * v + pt.s : v === 1 && this.end != null ? this.end : v ? this.join("") : this.start;

      if (pt.m) {
        val = pt.m.call(this._tween, val, this._target || pt.t, this._tween);
      } else if (val < min) if (val > -min && !pt.blob) {
        //prevents issues with converting very small numbers to strings in the browser
        val = 0;
      }

      if (!pt.f) {
        pt.t[pt.p] = val;
      } else if (pt.fp) {
        pt.t[pt.p](pt.fp, val);
      } else {
        pt.t[pt.p](val);
      }

      pt = pt._next;
    }
  },
      _blobRound = function _blobRound(v) {
    return (v * 1000 | 0) / 1000 + "";
  },
      //compares two strings (start/end), finds the numbers that are different and spits back an array representing the whole value but with the changing values isolated as elements. For example, "rgb(0,0,0)" and "rgb(100,50,0)" would become ["rgb(", 0, ",", 50, ",0)"]. Notice it merges the parts that are identical (performance optimization). The array also has a linked list of PropTweens attached starting with _firstPT that contain the tweening data (t, p, s, c, f, etc.). It also stores the starting value as a "start" property so that we can revert to it if/when necessary, like when a tween rewinds fully. If the quantity of numbers differs between the start and end, it will always prioritize the end value(s). The pt parameter is optional - it's for a PropTween that will be appended to the end of the linked list and is typically for actually setting the value after all of the elements have been updated (with array.join("")).
  _blobDif = function _blobDif(start, end, filter, pt) {
    var a = [],
        charIndex = 0,
        s = "",
        color = 0,
        startNums,
        endNums,
        num,
        i,
        l,
        nonNumbers,
        currentNum;
    a.start = start;
    a.end = end;
    start = a[0] = start + ""; //ensure values are strings

    end = a[1] = end + "";

    if (filter) {
      filter(a); //pass an array with the starting and ending values and let the filter do whatever it needs to the values.

      start = a[0];
      end = a[1];
    }

    a.length = 0;
    startNums = start.match(_numbersExp) || [];
    endNums = end.match(_numbersExp) || [];

    if (pt) {
      pt._next = null;
      pt.blob = 1;
      a._firstPT = a._applyPT = pt; //apply last in the linked list (which means inserting it first)
    }

    l = endNums.length;

    for (i = 0; i < l; i++) {
      currentNum = endNums[i];
      nonNumbers = end.substr(charIndex, end.indexOf(currentNum, charIndex) - charIndex);
      s += nonNumbers || !i ? nonNumbers : ","; //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.

      charIndex += nonNumbers.length;

      if (color) {
        //sense rgba() values and round them.
        color = (color + 1) % 5;
      } else if (nonNumbers.substr(-5) === "rgba(") {
        color = 1;
      }

      if (currentNum === startNums[i] || startNums.length <= i) {
        s += currentNum;
      } else {
        if (s) {
          a.push(s);
          s = "";
        }

        num = parseFloat(startNums[i]);
        a.push(num);
        a._firstPT = {
          _next: a._firstPT,
          t: a,
          p: a.length - 1,
          s: num,
          c: (currentNum.charAt(1) === "=" ? parseInt(currentNum.charAt(0) + "1", 10) * parseFloat(currentNum.substr(2)) : parseFloat(currentNum) - num) || 0,
          f: 0,
          m: color && color < 4 ? Math.round : _blobRound
        }; //limiting to 3 decimal places and casting as a string can really help performance when array.join() is called!
        //note: we don't set _prev because we'll never need to remove individual PropTweens from this list.
      }

      charIndex += currentNum.length;
    }

    s += end.substr(charIndex);

    if (s) {
      a.push(s);
    }

    a.setRatio = _setRatio;

    if (_relExp.test(end)) {
      //if the end string contains relative values, delete it so that on the final render (in _setRatio()), we don't actually set it to the string with += or -= characters (forces it to use the calculated value).
      a.end = null;
    }

    return a;
  },
      //note: "funcParam" is only necessary for function-based getters/setters that require an extra parameter like getAttribute("width") and setAttribute("width", value). In this example, funcParam would be "width". Used by AttrPlugin for example.
  _addPropTween = function _addPropTween(target, prop, start, end, overwriteProp, mod, funcParam, stringFilter, index) {
    if (typeof end === "function") {
      end = end(index || 0, target);
    }

    var type = (0,_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(target[prop]),
        getterName = type !== "function" ? "" : prop.indexOf("set") || typeof target["get" + prop.substr(3)] !== "function" ? prop : "get" + prop.substr(3),
        s = start !== "get" ? start : !getterName ? target[prop] : funcParam ? target[getterName](funcParam) : target[getterName](),
        isRelative = typeof end === "string" && end.charAt(1) === "=",
        pt = {
      t: target,
      p: prop,
      s: s,
      f: type === "function",
      pg: 0,
      n: overwriteProp || prop,
      m: !mod ? 0 : typeof mod === "function" ? mod : Math.round,
      pr: 0,
      c: isRelative ? parseInt(end.charAt(0) + "1", 10) * parseFloat(end.substr(2)) : parseFloat(end) - s || 0
    },
        blob;

    if (typeof s !== "number" || typeof end !== "number" && !isRelative) {
      if (funcParam || isNaN(s) || !isRelative && isNaN(end) || typeof s === "boolean" || typeof end === "boolean") {
        //a blob (string that has multiple numbers in it)
        pt.fp = funcParam;
        blob = _blobDif(s, isRelative ? parseFloat(pt.s) + pt.c + (pt.s + "").replace(/[0-9\-\.]/g, "") : end, stringFilter || TweenLite.defaultStringFilter, pt);
        pt = {
          t: blob,
          p: "setRatio",
          s: 0,
          c: 1,
          f: 2,
          pg: 0,
          n: overwriteProp || prop,
          pr: 0,
          m: 0
        }; //"2" indicates it's a Blob property tween. Needed for RoundPropsPlugin for example.
      } else {
        pt.s = parseFloat(s);

        if (!isRelative) {
          pt.c = parseFloat(end) - pt.s || 0;
        }
      }
    }

    if (pt.c) {
      //only add it to the linked list if there's a change.
      if (pt._next = this._firstPT) {
        pt._next._prev = pt;
      }

      this._firstPT = pt;
      return pt;
    }
  },
      _internals = TweenLite._internals = {
    isArray: _isArray,
    isSelector: _isSelector,
    lazyTweens: _lazyTweens,
    blobDif: _blobDif
  },
      //gives us a way to expose certain private values to other GreenSock classes without contaminating tha main TweenLite object.
  _plugins = TweenLite._plugins = {},
      _tweenLookup = _internals.tweenLookup = {},
      _tweenLookupNum = 0,
      _reservedProps = _internals.reservedProps = {
    ease: 1,
    delay: 1,
    overwrite: 1,
    onComplete: 1,
    onCompleteParams: 1,
    onCompleteScope: 1,
    useFrames: 1,
    runBackwards: 1,
    startAt: 1,
    onUpdate: 1,
    onUpdateParams: 1,
    onUpdateScope: 1,
    onStart: 1,
    onStartParams: 1,
    onStartScope: 1,
    onReverseComplete: 1,
    onReverseCompleteParams: 1,
    onReverseCompleteScope: 1,
    onRepeat: 1,
    onRepeatParams: 1,
    onRepeatScope: 1,
    easeParams: 1,
    yoyo: 1,
    immediateRender: 1,
    repeat: 1,
    repeatDelay: 1,
    data: 1,
    paused: 1,
    reversed: 1,
    autoCSS: 1,
    lazy: 1,
    onOverwrite: 1,
    callbackScope: 1,
    stringFilter: 1,
    id: 1,
    yoyoEase: 1,
    stagger: 1
  },
      _overwriteLookup = {
    none: 0,
    all: 1,
    auto: 2,
    concurrent: 3,
    allOnStart: 4,
    preexisting: 5,
    "true": 1,
    "false": 0
  },
      _rootFramesTimeline = Animation._rootFramesTimeline = new SimpleTimeline(),
      _rootTimeline = Animation._rootTimeline = new SimpleTimeline(),
      _nextGCFrame = 30,
      _lazyRender = _internals.lazyRender = function () {
    var l = _lazyTweens.length,
        i,
        tween;
    _lazyLookup = {};

    for (i = 0; i < l; i++) {
      tween = _lazyTweens[i];

      if (tween && tween._lazy !== false) {
        tween.render(tween._lazy[0], tween._lazy[1], true);
        tween._lazy = false;
      }
    }

    _lazyTweens.length = 0;
  };

  _rootTimeline._startTime = _ticker.time;
  _rootFramesTimeline._startTime = _ticker.frame;
  _rootTimeline._active = _rootFramesTimeline._active = true;
  setTimeout(_lazyRender, 1); //on some mobile devices, there isn't a "tick" before code runs which means any lazy renders wouldn't run before the next official "tick".

  Animation._updateRoot = TweenLite.render = function () {
    var i, a, p;

    if (_lazyTweens.length) {
      //if code is run outside of the requestAnimationFrame loop, there may be tweens queued AFTER the engine refreshed, so we need to ensure any pending renders occur before we refresh again.
      _lazyRender();
    }

    _rootTimeline.render((_ticker.time - _rootTimeline._startTime) * _rootTimeline._timeScale, false, false);

    _rootFramesTimeline.render((_ticker.frame - _rootFramesTimeline._startTime) * _rootFramesTimeline._timeScale, false, false);

    if (_lazyTweens.length) {
      _lazyRender();
    }

    if (_ticker.frame >= _nextGCFrame) {
      //dump garbage every 120 frames or whatever the user sets TweenLite.autoSleep to
      _nextGCFrame = _ticker.frame + (parseInt(TweenLite.autoSleep, 10) || 120);

      for (p in _tweenLookup) {
        a = _tweenLookup[p].tweens;
        i = a.length;

        while (--i > -1) {
          if (a[i]._gc) {
            a.splice(i, 1);
          }
        }

        if (a.length === 0) {
          delete _tweenLookup[p];
        }
      } //if there are no more tweens in the root timelines, or if they're all paused, make the _timer sleep to reduce load on the CPU slightly


      p = _rootTimeline._first;
      if (!p || p._paused) if (TweenLite.autoSleep && !_rootFramesTimeline._first && _ticker._listeners.tick.length === 1) {
        while (p && p._paused) {
          p = p._next;
        }

        if (!p) {
          _ticker.sleep();
        }
      }
    }
  };

  _ticker.addEventListener("tick", Animation._updateRoot);

  var _register = function _register(target, tween, scrub) {
    var id = target._gsTweenID,
        a,
        i;

    if (!_tweenLookup[id || (target._gsTweenID = id = "t" + _tweenLookupNum++)]) {
      _tweenLookup[id] = {
        target: target,
        tweens: []
      };
    }

    if (tween) {
      a = _tweenLookup[id].tweens;
      a[i = a.length] = tween;

      if (scrub) {
        while (--i > -1) {
          if (a[i] === tween) {
            a.splice(i, 1);
          }
        }
      }
    }

    return _tweenLookup[id].tweens;
  },
      _onOverwrite = function _onOverwrite(overwrittenTween, overwritingTween, target, killedProps) {
    var func = overwrittenTween.vars.onOverwrite,
        r1,
        r2;

    if (func) {
      r1 = func(overwrittenTween, overwritingTween, target, killedProps);
    }

    func = TweenLite.onOverwrite;

    if (func) {
      r2 = func(overwrittenTween, overwritingTween, target, killedProps);
    }

    return r1 !== false && r2 !== false;
  },
      _applyOverwrite = function _applyOverwrite(target, tween, props, mode, siblings) {
    var i, changed, curTween, l;

    if (mode === 1 || mode >= 4) {
      l = siblings.length;

      for (i = 0; i < l; i++) {
        if ((curTween = siblings[i]) !== tween) {
          if (!curTween._gc) {
            if (curTween._kill(null, target, tween)) {
              changed = true;
            }
          }
        } else if (mode === 5) {
          break;
        }
      }

      return changed;
    } //NOTE: Add tiny amount to overcome floating point errors that can cause the startTime to be VERY slightly off (when a tween's time() is set for example)


    var startTime = tween._startTime + _tinyNum,
        overlaps = [],
        oCount = 0,
        zeroDur = tween._duration === 0,
        globalStart;
    i = siblings.length;

    while (--i > -1) {
      if ((curTween = siblings[i]) === tween || curTween._gc || curTween._paused) {//ignore
      } else if (curTween._timeline !== tween._timeline) {
        globalStart = globalStart || _checkOverlap(tween, 0, zeroDur);

        if (_checkOverlap(curTween, globalStart, zeroDur) === 0) {
          overlaps[oCount++] = curTween;
        }
      } else if (curTween._startTime <= startTime) if (curTween._startTime + curTween.totalDuration() / curTween._timeScale > startTime) if (!((zeroDur || !curTween._initted) && startTime - curTween._startTime <= _tinyNum * 2)) {
        overlaps[oCount++] = curTween;
      }
    }

    i = oCount;

    while (--i > -1) {
      curTween = overlaps[i];
      l = curTween._firstPT; //we need to discern if there were property tweens originally; if they all get removed in the next line's _kill() call, the tween should be killed. See https://github.com/greensock/GreenSock-JS/issues/278

      if (mode === 2) if (curTween._kill(props, target, tween)) {
        changed = true;
      }

      if (mode !== 2 || !curTween._firstPT && curTween._initted && l) {
        if (mode !== 2 && !_onOverwrite(curTween, tween)) {
          continue;
        }

        if (curTween._enabled(false, false)) {
          //if all property tweens have been overwritten, kill the tween.
          changed = true;
        }
      }
    }

    return changed;
  },
      _checkOverlap = function _checkOverlap(tween, reference, zeroDur) {
    var tl = tween._timeline,
        ts = tl._timeScale,
        t = tween._startTime;

    while (tl._timeline) {
      t += tl._startTime;
      ts *= tl._timeScale;

      if (tl._paused) {
        return -100;
      }

      tl = tl._timeline;
    }

    t /= ts;
    return t > reference ? t - reference : zeroDur && t === reference || !tween._initted && t - reference < 2 * _tinyNum ? _tinyNum : (t += tween.totalDuration() / tween._timeScale / ts) > reference + _tinyNum ? 0 : t - reference - _tinyNum;
  }; //---- TweenLite instance methods -----------------------------------------------------------------------------


  p._init = function () {
    var v = this.vars,
        op = this._overwrittenProps,
        dur = this._duration,
        immediate = !!v.immediateRender,
        ease = v.ease,
        startAt = this._startAt,
        i,
        initPlugins,
        pt,
        p,
        startVars,
        l;

    if (v.startAt) {
      if (startAt) {
        startAt.render(-1, true); //if we've run a startAt previously (when the tween instantiated), we should revert it so that the values re-instantiate correctly particularly for relative tweens. Without this, a TweenLite.fromTo(obj, 1, {x:"+=100"}, {x:"-=100"}), for example, would actually jump to +=200 because the startAt would run twice, doubling the relative change.

        startAt.kill();
      }

      startVars = {};

      for (p in v.startAt) {
        //copy the properties/values into a new object to avoid collisions, like var to = {x:0}, from = {x:500}; timeline.fromTo(e, 1, from, to).fromTo(e, 1, to, from);
        startVars[p] = v.startAt[p];
      }

      startVars.data = "isStart";
      startVars.overwrite = false;
      startVars.immediateRender = true;
      startVars.lazy = immediate && v.lazy !== false;
      startVars.startAt = startVars.delay = null; //no nesting of startAt objects allowed (otherwise it could cause an infinite loop).

      startVars.onUpdate = v.onUpdate;
      startVars.onUpdateParams = v.onUpdateParams;
      startVars.onUpdateScope = v.onUpdateScope || v.callbackScope || this;
      this._startAt = TweenLite.to(this.target || {}, 0, startVars);

      if (immediate) {
        if (this._time > 0) {
          this._startAt = null; //tweens that render immediately (like most from() and fromTo() tweens) shouldn't revert when their parent timeline's playhead goes backward past the startTime because the initial render could have happened anytime and it shouldn't be directly correlated to this tween's startTime. Imagine setting up a complex animation where the beginning states of various objects are rendered immediately but the tween doesn't happen for quite some time - if we revert to the starting values as soon as the playhead goes backward past the tween's startTime, it will throw things off visually. Reversion should only happen in TimelineLite/Max instances where immediateRender was false (which is the default in the convenience methods like from()).
        } else if (dur !== 0) {
          return; //we skip initialization here so that overwriting doesn't occur until the tween actually begins. Otherwise, if you create several immediateRender:true tweens of the same target/properties to drop into a TimelineLite or TimelineMax, the last one created would overwrite the first ones because they didn't get placed into the timeline yet before the first render occurs and kicks in overwriting.
        }
      }
    } else if (v.runBackwards && dur !== 0) {
      //from() tweens must be handled uniquely: their beginning values must be rendered but we don't want overwriting to occur yet (when time is still 0). Wait until the tween actually begins before doing all the routines like overwriting. At that time, we should render at the END of the tween to ensure that things initialize correctly (remember, from() tweens go backwards)
      if (startAt) {
        startAt.render(-1, true);
        startAt.kill();
        this._startAt = null;
      } else {
        if (this._time !== 0) {
          //in rare cases (like if a from() tween runs and then is invalidate()-ed), immediateRender could be true but the initial forced-render gets skipped, so there's no need to force the render in this context when the _time is greater than 0
          immediate = false;
        }

        pt = {};

        for (p in v) {
          //copy props into a new object and skip any reserved props, otherwise onComplete or onUpdate or onStart could fire. We should, however, permit autoCSS to go through.
          if (!_reservedProps[p] || p === "autoCSS") {
            pt[p] = v[p];
          }
        }

        pt.overwrite = 0;
        pt.data = "isFromStart"; //we tag the tween with as "isFromStart" so that if [inside a plugin] we need to only do something at the very END of a tween, we have a way of identifying this tween as merely the one that's setting the beginning values for a "from()" tween. For example, clearProps in CSSPlugin should only get applied at the very END of a tween and without this tag, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in.

        pt.lazy = immediate && v.lazy !== false;
        pt.immediateRender = immediate; //zero-duration tweens render immediately by default, but if we're not specifically instructed to render this tween immediately, we should skip this and merely _init() to record the starting values (rendering them immediately would push them to completion which is wasteful in that case - we'd have to render(-1) immediately after)

        this._startAt = TweenLite.to(this.target, 0, pt);

        if (!immediate) {
          this._startAt._init(); //ensures that the initial values are recorded


          this._startAt._enabled(false); //no need to have the tween render on the next cycle. Disable it because we'll always manually control the renders of the _startAt tween.


          if (this.vars.immediateRender) {
            this._startAt = null;
          }
        } else if (this._time === 0) {
          return;
        }
      }
    }

    this._ease = ease = !ease ? TweenLite.defaultEase : ease instanceof Ease ? ease : typeof ease === "function" ? new Ease(ease, v.easeParams) : _easeMap[ease] || TweenLite.defaultEase;

    if (v.easeParams instanceof Array && ease.config) {
      this._ease = ease.config.apply(ease, v.easeParams);
    }

    this._easeType = this._ease._type;
    this._easePower = this._ease._power;
    this._firstPT = null;

    if (this._targets) {
      l = this._targets.length;

      for (i = 0; i < l; i++) {
        if (this._initProps(this._targets[i], this._propLookup[i] = {}, this._siblings[i], op ? op[i] : null, i)) {
          initPlugins = true;
        }
      }
    } else {
      initPlugins = this._initProps(this.target, this._propLookup, this._siblings, op, 0);
    }

    if (initPlugins) {
      TweenLite._onPluginEvent("_onInitAllProps", this); //reorders the array in order of priority. Uses a static TweenPlugin method in order to minimize file size in TweenLite

    }

    if (op) if (!this._firstPT) if (typeof this.target !== "function") {
      //if all tweening properties have been overwritten, kill the tween. If the target is a function, it's probably a delayedCall so let it live.
      this._enabled(false, false);
    }

    if (v.runBackwards) {
      pt = this._firstPT;

      while (pt) {
        pt.s += pt.c;
        pt.c = -pt.c;
        pt = pt._next;
      }
    }

    this._onUpdate = v.onUpdate;
    this._initted = true;
  };

  p._initProps = function (target, propLookup, siblings, overwrittenProps, index) {
    var p, i, initPlugins, plugin, pt, v;

    if (target == null) {
      return false;
    }

    if (_lazyLookup[target._gsTweenID]) {
      _lazyRender(); //if other tweens of the same target have recently initted but haven't rendered yet, we've got to force the render so that the starting values are correct (imagine populating a timeline with a bunch of sequential tweens and then jumping to the end)

    }

    if (!this.vars.css) if (target.style) if (target !== window && target.nodeType) if (_plugins.css) if (this.vars.autoCSS !== false) {
      //it's so common to use TweenLite/Max to animate the css of DOM elements, we assume that if the target is a DOM element, that's what is intended (a convenience so that users don't have to wrap things in css:{}, although we still recommend it for a slight performance boost and better specificity). Note: we cannot check "nodeType" on the window inside an iframe.
      _autoCSS(this.vars, target);
    }

    for (p in this.vars) {
      v = this.vars[p];

      if (_reservedProps[p]) {
        if (v) if (v instanceof Array || v.push && _isArray(v)) if (v.join("").indexOf("{self}") !== -1) {
          this.vars[p] = v = this._swapSelfInParams(v, this);
        }
      } else if (_plugins[p] && (plugin = new _plugins[p]())._onInitTween(target, this.vars[p], this, index)) {
        //t - target 		[object]
        //p - property 		[string]
        //s - start			[number]
        //c - change		[number]
        //f - isFunction	[boolean]
        //n - name			[string]
        //pg - isPlugin 	[boolean]
        //pr - priority		[number]
        //m - mod           [function | 0]
        this._firstPT = pt = {
          _next: this._firstPT,
          t: plugin,
          p: "setRatio",
          s: 0,
          c: 1,
          f: 1,
          n: p,
          pg: 1,
          pr: plugin._priority,
          m: 0
        };
        i = plugin._overwriteProps.length;

        while (--i > -1) {
          propLookup[plugin._overwriteProps[i]] = this._firstPT;
        }

        if (plugin._priority || plugin._onInitAllProps) {
          initPlugins = true;
        }

        if (plugin._onDisable || plugin._onEnable) {
          this._notifyPluginsOfEnabled = true;
        }

        if (pt._next) {
          pt._next._prev = pt;
        }
      } else {
        propLookup[p] = _addPropTween.call(this, target, p, "get", v, p, 0, null, this.vars.stringFilter, index);
      }
    }

    if (overwrittenProps) if (this._kill(overwrittenProps, target)) {
      //another tween may have tried to overwrite properties of this tween before init() was called (like if two tweens start at the same time, the one created second will run first)
      return this._initProps(target, propLookup, siblings, overwrittenProps, index);
    }
    if (this._overwrite > 1) if (this._firstPT) if (siblings.length > 1) if (_applyOverwrite(target, this, propLookup, this._overwrite, siblings)) {
      this._kill(propLookup, target);

      return this._initProps(target, propLookup, siblings, overwrittenProps, index);
    }
    if (this._firstPT) if (this.vars.lazy !== false && this._duration || this.vars.lazy && !this._duration) {
      //zero duration tweens don't lazy render by default; everything else does.
      _lazyLookup[target._gsTweenID] = true;
    }
    return initPlugins;
  };

  p.render = function (time, suppressEvents, force) {
    var self = this,
        prevTime = self._time,
        duration = self._duration,
        prevRawPrevTime = self._rawPrevTime,
        isComplete,
        callback,
        pt,
        rawPrevTime;

    if (time >= duration - _tinyNum && time >= 0) {
      //to work around occasional floating point math artifacts.
      self._totalTime = self._time = duration;
      self.ratio = self._ease._calcEnd ? self._ease.getRatio(1) : 1;

      if (!self._reversed) {
        isComplete = true;
        callback = "onComplete";
        force = force || self._timeline.autoRemoveChildren; //otherwise, if the animation is unpaused/activated after it's already finished, it doesn't get removed from the parent timeline.
      }

      if (duration === 0) if (self._initted || !self.vars.lazy || force) {
        //zero-duration tweens are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the "playhead" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's "playhead" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.
        if (self._startTime === self._timeline._duration) {
          //if a zero-duration tween is at the VERY end of a timeline and that timeline renders at its end, it will typically add a tiny bit of cushion to the render time to prevent rounding errors from getting in the way of tweens rendering their VERY end. If we then reverse() that timeline, the zero-duration tween will trigger its onReverseComplete even though technically the playhead didn't pass over it again. It's a very specific edge case we must accommodate.
          time = 0;
        }

        if (prevRawPrevTime < 0 || time <= 0 && time >= -_tinyNum || prevRawPrevTime === _tinyNum && self.data !== "isPause") if (prevRawPrevTime !== time) {
          //note: when this.data is "isPause", it's a callback added by addPause() on a timeline that we should not be triggered when LEAVING its exact start time. In other words, tl.addPause(1).play(1) shouldn't pause.
          force = true;

          if (prevRawPrevTime > _tinyNum) {
            callback = "onReverseComplete";
          }
        }
        self._rawPrevTime = rawPrevTime = !suppressEvents || time || prevRawPrevTime === time ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
      }
    } else if (time < _tinyNum) {
      //to work around occasional floating point math artifacts, round super small values to 0.
      self._totalTime = self._time = 0;
      self.ratio = self._ease._calcEnd ? self._ease.getRatio(0) : 0;

      if (prevTime !== 0 || duration === 0 && prevRawPrevTime > 0) {
        callback = "onReverseComplete";
        isComplete = self._reversed;
      }

      if (time > -_tinyNum) {
        time = 0;
      } else if (time < 0) {
        self._active = false;
        if (duration === 0) if (self._initted || !self.vars.lazy || force) {
          //zero-duration tweens are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the "playhead" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's "playhead" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.
          if (prevRawPrevTime >= 0 && !(prevRawPrevTime === _tinyNum && self.data === "isPause")) {
            force = true;
          }

          self._rawPrevTime = rawPrevTime = !suppressEvents || time || prevRawPrevTime === time ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
        }
      }

      if (!self._initted || self._startAt && self._startAt.progress()) {
        //if we render the very beginning (time == 0) of a fromTo(), we must force the render (normal tweens wouldn't need to render at a time of 0 when the prevTime was also 0). This is also mandatory to make sure overwriting kicks in immediately. Also, we check progress() because if startAt has already rendered at its end, we should force a render at its beginning. Otherwise, if you put the playhead directly on top of where a fromTo({immediateRender:false}) starts, and then move it backwards, the from() won't revert its values.
        force = true;
      }
    } else {
      self._totalTime = self._time = time;

      if (self._easeType) {
        var r = time / duration,
            type = self._easeType,
            pow = self._easePower;

        if (type === 1 || type === 3 && r >= 0.5) {
          r = 1 - r;
        }

        if (type === 3) {
          r *= 2;
        }

        if (pow === 1) {
          r *= r;
        } else if (pow === 2) {
          r *= r * r;
        } else if (pow === 3) {
          r *= r * r * r;
        } else if (pow === 4) {
          r *= r * r * r * r;
        }

        self.ratio = type === 1 ? 1 - r : type === 2 ? r : time / duration < 0.5 ? r / 2 : 1 - r / 2;
      } else {
        self.ratio = self._ease.getRatio(time / duration);
      }
    }

    if (self._time === prevTime && !force) {
      return;
    } else if (!self._initted) {
      self._init();

      if (!self._initted || self._gc) {
        //immediateRender tweens typically won't initialize until the playhead advances (_time is greater than 0) in order to ensure that overwriting occurs properly. Also, if all of the tweening properties have been overwritten (which would cause _gc to be true, as set in _init()), we shouldn't continue otherwise an onStart callback could be called for example.
        return;
      } else if (!force && self._firstPT && (self.vars.lazy !== false && self._duration || self.vars.lazy && !self._duration)) {
        self._time = self._totalTime = prevTime;
        self._rawPrevTime = prevRawPrevTime;

        _lazyTweens.push(self);

        self._lazy = [time, suppressEvents];
        return;
      } //_ease is initially set to defaultEase, so now that init() has run, _ease is set properly and we need to recalculate the ratio. Overall this is faster than using conditional logic earlier in the method to avoid having to set ratio twice because we only init() once but renderTime() gets called VERY frequently.


      if (self._time && !isComplete) {
        self.ratio = self._ease.getRatio(self._time / duration);
      } else if (isComplete && self._ease._calcEnd) {
        self.ratio = self._ease.getRatio(self._time === 0 ? 0 : 1);
      }
    }

    if (self._lazy !== false) {
      //in case a lazy render is pending, we should flush it because the new render is occurring now (imagine a lazy tween instantiating and then immediately the user calls tween.seek(tween.duration()), skipping to the end - the end render would be forced, and then if we didn't flush the lazy render, it'd fire AFTER the seek(), rendering it at the wrong time.
      self._lazy = false;
    }

    if (!self._active) if (!self._paused && self._time !== prevTime && time >= 0) {
      self._active = true; //so that if the user renders a tween (as opposed to the timeline rendering it), the timeline is forced to re-render and align it with the proper time/frame on the next rendering cycle. Maybe the tween already finished but the user manually re-renders it as halfway done.
    }

    if (prevTime === 0) {
      if (self._startAt) {
        if (time >= 0) {
          self._startAt.render(time, true, force);
        } else if (!callback) {
          callback = "_dummyGS"; //if no callback is defined, use a dummy value just so that the condition at the end evaluates as true because _startAt should render AFTER the normal render loop when the time is negative. We could handle this in a more intuitive way, of course, but the render loop is the MOST important thing to optimize, so this technique allows us to avoid adding extra conditional logic in a high-frequency area.
        }
      }

      if (self.vars.onStart) if (self._time !== 0 || duration === 0) if (!suppressEvents) {
        self._callback("onStart");
      }
    }

    pt = self._firstPT;

    while (pt) {
      if (pt.f) {
        pt.t[pt.p](pt.c * self.ratio + pt.s);
      } else {
        pt.t[pt.p] = pt.c * self.ratio + pt.s;
      }

      pt = pt._next;
    }

    if (self._onUpdate) {
      if (time < 0) if (self._startAt && time !== -0.0001) {
        //if the tween is positioned at the VERY beginning (_startTime 0) of its parent timeline, it's illegal for the playhead to go back further, so we should not render the recorded startAt values.
        self._startAt.render(time, true, force); //note: for performance reasons, we tuck this conditional logic inside less traveled areas (most tweens don't have an onUpdate). We'd just have it at the end before the onComplete, but the values should be updated before any onUpdate is called, so we ALSO put it here and then if it's not called, we do so later near the onComplete.

      }
      if (!suppressEvents) if (self._time !== prevTime || isComplete || force) {
        self._callback("onUpdate");
      }
    }

    if (callback) if (!self._gc || force) {
      //check _gc because there's a chance that kill() could be called in an onUpdate
      if (time < 0 && self._startAt && !self._onUpdate && time !== -0.0001) {
        //-0.0001 is a special value that we use when looping back to the beginning of a repeated TimelineMax, in which case we shouldn't render the _startAt values.
        self._startAt.render(time, true, force);
      }

      if (isComplete) {
        if (self._timeline.autoRemoveChildren) {
          self._enabled(false, false);
        }

        self._active = false;
      }

      if (!suppressEvents && self.vars[callback]) {
        self._callback(callback);
      }

      if (duration === 0 && self._rawPrevTime === _tinyNum && rawPrevTime !== _tinyNum) {
        //the onComplete or onReverseComplete could trigger movement of the playhead and for zero-duration tweens (which must discern direction) that land directly back on their start time, we don't want to fire again on the next render. Think of several addPause()'s in a timeline that forces the playhead to a certain spot, but what if it's already paused and another tween is tweening the "time" of the timeline? Each time it moves [forward] past that spot, it would move back, and since suppressEvents is true, it'd reset _rawPrevTime to _tinyNum so that when it begins again, the callback would fire (so ultimately it could bounce back and forth during that tween). Again, this is a very uncommon scenario, but possible nonetheless.
        self._rawPrevTime = 0;
      }
    }
  };

  p._kill = function (vars, target, overwritingTween) {
    if (vars === "all") {
      vars = null;
    }

    if (vars == null) if (target == null || target === this.target) {
      this._lazy = false;
      return this._enabled(false, false);
    }
    target = typeof target !== "string" ? target || this._targets || this.target : TweenLite.selector(target) || target;
    var simultaneousOverwrite = overwritingTween && this._time && overwritingTween._startTime === this._startTime && this._timeline === overwritingTween._timeline,
        firstPT = this._firstPT,
        i,
        overwrittenProps,
        p,
        pt,
        propLookup,
        changed,
        killProps,
        record,
        killed;

    if ((_isArray(target) || _isSelector(target)) && typeof target[0] !== "number") {
      i = target.length;

      while (--i > -1) {
        if (this._kill(vars, target[i], overwritingTween)) {
          changed = true;
        }
      }
    } else {
      if (this._targets) {
        i = this._targets.length;

        while (--i > -1) {
          if (target === this._targets[i]) {
            propLookup = this._propLookup[i] || {};
            this._overwrittenProps = this._overwrittenProps || [];
            overwrittenProps = this._overwrittenProps[i] = vars ? this._overwrittenProps[i] || {} : "all";
            break;
          }
        }
      } else if (target !== this.target) {
        return false;
      } else {
        propLookup = this._propLookup;
        overwrittenProps = this._overwrittenProps = vars ? this._overwrittenProps || {} : "all";
      }

      if (propLookup) {
        killProps = vars || propLookup;
        record = vars !== overwrittenProps && overwrittenProps !== "all" && vars !== propLookup && ((0,_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(vars) !== "object" || !vars._tempKill); //_tempKill is a super-secret way to delete a particular tweening property but NOT have it remembered as an official overwritten property (like in BezierPlugin)

        if (overwritingTween && (TweenLite.onOverwrite || this.vars.onOverwrite)) {
          for (p in killProps) {
            if (propLookup[p]) {
              if (!killed) {
                killed = [];
              }

              killed.push(p);
            }
          }

          if ((killed || !vars) && !_onOverwrite(this, overwritingTween, target, killed)) {
            //if the onOverwrite returned false, that means the user wants to override the overwriting (cancel it).
            return false;
          }
        }

        for (p in killProps) {
          if (pt = propLookup[p]) {
            if (simultaneousOverwrite) {
              //if another tween overwrites this one and they both start at exactly the same time, yet this tween has already rendered once (for example, at 0.001) because it's first in the queue, we should revert the values to where they were at 0 so that the starting values aren't contaminated on the overwriting tween.
              if (pt.f) {
                pt.t[pt.p](pt.s);
              } else {
                pt.t[pt.p] = pt.s;
              }

              changed = true;
            }

            if (pt.pg && pt.t._kill(killProps)) {
              changed = true; //some plugins need to be notified so they can perform cleanup tasks first
            }

            if (!pt.pg || pt.t._overwriteProps.length === 0) {
              if (pt._prev) {
                pt._prev._next = pt._next;
              } else if (pt === this._firstPT) {
                this._firstPT = pt._next;
              }

              if (pt._next) {
                pt._next._prev = pt._prev;
              }

              pt._next = pt._prev = null;
            }

            delete propLookup[p];
          }

          if (record) {
            overwrittenProps[p] = 1;
          }
        }

        if (!this._firstPT && this._initted && firstPT) {
          //if all tweening properties are killed, kill the tween. Without this line, if there's a tween with multiple targets and then you killTweensOf() each target individually, the tween would technically still remain active and fire its onComplete even though there aren't any more properties tweening.
          this._enabled(false, false);
        }
      }
    }

    return changed;
  };

  p.invalidate = function () {
    if (this._notifyPluginsOfEnabled) {
      TweenLite._onPluginEvent("_onDisable", this);
    }

    var t = this._time;
    this._firstPT = this._overwrittenProps = this._startAt = this._onUpdate = null;
    this._notifyPluginsOfEnabled = this._active = this._lazy = false;
    this._propLookup = this._targets ? {} : [];
    Animation.prototype.invalidate.call(this);

    if (this.vars.immediateRender) {
      this._time = -_tinyNum; //forces a render without having to set the render() "force" parameter to true because we want to allow lazying by default (using the "force" parameter always forces an immediate full render)

      this.render(t, false, this.vars.lazy !== false);
    }

    return this;
  };

  p._enabled = function (enabled, ignoreTimeline) {
    if (!_tickerActive) {
      _ticker.wake();
    }

    if (enabled && this._gc) {
      var targets = this._targets,
          i;

      if (targets) {
        i = targets.length;

        while (--i > -1) {
          this._siblings[i] = _register(targets[i], this, true);
        }
      } else {
        this._siblings = _register(this.target, this, true);
      }
    }

    Animation.prototype._enabled.call(this, enabled, ignoreTimeline);

    if (this._notifyPluginsOfEnabled) if (this._firstPT) {
      return TweenLite._onPluginEvent(enabled ? "_onEnable" : "_onDisable", this);
    }
    return false;
  }; //----TweenLite static methods -----------------------------------------------------


  TweenLite.to = function (target, duration, vars) {
    return new TweenLite(target, duration, vars);
  };

  TweenLite.from = function (target, duration, vars) {
    vars.runBackwards = true;
    vars.immediateRender = vars.immediateRender != false;
    return new TweenLite(target, duration, vars);
  };

  TweenLite.fromTo = function (target, duration, fromVars, toVars) {
    toVars.startAt = fromVars;
    toVars.immediateRender = toVars.immediateRender != false && fromVars.immediateRender != false;
    return new TweenLite(target, duration, toVars);
  };

  TweenLite.delayedCall = function (delay, callback, params, scope, useFrames) {
    return new TweenLite(callback, 0, {
      delay: delay,
      onComplete: callback,
      onCompleteParams: params,
      callbackScope: scope,
      onReverseComplete: callback,
      onReverseCompleteParams: params,
      immediateRender: false,
      lazy: false,
      useFrames: useFrames,
      overwrite: 0
    });
  };

  TweenLite.set = function (target, vars) {
    return new TweenLite(target, 0, vars);
  };

  TweenLite.getTweensOf = function (target, onlyActive) {
    if (target == null) {
      return [];
    }

    target = typeof target !== "string" ? target : TweenLite.selector(target) || target;
    var i, a, j, t;

    if ((_isArray(target) || _isSelector(target)) && typeof target[0] !== "number") {
      i = target.length;
      a = [];

      while (--i > -1) {
        a = a.concat(TweenLite.getTweensOf(target[i], onlyActive));
      }

      i = a.length; //now get rid of any duplicates (tweens of arrays of objects could cause duplicates)

      while (--i > -1) {
        t = a[i];
        j = i;

        while (--j > -1) {
          if (t === a[j]) {
            a.splice(i, 1);
          }
        }
      }
    } else if (target._gsTweenID) {
      a = _register(target).concat();
      i = a.length;

      while (--i > -1) {
        if (a[i]._gc || onlyActive && !a[i].isActive()) {
          a.splice(i, 1);
        }
      }
    }

    return a || [];
  };

  TweenLite.killTweensOf = TweenLite.killDelayedCallsTo = function (target, onlyActive, vars) {
    if ((0,_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(onlyActive) === "object") {
      vars = onlyActive; //for backwards compatibility (before "onlyActive" parameter was inserted)

      onlyActive = false;
    }

    var a = TweenLite.getTweensOf(target, onlyActive),
        i = a.length;

    while (--i > -1) {
      a[i]._kill(vars, target);
    }
  };
  /*
   * ----------------------------------------------------------------
   * TweenPlugin   (could easily be split out as a separate file/class, but included for ease of use (so that people don't need to include another script call before loading plugins which is easy to forget)
   * ----------------------------------------------------------------
   */


  var TweenPlugin = _class("plugins.TweenPlugin", function (props, priority) {
    this._overwriteProps = (props || "").split(",");
    this._propName = this._overwriteProps[0];
    this._priority = priority || 0;
    this._super = TweenPlugin.prototype;
  }, true);

  p = TweenPlugin.prototype;
  TweenPlugin.version = "1.19.0";
  TweenPlugin.API = 2;
  p._firstPT = null;
  p._addTween = _addPropTween;
  p.setRatio = _setRatio;

  p._kill = function (lookup) {
    var a = this._overwriteProps,
        pt = this._firstPT,
        i;

    if (lookup[this._propName] != null) {
      this._overwriteProps = [];
    } else {
      i = a.length;

      while (--i > -1) {
        if (lookup[a[i]] != null) {
          a.splice(i, 1);
        }
      }
    }

    while (pt) {
      if (lookup[pt.n] != null) {
        if (pt._next) {
          pt._next._prev = pt._prev;
        }

        if (pt._prev) {
          pt._prev._next = pt._next;
          pt._prev = null;
        } else if (this._firstPT === pt) {
          this._firstPT = pt._next;
        }
      }

      pt = pt._next;
    }

    return false;
  };

  p._mod = p._roundProps = function (lookup) {
    var pt = this._firstPT,
        val;

    while (pt) {
      val = lookup[this._propName] || pt.n != null && lookup[pt.n.split(this._propName + "_").join("")];

      if (val && typeof val === "function") {
        //some properties that are very plugin-specific add a prefix named after the _propName plus an underscore, so we need to ignore that extra stuff here.
        if (pt.f === 2) {
          pt.t._applyPT.m = val;
        } else {
          pt.m = val;
        }
      }

      pt = pt._next;
    }
  };

  TweenLite._onPluginEvent = function (type, tween) {
    var pt = tween._firstPT,
        changed,
        pt2,
        first,
        last,
        next;

    if (type === "_onInitAllProps") {
      //sorts the PropTween linked list in order of priority because some plugins need to render earlier/later than others, like MotionBlurPlugin applies its effects after all x/y/alpha tweens have rendered on each frame.
      while (pt) {
        next = pt._next;
        pt2 = first;

        while (pt2 && pt2.pr > pt.pr) {
          pt2 = pt2._next;
        }

        if (pt._prev = pt2 ? pt2._prev : last) {
          pt._prev._next = pt;
        } else {
          first = pt;
        }

        if (pt._next = pt2) {
          pt2._prev = pt;
        } else {
          last = pt;
        }

        pt = next;
      }

      pt = tween._firstPT = first;
    }

    while (pt) {
      if (pt.pg) if (typeof pt.t[type] === "function") if (pt.t[type]()) {
        changed = true;
      }
      pt = pt._next;
    }

    return changed;
  };

  TweenPlugin.activate = function (plugins) {
    var i = plugins.length;

    while (--i > -1) {
      if (plugins[i].API === TweenPlugin.API) {
        _plugins[new plugins[i]()._propName] = plugins[i];
      }
    }

    return true;
  }; //provides a more concise way to define plugins that have no dependencies besides TweenPlugin and TweenLite, wrapping common boilerplate stuff into one function (added in 1.9.0). You don't NEED to use this to define a plugin - the old way still works and can be useful in certain (rare) situations.


  _gsDefine.plugin = function (config) {
    if (!config || !config.propName || !config.init || !config.API) {
      throw "illegal plugin definition.";
    }

    var propName = config.propName,
        priority = config.priority || 0,
        overwriteProps = config.overwriteProps,
        map = {
      init: "_onInitTween",
      set: "setRatio",
      kill: "_kill",
      round: "_mod",
      mod: "_mod",
      initAll: "_onInitAllProps"
    },
        Plugin = _class("plugins." + propName.charAt(0).toUpperCase() + propName.substr(1) + "Plugin", function () {
      TweenPlugin.call(this, propName, priority);
      this._overwriteProps = overwriteProps || [];
    }, config.global === true),
        p = Plugin.prototype = new TweenPlugin(propName),
        prop;

    p.constructor = Plugin;
    Plugin.API = config.API;

    for (prop in map) {
      if (typeof config[prop] === "function") {
        p[map[prop]] = config[prop];
      }
    }

    Plugin.version = config.version;
    TweenPlugin.activate([Plugin]);
    return Plugin;
  }; //now run through all the dependencies discovered and if any are missing, log that to the console as a warning. This is why it's best to have TweenLite load last - it can check all the dependencies for you.


  a = window._gsQueue;

  if (a) {
    for (i = 0; i < a.length; i++) {
      a[i]();
    }

    for (p in _defLookup) {
      if (!_defLookup[p].func) {
        window.console.log("GSAP encountered missing dependency: " + p);
      }
    }
  }

  _tickerActive = false; //ensures that the first official animation forces a ticker.tick() to update the time when it is instantiated

  return TweenLite;
}(_gsScope, "TweenLite");
var globals = _gsScope.GreenSockGlobals;
var nonGlobals = globals.com.greensock;

var SimpleTimeline = nonGlobals.core.SimpleTimeline;
var Animation = nonGlobals.core.Animation;
var Ease = globals.Ease;
var Linear = globals.Linear;
var Power0 = (/* unused pure expression or super */ null && (Linear));
var Power1 = globals.Power1;
var Power2 = globals.Power2;
var Power3 = globals.Power3;
var Power4 = globals.Power4;
var TweenPlugin = globals.TweenPlugin;
var EventDispatcher = nonGlobals.events.EventDispatcher;

/***/ }),

/***/ 319:
/***/ (() => {

/* 
 *************************************
 * Get all attributes of an element using jQuery
 *
 * @return {array}                        - Returns a new array.
 * @usage:
 
	$( '#demo' ).attr();  // { "data-a": "1", "id": "b" }

 *************************************
 */
(function (old) {
  $.fn.attr = function () {
    if (arguments.length === 0) {
      if (this.length === 0) {
        return null;
      }

      var obj = {};
      $.each(this[0].attributes, function () {
        if (this.specified) {
          obj[this.name] = this.value;
        }
      });
      return obj;
    }

    return old.apply(this, arguments);
  };
})($.fn.attr);

/***/ }),

/***/ 111:
/***/ (() => {

/* 
 *************************************
 * Scroll Lock
 * @https://gist.github.com/barneycarroll/6550066
 * @return {Void}
 *************************************
 */

/*
	 // Locks the page
	$.scrollLock( true );
	
	// Unlocks the page
	$.scrollLock( false );
*/
(function ($) {
  'use strict';

  $.scrollLock = function scrollLockClosure() {
    var $html = $('html'),
        // State: unlocked by default
    locked = false,
        // State: scroll to revert to
    prevScroll = {
      scrollLeft: $(window).scrollLeft(),
      scrollTop: $(window).scrollTop()
    },
        // State: styles to revert to
    prevStyles = {},
        lockStyles = {
      'overflow-y': 'scroll',
      'position': 'fixed',
      'width': '100%'
    }; // Instantiate cache in case someone tries to unlock before locking

    saveStyles(); // Save context's inline styles in cache

    function saveStyles() {
      var styleAttr = $html.attr('style'),
          styleStrs = [],
          styleHash = {};

      if (!styleAttr) {
        return;
      }

      styleStrs = styleAttr.split(/;\s/);
      $.each(styleStrs, function serializeStyleProp(styleString) {
        if (!styleString) {
          return;
        }

        var keyValue = styleString.split(/\s:\s/);

        if (keyValue.length < 2) {
          return;
        }

        styleHash[keyValue[0]] = keyValue[1];
      });
      $.extend(prevStyles, styleHash);
    }

    function lock() {
      var appliedLock = {}; // Duplicate execution will break DOM statefulness

      if (locked) {
        return;
      } // Save scroll state...


      prevScroll = {
        scrollLeft: $(window).scrollLeft(),
        scrollTop: $(window).scrollTop()
      }; // ...and styles

      saveStyles(); // Compose our applied CSS

      $.extend(appliedLock, lockStyles, {
        // And apply scroll state as styles
        'left': -prevScroll.scrollLeft + 'px',
        'top': -prevScroll.scrollTop + 'px'
      }); // Then lock styles...

      $html.css(appliedLock); // ...and scroll state

      $(window).scrollLeft(0).scrollTop(0);
      locked = true;
    }

    function unlock() {
      // Duplicate execution will break DOM statefulness
      if (!locked) {
        return;
      } // Revert styles


      $html.attr('style', $('<x>').css(prevStyles).attr('style') || ''); // Revert scroll values

      $(window).scrollLeft(prevScroll.scrollLeft).scrollTop(prevScroll.scrollTop);
      locked = false;
    }

    return function scrollLock(on) {
      // If an argument is passed, lock or unlock depending on truthiness
      if (arguments.length) {
        if (on) {
          lock();
        } else {
          unlock();
        }
      } // Otherwise, toggle
      else {
        if (locked) {
          unlock();
        } else {
          lock();
        }
      }
    };
  }();
})(jQuery);

/***/ }),

/***/ 798:
/***/ (() => {

/* 
 *************************************
 * Count To
 *
 * @param  {Number} fixed                - formats a number using fixed-point notation.
 * @param  {Number} from                 - the number the element should start at
 * @param  {Number} to                   - the number the element should end at
 * @param  {Number} speed                - how long it should take to count between the target numbers
 * @param  {Number} refreshInterval      - how often the element should be updated
 * @param  {Boolean} dilimiter           - the number of decimal places to show
 * @param  {Boolean} doubleDigits        - two digits are used by default
 * @param  {Function} onUpdate           - callback method for every time the element is updated
 * @param  {Function} onComplete         - callback method for when the element finishes updating,
 * @return {Void}
 *
 *************************************
 */
(function ($) {
  $.fn.UixCountTo = function (options) {
    options = options || {};
    return $(this).each(function () {
      // set options for current element
      var settings = $.extend({}, $.fn.UixCountTo.defaults, {
        from: $(this).data('counter-start'),
        to: $(this).data('counter-number'),
        fixed: $(this).data('counter-fixed'),
        speed: $(this).data('counter-duration'),
        refreshInterval: $(this).data('counter-refresh-interval'),
        dilimiter: $(this).data('counter-dilimiter'),
        doubleDigits: $(this).data('counter-double-digits'),
        onUpdate: null,
        onComplete: null
      }, options); // how many times to update the value, and how much to increment the value on each update

      var loops = Math.ceil(settings.speed / settings.refreshInterval),
          increment = (settings.to - settings.from) / loops; // references & variables that will change with each update

      var self = this,
          $self = $(this),
          loopCount = 0,
          value = settings.from,
          data = $self.data('count-to') || {};
      $self.data('count-to', data); // if an existing interval can be found, clear it first

      if (data.interval) {
        clearInterval(data.interval);
      }

      data.interval = setInterval(updateTimer, settings.refreshInterval); // initialize the element with the starting value

      render(value);

      function updateTimer() {
        value += increment;
        loopCount++;
        render(value);

        if (typeof settings.onUpdate == 'function') {
          settings.onUpdate.call(self, value);
        }

        if (loopCount >= loops) {
          // remove the interval
          $self.removeData('count-to');
          clearInterval(data.interval);
          value = settings.to;

          if (typeof settings.onComplete == 'function') {
            settings.onComplete.call(self, value);
          }
        }
      }

      function render(value) {
        var formattedValue = Number(value).toFixed(settings.fixed);

        if (settings.dilimiter && formattedValue > 0) {
          formattedValue = formattedValue.toString().replace(/\B(?=(?:\d{3})+\b)/g, ',');
        }

        if (settings.doubleDigits) {
          if (formattedValue < 10) {
            formattedValue = '0' + formattedValue;
          }
        }

        $self.html(formattedValue);
      }
    });
  };

  $.fn.UixCountTo.defaults = {
    from: 0,
    to: 0,
    fixed: 0,
    speed: 500,
    refreshInterval: 1,
    dilimiter: true,
    doubleDigits: false,
    onUpdate: null,
    onComplete: null
  };
})(jQuery);

/***/ }),

/***/ 260:
/***/ (() => {

/*
 * Disabled Controls
 *
 * @param  {String} controls                 - Wrapper of controls.
 * @return {Void}
 */
(function ($) {
  'use strict';

  $.fn.UixRenderControlsDisable = function (options) {
    // This is the easiest way to have default options.
    var settings = $.extend({
      controls: 'input.is-disabled'
    }, options);
    this.each(function () {
      $(settings.controls).prop('disabled', true);
    });
  };
})(jQuery);

/***/ }),

/***/ 366:
/***/ (() => {

/*
 * Hover Effect
 *
 * @param  {String} controls                 - Wrapper of controls.
 * @return {Void}
 */
(function ($) {
  'use strict';

  $.fn.UixRenderControlsHover = function (options) {
    // This is the easiest way to have default options.
    var settings = $.extend({
      controls: '.js-uix-float-label'
    }, options);
    this.each(function () {
      $(settings.controls).each(function () {
        var $this = $(this); // on focus add cladd active to label

        $this.on('focus', function () {
          $(this).closest('div').find('label, .uix-controls__bar').addClass('is-active');
        }); //on blur check field and remove class if needed

        $this.on('blur change', function (e) {
          if ($this.val() === '' || $this.val() === 'blank') {
            $(this).closest('div').find('label').removeClass('is-active');
          } //----


          if ($this.val() === '' || $this.val() === 'blank' || $this.val() != '' && $this.val() != 'blank') {
            $(this).closest('div').find('.uix-controls__bar').removeClass('is-active');
          }
        }); // if exist cookie value

        if ($this.val() != '' && $this.val() != 'blank') {
          $(this).closest('div').find('label').addClass('is-active');
        }
      });
    });
  };
})(jQuery);

/***/ }),

/***/ 283:
/***/ (() => {

/*
 * Render Custom File Dropzone
 *
 * @param  {String} controls                 - Wrapper of controls.
 * @return {Void}
 */
(function ($) {
  'use strict';

  $.fn.UixRenderCustomFileDropzone = function (options) {
    // This is the easiest way to have default options.
    var settings = $.extend({
      controls: '.uix-controls__file-field-container'
    }, options);
    this.each(function () {
      $(settings.controls).each(function () {
        var $dropZone = $(this).find('input[type="file"]');
        $(document).on('dragover', function (e) {
          var timeout = window.dropZoneTimeout;

          if (!timeout) {
            $dropZone.addClass('in');
          } else {
            clearTimeout(timeout);
          }

          var found = false,
              node = e.target;

          do {
            if (node === $dropZone[0]) {
              found = true;
              break;
            }

            node = node.parentNode;
          } while (node != null);

          if (found) {
            $dropZone.addClass('hover');
          } else {
            $dropZone.removeClass('hover');
          }

          window.dropZoneTimeout = setTimeout(function () {
            window.dropZoneTimeout = null;
            $dropZone.removeClass('in hover');
          }, 100);
        });
        $dropZone.on('change', function (e) {
          var input = $(this)[0];

          if (input.files && input.files[0]) {
            var reader = new FileReader();

            reader.onload = function (e) {
              var imgData = e.target.result;
              var imgName = input.files[0].name;
              input.setAttribute('data-title', imgName); //console.log(e.target.result);
            };

            reader.readAsDataURL(input.files[0]);
          }
        });
      });
    });
  };
})(jQuery);

/***/ }),

/***/ 433:
/***/ (() => {

/*
 * Render Custom File Type
 *
 * @param  {String} controls                 - Wrapper of controls.
 * @return {Void}
 */
(function ($) {
  'use strict';

  $.fn.UixRenderCustomFile = function (options) {
    // This is the easiest way to have default options.
    var settings = $.extend({
      controls: '.uix-controls__file-container'
    }, options);
    this.each(function () {
      $(settings.controls).each(function () {
        var $fileInput = $(this).find('input[type="file"]'),
            $fileBtn = $(this).find('.uix-controls__file-trigger'),
            $filePath = $(this).next('.uix-controls__file-return');
        $fileBtn.off('click').on('click', function () {
          $fileInput.focusin();
        });
        $fileInput.on('change', function () {
          $filePath.text($(this).val());
        });
      });
    });
  };
})(jQuery);

/***/ }),

/***/ 126:
/***/ (() => {

/*!
 * jQuery Mousewheel 3.1.13
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 */
(function ($) {
  var toFix = ['wheel', 'mousewheel', 'DOMMouseScroll', 'MozMousePixelScroll'],
      toBind = 'onwheel' in document || document.documentMode >= 9 ? ['wheel'] : ['mousewheel', 'DomMouseScroll', 'MozMousePixelScroll'],
      slice = Array.prototype.slice,
      nullLowestDeltaTimeout,
      lowestDelta;

  if ($.event.fixHooks) {
    for (var i = toFix.length; i;) {
      $.event.fixHooks[toFix[--i]] = $.event.mouseHooks;
    }
  }

  var special = $.event.special.mousewheel = {
    version: '3.1.12',
    setup: function setup() {
      if (this.addEventListener) {
        for (var i = toBind.length; i;) {
          this.addEventListener(toBind[--i], handler, false);
        }
      } else {
        this.onmousewheel = handler;
      } // Store the line height and page height for this particular element


      $.data(this, 'mousewheel-line-height', special.getLineHeight(this));
      $.data(this, 'mousewheel-page-height', special.getPageHeight(this));
    },
    teardown: function teardown() {
      if (this.removeEventListener) {
        for (var i = toBind.length; i;) {
          this.removeEventListener(toBind[--i], handler, false);
        }
      } else {
        this.onmousewheel = null;
      } // Clean up the data we added to the element


      $.removeData(this, 'mousewheel-line-height');
      $.removeData(this, 'mousewheel-page-height');
    },
    getLineHeight: function getLineHeight(elem) {
      var $elem = $(elem),
          $parent = $elem['offsetParent' in $.fn ? 'offsetParent' : 'parent']();

      if (!$parent.length) {
        $parent = $('body');
      }

      return parseInt($parent.css('fontSize'), 10) || parseInt($elem.css('fontSize'), 10) || 16;
    },
    getPageHeight: function getPageHeight(elem) {
      return $(elem).height();
    },
    settings: {
      adjustOldDeltas: true,
      // see shouldAdjustOldDeltas() below
      normalizeOffset: true // calls getBoundingClientRect for each event

    }
  };
  $.fn.extend({
    mousewheel: function mousewheel(fn) {
      return fn ? this.bind('mousewheel', fn) : this.trigger('mousewheel');
    },
    unmousewheel: function unmousewheel(fn) {
      return this.unbind('mousewheel', fn);
    }
  });

  function handler(event) {
    var orgEvent = event || window.event,
        args = slice.call(arguments, 1),
        delta = 0,
        deltaX = 0,
        deltaY = 0,
        absDelta = 0,
        offsetX = 0,
        offsetY = 0;
    event = $.event.fix(orgEvent);
    event.type = 'mousewheel'; // Old school scrollwheel delta

    if ('detail' in orgEvent) {
      deltaY = orgEvent.detail * -1;
    }

    if ('wheelDelta' in orgEvent) {
      deltaY = orgEvent.wheelDelta;
    }

    if ('wheelDeltaY' in orgEvent) {
      deltaY = orgEvent.wheelDeltaY;
    }

    if ('wheelDeltaX' in orgEvent) {
      deltaX = orgEvent.wheelDeltaX * -1;
    } // Firefox < 17 horizontal scrolling related to DOMMouseScroll event


    if ('axis' in orgEvent && orgEvent.axis === orgEvent.HORIZONTAL_AXIS) {
      deltaX = deltaY * -1;
      deltaY = 0;
    } // Set delta to be deltaY or deltaX if deltaY is 0 for backwards compatabilitiy


    delta = deltaY === 0 ? deltaX : deltaY; // New school wheel delta (wheel event)

    if ('deltaY' in orgEvent) {
      deltaY = orgEvent.deltaY * -1;
      delta = deltaY;
    }

    if ('deltaX' in orgEvent) {
      deltaX = orgEvent.deltaX;

      if (deltaY === 0) {
        delta = deltaX * -1;
      }
    } // No change actually happened, no reason to go any further


    if (deltaY === 0 && deltaX === 0) {
      return;
    } // Need to convert lines and pages to pixels if we aren't already in pixels
    // There are three delta modes:
    //   * deltaMode 0 is by pixels, nothing to do
    //   * deltaMode 1 is by lines
    //   * deltaMode 2 is by pages


    if (orgEvent.deltaMode === 1) {
      var lineHeight = $.data(this, 'mousewheel-line-height');
      delta *= lineHeight;
      deltaY *= lineHeight;
      deltaX *= lineHeight;
    } else if (orgEvent.deltaMode === 2) {
      var pageHeight = $.data(this, 'mousewheel-page-height');
      delta *= pageHeight;
      deltaY *= pageHeight;
      deltaX *= pageHeight;
    } // Store lowest absolute delta to normalize the delta values


    absDelta = Math.max(Math.abs(deltaY), Math.abs(deltaX));

    if (!lowestDelta || absDelta < lowestDelta) {
      lowestDelta = absDelta; // Adjust older deltas if necessary

      if (shouldAdjustOldDeltas(orgEvent, absDelta)) {
        lowestDelta /= 40;
      }
    } // Adjust older deltas if necessary


    if (shouldAdjustOldDeltas(orgEvent, absDelta)) {
      // Divide all the things by 40!
      delta /= 40;
      deltaX /= 40;
      deltaY /= 40;
    } // Get a whole, normalized value for the deltas


    delta = Math[delta >= 1 ? 'floor' : 'ceil'](delta / lowestDelta);
    deltaX = Math[deltaX >= 1 ? 'floor' : 'ceil'](deltaX / lowestDelta);
    deltaY = Math[deltaY >= 1 ? 'floor' : 'ceil'](deltaY / lowestDelta); // Normalise offsetX and offsetY properties

    if (special.settings.normalizeOffset && this.getBoundingClientRect) {
      var boundingRect = this.getBoundingClientRect();
      offsetX = event.clientX - boundingRect.left;
      offsetY = event.clientY - boundingRect.top;
    } // Add information to the event object


    event.deltaX = deltaX;
    event.deltaY = deltaY;
    event.deltaFactor = lowestDelta;
    event.offsetX = offsetX;
    event.offsetY = offsetY; // Go ahead and set deltaMode to 0 since we converted to pixels
    // Although this is a little odd since we overwrite the deltaX/Y
    // properties with normalized deltas.

    event.deltaMode = 0; // Add event and delta to the front of the arguments

    args.unshift(event, delta, deltaX, deltaY); // Clearout lowestDelta after sometime to better
    // handle multiple device types that give different
    // a different lowestDelta
    // Ex: trackpad = 3 and mouse wheel = 120

    if (nullLowestDeltaTimeout) {
      clearTimeout(nullLowestDeltaTimeout);
    }

    nullLowestDeltaTimeout = setTimeout(nullLowestDelta, 200);
    return ($.event.dispatch || $.event.handle).apply(this, args);
  }

  function nullLowestDelta() {
    lowestDelta = null;
  }

  function shouldAdjustOldDeltas(orgEvent, absDelta) {
    // If this is an older event and the delta is divisable by 120,
    // then we are assuming that the browser is treating this as an
    // older mouse wheel event and that we should divide the deltas
    // by 40 to try and get a more usable deltaFactor.
    // Side note, this actually impacts the reported scroll distance
    // in older browsers and can cause scrolling to be slower than native.
    // Turn this off by setting $.event.special.mousewheel.settings.adjustOldDeltas to false.
    return special.settings.adjustOldDeltas && orgEvent.type === 'mousewheel' && absDelta % 120 === 0;
  }
})(jQuery);

/***/ }),

/***/ 996:
/***/ ((module, __unused_webpack___webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony import */ var _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* module decorator */ module = __webpack_require__.hmd(module);


/**
* Muuri v0.8.0
* https://github.com/haltu/muuri
* Copyright (c) 2015-present, Haltu Oy
* Released under the MIT license
* https://github.com/haltu/muuri/blob/master/LICENSE.md
* @license MIT
*
* Muuri Packer
* Copyright (c) 2016-present, Niklas Rämö <inramo@gmail.com>
* @license MIT
*
* Muuri Ticker / Muuri Emitter / Muuri Queue
* Copyright (c) 2018-present, Niklas Rämö <inramo@gmail.com>
* @license MIT
*/
(function (global, factory) {
  (typeof exports === "undefined" ? "undefined" : (0,_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(exports)) === 'object' && "object" !== 'undefined' ? module.exports = factory() : typeof define === 'function' && __webpack_require__.amdO ? define(factory) : (global = global || self, global.Muuri = factory());
})(undefined, function () {
  'use strict';

  var namespace = 'Muuri';
  var gridInstances = {};
  var actionSwap = 'swap';
  var actionMove = 'move';
  var eventSynchronize = 'synchronize';
  var eventLayoutStart = 'layoutStart';
  var eventLayoutEnd = 'layoutEnd';
  var eventAdd = 'add';
  var eventRemove = 'remove';
  var eventShowStart = 'showStart';
  var eventShowEnd = 'showEnd';
  var eventHideStart = 'hideStart';
  var eventHideEnd = 'hideEnd';
  var eventFilter = 'filter';
  var eventSort = 'sort';
  var eventMove = 'move';
  var eventSend = 'send';
  var eventBeforeSend = 'beforeSend';
  var eventReceive = 'receive';
  var eventBeforeReceive = 'beforeReceive';
  var eventDragInit = 'dragInit';
  var eventDragStart = 'dragStart';
  var eventDragMove = 'dragMove';
  var eventDragScroll = 'dragScroll';
  var eventDragEnd = 'dragEnd';
  var eventDragReleaseStart = 'dragReleaseStart';
  var eventDragReleaseEnd = 'dragReleaseEnd';
  var eventDestroy = 'destroy';
  /**
   * Event emitter constructor.
   *
   * @class
   */

  function Emitter() {
    this._events = {};
    this._queue = [];
    this._counter = 0;
    this._isDestroyed = false;
  }
  /**
   * Public prototype methods
   * ************************
   */

  /**
   * Bind an event listener.
   *
   * @public
   * @memberof Emitter.prototype
   * @param {String} event
   * @param {Function} listener
   * @returns {Emitter}
   */


  Emitter.prototype.on = function (event, listener) {
    if (this._isDestroyed) return this; // Get listeners queue and create it if it does not exist.

    var listeners = this._events[event];
    if (!listeners) listeners = this._events[event] = []; // Add the listener to the queue.

    listeners.push(listener);
    return this;
  };
  /**
   * Unbind all event listeners that match the provided listener function.
   *
   * @public
   * @memberof Emitter.prototype
   * @param {String} event
   * @param {Function} [listener]
   * @returns {Emitter}
   */


  Emitter.prototype.off = function (event, listener) {
    if (this._isDestroyed) return this; // Get listeners and return immediately if none is found.

    var listeners = this._events[event];
    if (!listeners || !listeners.length) return this; // If no specific listener is provided remove all listeners.

    if (!listener) {
      listeners.length = 0;
      return this;
    } // Remove all matching listeners.


    var i = listeners.length;

    while (i--) {
      if (listener === listeners[i]) listeners.splice(i, 1);
    }

    return this;
  };
  /**
   * Emit all listeners in a specified event with the provided arguments.
   *
   * @public
   * @memberof Emitter.prototype
   * @param {String} event
   * @param {*} [arg1]
   * @param {*} [arg2]
   * @param {*} [arg3]
   * @returns {Emitter}
   */


  Emitter.prototype.emit = function (event, arg1, arg2, arg3) {
    if (this._isDestroyed) return this; // Get event listeners and quit early if there's no listeners.

    var listeners = this._events[event];
    if (!listeners || !listeners.length) return this;
    var queue = this._queue;
    var qLength = queue.length;
    var aLength = arguments.length - 1;
    var i; // Add the current listeners to the callback queue before we process them.
    // This is necessary to guarantee that all of the listeners are called in
    // correct order even if new event listeners are removed/added during
    // processing and/or events are emitted during processing.

    for (i = 0; i < listeners.length; i++) {
      queue.push(listeners[i]);
    } // Increment queue counter. This is needed for the scenarios where emit is
    // triggered while the queue is already processing. We need to keep track of
    // how many "queue processors" there are active so that we can safely reset
    // the queue in the end when the last queue processor is finished.


    ++this._counter; // Process the queue (the specific part of it for this emit).

    for (i = qLength, qLength = queue.length; i < qLength; i++) {
      // prettier-ignore
      aLength === 0 ? queue[i]() : aLength === 1 ? queue[i](arg1) : aLength === 2 ? queue[i](arg1, arg2) : queue[i](arg1, arg2, arg3); // Stop processing if the emitter is destroyed.

      if (this._isDestroyed) return this;
    } // Decrement queue process counter.


    --this._counter; // Reset the queue if there are no more queue processes running.

    if (!this._counter) queue.length = 0;
    return this;
  };
  /**
   * Destroy emitter instance. Basically just removes all bound listeners.
   *
   * @public
   * @memberof Emitter.prototype
   * @returns {Emitter}
   */


  Emitter.prototype.destroy = function () {
    if (this._isDestroyed) return this;
    var events = this._events;
    var event; // Flag as destroyed.

    this._isDestroyed = true; // Reset queue (if queue is currently processing this will also stop that).

    this._queue.length = this._counter = 0; // Remove all listeners.

    for (event in events) {
      if (events[event]) {
        events[event].length = 0;
        events[event] = undefined;
      }
    }

    return this;
  }; // Set up the default export values.


  var transformStyle = 'transform';
  var transformProp = 'transform'; // Find the supported transform prop and style names.

  var docElemStyle = window.document.documentElement.style;
  var style = 'transform';
  var styleCap = 'Transform';
  var found = false;
  ['', 'Webkit', 'Moz', 'O', 'ms'].forEach(function (prefix) {
    if (found) return;
    var propName = prefix ? prefix + styleCap : style;

    if (docElemStyle[propName] !== undefined) {
      prefix = prefix.toLowerCase();
      transformStyle = prefix ? '-' + prefix + '-' + style : style;
      transformProp = propName;
      found = true;
    }
  });
  var stylesCache = typeof WeakMap === 'function' ? new WeakMap() : null;
  /**
   * Returns the computed value of an element's style property as a string.
   *
   * @param {HTMLElement} element
   * @param {String} style
   * @returns {String}
   */

  function getStyle(element, style) {
    var styles = stylesCache && stylesCache.get(element);

    if (!styles) {
      styles = window.getComputedStyle(element, null);
      if (stylesCache) stylesCache.set(element, styles);
    }

    return styles.getPropertyValue(style === 'transform' ? transformStyle : style);
  }

  var styleNameRegEx = /([A-Z])/g;
  /**
   * Transforms a camel case style property to kebab case style property.
   *
   * @param {String} string
   * @returns {String}
   */

  function getStyleName(string) {
    return string.replace(styleNameRegEx, '-$1').toLowerCase();
  }

  var strFunction = 'function';
  /**
   * Check if a value is a function.
   *
   * @param {*} val
   * @returns {Boolean}
   */

  function isFunction(val) {
    return (0,_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(val) === strFunction;
  }

  var transformStyle$1 = 'transform';
  /**
   * Set inline styles to an element.
   *
   * @param {HTMLElement} element
   * @param {Object} styles
   */

  function setStyles(element, styles) {
    for (var prop in styles) {
      element.style[prop === transformStyle$1 ? transformProp : prop] = styles[prop];
    }
  }
  /**
   * Item animation handler powered by Web Animations API.
   *
   * @class
   * @param {HTMLElement} element
   */


  function ItemAnimate(element) {
    this._element = element;
    this._animation = null;
    this._callback = null;
    this._props = [];
    this._values = [];
    this._keyframes = [];
    this._options = {};
    this._isDestroyed = false;
    this._onFinish = this._onFinish.bind(this);
  }
  /**
   * Public prototype methods
   * ************************
   */

  /**
   * Start instance's animation. Automatically stops current animation if it is
   * running.
   *
   * @public
   * @memberof ItemAnimate.prototype
   * @param {Object} propsFrom
   * @param {Object} propsTo
   * @param {Object} [options]
   * @param {Number} [options.duration=300]
   * @param {String} [options.easing='ease']
   * @param {Function} [options.onFinish]
   */


  ItemAnimate.prototype.start = function (propsFrom, propsTo, options) {
    if (this._isDestroyed) return;
    var animation = this._animation;
    var currentProps = this._props;
    var currentValues = this._values;
    var opts = options || 0;
    var cancelAnimation = false; // If we have an existing animation running, let's check if it needs to be
    // cancelled or if it can continue running.

    if (animation) {
      var propCount = 0;
      var propIndex; // Check if the requested animation target props and values match with the
      // current props and values.

      for (var propName in propsTo) {
        ++propCount;
        propIndex = currentProps.indexOf(propName);

        if (propIndex === -1 || propsTo[propName] !== currentValues[propIndex]) {
          cancelAnimation = true;
          break;
        }
      } // Check if the target props count matches current props count. This is
      // needed for the edge case scenario where target props contain the same
      // styles as current props, but the current props have some additional
      // props.


      if (!cancelAnimation && propCount !== currentProps.length) {
        cancelAnimation = true;
      }
    } // Cancel animation (if required).


    if (cancelAnimation) animation.cancel(); // Store animation callback.

    this._callback = isFunction(opts.onFinish) ? opts.onFinish : null; // If we have a running animation that does not need to be cancelled, let's
    // call it a day here and let it run.

    if (animation && !cancelAnimation) return; // Store target props and values to instance.

    currentProps.length = currentValues.length = 0;

    for (propName in propsTo) {
      currentProps.push(propName);
      currentValues.push(propsTo[propName]);
    } // Set up keyframes.


    var animKeyframes = this._keyframes;
    animKeyframes[0] = propsFrom;
    animKeyframes[1] = propsTo; // Set up options.

    var animOptions = this._options;
    animOptions.duration = opts.duration || 300;
    animOptions.easing = opts.easing || 'ease'; // Start the animation

    var element = this._element;
    animation = element.animate(animKeyframes, animOptions);
    animation.onfinish = this._onFinish;
    this._animation = animation; // Set the end styles. This makes sure that the element stays at the end
    // values after animation is finished.

    setStyles(element, propsTo);
  };
  /**
   * Stop instance's current animation if running.
   *
   * @public
   * @memberof ItemAnimate.prototype
   * @param {Object} [styles]
   */


  ItemAnimate.prototype.stop = function (styles) {
    if (this._isDestroyed || !this._animation) return;
    var element = this._element;
    var currentProps = this._props;
    var currentValues = this._values;
    var propName;
    var propValue;
    var i; // Calculate (if not provided) and set styles.

    if (!styles) {
      for (i = 0; i < currentProps.length; i++) {
        propName = currentProps[i];
        propValue = getStyle(element, getStyleName(propName));
        element.style[propName === 'transform' ? transformProp : propName] = propValue;
      }
    } else {
      setStyles(element, styles);
    } //  Cancel animation.


    this._animation.cancel();

    this._animation = this._callback = null; // Reset current props and values.

    currentProps.length = currentValues.length = 0;
  };
  /**
   * Check if the item is being animated currently.
   *
   * @public
   * @memberof ItemAnimate.prototype
   * @return {Boolean}
   */


  ItemAnimate.prototype.isAnimating = function () {
    return !!this._animation;
  };
  /**
   * Destroy the instance and stop current animation if it is running.
   *
   * @public
   * @memberof ItemAnimate.prototype
   */


  ItemAnimate.prototype.destroy = function () {
    if (this._isDestroyed) return;
    this.stop();
    this._element = this._options = this._keyframes = null;
    this._isDestroyed = true;
  };
  /**
   * Private prototype methods
   * *************************
   */

  /**
   * Animation end handler.
   *
   * @private
   * @memberof ItemAnimate.prototype
   */


  ItemAnimate.prototype._onFinish = function () {
    var callback = this._callback;
    this._animation = this._callback = null;
    this._props.length = this._values.length = 0;
    callback && callback();
  };

  var vendorPrefixes = ['', 'webkit', 'moz', 'ms', 'o', 'Webkit', 'Moz', 'MS', 'O'];
  /**
   * Get prefixed CSS property name when given a non-prefixed CSS property name.
   * @param {Object} elemStyle
   * @param {String} propName
   * @returns {!String}
   */

  function getPrefixedPropName(elemStyle, propName) {
    var camelPropName = propName[0].toUpperCase() + propName.slice(1);
    var i = 0;
    var prefix;
    var prefixedPropName;

    while (i < vendorPrefixes.length) {
      prefix = vendorPrefixes[i];
      prefixedPropName = prefix ? prefix + camelPropName : propName;
      if (prefixedPropName in elemStyle) return prefixedPropName;
      ++i;
    }

    return null;
  }

  var dt = 1000 / 60;

  var raf = (window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {
    return this.setTimeout(function () {
      callback(dt);
    }, dt);
  }).bind(window); // Detect support for passive events:
  // https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md#feature-detection


  var isPassiveEventsSupported = false;

  try {
    var passiveOpts = Object.defineProperty({}, 'passive', {
      get: function get() {
        isPassiveEventsSupported = true;
      }
    });
    window.addEventListener('testPassive', null, passiveOpts);
    window.removeEventListener('testPassive', null, passiveOpts);
  } catch (e) {} // Dragger events.


  var events = {
    start: 'start',
    move: 'move',
    end: 'end',
    cancel: 'cancel'
  };
  var hasTouchEvents = !!('ontouchstart' in window || window.TouchEvent);
  var hasPointerEvents = !!window.PointerEvent;
  var hasMsPointerEvents = !!window.navigator.msPointerEnabled;
  var isAndroid = /(android)/i.test(window.navigator.userAgent);
  var listenerOptions = isPassiveEventsSupported ? {
    passive: true
  } : false;
  var taProp = 'touchAction';
  var taPropPrefixed = getPrefixedPropName(window.document.documentElement.style, taProp);
  var taDefaultValue = 'auto';
  /**
   * Creates a new Dragger instance for an element.
   *
   * @public
   * @class
   * @param {HTMLElement} element
   * @param {Object} [cssProps]
   */

  function Dragger(element, cssProps) {
    this._element = element;
    this._emitter = new Emitter();
    this._isDestroyed = false;
    this._cssProps = {};
    this._touchAction = '';
    this._startEvent = null;
    this._pointerId = null;
    this._startTime = 0;
    this._startX = 0;
    this._startY = 0;
    this._currentX = 0;
    this._currentY = 0;
    this._preStartCheck = this._preStartCheck.bind(this);
    this._abortNonCancelable = this._abortNonCancelable.bind(this);
    this._onStart = this._onStart.bind(this);
    this._onMove = this._onMove.bind(this);
    this._onCancel = this._onCancel.bind(this);
    this._onEnd = this._onEnd.bind(this); // Apply initial css props.

    this.setCssProps(cssProps); // If touch action was not provided with initial css props let's assume it's
    // auto.

    if (!this._touchAction) {
      this.setTouchAction(taDefaultValue);
    } // Prevent native link/image dragging for the item and it's ancestors.


    element.addEventListener('dragstart', Dragger._preventDefault, false); // Listen to start event.

    element.addEventListener(Dragger._events.start, this._preStartCheck, listenerOptions); // If we have touch events, but no pointer events we need to also listen for
    // mouse events in addition to touch events for devices which support both
    // mouse and touch interaction.

    if (hasTouchEvents && !hasPointerEvents && !hasMsPointerEvents) {
      element.addEventListener(Dragger._mouseEvents.start, this._preStartCheck, listenerOptions);
    }
  }
  /**
   * Protected properties
   * ********************
   */


  Dragger._pointerEvents = {
    start: 'pointerdown',
    move: 'pointermove',
    cancel: 'pointercancel',
    end: 'pointerup'
  };
  Dragger._msPointerEvents = {
    start: 'MSPointerDown',
    move: 'MSPointerMove',
    cancel: 'MSPointerCancel',
    end: 'MSPointerUp'
  };
  Dragger._touchEvents = {
    start: 'touchstart',
    move: 'touchmove',
    cancel: 'touchcancel',
    end: 'touchend'
  };
  Dragger._mouseEvents = {
    start: 'mousedown',
    move: 'mousemove',
    cancel: '',
    end: 'mouseup'
  };

  Dragger._events = function () {
    if (hasPointerEvents) return Dragger._pointerEvents;
    if (hasMsPointerEvents) return Dragger._msPointerEvents;
    if (hasTouchEvents) return Dragger._touchEvents;
    return Dragger._mouseEvents;
  }();

  Dragger._emitter = new Emitter();
  Dragger._activeInstances = [];
  /**
   * Protected static methods
   * ************************
   */

  Dragger._preventDefault = function (e) {
    if (e.preventDefault && e.cancelable !== false) e.preventDefault();
  };

  Dragger._activateInstance = function (instance) {
    var index = Dragger._activeInstances.indexOf(instance);

    if (index > -1) return;

    Dragger._activeInstances.push(instance);

    Dragger._emitter.on(events.move, instance._onMove);

    Dragger._emitter.on(events.cancel, instance._onCancel);

    Dragger._emitter.on(events.end, instance._onEnd);

    if (Dragger._activeInstances.length === 1) {
      Dragger._bindListeners();
    }
  };

  Dragger._deactivateInstance = function (instance) {
    var index = Dragger._activeInstances.indexOf(instance);

    if (index === -1) return;

    Dragger._activeInstances.splice(index, 1);

    Dragger._emitter.off(events.move, instance._onMove);

    Dragger._emitter.off(events.cancel, instance._onCancel);

    Dragger._emitter.off(events.end, instance._onEnd);

    if (!Dragger._activeInstances.length) {
      Dragger._unbindListeners();
    }
  };

  Dragger._bindListeners = function () {
    var events = Dragger._events;
    window.addEventListener(events.move, Dragger._onMove, listenerOptions);
    window.addEventListener(events.end, Dragger._onEnd, listenerOptions);
    events.cancel && window.addEventListener(events.cancel, Dragger._onCancel, listenerOptions);
  };

  Dragger._unbindListeners = function () {
    var events = Dragger._events;
    window.removeEventListener(events.move, Dragger._onMove, listenerOptions);
    window.removeEventListener(events.end, Dragger._onEnd, listenerOptions);
    events.cancel && window.removeEventListener(events.cancel, Dragger._onCancel, listenerOptions);
  };

  Dragger._getEventPointerId = function (event) {
    // If we have pointer id available let's use it.
    if (typeof event.pointerId === 'number') {
      return event.pointerId;
    } // For touch events let's get the first changed touch's identifier.


    if (event.changedTouches) {
      return event.changedTouches[0] ? event.changedTouches[0].identifier : null;
    } // For mouse/other events let's provide a static id.


    return 1;
  };

  Dragger._getTouchById = function (event, id) {
    // If we have a pointer event return the whole event if there's a match, and
    // null otherwise.
    if (typeof event.pointerId === 'number') {
      return event.pointerId === id ? event : null;
    } // For touch events let's check if there's a changed touch object that matches
    // the pointerId in which case return the touch object.


    if (event.changedTouches) {
      for (var i = 0; i < event.changedTouches.length; i++) {
        if (event.changedTouches[i].identifier === id) {
          return event.changedTouches[i];
        }
      }

      return null;
    } // For mouse/other events let's assume there's only one pointer and just
    // return the event.


    return event;
  };

  Dragger._onMove = function (e) {
    Dragger._emitter.emit(events.move, e);
  };

  Dragger._onCancel = function (e) {
    Dragger._emitter.emit(events.cancel, e);
  };

  Dragger._onEnd = function (e) {
    Dragger._emitter.emit(events.end, e);
  };
  /**
   * Private prototype methods
   * *************************
   */

  /**
   * Reset current drag operation (if any).
   *
   * @private
   * @memberof Dragger.prototype
   */


  Dragger.prototype._reset = function () {
    if (this._isDestroyed) return;
    this._pointerId = null;
    this._startTime = 0;
    this._startX = 0;
    this._startY = 0;
    this._currentX = 0;
    this._currentY = 0;
    this._startEvent = null;

    this._element.removeEventListener(Dragger._touchEvents.start, this._abortNonCancelable, listenerOptions);

    Dragger._deactivateInstance(this);
  };
  /**
   * Create a custom dragger event from a raw event.
   *
   * @private
   * @memberof Dragger.prototype
   * @param {String} type
   * @param {(PointerEvent|TouchEvent|MouseEvent)} e
   * @returns {DraggerEvent}
   */


  Dragger.prototype._createEvent = function (type, e) {
    var touch = this._getTrackedTouch(e);

    return {
      // Hammer.js compatibility interface.
      type: type,
      srcEvent: e,
      distance: this.getDistance(),
      deltaX: this.getDeltaX(),
      deltaY: this.getDeltaY(),
      deltaTime: type === events.start ? 0 : this.getDeltaTime(),
      isFirst: type === events.start,
      isFinal: type === events.end || type === events.cancel,
      // Partial Touch API interface.
      identifier: this._pointerId,
      screenX: touch.screenX,
      screenY: touch.screenY,
      clientX: touch.clientX,
      clientY: touch.clientY,
      pageX: touch.pageX,
      pageY: touch.pageY,
      target: touch.target
    };
  };
  /**
   * Emit a raw event as dragger event internally.
   *
   * @private
   * @memberof Dragger.prototype
   * @param {String} type
   * @param {(PointerEvent|TouchEvent|MouseEvent)} e
   */


  Dragger.prototype._emit = function (type, e) {
    this._emitter.emit(type, this._createEvent(type, e));
  };
  /**
   * If the provided event is a PointerEvent this method will return it if it has
   * the same pointerId as the instance. If the provided event is a TouchEvent
   * this method will try to look for a Touch instance in the changedTouches that
   * has an identifier matching this instance's pointerId. If the provided event
   * is a MouseEvent (or just any other event than PointerEvent or TouchEvent)
   * it will be returned immediately.
   *
   * @private
   * @memberof Dragger.prototype
   * @param {(PointerEvent|TouchEvent|MouseEvent)}
   * @returns {?(Touch|PointerEvent|MouseEvent)}
   */


  Dragger.prototype._getTrackedTouch = function (e) {
    if (this._pointerId === null) {
      return null;
    } else {
      return Dragger._getTouchById(e, this._pointerId);
    }
  };
  /**
   * A pre-handler for start event that checks if we can start dragging.
   *
   * @private
   * @memberof Dragger.prototype
   * @param {(PointerEvent|TouchEvent|MouseEvent)} e
   */


  Dragger.prototype._preStartCheck = function (e) {
    if (this._isDestroyed) return; // Make sure the element is not being dragged currently.

    if (this.isDragging()) return; // Special cancelable check for Android to prevent drag procedure from
    // starting if native scrolling is in progress. Part 1.

    if (isAndroid && e.cancelable === false) return; // Make sure left button is pressed on mouse.

    if (e.button) return; // Get (and set) pointer id.

    this._pointerId = Dragger._getEventPointerId(e);
    if (this._pointerId === null) return; // Store the start event and trigger start (async or sync). Pointer events
    // are emitted before touch events if the browser supports both of them. And
    // if you try to move an element before `touchstart` is emitted the pointer
    // events for that element will be canceled. The fix is to delay the emitted
    // pointer events in such a scenario by one frame so that `touchstart` has
    // time to be emitted before the element is (potentially) moved.

    this._startEvent = e;

    if (hasTouchEvents && (hasPointerEvents || hasMsPointerEvents)) {
      // Special cancelable check for Android to prevent drag procedure from
      // starting if native scrolling is in progress. Part 2.
      if (isAndroid) {
        this._element.addEventListener(Dragger._touchEvents.start, this._abortNonCancelable, listenerOptions);
      }

      raf(this._onStart);
    } else {
      this._onStart();
    }
  };
  /**
   * Abort start event if it turns out to be non-cancelable.
   *
   * @private
   * @memberof Dragger.prototype
   * @param {(PointerEvent|TouchEvent|MouseEvent)} e
   */


  Dragger.prototype._abortNonCancelable = function (e) {
    this._element.removeEventListener(Dragger._touchEvents.start, this._abortNonCancelable, listenerOptions);

    if (this._startEvent && e.cancelable === false) {
      this._pointerId = null;
      this._startEvent = null;
    }
  };
  /**
   * Start the drag procedure if possible.
   *
   * @private
   * @memberof Dragger.prototype
   */


  Dragger.prototype._onStart = function () {
    var e = this._startEvent;
    if (!e) return;
    this._startEvent = null;

    var touch = this._getTrackedTouch(e);

    if (!touch) return; // Set up init data and emit start event.

    this._startX = this._currentX = touch.clientX;
    this._startY = this._currentY = touch.clientY;
    this._startTime = Date.now();

    this._emit(events.start, e);

    Dragger._activateInstance(this);
  };
  /**
   * Handler for move event.
   *
   * @private
   * @memberof Dragger.prototype
   * @param {(PointerEvent|TouchEvent|MouseEvent)} e
   */


  Dragger.prototype._onMove = function (e) {
    var touch = this._getTrackedTouch(e);

    if (!touch) return;
    this._currentX = touch.clientX;
    this._currentY = touch.clientY;

    this._emit(events.move, e);
  };
  /**
   * Handler for move cancel event.
   *
   * @private
   * @memberof Dragger.prototype
   * @param {(PointerEvent|TouchEvent|MouseEvent)} e
   */


  Dragger.prototype._onCancel = function (e) {
    if (!this._getTrackedTouch(e)) return;

    this._emit(events.cancel, e);

    this._reset();
  };
  /**
   * Handler for end event.
   *
   * @private
   * @memberof Dragger.prototype
   * @param {(PointerEvent|TouchEvent|MouseEvent)} e
   */


  Dragger.prototype._onEnd = function (e) {
    if (!this._getTrackedTouch(e)) return;

    this._emit(events.end, e);

    this._reset();
  };
  /**
   * Public prototype methods
   * ************************
   */

  /**
   * Check if the element is being dragged at the moment.
   *
   * @public
   * @memberof Dragger.prototype
   * @returns {Boolean}
   */


  Dragger.prototype.isDragging = function () {
    return this._pointerId !== null;
  };
  /**
   * Set element's touch-action CSS property.
   *
   * @public
   * @memberof Dragger.prototype
   * @param {String} value
   */


  Dragger.prototype.setTouchAction = function (value) {
    // Store unmodified touch action value (we trust user input here).
    this._touchAction = value; // Set touch-action style.

    if (taPropPrefixed) {
      this._cssProps[taPropPrefixed] = '';
      this._element.style[taPropPrefixed] = value;
    } // If we have an unsupported touch-action value let's add a special listener
    // that prevents default action on touch start event. A dirty hack, but best
    // we can do for now. The other options would be to somehow polyfill the
    // unsupported touch action behavior with custom heuristics which sounds like
    // a can of worms.


    if (hasTouchEvents) {
      this._element.removeEventListener(Dragger._touchEvents.start, Dragger._preventDefault, false);

      if (this._element.style[taPropPrefixed] !== value) {
        this._element.addEventListener(Dragger._touchEvents.start, Dragger._preventDefault, false);
      }
    }
  };
  /**
   * Update element's CSS properties. Accepts an object with camel cased style
   * props with value pairs as it's first argument.
   *
   * @public
   * @memberof Dragger.prototype
   * @param {Object} [newProps]
   */


  Dragger.prototype.setCssProps = function (newProps) {
    if (!newProps) return;
    var currentProps = this._cssProps;
    var element = this._element;
    var prop;
    var prefixedProp; // Reset current props.

    for (prop in currentProps) {
      element.style[prop] = currentProps[prop];
      delete currentProps[prop];
    } // Set new props.


    for (prop in newProps) {
      // Make sure we have a value for the prop.
      if (!newProps[prop]) continue; // Special handling for touch-action.

      if (prop === taProp) {
        this.setTouchAction(newProps[prop]);
        continue;
      } // Get prefixed prop and skip if it does not exist.


      prefixedProp = getPrefixedPropName(element.style, prop);
      if (!prefixedProp) continue; // Store the prop and add the style.

      currentProps[prefixedProp] = '';
      element.style[prefixedProp] = newProps[prop];
    }
  };
  /**
   * How much the pointer has moved on x-axis from start position, in pixels.
   * Positive value indicates movement from left to right.
   *
   * @public
   * @memberof Dragger.prototype
   * @returns {Number}
   */


  Dragger.prototype.getDeltaX = function () {
    return this._currentX - this._startX;
  };
  /**
   * How much the pointer has moved on y-axis from start position, in pixels.
   * Positive value indicates movement from top to bottom.
   *
   * @public
   * @memberof Dragger.prototype
   * @returns {Number}
   */


  Dragger.prototype.getDeltaY = function () {
    return this._currentY - this._startY;
  };
  /**
   * How far (in pixels) has pointer moved from start position.
   *
   * @public
   * @memberof Dragger.prototype
   * @returns {Number}
   */


  Dragger.prototype.getDistance = function () {
    var x = this.getDeltaX();
    var y = this.getDeltaY();
    return Math.sqrt(x * x + y * y);
  };
  /**
   * How long has pointer been dragged.
   *
   * @public
   * @memberof Dragger.prototype
   * @returns {Number}
   */


  Dragger.prototype.getDeltaTime = function () {
    return this._startTime ? Date.now() - this._startTime : 0;
  };
  /**
   * Bind drag event listeners.
   *
   * @public
   * @memberof Dragger.prototype
   * @param {String} eventName
   *   - 'start', 'move', 'cancel' or 'end'.
   * @param {Function} listener
   */


  Dragger.prototype.on = function (eventName, listener) {
    this._emitter.on(eventName, listener);
  };
  /**
   * Unbind drag event listeners.
   *
   * @public
   * @memberof Dragger.prototype
   * @param {String} eventName
   *   - 'start', 'move', 'cancel' or 'end'.
   * @param {Function} listener
   */


  Dragger.prototype.off = function (events, listener) {
    this._emitter.off(eventName, listener);
  };
  /**
   * Destroy the instance and unbind all drag event listeners.
   *
   * @public
   * @memberof Dragger.prototype
   */


  Dragger.prototype.destroy = function () {
    if (this._isDestroyed) return;
    var element = this._element;
    var events = Dragger._events; // Reset data and deactivate the instance.

    this._reset(); // Destroy emitter.


    this._emitter.destroy(); // Unbind event handlers.


    element.removeEventListener(events.start, this._preStartCheck, listenerOptions);
    element.removeEventListener(Dragger._mouseEvents.start, this._preStartCheck, listenerOptions);
    element.removeEventListener('dragstart', Dragger._preventDefault, false);
    element.removeEventListener(Dragger._touchEvents.start, Dragger._preventDefault, false); // Reset styles.

    for (var prop in this._cssProps) {
      element.style[prop] = this._cssProps[prop];
      delete this._cssProps[prop];
    } // Reset data.


    this._element = null; // Mark as destroyed.

    this._isDestroyed = true;
  };
  /**
   * A ticker system for handling DOM reads and writes in an efficient way.
   * Contains a read queue and a write queue that are processed on the next
   * animation frame when needed.
   *
   * @class
   */


  function Ticker() {
    this._nextStep = null;
    this._queue = [];
    this._reads = {};
    this._writes = {};
    this._batch = [];
    this._batchReads = {};
    this._batchWrites = {};
    this._step = this._step.bind(this);
  }

  Ticker.prototype.add = function (id, readOperation, writeOperation, isPrioritized) {
    // First, let's check if an item has been added to the queues with the same id
    // and if so -> remove it.
    var currentIndex = this._queue.indexOf(id);

    if (currentIndex > -1) this._queue[currentIndex] = undefined; // Add entry.

    isPrioritized ? this._queue.unshift(id) : this._queue.push(id);
    this._reads[id] = readOperation;
    this._writes[id] = writeOperation; // Finally, let's kick-start the next tick if it is not running yet.

    if (!this._nextStep) this._nextStep = raf(this._step);
  };

  Ticker.prototype.cancel = function (id) {
    var currentIndex = this._queue.indexOf(id);

    if (currentIndex > -1) {
      this._queue[currentIndex] = undefined;
      delete this._reads[id];
      delete this._writes[id];
    }
  };

  Ticker.prototype._step = function () {
    var queue = this._queue;
    var reads = this._reads;
    var writes = this._writes;
    var batch = this._batch;
    var batchReads = this._batchReads;
    var batchWrites = this._batchWrites;
    var length = queue.length;
    var id;
    var i; // Reset ticker.

    this._nextStep = null; // Setup queues and callback placeholders.

    for (i = 0; i < length; i++) {
      id = queue[i];
      if (!id) continue;
      batch.push(id);
      batchReads[id] = reads[id];
      delete reads[id];
      batchWrites[id] = writes[id];
      delete writes[id];
    } // Reset queue.


    queue.length = 0; // Process read callbacks.

    for (i = 0; i < length; i++) {
      id = batch[i];

      if (batchReads[id]) {
        batchReads[id]();
        delete batchReads[id];
      }
    } // Process write callbacks.


    for (i = 0; i < length; i++) {
      id = batch[i];

      if (batchWrites[id]) {
        batchWrites[id]();
        delete batchWrites[id];
      }
    } // Reset batch.


    batch.length = 0; // Restart the ticker if needed.

    if (!this._nextStep && queue.length) {
      this._nextStep = raf(this._step);
    }
  };

  var ticker = new Ticker();
  var layoutTick = 'layout';
  var visibilityTick = 'visibility';
  var moveTick = 'move';
  var scrollTick = 'scroll';
  var placeholderTick = 'placeholder';

  function addLayoutTick(itemId, readCallback, writeCallback) {
    return ticker.add(itemId + layoutTick, readCallback, writeCallback);
  }

  function cancelLayoutTick(itemId) {
    return ticker.cancel(itemId + layoutTick);
  }

  function addVisibilityTick(itemId, readCallback, writeCallback) {
    return ticker.add(itemId + visibilityTick, readCallback, writeCallback);
  }

  function cancelVisibilityTick(itemId) {
    return ticker.cancel(itemId + visibilityTick);
  }

  function addMoveTick(itemId, readCallback, writeCallback) {
    return ticker.add(itemId + moveTick, readCallback, writeCallback, true);
  }

  function cancelMoveTick(itemId) {
    return ticker.cancel(itemId + moveTick);
  }

  function addScrollTick(itemId, readCallback, writeCallback) {
    return ticker.add(itemId + scrollTick, readCallback, writeCallback, true);
  }

  function cancelScrollTick(itemId) {
    return ticker.cancel(itemId + scrollTick);
  }

  function addPlaceholderTick(itemId, readCallback, writeCallback) {
    return ticker.add(itemId + placeholderTick, readCallback, writeCallback);
  }

  function cancelPlaceholderTick(itemId) {
    return ticker.cancel(itemId + placeholderTick);
  }

  var ElProto = window.Element.prototype;

  var matchesFn = ElProto.matches || ElProto.matchesSelector || ElProto.webkitMatchesSelector || ElProto.mozMatchesSelector || ElProto.msMatchesSelector || ElProto.oMatchesSelector || function () {
    return false;
  };
  /**
   * Check if element matches a CSS selector.
   *
   * @param {Element} el
   * @param {String} selector
   * @returns {Boolean}
   */


  function elementMatches(el, selector) {
    return matchesFn.call(el, selector);
  }
  /**
   * Add class to an element.
   *
   * @param {HTMLElement} element
   * @param {String} className
   */


  function addClass(element, className) {
    if (element.classList) {
      element.classList.add(className);
    } else {
      if (!elementMatches(element, '.' + className)) {
        element.className += ' ' + className;
      }
    }
  }

  var tempArray = [];
  var numberType = 'number';
  /**
   * Insert an item or an array of items to array to a specified index. Mutates
   * the array. The index can be negative in which case the items will be added
   * to the end of the array.
   *
   * @param {Array} array
   * @param {*} items
   * @param {Number} [index=-1]
   */

  function arrayInsert(array, items, index) {
    var startIndex = (0,_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(index) === numberType ? index : -1;
    if (startIndex < 0) startIndex = array.length - startIndex + 1;
    array.splice.apply(array, tempArray.concat(startIndex, 0, items));
    tempArray.length = 0;
  }
  /**
   * Normalize array index. Basically this function makes sure that the provided
   * array index is within the bounds of the provided array and also transforms
   * negative index to the matching positive index.
   *
   * @param {Array} array
   * @param {Number} index
   * @param {Boolean} isMigration
   */


  function normalizeArrayIndex(array, index, isMigration) {
    var length = array.length;
    var maxIndex = Math.max(0, isMigration ? length : length - 1);
    return index > maxIndex ? maxIndex : index < 0 ? Math.max(maxIndex + index + 1, 0) : index;
  }
  /**
   * Move array item to another index.
   *
   * @param {Array} array
   * @param {Number} fromIndex
   *   - Index (positive or negative) of the item that will be moved.
   * @param {Number} toIndex
   *   - Index (positive or negative) where the item should be moved to.
   */


  function arrayMove(array, fromIndex, toIndex) {
    // Make sure the array has two or more items.
    if (array.length < 2) return; // Normalize the indices.

    var from = normalizeArrayIndex(array, fromIndex);
    var to = normalizeArrayIndex(array, toIndex); // Add target item to the new position.

    if (from !== to) {
      array.splice(to, 0, array.splice(from, 1)[0]);
    }
  }
  /**
   * Swap array items.
   *
   * @param {Array} array
   * @param {Number} index
   *   - Index (positive or negative) of the item that will be swapped.
   * @param {Number} withIndex
   *   - Index (positive or negative) of the other item that will be swapped.
   */


  function arraySwap(array, index, withIndex) {
    // Make sure the array has two or more items.
    if (array.length < 2) return; // Normalize the indices.

    var indexA = normalizeArrayIndex(array, index);
    var indexB = normalizeArrayIndex(array, withIndex);
    var temp; // Swap the items.

    if (indexA !== indexB) {
      temp = array[indexA];
      array[indexA] = array[indexB];
      array[indexB] = temp;
    }
  }

  var actionCancel = 'cancel';
  var actionFinish = 'finish';
  var debounceTick = 'debounce';
  var debounceId = 0;
  /**
   * Returns a function, that, as long as it continues to be invoked, will not
   * be triggered. The function will be called after it stops being called for
   * N milliseconds. The returned function accepts one argument which, when
   * being "finish", calls the debounce function immediately if it is currently
   * waiting to be called, and when being "cancel" cancels the currently queued
   * function call.
   *
   * @param {Function} fn
   * @param {Number} wait
   * @returns {Function}
   */

  function debounce(fn, wait) {
    var timeout;
    var tickerId = ++debounceId + debounceTick;

    if (wait > 0) {
      return function (action) {
        if (timeout !== undefined) {
          timeout = window.clearTimeout(timeout);
          ticker.cancel(tickerId);
          if (action === actionFinish) fn();
        }

        if (action !== actionCancel && action !== actionFinish) {
          timeout = window.setTimeout(function () {
            timeout = undefined;
            ticker.add(tickerId, fn, null, true);
          }, wait);
        }
      };
    }

    return function (action) {
      if (action !== actionCancel) fn();
    };
  }
  /**
   * Returns true if element is transformed, false if not. In practice the
   * element's display value must be anything else than "none" or "inline" as
   * well as have a valid transform value applied in order to be counted as a
   * transformed element.
   *
   * Borrowed from Mezr (v0.6.1):
   * https://github.com/niklasramo/mezr/blob/0.6.1/mezr.js#L661
   *
   * @param {HTMLElement} element
   * @returns {Boolean}
   */


  function isTransformed(element) {
    var transform = getStyle(element, 'transform');
    if (!transform || transform === 'none') return false;
    var display = getStyle(element, 'display');
    if (display === 'inline' || display === 'none') return false;
    return true;
  }
  /**
   * Returns an absolute positioned element's containing block, which is
   * considered to be the closest ancestor element that the target element's
   * positioning is relative to. Disclaimer: this only works as intended for
   * absolute positioned elements.
   *
   * @param {HTMLElement} element
   * @param {Boolean} [includeSelf=false]
   *   - When this is set to true the containing block checking is started from
   *     the provided element. Otherwise the checking is started from the
   *     provided element's parent element.
   * @returns {(Document|Element)}
   */


  function getContainingBlock(element, includeSelf) {
    // As long as the containing block is an element, static and not
    // transformed, try to get the element's parent element and fallback to
    // document. https://github.com/niklasramo/mezr/blob/0.6.1/mezr.js#L339
    var document = window.document;
    var ret = (includeSelf ? element : element.parentElement) || document;

    while (ret && ret !== document && getStyle(ret, 'position') === 'static' && !isTransformed(ret)) {
      ret = ret.parentElement || document;
    }

    return ret;
  }
  /**
   * Returns the computed value of an element's style property transformed into
   * a float value.
   *
   * @param {HTMLElement} el
   * @param {String} style
   * @returns {Number}
   */


  function getStyleAsFloat(el, style) {
    return parseFloat(getStyle(el, style)) || 0;
  }

  var offsetA = {};
  var offsetB = {};
  var offsetDiff = {};
  /**
   * Returns the element's document offset, which in practice means the vertical
   * and horizontal distance between the element's northwest corner and the
   * document's northwest corner. Note that this function always returns the same
   * object so be sure to read the data from it instead using it as a reference.
   *
   * @param {(Document|Element|Window)} element
   * @param {Object} [offsetData]
   *   - Optional data object where the offset data will be inserted to. If not
   *     provided a new object will be created for the return data.
   * @returns {Object}
   */

  function getOffset(element, offsetData) {
    var ret = offsetData || {};
    var rect; // Set up return data.

    ret.left = 0;
    ret.top = 0; // Document's offsets are always 0.

    if (element === document) return ret; // Add viewport scroll left/top to the respective offsets.

    ret.left = window.pageXOffset || 0;
    ret.top = window.pageYOffset || 0; // Window's offsets are the viewport scroll left/top values.

    if (element.self === window.self) return ret; // Add element's client rects to the offsets.

    rect = element.getBoundingClientRect();
    ret.left += rect.left;
    ret.top += rect.top; // Exclude element's borders from the offset.

    ret.left += getStyleAsFloat(element, 'border-left-width');
    ret.top += getStyleAsFloat(element, 'border-top-width');
    return ret;
  }
  /**
   * Calculate the offset difference two elements.
   *
   * @param {HTMLElement} elemA
   * @param {HTMLElement} elemB
   * @param {Boolean} [compareContainingBlocks=false]
   *   - When this is set to true the containing blocks of the provided elements
   *     will be used for calculating the difference. Otherwise the provided
   *     elements will be compared directly.
   * @returns {Object}
   */


  function getOffsetDiff(elemA, elemB, compareContainingBlocks) {
    offsetDiff.left = 0;
    offsetDiff.top = 0; // If elements are same let's return early.

    if (elemA === elemB) return offsetDiff; // Compare containing blocks if necessary.

    if (compareContainingBlocks) {
      elemA = getContainingBlock(elemA, true);
      elemB = getContainingBlock(elemB, true); // If containing blocks are identical, let's return early.

      if (elemA === elemB) return offsetDiff;
    } // Finally, let's calculate the offset diff.


    getOffset(elemA, offsetA);
    getOffset(elemB, offsetB);
    offsetDiff.left = offsetB.left - offsetA.left;
    offsetDiff.top = offsetB.top - offsetA.top;
    return offsetDiff;
  }

  var styleOverflow = 'overflow';
  var styleOverflowX = 'overflow-x';
  var styleOverflowY = 'overflow-y';
  var overflowAuto = 'auto';
  var overflowScroll = 'scroll';
  /**
   * Check if an element is scrollable.
   *
   * @param {HTMLElement} element
   * @returns {Boolean}
   */

  function isScrollable(element) {
    var overflow = getStyle(element, styleOverflow);
    if (overflow === overflowAuto || overflow === overflowScroll) return true;
    overflow = getStyle(element, styleOverflowX);
    if (overflow === overflowAuto || overflow === overflowScroll) return true;
    overflow = getStyle(element, styleOverflowY);
    if (overflow === overflowAuto || overflow === overflowScroll) return true;
    return false;
  }
  /**
   * Collect element's ancestors that are potentially scrollable elements.
   *
   * @param {HTMLElement} element
   * @param {Boolean} [includeSelf=false]
   * @param {Array} [data]
   * @returns {Array}
   */


  function getScrollableAncestors(element, includeSelf, data) {
    var ret = data || [];
    var parent = includeSelf ? element : element.parentNode; // Find scroll parents.

    while (parent && parent !== document) {
      // If element is inside ShadowDOM let's get it's host node from the real
      // DOM and continue looping.
      if (parent.getRootNode && parent instanceof DocumentFragment) {
        parent = parent.getRootNode().host;
        continue;
      } // If element is scrollable let's add it to the scrollable list.


      if (isScrollable(parent)) {
        ret.push(parent);
      }

      parent = parent.parentNode;
    } // Always add window to the results.


    ret.push(window);
    return ret;
  }

  var translateValue = {};
  var transformStyle$2 = 'transform';
  var transformNone = 'none';
  var rxMat3d = /^matrix3d/;
  var rxMatTx = /([^,]*,){4}/;
  var rxMat3dTx = /([^,]*,){12}/;
  var rxNextItem = /[^,]*,/;
  /**
   * Returns the element's computed translateX and translateY values as a floats.
   * The returned object is always the same object and updated every time this
   * function is called.
   *
   * @param {HTMLElement} element
   * @returns {Object}
   */

  function getTranslate(element) {
    translateValue.x = 0;
    translateValue.y = 0;
    var transform = getStyle(element, transformStyle$2);

    if (!transform || transform === transformNone) {
      return translateValue;
    } // Transform style can be in either matrix3d(...) or matrix(...).


    var isMat3d = rxMat3d.test(transform);
    var tX = transform.replace(isMat3d ? rxMat3dTx : rxMatTx, '');
    var tY = tX.replace(rxNextItem, '');
    translateValue.x = parseFloat(tX) || 0;
    translateValue.y = parseFloat(tY) || 0;
    return translateValue;
  }
  /**
   * Transform translateX and translateY value into CSS transform style
   * property's value.
   *
   * @param {Number} x
   * @param {Number} y
   * @returns {String}
   */


  function getTranslateString(x, y) {
    return 'translateX(' + x + 'px) translateY(' + y + 'px)';
  }
  /**
   * Remove class from an element.
   *
   * @param {HTMLElement} element
   * @param {String} className
   */


  function removeClass(element, className) {
    if (element.classList) {
      element.classList.remove(className);
    } else {
      if (elementMatches(element, '.' + className)) {
        element.className = (' ' + element.className + ' ').replace(' ' + className + ' ', ' ').trim();
      }
    }
  } // Drag start predicate states.


  var startPredicateInactive = 0;
  var startPredicatePending = 1;
  var startPredicateResolved = 2;
  var startPredicateRejected = 3;
  /**
   * Bind touch interaction to an item.
   *
   * @class
   * @param {Item} item
   */

  function ItemDrag(item) {
    var element = item._element;
    var grid = item.getGrid();
    var settings = grid._settings;
    this._item = item;
    this._gridId = grid._id;
    this._isDestroyed = false;
    this._isMigrating = false; // Start predicate data.

    this._startPredicate = isFunction(settings.dragStartPredicate) ? settings.dragStartPredicate : ItemDrag.defaultStartPredicate;
    this._startPredicateState = startPredicateInactive;
    this._startPredicateResult = undefined; // Data for drag sort predicate heuristics.

    this._hBlockedIndex = null;
    this._hX1 = 0;
    this._hX2 = 0;
    this._hY1 = 0;
    this._hY2 = 0; // Setup item's initial drag data.

    this._reset(); // Bind the methods that needs binding.


    this._preStartCheck = this._preStartCheck.bind(this);
    this._preEndCheck = this._preEndCheck.bind(this);
    this._onScroll = this._onScroll.bind(this);
    this._prepareMove = this._prepareMove.bind(this);
    this._applyMove = this._applyMove.bind(this);
    this._prepareScroll = this._prepareScroll.bind(this);
    this._applyScroll = this._applyScroll.bind(this);
    this._checkOverlap = this._checkOverlap.bind(this); // Create debounce overlap checker function.

    var sortInterval = settings.dragSortHeuristics.sortInterval;
    this._checkOverlapDebounce = debounce(this._checkOverlap, sortInterval); // Init dragger.

    this._dragger = new Dragger(element, settings.dragCssProps);

    this._dragger.on('start', this._preStartCheck);

    this._dragger.on('move', this._preStartCheck);

    this._dragger.on('cancel', this._preEndCheck);

    this._dragger.on('end', this._preEndCheck);
  }
  /**
   * Public static methods
   * *********************
   */

  /**
   * Default drag start predicate handler that handles anchor elements
   * gracefully. The return value of this function defines if the drag is
   * started, rejected or pending. When true is returned the dragging is started
   * and when false is returned the dragging is rejected. If nothing is returned
   * the predicate will be called again on the next drag movement.
   *
   * @public
   * @memberof ItemDrag
   * @param {Item} item
   * @param {DraggerEvent} event
   * @param {Object} [options]
   *   - An optional options object which can be used to pass the predicate
   *     it's options manually. By default the predicate retrieves the options
   *     from the grid's settings.
   * @returns {Boolean}
   */


  ItemDrag.defaultStartPredicate = function (item, event, options) {
    var drag = item._drag;

    var predicate = drag._startPredicateData || drag._setupStartPredicate(options); // Final event logic. At this stage return value does not matter anymore,
    // the predicate is either resolved or it's not and there's nothing to do
    // about it. Here we just reset data and if the item element is a link
    // we follow it (if there has only been slight movement).


    if (event.isFinal) {
      drag._finishStartPredicate(event);

      return;
    } // Find and store the handle element so we can check later on if the
    // cursor is within the handle. If we have a handle selector let's find
    // the corresponding element. Otherwise let's use the item element as the
    // handle.


    if (!predicate.handleElement) {
      predicate.handleElement = drag._getStartPredicateHandle(event);
      if (!predicate.handleElement) return false;
    } // If delay is defined let's keep track of the latest event and initiate
    // delay if it has not been done yet.


    if (predicate.delay) {
      predicate.event = event;

      if (!predicate.delayTimer) {
        predicate.delayTimer = window.setTimeout(function () {
          predicate.delay = 0;

          if (drag._resolveStartPredicate(predicate.event)) {
            drag._forceResolveStartPredicate(predicate.event);

            drag._resetStartPredicate();
          }
        }, predicate.delay);
      }
    }

    return drag._resolveStartPredicate(event);
  };
  /**
   * Default drag sort predicate.
   *
   * @public
   * @memberof ItemDrag
   * @param {Item} item
   * @param {Object} [options]
   * @param {Number} [options.threshold=50]
   * @param {String} [options.action='move']
   * @returns {(Boolean|DragSortCommand)}
   *   - Returns false if no valid index was found. Otherwise returns drag sort
   *     command.
   */


  ItemDrag.defaultSortPredicate = function () {
    var itemRect = {};
    var targetRect = {};
    var returnData = {};
    var rootGridArray = [];

    function getTargetGrid(item, rootGrid, threshold) {
      var target = null;
      var dragSort = rootGrid._settings.dragSort;
      var bestScore = -1;
      var gridScore;
      var grids;
      var grid;
      var i; // Get potential target grids.

      if (dragSort === true) {
        rootGridArray[0] = rootGrid;
        grids = rootGridArray;
      } else {
        grids = dragSort.call(rootGrid, item);
      } // Return immediately if there are no grids.


      if (!Array.isArray(grids)) return target; // Loop through the grids and get the best match.

      for (i = 0; i < grids.length; i++) {
        grid = grids[i]; // Filter out all destroyed grids.

        if (grid._isDestroyed) continue; // We need to update the grid's offsets and dimensions since they might
        // have changed (e.g during scrolling).

        grid._updateBoundingRect(); // Check how much dragged element overlaps the container element.


        targetRect.width = grid._width;
        targetRect.height = grid._height;
        targetRect.left = grid._left;
        targetRect.top = grid._top;
        gridScore = getRectOverlapScore(itemRect, targetRect); // Check if this grid is the best match so far.

        if (gridScore > threshold && gridScore > bestScore) {
          bestScore = gridScore;
          target = grid;
        }
      } // Always reset root grid array.


      rootGridArray.length = 0;
      return target;
    }

    return function (item, options) {
      var drag = item._drag;

      var rootGrid = drag._getGrid(); // Get drag sort predicate settings.


      var sortThreshold = options && typeof options.threshold === 'number' ? options.threshold : 50;
      var sortAction = options && options.action === actionSwap ? actionSwap : actionMove; // Populate item rect data.

      itemRect.width = item._width;
      itemRect.height = item._height;
      itemRect.left = drag._elementClientX;
      itemRect.top = drag._elementClientY; // Calculate the target grid.

      var grid = getTargetGrid(item, rootGrid, sortThreshold); // Return early if we found no grid container element that overlaps the
      // dragged item enough.

      if (!grid) return false;
      var gridOffsetLeft = 0;
      var gridOffsetTop = 0;
      var matchScore = -1;
      var matchIndex;
      var hasValidTargets;
      var target;
      var score;
      var i; // If item is moved within it's originating grid adjust item's left and
      // top props. Otherwise if item is moved to/within another grid get the
      // container element's offset (from the element's content edge).

      if (grid === rootGrid) {
        itemRect.left = drag._gridX + item._marginLeft;
        itemRect.top = drag._gridY + item._marginTop;
      } else {
        grid._updateBorders(1, 0, 1, 0);

        gridOffsetLeft = grid._left + grid._borderLeft;
        gridOffsetTop = grid._top + grid._borderTop;
      } // Loop through the target grid items and try to find the best match.


      for (i = 0; i < grid._items.length; i++) {
        target = grid._items[i]; // If the target item is not active or the target item is the dragged
        // item let's skip to the next item.

        if (!target._isActive || target === item) {
          continue;
        } // Mark the grid as having valid target items.


        hasValidTargets = true; // Calculate the target's overlap score with the dragged item.

        targetRect.width = target._width;
        targetRect.height = target._height;
        targetRect.left = target._left + target._marginLeft + gridOffsetLeft;
        targetRect.top = target._top + target._marginTop + gridOffsetTop;
        score = getRectOverlapScore(itemRect, targetRect); // Update best match index and score if the target's overlap score with
        // the dragged item is higher than the current best match score.

        if (score > matchScore) {
          matchIndex = i;
          matchScore = score;
        }
      } // If there is no valid match and the item is being moved into another
      // grid.


      if (matchScore < sortThreshold && item.getGrid() !== grid) {
        matchIndex = hasValidTargets ? -1 : 0;
        matchScore = Infinity;
      } // Check if the best match overlaps enough to justify a placement switch.


      if (matchScore >= sortThreshold) {
        returnData.grid = grid;
        returnData.index = matchIndex;
        returnData.action = sortAction;
        return returnData;
      }

      return false;
    };
  }();
  /**
   * Public prototype methods
   * ************************
   */

  /**
   * Abort dragging and reset drag data.
   *
   * @public
   * @memberof ItemDrag.prototype
   * @returns {ItemDrag}
   */


  ItemDrag.prototype.stop = function () {
    var item = this._item;
    var element = item._element;

    var grid = this._getGrid();

    if (!this._isActive) return this; // If the item is being dropped into another grid, finish it up and return
    // immediately.

    if (this._isMigrating) {
      this._finishMigration();

      return this;
    } // Cancel queued move and scroll ticks.


    cancelMoveTick(item._id);
    cancelScrollTick(item._id); // Remove scroll listeners.

    this._unbindScrollListeners(); // Cancel overlap check.


    this._checkOverlapDebounce('cancel'); // Append item element to the container if it's not it's child. Also make
    // sure the translate values are adjusted to account for the DOM shift.


    if (element.parentNode !== grid._element) {
      grid._element.appendChild(element);

      element.style[transformProp] = getTranslateString(this._gridX, this._gridY);
    } // Remove dragging class.


    removeClass(element, grid._settings.itemDraggingClass); // Reset drag data.

    this._reset();

    return this;
  };
  /**
   * Destroy instance.
   *
   * @public
   * @memberof ItemDrag.prototype
   * @returns {ItemDrag}
   */


  ItemDrag.prototype.destroy = function () {
    if (this._isDestroyed) return this;
    this.stop();

    this._dragger.destroy();

    this._isDestroyed = true;
    return this;
  };
  /**
   * Private prototype methods
   * *************************
   */

  /**
   * Get Grid instance.
   *
   * @private
   * @memberof ItemDrag.prototype
   * @returns {?Grid}
   */


  ItemDrag.prototype._getGrid = function () {
    return gridInstances[this._gridId] || null;
  };
  /**
   * Setup/reset drag data.
   *
   * @private
   * @memberof ItemDrag.prototype
   */


  ItemDrag.prototype._reset = function () {
    // Is item being dragged?
    this._isActive = false; // The dragged item's container element.

    this._container = null; // The dragged item's containing block.

    this._containingBlock = null; // Drag/scroll event data.

    this._dragEvent = null;
    this._scrollEvent = null; // All the elements which need to be listened for scroll events during
    // dragging.

    this._scrollers = []; // The current translateX/translateY position.

    this._left = 0;
    this._top = 0; // Dragged element's current position within the grid.

    this._gridX = 0;
    this._gridY = 0; // Dragged element's current offset from window's northwest corner. Does
    // not account for element's margins.

    this._elementClientX = 0;
    this._elementClientY = 0; // Offset difference between the dragged element's temporary drag
    // container and it's original container.

    this._containerDiffX = 0;
    this._containerDiffY = 0;
  };
  /**
   * Bind drag scroll handlers to all scrollable ancestor elements of the
   * dragged element and the drag container element.
   *
   * @private
   * @memberof ItemDrag.prototype
   */


  ItemDrag.prototype._bindScrollListeners = function () {
    var gridContainer = this._getGrid()._element;

    var dragContainer = this._container;
    var scrollers = this._scrollers;
    var gridScrollers;
    var i; // Get dragged element's scrolling parents.

    scrollers.length = 0;
    getScrollableAncestors(this._item._element, false, scrollers); // If drag container is defined and it's not the same element as grid
    // container then we need to add the grid container and it's scroll parents
    // to the elements which are going to be listener for scroll events.

    if (dragContainer !== gridContainer) {
      gridScrollers = [];
      getScrollableAncestors(gridContainer, true, gridScrollers);

      for (i = 0; i < gridScrollers.length; i++) {
        if (scrollers.indexOf(gridScrollers[i]) < 0) {
          scrollers.push(gridScrollers[i]);
        }
      }
    } // Bind scroll listeners.


    for (i = 0; i < scrollers.length; i++) {
      scrollers[i].addEventListener('scroll', this._onScroll);
    }
  };
  /**
   * Unbind currently bound drag scroll handlers from all scrollable ancestor
   * elements of the dragged element and the drag container element.
   *
   * @private
   * @memberof ItemDrag.prototype
   */


  ItemDrag.prototype._unbindScrollListeners = function () {
    var scrollers = this._scrollers;
    var i;

    for (i = 0; i < scrollers.length; i++) {
      scrollers[i].removeEventListener('scroll', this._onScroll);
    }

    scrollers.length = 0;
  };
  /**
   * Setup default start predicate.
   *
   * @private
   * @memberof ItemDrag.prototype
   * @param {Object} [options]
   * @returns {Object}
   */


  ItemDrag.prototype._setupStartPredicate = function (options) {
    var config = options || this._getGrid()._settings.dragStartPredicate || 0;
    return this._startPredicateData = {
      distance: Math.abs(config.distance) || 0,
      delay: Math.max(config.delay, 0) || 0,
      handle: typeof config.handle === 'string' ? config.handle : false
    };
  };
  /**
   * Setup default start predicate handle.
   *
   * @private
   * @memberof ItemDrag.prototype
   * @param {DraggerEvent} event
   * @returns {?HTMLElement}
   */


  ItemDrag.prototype._getStartPredicateHandle = function (event) {
    var predicate = this._startPredicateData;
    var element = this._item._element;
    var handleElement = element; // No handle, no hassle -> let's use the item element as the handle.

    if (!predicate.handle) return handleElement; // If there is a specific predicate handle defined, let's try to get it.

    handleElement = event.target;

    while (handleElement && !elementMatches(handleElement, predicate.handle)) {
      handleElement = handleElement !== element ? handleElement.parentElement : null;
    }

    return handleElement || null;
  };
  /**
   * Unbind currently bound drag scroll handlers from all scrollable ancestor
   * elements of the dragged element and the drag container element.
   *
   * @private
   * @memberof ItemDrag.prototype
   * @param {DraggerEvent} event
   * @returns {Boolean}
   */


  ItemDrag.prototype._resolveStartPredicate = function (event) {
    var predicate = this._startPredicateData; // If the moved distance is smaller than the threshold distance or there is
    // some delay left, ignore this predicate cycle.

    if (event.distance < predicate.distance || predicate.delay) return; // Get handle rect data.

    var handleRect = predicate.handleElement.getBoundingClientRect();
    var handleLeft = handleRect.left + (window.pageXOffset || 0);
    var handleTop = handleRect.top + (window.pageYOffset || 0);
    var handleWidth = handleRect.width;
    var handleHeight = handleRect.height; // Reset predicate data.

    this._resetStartPredicate(); // If the cursor is still within the handle let's start the drag.


    return handleWidth && handleHeight && event.pageX >= handleLeft && event.pageX < handleLeft + handleWidth && event.pageY >= handleTop && event.pageY < handleTop + handleHeight;
  };
  /**
   * Forcefully resolve drag start predicate.
   *
   * @private
   * @memberof ItemDrag.prototype
   * @param {DraggerEvent} event
   */


  ItemDrag.prototype._forceResolveStartPredicate = function (event) {
    if (!this._isDestroyed && this._startPredicateState === startPredicatePending) {
      this._startPredicateState = startPredicateResolved;

      this._onStart(event);
    }
  };
  /**
   * Finalize start predicate.
   *
   * @private
   * @memberof ItemDrag.prototype
   * @param {DraggerEvent} event
   */


  ItemDrag.prototype._finishStartPredicate = function (event) {
    var element = this._item._element; // Check if this is a click (very subjective heuristics).

    var isClick = Math.abs(event.deltaX) < 2 && Math.abs(event.deltaY) < 2 && event.deltaTime < 200; // Reset predicate.

    this._resetStartPredicate(); // If the gesture can be interpreted as click let's try to open the element's
    // href url (if it is an anchor element).


    if (isClick) openAnchorHref(element);
  };
  /**
   * Reset drag sort heuristics.
   *
   * @private
   * @memberof ItemDrag.prototype
   * @param {DraggerEvent} event
   */


  ItemDrag.prototype._resetHeuristics = function (event) {
    this._hBlockedIndex = null;
    this._hX1 = this._hX2 = event.clientX;
    this._hY1 = this._hY2 = event.clientY;
  };
  /**
   * Run heuristics and return true if overlap check can be performed, and false
   * if it can not.
   *
   * @private
   * @memberof ItemDrag.prototype
   * @param {DraggerEvent} event
   * @returns {Boolean}
   */


  ItemDrag.prototype._checkHeuristics = function (event) {
    var settings = this._getGrid()._settings.dragSortHeuristics;

    var minDist = settings.minDragDistance; // Skip heuristics if not needed.

    if (minDist <= 0) {
      this._hBlockedIndex = null;
      return true;
    }

    var x = event.clientX;
    var y = event.clientY;
    var diffX = x - this._hX2;
    var diffY = y - this._hY2; // If we can't do proper bounce back check make sure that the blocked index
    // is not set.

    var canCheckBounceBack = minDist > 3 && settings.minBounceBackAngle > 0;

    if (!canCheckBounceBack) {
      this._hBlockedIndex = null;
    }

    if (Math.abs(diffX) > minDist || Math.abs(diffY) > minDist) {
      // Reset blocked index if angle changed enough. This check requires a
      // minimum value of 3 for minDragDistance to function properly.
      if (canCheckBounceBack) {
        var angle = Math.atan2(diffX, diffY);
        var prevAngle = Math.atan2(this._hX2 - this._hX1, this._hY2 - this._hY1);
        var deltaAngle = Math.atan2(Math.sin(angle - prevAngle), Math.cos(angle - prevAngle));

        if (Math.abs(deltaAngle) > settings.minBounceBackAngle) {
          this._hBlockedIndex = null;
        }
      } // Update points.


      this._hX1 = this._hX2;
      this._hY1 = this._hY2;
      this._hX2 = x;
      this._hY2 = y;
      return true;
    }

    return false;
  };
  /**
   * Reset for default drag start predicate function.
   *
   * @private
   * @memberof ItemDrag.prototype
   */


  ItemDrag.prototype._resetStartPredicate = function () {
    var predicate = this._startPredicateData;

    if (predicate) {
      if (predicate.delayTimer) {
        predicate.delayTimer = window.clearTimeout(predicate.delayTimer);
      }

      this._startPredicateData = null;
    }
  };
  /**
   * Check (during drag) if an item is overlapping other items and based on
   * the configuration layout the items.
   *
   * @private
   * @memberof ItemDrag.prototype
   */


  ItemDrag.prototype._checkOverlap = function () {
    if (!this._isActive) return;
    var item = this._item;

    var settings = this._getGrid()._settings;

    var result;
    var currentGrid;
    var currentIndex;
    var targetGrid;
    var targetIndex;
    var sortAction;
    var isMigration; // Get overlap check result.

    if (isFunction(settings.dragSortPredicate)) {
      result = settings.dragSortPredicate(item, this._dragEvent);
    } else {
      result = ItemDrag.defaultSortPredicate(item, settings.dragSortPredicate);
    } // Let's make sure the result object has a valid index before going further.


    if (!result || typeof result.index !== 'number') return;
    currentGrid = item.getGrid();
    targetGrid = result.grid || currentGrid;
    isMigration = currentGrid !== targetGrid;
    currentIndex = currentGrid._items.indexOf(item);
    targetIndex = normalizeArrayIndex(targetGrid._items, result.index, isMigration);
    sortAction = result.action === actionSwap ? actionSwap : actionMove; // Prevent position bounce.

    if (!isMigration && targetIndex === this._hBlockedIndex) {
      return;
    } // If the item was moved within it's current grid.


    if (!isMigration) {
      // Make sure the target index is not the current index.
      if (currentIndex !== targetIndex) {
        this._hBlockedIndex = currentIndex; // Do the sort.

        (sortAction === actionSwap ? arraySwap : arrayMove)(currentGrid._items, currentIndex, targetIndex); // Emit move event.

        if (currentGrid._hasListeners(eventMove)) {
          currentGrid._emit(eventMove, {
            item: item,
            fromIndex: currentIndex,
            toIndex: targetIndex,
            action: sortAction
          });
        } // Layout the grid.


        currentGrid.layout();
      }
    } // If the item was moved to another grid.
    else {
      this._hBlockedIndex = null; // Emit beforeSend event.

      if (currentGrid._hasListeners(eventBeforeSend)) {
        currentGrid._emit(eventBeforeSend, {
          item: item,
          fromGrid: currentGrid,
          fromIndex: currentIndex,
          toGrid: targetGrid,
          toIndex: targetIndex
        });
      } // Emit beforeReceive event.


      if (targetGrid._hasListeners(eventBeforeReceive)) {
        targetGrid._emit(eventBeforeReceive, {
          item: item,
          fromGrid: currentGrid,
          fromIndex: currentIndex,
          toGrid: targetGrid,
          toIndex: targetIndex
        });
      } // Update item's grid id reference.


      item._gridId = targetGrid._id; // Update drag instance's migrating indicator.

      this._isMigrating = item._gridId !== this._gridId; // Move item instance from current grid to target grid.

      currentGrid._items.splice(currentIndex, 1);

      arrayInsert(targetGrid._items, item, targetIndex); // Set sort data as null, which is an indicator for the item comparison
      // function that the sort data of this specific item should be fetched
      // lazily.

      item._sortData = null; // Emit send event.

      if (currentGrid._hasListeners(eventSend)) {
        currentGrid._emit(eventSend, {
          item: item,
          fromGrid: currentGrid,
          fromIndex: currentIndex,
          toGrid: targetGrid,
          toIndex: targetIndex
        });
      } // Emit receive event.


      if (targetGrid._hasListeners(eventReceive)) {
        targetGrid._emit(eventReceive, {
          item: item,
          fromGrid: currentGrid,
          fromIndex: currentIndex,
          toGrid: targetGrid,
          toIndex: targetIndex
        });
      } // Layout both grids.


      currentGrid.layout();
      targetGrid.layout();
    }
  };
  /**
   * If item is dragged into another grid, finish the migration process
   * gracefully.
   *
   * @private
   * @memberof ItemDrag.prototype
   */


  ItemDrag.prototype._finishMigration = function () {
    var item = this._item;
    var release = item._release;
    var element = item._element;
    var isActive = item._isActive;
    var targetGrid = item.getGrid();
    var targetGridElement = targetGrid._element;
    var targetSettings = targetGrid._settings;
    var targetContainer = targetSettings.dragContainer || targetGridElement;

    var currentSettings = this._getGrid()._settings;

    var currentContainer = element.parentNode;
    var translate;
    var offsetDiff; // Destroy current drag. Note that we need to set the migrating flag to
    // false first, because otherwise we create an infinite loop between this
    // and the drag.stop() method.

    this._isMigrating = false;
    this.destroy(); // Remove current classnames.

    removeClass(element, currentSettings.itemClass);
    removeClass(element, currentSettings.itemVisibleClass);
    removeClass(element, currentSettings.itemHiddenClass); // Add new classnames.

    addClass(element, targetSettings.itemClass);
    addClass(element, isActive ? targetSettings.itemVisibleClass : targetSettings.itemHiddenClass); // Move the item inside the target container if it's different than the
    // current container.

    if (targetContainer !== currentContainer) {
      targetContainer.appendChild(element);
      offsetDiff = getOffsetDiff(currentContainer, targetContainer, true);
      translate = getTranslate(element);
      translate.x -= offsetDiff.left;
      translate.y -= offsetDiff.top;
    } // Update item's cached dimensions and sort data.


    item._refreshDimensions();

    item._refreshSortData(); // Calculate the offset difference between target's drag container (if any)
    // and actual grid container element. We save it later for the release
    // process.


    offsetDiff = getOffsetDiff(targetContainer, targetGridElement, true);
    release._containerDiffX = offsetDiff.left;
    release._containerDiffY = offsetDiff.top; // Recreate item's drag handler.

    item._drag = targetSettings.dragEnabled ? new ItemDrag(item) : null; // Adjust the position of the item element if it was moved from a container
    // to another.

    if (targetContainer !== currentContainer) {
      element.style[transformProp] = getTranslateString(translate.x, translate.y);
    } // Update child element's styles to reflect the current visibility state.


    item._child.removeAttribute('style');

    setStyles(item._child, isActive ? targetSettings.visibleStyles : targetSettings.hiddenStyles); // Start the release.

    release.start();
  };
  /**
   * Drag pre-start handler.
   *
   * @private
   * @memberof ItemDrag.prototype
   * @param {DraggerEvent} event
   */


  ItemDrag.prototype._preStartCheck = function (event) {
    // Let's activate drag start predicate state.
    if (this._startPredicateState === startPredicateInactive) {
      this._startPredicateState = startPredicatePending;
    } // If predicate is pending try to resolve it.


    if (this._startPredicateState === startPredicatePending) {
      this._startPredicateResult = this._startPredicate(this._item, event);

      if (this._startPredicateResult === true) {
        this._startPredicateState = startPredicateResolved;

        this._onStart(event);
      } else if (this._startPredicateResult === false) {
        this._startPredicateState = startPredicateRejected;
      }
    } // Otherwise if predicate is resolved and drag is active, move the item.
    else if (this._startPredicateState === startPredicateResolved && this._isActive) {
      this._onMove(event);
    }
  };
  /**
   * Drag pre-end handler.
   *
   * @private
   * @memberof ItemDrag.prototype
   * @param {DraggerEvent} event
   */


  ItemDrag.prototype._preEndCheck = function (event) {
    // Check if the start predicate was resolved during drag.
    var isResolved = this._startPredicateState === startPredicateResolved; // Do final predicate check to allow user to unbind stuff for the current
    // drag procedure within the predicate callback. The return value of this
    // check will have no effect to the state of the predicate.

    this._startPredicate(this._item, event); // Reset start predicate state.


    this._startPredicateState = startPredicateInactive; // If predicate is resolved and dragging is active, call the end handler.

    if (isResolved && this._isActive) this._onEnd(event);
  };
  /**
   * Drag start handler.
   *
   * @private
   * @memberof ItemDrag.prototype
   * @param {DraggerEvent} event
   */


  ItemDrag.prototype._onStart = function (event) {
    var item = this._item; // If item is not active, don't start the drag.

    if (!item._isActive) return;
    var element = item._element;

    var grid = this._getGrid();

    var settings = grid._settings;
    var release = item._release;
    var migrate = item._migrate;
    var gridContainer = grid._element;
    var dragContainer = settings.dragContainer || gridContainer;
    var containingBlock = getContainingBlock(dragContainer, true);
    var translate = getTranslate(element);
    var currentLeft = translate.x;
    var currentTop = translate.y;
    var elementRect = element.getBoundingClientRect();
    var hasDragContainer = dragContainer !== gridContainer;
    var offsetDiff; // Reset heuristics data.

    this._resetHeuristics(event); // If grid container is not the drag container, we need to calculate the
    // offset difference between grid container and drag container's containing
    // element.


    if (hasDragContainer) {
      offsetDiff = getOffsetDiff(containingBlock, gridContainer);
    } // Stop current positioning animation.


    if (item.isPositioning()) {
      item._layout.stop(true, {
        transform: getTranslateString(currentLeft, currentTop)
      });
    } // Stop current migration animation.


    if (migrate._isActive) {
      currentLeft -= migrate._containerDiffX;
      currentTop -= migrate._containerDiffY;
      migrate.stop(true, {
        transform: getTranslateString(currentLeft, currentTop)
      });
    } // If item is being released reset release data.


    if (item.isReleasing()) release._reset(); // Setup drag data.

    this._isActive = true;
    this._dragEvent = event;
    this._container = dragContainer;
    this._containingBlock = containingBlock;
    this._elementClientX = elementRect.left;
    this._elementClientY = elementRect.top;
    this._left = this._gridX = currentLeft;
    this._top = this._gridY = currentTop; // Create placeholder (if necessary).

    if (settings.dragPlaceholder.enabled) {
      item._dragPlaceholder.create();
    } // Emit dragInit event.


    grid._emit(eventDragInit, item, event); // If a specific drag container is set and it is different from the
    // grid's container element we need to cast some extra spells.


    if (hasDragContainer) {
      // Store the container offset diffs to drag data.
      this._containerDiffX = offsetDiff.left;
      this._containerDiffY = offsetDiff.top; // If the dragged element is a child of the drag container all we need to
      // do is setup the relative drag position data.

      if (element.parentNode === dragContainer) {
        this._gridX = currentLeft - this._containerDiffX;
        this._gridY = currentTop - this._containerDiffY;
      } // Otherwise we need to append the element inside the correct container,
      // setup the actual drag position data and adjust the element's translate
      // values to account for the DOM position shift.
      else {
        this._left = currentLeft + this._containerDiffX;
        this._top = currentTop + this._containerDiffY;
        dragContainer.appendChild(element);
        element.style[transformProp] = getTranslateString(this._left, this._top);
      }
    } // Set drag class and bind scrollers.


    addClass(element, settings.itemDraggingClass);

    this._bindScrollListeners(); // Emit dragStart event.


    grid._emit(eventDragStart, item, event);
  };
  /**
   * Drag move handler.
   *
   * @private
   * @memberof ItemDrag.prototype
   * @param {DraggerEvent} event
   */


  ItemDrag.prototype._onMove = function (event) {
    var item = this._item; // If item is not active, reset drag.

    if (!item._isActive) {
      this.stop();
      return;
    }

    var settings = this._getGrid()._settings;

    var axis = settings.dragAxis; // Update horizontal position data.

    if (axis !== 'y') {
      var xDiff = event.clientX - this._dragEvent.clientX;
      this._left += xDiff;
      this._gridX += xDiff;
      this._elementClientX += xDiff;
    } // Update vertical position data.


    if (axis !== 'x') {
      var yDiff = event.clientY - this._dragEvent.clientY;
      this._top += yDiff;
      this._gridY += yDiff;
      this._elementClientY += yDiff;
    } // Update event data.


    this._dragEvent = event; // Do move prepare/apply handling in the next tick.

    addMoveTick(item._id, this._prepareMove, this._applyMove);
  };
  /**
   * Prepare dragged item for moving.
   *
   * @private
   * @memberof ItemDrag.prototype
   */


  ItemDrag.prototype._prepareMove = function () {
    // Do nothing if item is not active.
    if (!this._item._isActive) return; // If drag sort is enabled -> check overlap.

    if (this._getGrid()._settings.dragSort) {
      if (this._checkHeuristics(this._dragEvent)) {
        this._checkOverlapDebounce();
      }
    }
  };
  /**
   * Apply movement to dragged item.
   *
   * @private
   * @memberof ItemDrag.prototype
   */


  ItemDrag.prototype._applyMove = function () {
    var item = this._item; // Do nothing if item is not active.

    if (!item._isActive) return; // Update element's translateX/Y values.

    item._element.style[transformProp] = getTranslateString(this._left, this._top); // Emit dragMove event.

    this._getGrid()._emit(eventDragMove, item, this._dragEvent);
  };
  /**
   * Drag scroll handler.
   *
   * @private
   * @memberof ItemDrag.prototype
   * @param {Event} event
   */


  ItemDrag.prototype._onScroll = function (event) {
    var item = this._item; // If item is not active, reset drag.

    if (!item._isActive) {
      this.stop();
      return;
    } // Update last scroll event.


    this._scrollEvent = event; // Do scroll prepare/apply handling in the next tick.

    addScrollTick(item._id, this._prepareScroll, this._applyScroll);
  };
  /**
   * Prepare dragged item for scrolling.
   *
   * @private
   * @memberof ItemDrag.prototype
   */


  ItemDrag.prototype._prepareScroll = function () {
    var item = this._item; // If item is not active do nothing.

    if (!item._isActive) return;
    var element = item._element;

    var grid = this._getGrid();

    var settings = grid._settings;
    var axis = settings.dragAxis;
    var gridContainer = grid._element;
    var offsetDiff; // Calculate element's rect and x/y diff.

    var rect = element.getBoundingClientRect();
    var xDiff = this._elementClientX - rect.left;
    var yDiff = this._elementClientY - rect.top; // Update container diff.

    if (this._container !== gridContainer) {
      offsetDiff = getOffsetDiff(this._containingBlock, gridContainer);
      this._containerDiffX = offsetDiff.left;
      this._containerDiffY = offsetDiff.top;
    } // Update horizontal position data.


    if (axis !== 'y') {
      this._left += xDiff;
      this._gridX = this._left - this._containerDiffX;
    } // Update vertical position data.


    if (axis !== 'x') {
      this._top += yDiff;
      this._gridY = this._top - this._containerDiffY;
    } // Overlap handling.


    if (settings.dragSort) this._checkOverlapDebounce();
  };
  /**
   * Apply scroll to dragged item.
   *
   * @private
   * @memberof ItemDrag.prototype
   */


  ItemDrag.prototype._applyScroll = function () {
    var item = this._item; // If item is not active do nothing.

    if (!item._isActive) return; // Update element's translateX/Y values.

    item._element.style[transformProp] = getTranslateString(this._left, this._top); // Emit dragScroll event.

    this._getGrid()._emit(eventDragScroll, item, this._scrollEvent);
  };
  /**
   * Drag end handler.
   *
   * @private
   * @memberof ItemDrag.prototype
   * @param {DraggerEvent} event
   */


  ItemDrag.prototype._onEnd = function (event) {
    var item = this._item;
    var element = item._element;

    var grid = this._getGrid();

    var settings = grid._settings;
    var release = item._release; // If item is not active, reset drag.

    if (!item._isActive) {
      this.stop();
      return;
    } // Cancel queued move and scroll ticks.


    cancelMoveTick(item._id);
    cancelScrollTick(item._id); // Finish currently queued overlap check.

    settings.dragSort && this._checkOverlapDebounce('finish'); // Remove scroll listeners.

    this._unbindScrollListeners(); // Setup release data.


    release._containerDiffX = this._containerDiffX;
    release._containerDiffY = this._containerDiffY; // Reset drag data.

    this._reset(); // Remove drag class name from element.


    removeClass(element, settings.itemDraggingClass); // Emit dragEnd event.

    grid._emit(eventDragEnd, item, event); // Finish up the migration process or start the release process.


    this._isMigrating ? this._finishMigration() : release.start();
  };
  /**
   * Private helpers
   * ***************
   */

  /**
   * Calculate how many percent the intersection area of two rectangles is from
   * the maximum potential intersection area between the rectangles.
   *
   * @param {Rectangle} a
   * @param {Rectangle} b
   * @returns {Number}
   *   - A number between 0-100.
   */


  function getRectOverlapScore(a, b) {
    // Return 0 immediately if the rectangles do not overlap.
    if (a.left + a.width <= b.left || b.left + b.width <= a.left || a.top + a.height <= b.top || b.top + b.height <= a.top) {
      return 0;
    } // Calculate intersection area's width, height, max height and max width.


    var width = Math.min(a.left + a.width, b.left + b.width) - Math.max(a.left, b.left);
    var height = Math.min(a.top + a.height, b.top + b.height) - Math.max(a.top, b.top);
    var maxWidth = Math.min(a.width, b.width);
    var maxHeight = Math.min(a.height, b.height);
    return width * height / (maxWidth * maxHeight) * 100;
  }
  /**
   * Check if an element is an anchor element and open the href url if possible.
   *
   * @param {HTMLElement} element
   */


  function openAnchorHref(element) {
    // Make sure the element is anchor element.
    if (element.tagName.toLowerCase() !== 'a') return; // Get href and make sure it exists.

    var href = element.getAttribute('href');
    if (!href) return; // Finally let's navigate to the link href.

    var target = element.getAttribute('target');

    if (target && target !== '_self') {
      window.open(href, target);
    } else {
      window.location.href = href;
    }
  }
  /**
   * Drag placeholder.
   *
   * @class
   * @param {Item} item
   */


  function ItemDragPlaceholder(item) {
    this._item = item;
    this._animate = new ItemAnimate();
    this._element = null;
    this._className = '';
    this._didMigrate = false;
    this._resetAfterLayout = false;
    this._currentLeft = 0;
    this._currentTop = 0;
    this._nextLeft = 0;
    this._nextTop = 0; // Bind animation handlers.

    this._setupAnimation = this._setupAnimation.bind(this);
    this._startAnimation = this._startAnimation.bind(this); // Bind event handlers.

    this._onLayoutStart = this._onLayoutStart.bind(this);
    this._onLayoutEnd = this._onLayoutEnd.bind(this);
    this._onReleaseEnd = this._onReleaseEnd.bind(this);
    this._onMigrate = this._onMigrate.bind(this);
  }
  /**
   * Private prototype methods
   * *************************
   */

  /**
   * Move placeholder to a new position.
   *
   * @private
   * @memberof ItemDragPlaceholder.prototype
   */


  ItemDragPlaceholder.prototype._onLayoutStart = function () {
    var item = this._item;
    var grid = item.getGrid(); // Find out the item's new (unapplied) left and top position.

    var itemIndex = grid._items.indexOf(item);

    var nextLeft = grid._layout.slots[itemIndex * 2];
    var nextTop = grid._layout.slots[itemIndex * 2 + 1]; // If item's position did not change and the item did not migrate we can
    // safely skip layout.

    if (!this._didMigrate && item._left === nextLeft && item._top === nextTop) {
      return;
    } // Slots data is calculated with item margins added to them so we need to add
    // item's left and top margin to the slot data to get the placeholder's
    // next position.


    nextLeft += item._marginLeft;
    nextTop += item._marginTop; // Just snap to new position without any animations if no animation is
    // required or if placeholder moves between grids.

    var animEnabled = grid._settings.dragPlaceholder.duration > 0;

    if (!animEnabled || this._didMigrate) {
      // Cancel potential (queued) layout tick.
      cancelPlaceholderTick(item._id); // Snap placeholder to correct position.

      var targetStyles = {
        transform: getTranslateString(nextLeft, nextTop)
      };

      if (this._animate.isAnimating()) {
        this._animate.stop(targetStyles);
      } else {
        setStyles(this._element, targetStyles);
      } // Move placeholder inside correct container after migration.


      if (this._didMigrate) {
        grid.getElement().appendChild(this._element);
        this._didMigrate = false;
      }

      return;
    } // Start the placeholder's layout animation in the next tick. We do this to
    // avoid layout thrashing.


    this._nextLeft = nextLeft;
    this._nextTop = nextTop;
    addPlaceholderTick(item._id, this._setupAnimation, this._startAnimation);
  };
  /**
   * Prepare placeholder for layout animation.
   *
   * @private
   * @memberof ItemDragPlaceholder.prototype
   */


  ItemDragPlaceholder.prototype._setupAnimation = function () {
    if (!this.isActive()) return;
    var translate = getTranslate(this._element);
    this._currentLeft = translate.x;
    this._currentTop = translate.y;
  };
  /**
   * Start layout animation.
   *
   * @private
   * @memberof ItemDragPlaceholder.prototype
   */


  ItemDragPlaceholder.prototype._startAnimation = function () {
    if (!this.isActive()) return;
    var animation = this._animate;
    var currentLeft = this._currentLeft;
    var currentTop = this._currentTop;
    var nextLeft = this._nextLeft;
    var nextTop = this._nextTop;
    var targetStyles = {
      transform: getTranslateString(nextLeft, nextTop)
    }; // If placeholder is already in correct position let's just stop animation
    // and be done with it.

    if (currentLeft === nextLeft && currentTop === nextTop) {
      if (animation.isAnimating()) animation.stop(targetStyles);
      return;
    } // Otherwise let's start the animation.


    var settings = this._item.getGrid()._settings.dragPlaceholder;

    var currentStyles = {
      transform: getTranslateString(currentLeft, currentTop)
    };
    animation.start(currentStyles, targetStyles, {
      duration: settings.duration,
      easing: settings.easing,
      onFinish: this._onLayoutEnd
    });
  };
  /**
   * Layout end handler.
   *
   * @private
   * @memberof ItemDragPlaceholder.prototype
   */


  ItemDragPlaceholder.prototype._onLayoutEnd = function () {
    if (this._resetAfterLayout) {
      this.reset();
    }
  };
  /**
   * Drag end handler. This handler is called when dragReleaseEnd event is
   * emitted and receives the event data as it's argument.
   *
   * @private
   * @memberof ItemDragPlaceholder.prototype
   * @param {Item} item
   */


  ItemDragPlaceholder.prototype._onReleaseEnd = function (item) {
    if (item._id === this._item._id) {
      // If the placeholder is not animating anymore we can safely reset it.
      if (!this._animate.isAnimating()) {
        this.reset();
        return;
      } // If the placeholder item is still animating here, let's wait for it to
      // finish it's animation.


      this._resetAfterLayout = true;
    }
  };
  /**
   * Migration start handler. This handler is called when beforeSend event is
   * emitted and receives the event data as it's argument.
   *
   * @private
   * @memberof ItemDragPlaceholder.prototype
   * @param {Object} data
   * @param {Item} data.item
   * @param {Grid} data.fromGrid
   * @param {Number} data.fromIndex
   * @param {Grid} data.toGrid
   * @param {Number} data.toIndex
   */


  ItemDragPlaceholder.prototype._onMigrate = function (data) {
    // Make sure we have a matching item.
    if (data.item !== this._item) return;

    var grid = this._item.getGrid();

    var nextGrid = data.toGrid; // Unbind listeners from current grid.

    grid.off(eventDragReleaseEnd, this._onReleaseEnd);
    grid.off(eventLayoutStart, this._onLayoutStart);
    grid.off(eventBeforeSend, this._onMigrate); // Bind listeners to the next grid.

    nextGrid.on(eventDragReleaseEnd, this._onReleaseEnd);
    nextGrid.on(eventLayoutStart, this._onLayoutStart);
    nextGrid.on(eventBeforeSend, this._onMigrate); // Mark the item as migrated.

    this._didMigrate = true;
  };
  /**
   * Public prototype methods
   * ************************
   */

  /**
   * Create placeholder. Note that this method only writes to DOM and does not
   * read anything from DOM so it should not cause any additional layout
   * thrashing when it's called at the end of the drag start procedure.
   *
   * @public
   * @memberof ItemDragPlaceholder.prototype
   */


  ItemDragPlaceholder.prototype.create = function () {
    // If we already have placeholder set up we can skip the initiation logic.
    if (this.isActive()) {
      this._resetAfterLayout = false;
      return;
    }

    var item = this._item;
    var grid = item.getGrid();
    var settings = grid._settings;
    var animation = this._animate; // Create placeholder element.

    var element;

    if (isFunction(settings.dragPlaceholder.createElement)) {
      element = settings.dragPlaceholder.createElement(item);
    } else {
      element = window.document.createElement('div');
    }

    this._element = element; // Update element to animation instance.

    animation._element = element; // Add placeholder class to the placeholder element.

    this._className = settings.itemPlaceholderClass || '';

    if (this._className) {
      addClass(element, this._className);
    } // Position the placeholder item correctly.


    var left = item._left + item._marginLeft;
    var top = item._top + item._marginTop;
    setStyles(element, {
      display: 'block',
      position: 'absolute',
      left: '0',
      top: '0',
      width: item._width + 'px',
      height: item._height + 'px',
      transform: getTranslateString(left, top)
    }); // Bind event listeners.

    grid.on(eventLayoutStart, this._onLayoutStart);
    grid.on(eventDragReleaseEnd, this._onReleaseEnd);
    grid.on(eventBeforeSend, this._onMigrate); // onCreate hook.

    if (isFunction(settings.dragPlaceholder.onCreate)) {
      settings.dragPlaceholder.onCreate(item, element);
    } // Insert the placeholder element to the grid.


    grid.getElement().appendChild(element);
  };
  /**
   * Reset placeholder data.
   *
   * @public
   * @memberof ItemDragPlaceholder.prototype
   */


  ItemDragPlaceholder.prototype.reset = function () {
    if (!this.isActive()) return;
    var element = this._element;
    var item = this._item;
    var grid = item.getGrid();
    var settings = grid._settings;
    var animation = this._animate; // Reset flag.

    this._resetAfterLayout = false; // Cancel potential (queued) layout tick.

    cancelPlaceholderTick(item._id); // Reset animation instance.

    animation.stop();
    animation._element = null; // Unbind event listeners.

    grid.off(eventDragReleaseEnd, this._onReleaseEnd);
    grid.off(eventLayoutStart, this._onLayoutStart);
    grid.off(eventBeforeSend, this._onMigrate); // Remove placeholder class from the placeholder element.

    if (this._className) {
      removeClass(element, this._className);
      this._className = '';
    } // Remove element.


    element.parentNode.removeChild(element);
    this._element = null; // onRemove hook. Note that here we use the current grid's onRemove callback
    // so if the item has migrated during drag the onRemove method will not be
    // the originating grid's method.

    if (isFunction(settings.dragPlaceholder.onRemove)) {
      settings.dragPlaceholder.onRemove(item, element);
    }
  };
  /**
   * Update placeholder's dimensions.
   *
   * @public
   * @memberof ItemDragPlaceholder.prototype
   * @param {Number} width
   * @param {height} height
   */


  ItemDragPlaceholder.prototype.updateDimensions = function (width, height) {
    if (this.isActive()) {
      setStyles(this._element, {
        width: width + 'px',
        height: height + 'px'
      });
    }
  };
  /**
   * Check if placeholder is currently active (visible).
   *
   * @public
   * @memberof ItemDragPlaceholder.prototype
   * @returns {Boolean}
   */


  ItemDragPlaceholder.prototype.isActive = function () {
    return !!this._element;
  };
  /**
   * Destroy placeholder instance.
   *
   * @public
   * @memberof ItemDragPlaceholder.prototype
   */


  ItemDragPlaceholder.prototype.destroy = function () {
    this.reset();

    this._animate.destroy();

    this._item = this._animate = null;
  };
  /**
   * Queue constructor.
   *
   * @class
   */


  function Queue() {
    this._queue = [];
    this._isDestroyed = false;
  }
  /**
   * Public prototype methods
   * ************************
   */

  /**
   * Add callback to the queue.
   *
   * @public
   * @memberof Queue.prototype
   * @param {Function} callback
   * @returns {Queue}
   */


  Queue.prototype.add = function (callback) {
    if (this._isDestroyed) return this;

    this._queue.push(callback);

    return this;
  };
  /**
   * Process queue callbacks and reset the queue.
   *
   * @public
   * @memberof Queue.prototype
   * @param {*} arg1
   * @param {*} arg2
   * @returns {Queue}
   */


  Queue.prototype.flush = function (arg1, arg2) {
    if (this._isDestroyed) return this;
    var queue = this._queue;
    var length = queue.length;
    var i; // Quit early if the queue is empty.

    if (!length) return this;
    var singleCallback = length === 1;
    var snapshot = singleCallback ? queue[0] : queue.slice(0); // Reset queue.

    queue.length = 0; // If we only have a single callback let's just call it.

    if (singleCallback) {
      snapshot(arg1, arg2);
      return this;
    } // If we have multiple callbacks, let's process them.


    for (i = 0; i < length; i++) {
      snapshot[i](arg1, arg2);
      if (this._isDestroyed) break;
    }

    return this;
  };
  /**
   * Destroy Queue instance.
   *
   * @public
   * @memberof Queue.prototype
   * @returns {Queue}
   */


  Queue.prototype.destroy = function () {
    if (this._isDestroyed) return this;
    this._isDestroyed = true;
    this._queue.length = 0;
    return this;
  };
  /**
   * Layout manager for Item instance.
   *
   * @class
   * @param {Item} item
   */


  function ItemLayout(item) {
    this._item = item;
    this._isActive = false;
    this._isDestroyed = false;
    this._isInterrupted = false;
    this._currentStyles = {};
    this._targetStyles = {};
    this._currentLeft = 0;
    this._currentTop = 0;
    this._offsetLeft = 0;
    this._offsetTop = 0;
    this._skipNextAnimation = false;
    this._animateOptions = {
      onFinish: this._finish.bind(this)
    };
    this._queue = new Queue(); // Bind animation handlers and finish method.

    this._setupAnimation = this._setupAnimation.bind(this);
    this._startAnimation = this._startAnimation.bind(this);
  }
  /**
   * Public prototype methods
   * ************************
   */

  /**
   * Start item layout based on it's current data.
   *
   * @public
   * @memberof ItemLayout.prototype
   * @param {Boolean} [instant=false]
   * @param {Function} [onFinish]
   * @returns {ItemLayout}
   */


  ItemLayout.prototype.start = function (instant, onFinish) {
    if (this._isDestroyed) return;
    var item = this._item;
    var element = item._element;
    var release = item._release;

    var gridSettings = item.getGrid()._settings;

    var isPositioning = this._isActive;
    var isJustReleased = release._isActive && release._isPositioningStarted === false;
    var animDuration = isJustReleased ? gridSettings.dragReleaseDuration : gridSettings.layoutDuration;
    var animEasing = isJustReleased ? gridSettings.dragReleaseEasing : gridSettings.layoutEasing;
    var animEnabled = !instant && !this._skipNextAnimation && animDuration > 0;
    var isAnimating; // If the item is currently positioning process current layout callback
    // queue with interrupted flag on.

    if (isPositioning) this._queue.flush(true, item); // Mark release positioning as started.

    if (isJustReleased) release._isPositioningStarted = true; // Push the callback to the callback queue.

    if (isFunction(onFinish)) this._queue.add(onFinish); // If no animations are needed, easy peasy!

    if (!animEnabled) {
      this._updateOffsets();

      this._updateTargetStyles();

      isAnimating = item._animate.isAnimating();
      this.stop(false, this._targetStyles);
      !isAnimating && setStyles(element, this._targetStyles);
      this._skipNextAnimation = false;
      return this._finish();
    } // Set item active and store some data for the animation that is about to be
    // triggered.


    this._isActive = true;
    this._animateOptions.easing = animEasing;
    this._animateOptions.duration = animDuration;
    this._isInterrupted = isPositioning; // Start the item's layout animation in the next tick.

    addLayoutTick(item._id, this._setupAnimation, this._startAnimation);
    return this;
  };
  /**
   * Stop item's position animation if it is currently animating.
   *
   * @public
   * @memberof ItemLayout.prototype
   * @param {Boolean} [processCallbackQueue=false]
   * @param {Object} [targetStyles]
   * @returns {ItemLayout}
   */


  ItemLayout.prototype.stop = function (processCallbackQueue, targetStyles) {
    if (this._isDestroyed || !this._isActive) return this;
    var item = this._item; // Cancel animation init.

    cancelLayoutTick(item._id); // Stop animation.

    item._animate.stop(targetStyles); // Remove positioning class.


    removeClass(item._element, item.getGrid()._settings.itemPositioningClass); // Reset active state.

    this._isActive = false; // Process callback queue if needed.

    if (processCallbackQueue) this._queue.flush(true, item);
    return this;
  };
  /**
   * Destroy the instance and stop current animation if it is running.
   *
   * @public
   * @memberof ItemLayout.prototype
   * @returns {ItemLayout}
   */


  ItemLayout.prototype.destroy = function () {
    if (this._isDestroyed) return this;
    this.stop(true, {});

    this._queue.destroy();

    this._item = this._currentStyles = this._targetStyles = this._animateOptions = null;
    this._isDestroyed = true;
    return this;
  };
  /**
   * Private prototype methods
   * *************************
   */

  /**
   * Calculate and update item's current layout offset data.
   *
   * @private
   * @memberof ItemLayout.prototype
   */


  ItemLayout.prototype._updateOffsets = function () {
    if (this._isDestroyed) return;
    var item = this._item;
    var migrate = item._migrate;
    var release = item._release;
    this._offsetLeft = release._isActive ? release._containerDiffX : migrate._isActive ? migrate._containerDiffX : 0;
    this._offsetTop = release._isActive ? release._containerDiffY : migrate._isActive ? migrate._containerDiffY : 0;
  };
  /**
   * Calculate and update item's layout target styles.
   *
   * @private
   * @memberof ItemLayout.prototype
   */


  ItemLayout.prototype._updateTargetStyles = function () {
    if (this._isDestroyed) return;
    this._targetStyles.transform = getTranslateString(this._item._left + this._offsetLeft, this._item._top + this._offsetTop);
  };
  /**
   * Finish item layout procedure.
   *
   * @private
   * @memberof ItemLayout.prototype
   */


  ItemLayout.prototype._finish = function () {
    if (this._isDestroyed) return;
    var item = this._item;
    var migrate = item._migrate;
    var release = item._release; // Mark the item as inactive and remove positioning classes.

    if (this._isActive) {
      this._isActive = false;
      removeClass(item._element, item.getGrid()._settings.itemPositioningClass);
    } // Finish up release and migration.


    if (release._isActive) release.stop();
    if (migrate._isActive) migrate.stop(); // Process the callback queue.

    this._queue.flush(false, item);
  };
  /**
   * Prepare item for layout animation.
   *
   * @private
   * @memberof ItemLayout.prototype
   */


  ItemLayout.prototype._setupAnimation = function () {
    var translate = getTranslate(this._item._element);
    this._currentLeft = translate.x;
    this._currentTop = translate.y;
  };
  /**
   * Start layout animation.
   *
   * @private
   * @memberof ItemLayout.prototype
   */


  ItemLayout.prototype._startAnimation = function () {
    var item = this._item;

    var settings = item.getGrid()._settings; // Let's update the offset data and target styles.


    this._updateOffsets();

    this._updateTargetStyles(); // If the item is already in correct position let's quit early.


    if (item._left === this._currentLeft - this._offsetLeft && item._top === this._currentTop - this._offsetTop) {
      if (this._isInterrupted) this.stop(false, this._targetStyles);
      this._isActive = false;

      this._finish();

      return;
    } // Set item's positioning class if needed.


    if (!this._isInterrupted) {
      addClass(item._element, settings.itemPositioningClass);
    } // Get current styles for animation.


    this._currentStyles.transform = getTranslateString(this._currentLeft, this._currentTop); // Animate.

    item._animate.start(this._currentStyles, this._targetStyles, this._animateOptions);
  };

  var tempStyles = {};
  /**
   * The migrate process handler constructor.
   *
   * @class
   * @param {Item} item
   */

  function ItemMigrate(item) {
    // Private props.
    this._item = item;
    this._isActive = false;
    this._isDestroyed = false;
    this._container = false;
    this._containerDiffX = 0;
    this._containerDiffY = 0;
  }
  /**
   * Public prototype methods
   * ************************
   */

  /**
   * Start the migrate process of an item.
   *
   * @public
   * @memberof ItemMigrate.prototype
   * @param {Grid} targetGrid
   * @param {GridSingleItemQuery} position
   * @param {HTMLElement} [container]
   * @returns {ItemMigrate}
   */


  ItemMigrate.prototype.start = function (targetGrid, position, container) {
    if (this._isDestroyed) return this;
    var item = this._item;
    var element = item._element;
    var isVisible = item.isVisible();
    var grid = item.getGrid();
    var settings = grid._settings;
    var targetSettings = targetGrid._settings;
    var targetElement = targetGrid._element;
    var targetItems = targetGrid._items;

    var currentIndex = grid._items.indexOf(item);

    var targetContainer = container || window.document.body;
    var targetIndex;
    var targetItem;
    var currentContainer;
    var offsetDiff;
    var containerDiff;
    var translate;
    var translateX;
    var translateY; // Get target index.

    if (typeof position === 'number') {
      targetIndex = normalizeArrayIndex(targetItems, position, true);
    } else {
      targetItem = targetGrid._getItem(position);
      /** @todo Consider throwing an error here instead of silently failing. */

      if (!targetItem) return this;
      targetIndex = targetItems.indexOf(targetItem);
    } // Get current translateX and translateY values if needed.


    if (item.isPositioning() || this._isActive || item.isReleasing()) {
      translate = getTranslate(element);
      translateX = translate.x;
      translateY = translate.y;
    } // Abort current positioning.


    if (item.isPositioning()) {
      item._layout.stop(true, {
        transform: getTranslateString(translateX, translateY)
      });
    } // Abort current migration.


    if (this._isActive) {
      translateX -= this._containerDiffX;
      translateY -= this._containerDiffY;
      this.stop(true, {
        transform: getTranslateString(translateX, translateY)
      });
    } // Abort current release.


    if (item.isReleasing()) {
      translateX -= item._release._containerDiffX;
      translateY -= item._release._containerDiffY;

      item._release.stop(true, {
        transform: getTranslateString(translateX, translateY)
      });
    } // Stop current visibility animations.


    item._visibility._stopAnimation(); // Destroy current drag.


    if (item._drag) item._drag.destroy(); // Process current visibility animation queue.

    item._visibility._queue.flush(true, item); // Emit beforeSend event.


    if (grid._hasListeners(eventBeforeSend)) {
      grid._emit(eventBeforeSend, {
        item: item,
        fromGrid: grid,
        fromIndex: currentIndex,
        toGrid: targetGrid,
        toIndex: targetIndex
      });
    } // Emit beforeReceive event.


    if (targetGrid._hasListeners(eventBeforeReceive)) {
      targetGrid._emit(eventBeforeReceive, {
        item: item,
        fromGrid: grid,
        fromIndex: currentIndex,
        toGrid: targetGrid,
        toIndex: targetIndex
      });
    } // Remove current classnames.


    removeClass(element, settings.itemClass);
    removeClass(element, settings.itemVisibleClass);
    removeClass(element, settings.itemHiddenClass); // Add new classnames.

    addClass(element, targetSettings.itemClass);
    addClass(element, isVisible ? targetSettings.itemVisibleClass : targetSettings.itemHiddenClass); // Move item instance from current grid to target grid.

    grid._items.splice(currentIndex, 1);

    arrayInsert(targetItems, item, targetIndex); // Update item's grid id reference.

    item._gridId = targetGrid._id; // Get current container.

    currentContainer = element.parentNode; // Move the item inside the target container if it's different than the
    // current container.

    if (targetContainer !== currentContainer) {
      targetContainer.appendChild(element);
      offsetDiff = getOffsetDiff(targetContainer, currentContainer, true);

      if (!translate) {
        translate = getTranslate(element);
        translateX = translate.x;
        translateY = translate.y;
      }

      element.style[transformProp] = getTranslateString(translateX + offsetDiff.left, translateY + offsetDiff.top);
    } // Update child element's styles to reflect the current visibility state.


    item._child.removeAttribute('style');

    setStyles(item._child, isVisible ? targetSettings.visibleStyles : targetSettings.hiddenStyles); // Update display style.

    element.style.display = isVisible ? 'block' : 'hidden'; // Get offset diff for the migration data.

    containerDiff = getOffsetDiff(targetContainer, targetElement, true); // Update item's cached dimensions and sort data.

    item._refreshDimensions();

    item._refreshSortData(); // Create new drag handler.


    item._drag = targetSettings.dragEnabled ? new ItemDrag(item) : null; // Setup migration data.

    this._isActive = true;
    this._container = targetContainer;
    this._containerDiffX = containerDiff.left;
    this._containerDiffY = containerDiff.top; // Emit send event.

    if (grid._hasListeners(eventSend)) {
      grid._emit(eventSend, {
        item: item,
        fromGrid: grid,
        fromIndex: currentIndex,
        toGrid: targetGrid,
        toIndex: targetIndex
      });
    } // Emit receive event.


    if (targetGrid._hasListeners(eventReceive)) {
      targetGrid._emit(eventReceive, {
        item: item,
        fromGrid: grid,
        fromIndex: currentIndex,
        toGrid: targetGrid,
        toIndex: targetIndex
      });
    }

    return this;
  };
  /**
   * End the migrate process of an item. This method can be used to abort an
   * ongoing migrate process (animation) or finish the migrate process.
   *
   * @public
   * @memberof ItemMigrate.prototype
   * @param {Boolean} [abort=false]
   *  - Should the migration be aborted?
   * @param {Object} [currentStyles]
   *  - Optional current translateX and translateY styles.
   * @returns {ItemMigrate}
   */


  ItemMigrate.prototype.stop = function (abort, currentStyles) {
    if (this._isDestroyed || !this._isActive) return this;
    var item = this._item;
    var element = item._element;
    var grid = item.getGrid();
    var gridElement = grid._element;
    var translate;

    if (this._container !== gridElement) {
      if (!currentStyles) {
        if (abort) {
          translate = getTranslate(element);
          tempStyles.transform = getTranslateString(translate.x - this._containerDiffX, translate.y - this._containerDiffY);
        } else {
          tempStyles.transform = getTranslateString(item._left, item._top);
        }

        currentStyles = tempStyles;
      }

      gridElement.appendChild(element);
      setStyles(element, currentStyles);
    }

    this._isActive = false;
    this._container = null;
    this._containerDiffX = 0;
    this._containerDiffY = 0;
    return this;
  };
  /**
   * Destroy instance.
   *
   * @public
   * @memberof ItemMigrate.prototype
   * @returns {ItemMigrate}
   */


  ItemMigrate.prototype.destroy = function () {
    if (this._isDestroyed) return this;
    this.stop(true);
    this._item = null;
    this._isDestroyed = true;
    return this;
  };

  var tempStyles$1 = {};
  /**
   * The release process handler constructor. Although this might seem as proper
   * fit for the drag process this needs to be separated into it's own logic
   * because there might be a scenario where drag is disabled, but the release
   * process still needs to be implemented (dragging from a grid to another).
   *
   * @class
   * @param {Item} item
   */

  function ItemRelease(item) {
    this._item = item;
    this._isActive = false;
    this._isDestroyed = false;
    this._isPositioningStarted = false;
    this._containerDiffX = 0;
    this._containerDiffY = 0;
  }
  /**
   * Public prototype methods
   * ************************
   */

  /**
   * Start the release process of an item.
   *
   * @public
   * @memberof ItemRelease.prototype
   * @returns {ItemRelease}
   */


  ItemRelease.prototype.start = function () {
    if (this._isDestroyed || this._isActive) return this;
    var item = this._item;
    var grid = item.getGrid(); // Flag release as active.

    this._isActive = true; // Add release class name to the released element.

    addClass(item._element, grid._settings.itemReleasingClass); // Emit dragReleaseStart event.

    grid._emit(eventDragReleaseStart, item); // Position the released item.


    item._layout.start(false);

    return this;
  };
  /**
   * End the release process of an item. This method can be used to abort an
   * ongoing release process (animation) or finish the release process.
   *
   * @public
   * @memberof ItemRelease.prototype
   * @param {Boolean} [abort=false]
   *  - Should the release be aborted? When true, the release end event won't be
   *    emitted. Set to true only when you need to abort the release process
   *    while the item is animating to it's position.
   * @param {Object} [currentStyles]
   *  - Optional current translateX and translateY styles.
   * @returns {ItemRelease}
   */


  ItemRelease.prototype.stop = function (abort, currentStyles) {
    if (this._isDestroyed || !this._isActive) return this;
    var item = this._item;
    var element = item._element;
    var grid = item.getGrid();
    var container = grid._element;
    var translate; // Reset data and remove releasing class name from the element.

    this._reset(); // If the released element is outside the grid's container element put it
    // back there and adjust position accordingly.


    if (element.parentNode !== container) {
      if (!currentStyles) {
        if (abort) {
          translate = getTranslate(element);
          tempStyles$1.transform = getTranslateString(translate.x - this._containerDiffX, translate.y - this._containerDiffY);
        } else {
          tempStyles$1.transform = getTranslateString(item._left, item._top);
        }

        currentStyles = tempStyles$1;
      }

      container.appendChild(element);
      setStyles(element, currentStyles);
    } // Emit dragReleaseEnd event.


    if (!abort) grid._emit(eventDragReleaseEnd, item);
    return this;
  };
  /**
   * Destroy instance.
   *
   * @public
   * @memberof ItemRelease.prototype
   * @returns {ItemRelease}
   */


  ItemRelease.prototype.destroy = function () {
    if (this._isDestroyed) return this;
    this.stop(true);
    this._item = null;
    this._isDestroyed = true;
    return this;
  };
  /**
   * Private prototype methods
   * *************************
   */

  /**
   * Reset public data and remove releasing class.
   *
   * @private
   * @memberof ItemRelease.prototype
   */


  ItemRelease.prototype._reset = function () {
    if (this._isDestroyed) return;
    var item = this._item;
    this._isActive = false;
    this._isPositioningStarted = false;
    this._containerDiffX = 0;
    this._containerDiffY = 0;
    removeClass(item._element, item.getGrid()._settings.itemReleasingClass);
  };
  /**
   * Get current values of the provided styles definition object.
   *
   * @param {HTMLElement} element
   * @param {Object} styles
   * @return {Object}
   */


  function getCurrentStyles(element, styles) {
    var current = {};

    for (var prop in styles) {
      current[prop] = getStyle(element, getStyleName(prop));
    }

    return current;
  }
  /**
   * Visibility manager for Item instance.
   *
   * @class
   * @param {Item} item
   */


  function ItemVisibility(item) {
    var isActive = item._isActive;
    var element = item._element;

    var settings = item.getGrid()._settings;

    this._item = item;
    this._isDestroyed = false; // Set up visibility states.

    this._isHidden = !isActive;
    this._isHiding = false;
    this._isShowing = false; // Callback queue.

    this._queue = new Queue(); // Bind show/hide finishers.

    this._finishShow = this._finishShow.bind(this);
    this._finishHide = this._finishHide.bind(this); // Force item to be either visible or hidden on init.

    element.style.display = isActive ? 'block' : 'none'; // Set visible/hidden class.

    addClass(element, isActive ? settings.itemVisibleClass : settings.itemHiddenClass); // Set initial styles for the child element.

    setStyles(item._child, isActive ? settings.visibleStyles : settings.hiddenStyles);
  }
  /**
   * Public prototype methods
   * ************************
   */

  /**
   * Show item.
   *
   * @public
   * @memberof ItemVisibility.prototype
   * @param {Boolean} instant
   * @param {Function} [onFinish]
   * @returns {ItemVisibility}
   */


  ItemVisibility.prototype.show = function (instant, onFinish) {
    if (this._isDestroyed) return this;
    var item = this._item;
    var element = item._element;
    var queue = this._queue;
    var callback = isFunction(onFinish) ? onFinish : null;
    var grid = item.getGrid();
    var settings = grid._settings; // If item is visible call the callback and be done with it.

    if (!this._isShowing && !this._isHidden) {
      callback && callback(false, item);
      return this;
    } // If item is showing and does not need to be shown instantly, let's just
    // push callback to the callback queue and be done with it.


    if (this._isShowing && !instant) {
      callback && queue.add(callback);
      return this;
    } // If the item is hiding or hidden process the current visibility callback
    // queue with the interrupted flag active, update classes and set display
    // to block if necessary.


    if (!this._isShowing) {
      queue.flush(true, item);
      removeClass(element, settings.itemHiddenClass);
      addClass(element, settings.itemVisibleClass);
      if (!this._isHiding) element.style.display = 'block';
    } // Push callback to the callback queue.


    callback && queue.add(callback); // Update visibility states.

    item._isActive = this._isShowing = true;
    this._isHiding = this._isHidden = false; // Finally let's start show animation.

    this._startAnimation(true, instant, this._finishShow);

    return this;
  };
  /**
   * Hide item.
   *
   * @public
   * @memberof ItemVisibility.prototype
   * @param {Boolean} instant
   * @param {Function} [onFinish]
   * @returns {ItemVisibility}
   */


  ItemVisibility.prototype.hide = function (instant, onFinish) {
    if (this._isDestroyed) return this;
    var item = this._item;
    var element = item._element;
    var queue = this._queue;
    var callback = isFunction(onFinish) ? onFinish : null;
    var grid = item.getGrid();
    var settings = grid._settings; // If item is already hidden call the callback and be done with it.

    if (!this._isHiding && this._isHidden) {
      callback && callback(false, item);
      return this;
    } // If item is hiding and does not need to be hidden instantly, let's just
    // push callback to the callback queue and be done with it.


    if (this._isHiding && !instant) {
      callback && queue.add(callback);
      return this;
    } // If the item is showing or visible process the current visibility callback
    // queue with the interrupted flag active, update classes and set display
    // to block if necessary.


    if (!this._isHiding) {
      queue.flush(true, item);
      addClass(element, settings.itemHiddenClass);
      removeClass(element, settings.itemVisibleClass);
    } // Push callback to the callback queue.


    callback && queue.add(callback); // Update visibility states.

    this._isHidden = this._isHiding = true;
    item._isActive = this._isShowing = false; // Finally let's start hide animation.

    this._startAnimation(false, instant, this._finishHide);

    return this;
  };
  /**
   * Destroy the instance and stop current animation if it is running.
   *
   * @public
   * @memberof ItemVisibility.prototype
   * @returns {ItemVisibility}
   */


  ItemVisibility.prototype.destroy = function () {
    if (this._isDestroyed) return this;
    var item = this._item;
    var element = item._element;
    var grid = item.getGrid();
    var queue = this._queue;
    var settings = grid._settings; // Stop visibility animation.

    this._stopAnimation({}); // Fire all uncompleted callbacks with interrupted flag and destroy the queue.


    queue.flush(true, item).destroy(); // Remove visible/hidden classes.

    removeClass(element, settings.itemVisibleClass);
    removeClass(element, settings.itemHiddenClass); // Reset state.

    this._item = null;
    this._isHiding = this._isShowing = false;
    this._isDestroyed = this._isHidden = true;
    return this;
  };
  /**
   * Private prototype methods
   * *************************
   */

  /**
   * Start visibility animation.
   *
   * @private
   * @memberof ItemVisibility.prototype
   * @param {Boolean} toVisible
   * @param {Boolean} [instant]
   * @param {Function} [onFinish]
   */


  ItemVisibility.prototype._startAnimation = function (toVisible, instant, onFinish) {
    if (this._isDestroyed) return;
    var item = this._item;

    var settings = item.getGrid()._settings;

    var targetStyles = toVisible ? settings.visibleStyles : settings.hiddenStyles;
    var duration = parseInt(toVisible ? settings.showDuration : settings.hideDuration) || 0;
    var easing = (toVisible ? settings.showEasing : settings.hideEasing) || 'ease';
    var isInstant = instant || duration <= 0;
    var currentStyles; // No target styles? Let's quit early.

    if (!targetStyles) {
      onFinish && onFinish();
      return;
    } // Cancel queued visibility tick.


    cancelVisibilityTick(item._id); // If we need to apply the styles instantly without animation.

    if (isInstant) {
      if (item._animateChild.isAnimating()) {
        item._animateChild.stop(targetStyles);
      } else {
        setStyles(item._child, targetStyles);
      }

      onFinish && onFinish();
      return;
    } // Start the animation in the next tick (to avoid layout thrashing).


    addVisibilityTick(item._id, function () {
      currentStyles = getCurrentStyles(item._child, targetStyles);
    }, function () {
      item._animateChild.start(currentStyles, targetStyles, {
        duration: duration,
        easing: easing,
        onFinish: onFinish
      });
    });
  };
  /**
   * Stop visibility animation.
   *
   * @private
   * @memberof ItemVisibility.prototype
   * @param {Object} [targetStyles]
   */


  ItemVisibility.prototype._stopAnimation = function (targetStyles) {
    if (this._isDestroyed) return;
    var item = this._item;
    cancelVisibilityTick(item._id);

    item._animateChild.stop(targetStyles);
  };
  /**
   * Finish show procedure.
   *
   * @private
   * @memberof ItemVisibility.prototype
   */


  ItemVisibility.prototype._finishShow = function () {
    if (this._isHidden) return;
    this._isShowing = false;

    this._queue.flush(false, this._item);
  };
  /**
   * Finish hide procedure.
   *
   * @private
   * @memberof ItemVisibility.prototype
   */


  var finishStyles = {};

  ItemVisibility.prototype._finishHide = function () {
    if (!this._isHidden) return;
    var item = this._item;
    this._isHiding = false;
    finishStyles.transform = getTranslateString(0, 0);

    item._layout.stop(true, finishStyles);

    item._element.style.display = 'none';

    this._queue.flush(false, item);
  };

  var id = 0;
  /**
   * Returns a unique numeric id (increments a base value on every call).
   * @returns {Number}
   */

  function createUid() {
    return ++id;
  }
  /**
   * Creates a new Item instance for a Grid instance.
   *
   * @class
   * @param {Grid} grid
   * @param {HTMLElement} element
   * @param {Boolean} [isActive]
   */


  function Item(grid, element, isActive) {
    var settings = grid._settings; // Create instance id.

    this._id = createUid(); // Reference to connected Grid instance's id.

    this._gridId = grid._id; // Destroyed flag.

    this._isDestroyed = false; // Set up initial positions.

    this._left = 0;
    this._top = 0; // The elements.

    this._element = element;
    this._child = element.children[0]; // If the provided item element is not a direct child of the grid container
    // element, append it to the grid container.

    if (element.parentNode !== grid._element) {
      grid._element.appendChild(element);
    } // Set item class.


    addClass(element, settings.itemClass); // If isActive is not defined, let's try to auto-detect it.

    if (typeof isActive !== 'boolean') {
      isActive = getStyle(element, 'display') !== 'none';
    } // Set up active state (defines if the item is considered part of the layout
    // or not).


    this._isActive = isActive; // Set element's initial position styles.

    element.style.left = '0';
    element.style.top = '0';
    element.style[transformProp] = getTranslateString(0, 0); // Initiate item's animation controllers.

    this._animate = new ItemAnimate(element);
    this._animateChild = new ItemAnimate(this._child); // Setup visibility handler.

    this._visibility = new ItemVisibility(this); // Set up layout handler.

    this._layout = new ItemLayout(this); // Set up migration handler data.

    this._migrate = new ItemMigrate(this); // Set up release handler. Note that although this is fully linked to dragging
    // this still needs to be always instantiated to handle migration scenarios
    // correctly.

    this._release = new ItemRelease(this); // Set up drag placeholder handler. Note that although this is fully linked to
    // dragging this still needs to be always instantiated to handle migration
    // scenarios correctly.

    this._dragPlaceholder = new ItemDragPlaceholder(this); // Set up drag handler.

    this._drag = settings.dragEnabled ? new ItemDrag(this) : null; // Set up the initial dimensions and sort data.

    this._refreshDimensions();

    this._refreshSortData();
  }
  /**
   * Public prototype methods
   * ************************
   */

  /**
   * Get the instance grid reference.
   *
   * @public
   * @memberof Item.prototype
   * @returns {Grid}
   */


  Item.prototype.getGrid = function () {
    return gridInstances[this._gridId];
  };
  /**
   * Get the instance element.
   *
   * @public
   * @memberof Item.prototype
   * @returns {HTMLElement}
   */


  Item.prototype.getElement = function () {
    return this._element;
  };
  /**
   * Get instance element's cached width.
   *
   * @public
   * @memberof Item.prototype
   * @returns {Number}
   */


  Item.prototype.getWidth = function () {
    return this._width;
  };
  /**
   * Get instance element's cached height.
   *
   * @public
   * @memberof Item.prototype
   * @returns {Number}
   */


  Item.prototype.getHeight = function () {
    return this._height;
  };
  /**
   * Get instance element's cached margins.
   *
   * @public
   * @memberof Item.prototype
   * @returns {Object}
   *   - The returned object contains left, right, top and bottom properties
   *     which indicate the item element's cached margins.
   */


  Item.prototype.getMargin = function () {
    return {
      left: this._marginLeft,
      right: this._marginRight,
      top: this._marginTop,
      bottom: this._marginBottom
    };
  };
  /**
   * Get instance element's cached position.
   *
   * @public
   * @memberof Item.prototype
   * @returns {Object}
   *   - The returned object contains left and top properties which indicate the
   *     item element's cached position in the grid.
   */


  Item.prototype.getPosition = function () {
    return {
      left: this._left,
      top: this._top
    };
  };
  /**
   * Is the item active?
   *
   * @public
   * @memberof Item.prototype
   * @returns {Boolean}
   */


  Item.prototype.isActive = function () {
    return this._isActive;
  };
  /**
   * Is the item visible?
   *
   * @public
   * @memberof Item.prototype
   * @returns {Boolean}
   */


  Item.prototype.isVisible = function () {
    return !!this._visibility && !this._visibility._isHidden;
  };
  /**
   * Is the item being animated to visible?
   *
   * @public
   * @memberof Item.prototype
   * @returns {Boolean}
   */


  Item.prototype.isShowing = function () {
    return !!(this._visibility && this._visibility._isShowing);
  };
  /**
   * Is the item being animated to hidden?
   *
   * @public
   * @memberof Item.prototype
   * @returns {Boolean}
   */


  Item.prototype.isHiding = function () {
    return !!(this._visibility && this._visibility._isHiding);
  };
  /**
   * Is the item positioning?
   *
   * @public
   * @memberof Item.prototype
   * @returns {Boolean}
   */


  Item.prototype.isPositioning = function () {
    return !!(this._layout && this._layout._isActive);
  };
  /**
   * Is the item being dragged?
   *
   * @public
   * @memberof Item.prototype
   * @returns {Boolean}
   */


  Item.prototype.isDragging = function () {
    return !!(this._drag && this._drag._isActive);
  };
  /**
   * Is the item being released?
   *
   * @public
   * @memberof Item.prototype
   * @returns {Boolean}
   */


  Item.prototype.isReleasing = function () {
    return !!(this._release && this._release._isActive);
  };
  /**
   * Is the item destroyed?
   *
   * @public
   * @memberof Item.prototype
   * @returns {Boolean}
   */


  Item.prototype.isDestroyed = function () {
    return this._isDestroyed;
  };
  /**
   * Private prototype methods
   * *************************
   */

  /**
   * Recalculate item's dimensions.
   *
   * @private
   * @memberof Item.prototype
   */


  Item.prototype._refreshDimensions = function () {
    if (this._isDestroyed || this._visibility._isHidden) return;
    var element = this._element;
    var dragPlaceholder = this._dragPlaceholder;
    var rect = element.getBoundingClientRect(); // Calculate width and height.

    this._width = rect.width;
    this._height = rect.height; // Calculate margins (ignore negative margins).

    this._marginLeft = Math.max(0, getStyleAsFloat(element, 'margin-left'));
    this._marginRight = Math.max(0, getStyleAsFloat(element, 'margin-right'));
    this._marginTop = Math.max(0, getStyleAsFloat(element, 'margin-top'));
    this._marginBottom = Math.max(0, getStyleAsFloat(element, 'margin-bottom')); // Keep drag placeholder's dimensions synced with the item's.

    if (dragPlaceholder) {
      dragPlaceholder.updateDimensions(this._width, this._height);
    }
  };
  /**
   * Fetch and store item's sort data.
   *
   * @private
   * @memberof Item.prototype
   */


  Item.prototype._refreshSortData = function () {
    if (this._isDestroyed) return;
    var data = this._sortData = {};

    var getters = this.getGrid()._settings.sortData;

    var prop;

    for (prop in getters) {
      data[prop] = getters[prop](this, this._element);
    }
  };
  /**
   * Destroy item instance.
   *
   * @private
   * @memberof Item.prototype
   * @param {Boolean} [removeElement=false]
   */


  Item.prototype._destroy = function (removeElement) {
    if (this._isDestroyed) return;
    var element = this._element;
    var grid = this.getGrid();
    var settings = grid._settings;

    var index = grid._items.indexOf(this); // Destroy handlers.


    this._release.destroy();

    this._migrate.destroy();

    this._layout.destroy();

    this._visibility.destroy();

    this._animate.destroy();

    this._animateChild.destroy();

    this._dragPlaceholder.destroy();

    this._drag && this._drag.destroy(); // Remove all inline styles.

    element.removeAttribute('style');

    this._child.removeAttribute('style'); // Remove item class.


    removeClass(element, settings.itemClass); // Remove item from Grid instance if it still exists there.

    index > -1 && grid._items.splice(index, 1); // Remove element from DOM.

    removeElement && element.parentNode.removeChild(element); // Reset state.

    this._isActive = false;
    this._isDestroyed = true;
  };
  /**
   * This is the default layout algorithm for Muuri. Based on MAXRECTS approach
   * as described by Jukka Jylänki in his survey: "A Thousand Ways to Pack the
   * Bin - A Practical Approach to Two-Dimensional Rectangle Bin Packing.".
   *
   * @class
   */


  function Packer() {
    this._slots = [];
    this._slotSizes = [];
    this._freeSlots = [];
    this._newSlots = [];
    this._rectItem = {};
    this._rectStore = [];
    this._rectId = 0; // The layout return data, which will be populated in getLayout.

    this._layout = {
      slots: null,
      setWidth: false,
      setHeight: false,
      width: false,
      height: false
    }; // Bind sort handlers.

    this._sortRectsLeftTop = this._sortRectsLeftTop.bind(this);
    this._sortRectsTopLeft = this._sortRectsTopLeft.bind(this);
  }
  /**
   * @public
   * @memberof Packer.prototype
   * @param {Item[]} items
   * @param {Number} width
   * @param {Number} height
   * @param {Number[]} [slots]
   * @param {Object} [options]
   * @param {Boolean} [options.fillGaps=false]
   * @param {Boolean} [options.horizontal=false]
   * @param {Boolean} [options.alignRight=false]
   * @param {Boolean} [options.alignBottom=false]
   * @returns {LayoutData}
   */


  Packer.prototype.getLayout = function (items, width, height, slots, options) {
    var layout = this._layout;
    var fillGaps = !!(options && options.fillGaps);
    var isHorizontal = !!(options && options.horizontal);
    var alignRight = !!(options && options.alignRight);
    var alignBottom = !!(options && options.alignBottom);
    var rounding = !!(options && options.rounding);
    var slotSizes = this._slotSizes;
    var i; // Reset layout data.

    layout.slots = slots ? slots : this._slots;
    layout.width = isHorizontal ? 0 : rounding ? Math.round(width) : width;
    layout.height = !isHorizontal ? 0 : rounding ? Math.round(height) : height;
    layout.setWidth = isHorizontal;
    layout.setHeight = !isHorizontal; // Make sure slots and slot size arrays are reset.

    layout.slots.length = 0;
    slotSizes.length = 0; // No need to go further if items do not exist.

    if (!items.length) return layout; // Find slots for items.

    for (i = 0; i < items.length; i++) {
      this._addSlot(items[i], isHorizontal, fillGaps, rounding, alignRight || alignBottom);
    } // If the alignment is set to right we need to adjust the results.


    if (alignRight) {
      for (i = 0; i < layout.slots.length; i = i + 2) {
        layout.slots[i] = layout.width - (layout.slots[i] + slotSizes[i]);
      }
    } // If the alignment is set to bottom we need to adjust the results.


    if (alignBottom) {
      for (i = 1; i < layout.slots.length; i = i + 2) {
        layout.slots[i] = layout.height - (layout.slots[i] + slotSizes[i]);
      }
    } // Reset slots arrays and rect id.


    slotSizes.length = 0;
    this._freeSlots.length = 0;
    this._newSlots.length = 0;
    this._rectId = 0;
    return layout;
  };
  /**
   * Calculate position for the layout item. Returns the left and top position
   * of the item in pixels.
   *
   * @private
   * @memberof Packer.prototype
   * @param {Item} item
   * @param {Boolean} isHorizontal
   * @param {Boolean} fillGaps
   * @param {Boolean} rounding
   * @returns {Array}
   */


  Packer.prototype._addSlot = function () {
    var eps = 0.001;
    var itemSlot = {};
    return function (item, isHorizontal, fillGaps, rounding, trackSize) {
      var layout = this._layout;
      var freeSlots = this._freeSlots;
      var newSlots = this._newSlots;
      var rect;
      var rectId;
      var potentialSlots;
      var ignoreCurrentSlots;
      var i;
      var ii; // Reset new slots.

      newSlots.length = 0; // Set item slot initial data.

      itemSlot.left = null;
      itemSlot.top = null;
      itemSlot.width = item._width + item._marginLeft + item._marginRight;
      itemSlot.height = item._height + item._marginTop + item._marginBottom; // Round item slot width and height if needed.

      if (rounding) {
        itemSlot.width = Math.round(itemSlot.width);
        itemSlot.height = Math.round(itemSlot.height);
      } // Try to find a slot for the item.


      for (i = 0; i < freeSlots.length; i++) {
        rectId = freeSlots[i];
        if (!rectId) continue;
        rect = this._getRect(rectId);

        if (itemSlot.width <= rect.width + eps && itemSlot.height <= rect.height + eps) {
          itemSlot.left = rect.left;
          itemSlot.top = rect.top;
          break;
        }
      } // If no slot was found for the item.


      if (itemSlot.left === null) {
        // Position the item in to the bottom left (vertical mode) or top right
        // (horizontal mode) of the grid.
        itemSlot.left = !isHorizontal ? 0 : layout.width;
        itemSlot.top = !isHorizontal ? layout.height : 0; // If gaps don't need filling do not add any current slots to the new
        // slots array.

        if (!fillGaps) {
          ignoreCurrentSlots = true;
        }
      } // In vertical mode, if the item's bottom overlaps the grid's bottom.


      if (!isHorizontal && itemSlot.top + itemSlot.height > layout.height) {
        // If item is not aligned to the left edge, create a new slot.
        if (itemSlot.left > 0) {
          newSlots.push(this._addRect(0, layout.height, itemSlot.left, Infinity));
        } // If item is not aligned to the right edge, create a new slot.


        if (itemSlot.left + itemSlot.width < layout.width) {
          newSlots.push(this._addRect(itemSlot.left + itemSlot.width, layout.height, layout.width - itemSlot.left - itemSlot.width, Infinity));
        } // Update grid height.


        layout.height = itemSlot.top + itemSlot.height;
      } // In horizontal mode, if the item's right overlaps the grid's right edge.


      if (isHorizontal && itemSlot.left + itemSlot.width > layout.width) {
        // If item is not aligned to the top, create a new slot.
        if (itemSlot.top > 0) {
          newSlots.push(this._addRect(layout.width, 0, Infinity, itemSlot.top));
        } // If item is not aligned to the bottom, create a new slot.


        if (itemSlot.top + itemSlot.height < layout.height) {
          newSlots.push(this._addRect(layout.width, itemSlot.top + itemSlot.height, Infinity, layout.height - itemSlot.top - itemSlot.height));
        } // Update grid width.


        layout.width = itemSlot.left + itemSlot.width;
      } // Clean up the current slots making sure there are no old slots that
      // overlap with the item. If an old slot overlaps with the item, split it
      // into smaller slots if necessary.


      for (i = fillGaps ? 0 : ignoreCurrentSlots ? freeSlots.length : i; i < freeSlots.length; i++) {
        rectId = freeSlots[i];
        if (!rectId) continue;
        rect = this._getRect(rectId);
        potentialSlots = this._splitRect(rect, itemSlot);

        for (ii = 0; ii < potentialSlots.length; ii++) {
          rectId = potentialSlots[ii];
          rect = this._getRect(rectId); // Let's make sure here that we have a big enough slot
          // (width/height > 0.49px) and also let's make sure that the slot is
          // within the boundaries of the grid.

          if (rect.width > 0.49 && rect.height > 0.49 && (!isHorizontal && rect.top < layout.height || isHorizontal && rect.left < layout.width)) {
            newSlots.push(rectId);
          }
        }
      } // Sanitize new slots.


      if (newSlots.length) {
        this._purgeRects(newSlots).sort(isHorizontal ? this._sortRectsLeftTop : this._sortRectsTopLeft);
      } // Update layout width/height.


      if (isHorizontal) {
        layout.width = Math.max(layout.width, itemSlot.left + itemSlot.width);
      } else {
        layout.height = Math.max(layout.height, itemSlot.top + itemSlot.height);
      } // Add item slot data to layout slots (and store the slot size for later
      // usage too if necessary).


      layout.slots.push(itemSlot.left, itemSlot.top);
      if (trackSize) this._slotSizes.push(itemSlot.width, itemSlot.height); // Free/new slots switcheroo!

      this._freeSlots = newSlots;
      this._newSlots = freeSlots;
    };
  }();
  /**
   * Add a new rectangle to the rectangle store. Returns the id of the new
   * rectangle.
   *
   * @private
   * @memberof Packer.prototype
   * @param {Number} left
   * @param {Number} top
   * @param {Number} width
   * @param {Number} height
   * @returns {RectId}
   */


  Packer.prototype._addRect = function (left, top, width, height) {
    var rectId = ++this._rectId;
    var rectStore = this._rectStore;
    rectStore[rectId] = left || 0;
    rectStore[++this._rectId] = top || 0;
    rectStore[++this._rectId] = width || 0;
    rectStore[++this._rectId] = height || 0;
    return rectId;
  };
  /**
   * Get rectangle data from the rectangle store by id. Optionally you can
   * provide a target object where the rectangle data will be written in. By
   * default an internal object is reused as a target object.
   *
   * @private
   * @memberof Packer.prototype
   * @param {RectId} id
   * @param {Object} [target]
   * @returns {Object}
   */


  Packer.prototype._getRect = function (id, target) {
    var rectItem = target ? target : this._rectItem;
    var rectStore = this._rectStore;
    rectItem.left = rectStore[id] || 0;
    rectItem.top = rectStore[++id] || 0;
    rectItem.width = rectStore[++id] || 0;
    rectItem.height = rectStore[++id] || 0;
    return rectItem;
  };
  /**
   * Punch a hole into a rectangle and split the remaining area into smaller
   * rectangles (4 at max).
   *
   * @private
   * @memberof Packer.prototype
   * @param {Rectangle} rect
   * @param {Rectangle} hole
   * @returns {RectId[]}
   */


  Packer.prototype._splitRect = function () {
    var results = [];
    return function (rect, hole) {
      // Reset old results.
      results.length = 0; // If the rect does not overlap with the hole add rect to the return data
      // as is.

      if (!this._doRectsOverlap(rect, hole)) {
        results.push(this._addRect(rect.left, rect.top, rect.width, rect.height));
        return results;
      } // Left split.


      if (rect.left < hole.left) {
        results.push(this._addRect(rect.left, rect.top, hole.left - rect.left, rect.height));
      } // Right split.


      if (rect.left + rect.width > hole.left + hole.width) {
        results.push(this._addRect(hole.left + hole.width, rect.top, rect.left + rect.width - (hole.left + hole.width), rect.height));
      } // Top split.


      if (rect.top < hole.top) {
        results.push(this._addRect(rect.left, rect.top, rect.width, hole.top - rect.top));
      } // Bottom split.


      if (rect.top + rect.height > hole.top + hole.height) {
        results.push(this._addRect(rect.left, hole.top + hole.height, rect.width, rect.top + rect.height - (hole.top + hole.height)));
      }

      return results;
    };
  }();
  /**
   * Check if two rectangles overlap.
   *
   * @private
   * @memberof Packer.prototype
   * @param {Rectangle} a
   * @param {Rectangle} b
   * @returns {Boolean}
   */


  Packer.prototype._doRectsOverlap = function (a, b) {
    return !(a.left + a.width <= b.left || b.left + b.width <= a.left || a.top + a.height <= b.top || b.top + b.height <= a.top);
  };
  /**
   * Check if a rectangle is fully within another rectangle.
   *
   * @private
   * @memberof Packer.prototype
   * @param {Rectangle} a
   * @param {Rectangle} b
   * @returns {Boolean}
   */


  Packer.prototype._isRectWithinRect = function (a, b) {
    return a.left >= b.left && a.top >= b.top && a.left + a.width <= b.left + b.width && a.top + a.height <= b.top + b.height;
  };
  /**
   * Loops through an array of rectangle ids and resets all that are fully
   * within another rectangle in the array. Resetting in this case means that
   * the rectangle id value is replaced with zero.
   *
   * @private
   * @memberof Packer.prototype
   * @param {RectId[]} rectIds
   * @returns {RectId[]}
   */


  Packer.prototype._purgeRects = function () {
    var rectA = {};
    var rectB = {};
    return function (rectIds) {
      var i = rectIds.length;
      var ii;

      while (i--) {
        ii = rectIds.length;
        if (!rectIds[i]) continue;

        this._getRect(rectIds[i], rectA);

        while (ii--) {
          if (!rectIds[ii] || i === ii) continue;

          if (this._isRectWithinRect(rectA, this._getRect(rectIds[ii], rectB))) {
            rectIds[i] = 0;
            break;
          }
        }
      }

      return rectIds;
    };
  }();
  /**
   * Sort rectangles with top-left gravity.
   *
   * @private
   * @memberof Packer.prototype
   * @param {RectId} aId
   * @param {RectId} bId
   * @returns {Number}
   */


  Packer.prototype._sortRectsTopLeft = function () {
    var rectA = {};
    var rectB = {};
    return function (aId, bId) {
      this._getRect(aId, rectA);

      this._getRect(bId, rectB); // prettier-ignore


      return rectA.top < rectB.top ? -1 : rectA.top > rectB.top ? 1 : rectA.left < rectB.left ? -1 : rectA.left > rectB.left ? 1 : 0;
    };
  }();
  /**
   * Sort rectangles with left-top gravity.
   *
   * @private
   * @memberof Packer.prototype
   * @param {RectId} aId
   * @param {RectId} bId
   * @returns {Number}
   */


  Packer.prototype._sortRectsLeftTop = function () {
    var rectA = {};
    var rectB = {};
    return function (aId, bId) {
      this._getRect(aId, rectA);

      this._getRect(bId, rectB); // prettier-ignore


      return rectA.left < rectB.left ? -1 : rectA.left > rectB.left ? 1 : rectA.top < rectB.top ? -1 : rectA.top > rectB.top ? 1 : 0;
    };
  }();

  var htmlCollectionType = '[object HTMLCollection]';
  var nodeListType = '[object NodeList]';
  /**
   * Check if a value is a node list
   *
   * @param {*} val
   * @returns {Boolean}
   */

  function isNodeList(val) {
    var type = Object.prototype.toString.call(val);
    return type === htmlCollectionType || type === nodeListType;
  }

  var objectType = 'object';
  var objectToStringType = '[object Object]';
  var toString = Object.prototype.toString;
  /**
   * Check if a value is a plain object.
   *
   * @param {*} val
   * @returns {Boolean}
   */

  function isPlainObject(val) {
    return (0,_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(val) === objectType && toString.call(val) === objectToStringType;
  }
  /**
   * Converts a value to an array or clones an array.
   *
   * @param {*} target
   * @returns {Array}
   */


  function toArray(target) {
    return isNodeList(target) ? Array.prototype.slice.call(target) : Array.prototype.concat(target);
  }

  var packer = new Packer();

  var noop = function noop() {};

  var numberType$1 = 'number';
  var stringType = 'string';
  var instantLayout = 'instant';
  /**
   * Creates a new Grid instance.
   *
   * @class
   * @param {(HTMLElement|String)} element
   * @param {Object} [options]
   * @param {?(HTMLElement[]|NodeList|String)} [options.items]
   * @param {Number} [options.showDuration=300]
   * @param {String} [options.showEasing="ease"]
   * @param {Object} [options.visibleStyles]
   * @param {Number} [options.hideDuration=300]
   * @param {String} [options.hideEasing="ease"]
   * @param {Object} [options.hiddenStyles]
   * @param {(Function|Object)} [options.layout]
   * @param {Boolean} [options.layout.fillGaps=false]
   * @param {Boolean} [options.layout.horizontal=false]
   * @param {Boolean} [options.layout.alignRight=false]
   * @param {Boolean} [options.layout.alignBottom=false]
   * @param {Boolean} [options.layout.rounding=true]
   * @param {(Boolean|Number)} [options.layoutOnResize=100]
   * @param {Boolean} [options.layoutOnInit=true]
   * @param {Number} [options.layoutDuration=300]
   * @param {String} [options.layoutEasing="ease"]
   * @param {?Object} [options.sortData=null]
   * @param {Boolean} [options.dragEnabled=false]
   * @param {?HtmlElement} [options.dragContainer=null]
   * @param {?Function} [options.dragStartPredicate]
   * @param {Number} [options.dragStartPredicate.distance=0]
   * @param {Number} [options.dragStartPredicate.delay=0]
   * @param {(Boolean|String)} [options.dragStartPredicate.handle=false]
   * @param {?String} [options.dragAxis]
   * @param {(Boolean|Function)} [options.dragSort=true]
   * @param {Object} [options.dragSortHeuristics]
   * @param {Number} [options.dragSortHeuristics.sortInterval=100]
   * @param {Number} [options.dragSortHeuristics.minDragDistance=10]
   * @param {Number} [options.dragSortHeuristics.minBounceBackAngle=1]
   * @param {(Function|Object)} [options.dragSortPredicate]
   * @param {Number} [options.dragSortPredicate.threshold=50]
   * @param {String} [options.dragSortPredicate.action="move"]
   * @param {Number} [options.dragReleaseDuration=300]
   * @param {String} [options.dragReleaseEasing="ease"]
   * @param {Object} [options.dragCssProps]
   * @param {Object} [options.dragPlaceholder]
   * @param {Boolean} [options.dragPlaceholder.enabled=false]
   * @param {Number} [options.dragPlaceholder.duration=300]
   * @param {String} [options.dragPlaceholder.easing="ease"]
   * @param {?Function} [options.dragPlaceholder.createElement=null]
   * @param {?Function} [options.dragPlaceholder.onCreate=null]
   * @param {?Function} [options.dragPlaceholder.onRemove=null]
   * @param {String} [options.containerClass="muuri"]
   * @param {String} [options.itemClass="muuri-item"]
   * @param {String} [options.itemVisibleClass="muuri-item-visible"]
   * @param {String} [options.itemHiddenClass="muuri-item-hidden"]
   * @param {String} [options.itemPositioningClass="muuri-item-positioning"]
   * @param {String} [options.itemDraggingClass="muuri-item-dragging"]
   * @param {String} [options.itemReleasingClass="muuri-item-releasing"]
   * @param {String} [options.itemPlaceholderClass="muuri-item-placeholder"]
   */

  function Grid(element, options) {
    var inst = this;
    var settings;
    var items;
    var layoutOnResize; // Allow passing element as selector string. Store element for instance.

    element = this._element = (0,_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(element) === stringType ? window.document.querySelector(element) : element; // Throw an error if the container element is not body element or does not
    // exist within the body element.

    var isElementInDom = element.getRootNode ? element.getRootNode({
      composed: true
    }) === document : window.document.body.contains(element);

    if (!isElementInDom || element === window.document.documentElement) {
      throw new Error('Container element must be an existing DOM element');
    } // Create instance settings by merging the options with default options.


    settings = this._settings = mergeSettings(Grid.defaultOptions, options); // Sanitize dragSort setting.

    if (!isFunction(settings.dragSort)) {
      settings.dragSort = !!settings.dragSort;
    } // Create instance id and store it to the grid instances collection.


    this._id = createUid();
    gridInstances[this._id] = inst; // Destroyed flag.

    this._isDestroyed = false; // The layout object (mutated on every layout).

    this._layout = {
      id: 0,
      items: [],
      slots: [],
      setWidth: false,
      setHeight: false,
      width: 0,
      height: 0
    }; // Create private Emitter instance.

    this._emitter = new Emitter(); // Add container element's class name.

    addClass(element, settings.containerClass); // Create initial items.

    this._items = [];
    items = settings.items;

    if ((0,_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(items) === stringType) {
      toArray(element.children).forEach(function (itemElement) {
        if (items === '*' || elementMatches(itemElement, items)) {
          inst._items.push(new Item(inst, itemElement));
        }
      });
    } else if (Array.isArray(items) || isNodeList(items)) {
      this._items = toArray(items).map(function (itemElement) {
        return new Item(inst, itemElement);
      });
    } // If layoutOnResize option is a valid number sanitize it and bind the resize
    // handler.


    layoutOnResize = settings.layoutOnResize;

    if ((0,_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(layoutOnResize) !== numberType$1) {
      layoutOnResize = layoutOnResize === true ? 0 : -1;
    }

    if (layoutOnResize >= 0) {
      window.addEventListener('resize', inst._resizeHandler = debounce(function () {
        inst.refreshItems().layout();
      }, layoutOnResize));
    } // Layout on init if necessary.


    if (settings.layoutOnInit) {
      this.layout(true);
    }
  }
  /**
   * Public properties
   * *****************
   */

  /**
   * @see Item
   */


  Grid.Item = Item;
  /**
   * @see ItemLayout
   */

  Grid.ItemLayout = ItemLayout;
  /**
   * @see ItemVisibility
   */

  Grid.ItemVisibility = ItemVisibility;
  /**
   * @see ItemMigrate
   */

  Grid.ItemMigrate = ItemMigrate;
  /**
   * @see ItemAnimate
   */

  Grid.ItemAnimate = ItemAnimate;
  /**
   * @see ItemDrag
   */

  Grid.ItemDrag = ItemDrag;
  /**
   * @see ItemRelease
   */

  Grid.ItemRelease = ItemRelease;
  /**
   * @see ItemDragPlaceholder
   */

  Grid.ItemDragPlaceholder = ItemDragPlaceholder;
  /**
   * @see Emitter
   */

  Grid.Emitter = Emitter;
  /**
   * @see Dragger
   */

  Grid.Dragger = Dragger;
  /**
   * @see Packer
   */

  Grid.Packer = Packer;
  /**
   * Default options for Grid instance.
   *
   * @public
   * @memberof Grid
   */

  Grid.defaultOptions = {
    // Item elements
    items: '*',
    // Default show animation
    showDuration: 300,
    showEasing: 'ease',
    // Default hide animation
    hideDuration: 300,
    hideEasing: 'ease',
    // Item's visible/hidden state styles
    visibleStyles: {
      opacity: '1',
      transform: 'scale(1)'
    },
    hiddenStyles: {
      opacity: '0',
      transform: 'scale(0.5)'
    },
    // Layout
    layout: {
      fillGaps: false,
      horizontal: false,
      alignRight: false,
      alignBottom: false,
      rounding: true
    },
    layoutOnResize: 100,
    layoutOnInit: true,
    layoutDuration: 300,
    layoutEasing: 'ease',
    // Sorting
    sortData: null,
    // Drag & Drop
    dragEnabled: false,
    dragContainer: null,
    dragStartPredicate: {
      distance: 0,
      delay: 0,
      handle: false
    },
    dragAxis: null,
    dragSort: true,
    dragSortHeuristics: {
      sortInterval: 100,
      minDragDistance: 10,
      minBounceBackAngle: 1
    },
    dragSortPredicate: {
      threshold: 50,
      action: actionMove
    },
    dragReleaseDuration: 300,
    dragReleaseEasing: 'ease',
    dragCssProps: {
      touchAction: 'none',
      userSelect: 'none',
      userDrag: 'none',
      tapHighlightColor: 'rgba(0, 0, 0, 0)',
      touchCallout: 'none',
      contentZooming: 'none'
    },
    dragPlaceholder: {
      enabled: false,
      duration: 300,
      easing: 'ease',
      createElement: null,
      onCreate: null,
      onRemove: null
    },
    // Classnames
    containerClass: 'muuri',
    itemClass: 'muuri-item',
    itemVisibleClass: 'muuri-item-shown',
    itemHiddenClass: 'muuri-item-hidden',
    itemPositioningClass: 'muuri-item-positioning',
    itemDraggingClass: 'muuri-item-dragging',
    itemReleasingClass: 'muuri-item-releasing',
    itemPlaceholderClass: 'muuri-item-placeholder'
  };
  /**
   * Public prototype methods
   * ************************
   */

  /**
   * Bind an event listener.
   *
   * @public
   * @memberof Grid.prototype
   * @param {String} event
   * @param {Function} listener
   * @returns {Grid}
   */

  Grid.prototype.on = function (event, listener) {
    this._emitter.on(event, listener);

    return this;
  };
  /**
   * Unbind an event listener.
   *
   * @public
   * @memberof Grid.prototype
   * @param {String} event
   * @param {Function} listener
   * @returns {Grid}
   */


  Grid.prototype.off = function (event, listener) {
    this._emitter.off(event, listener);

    return this;
  };
  /**
   * Get the container element.
   *
   * @public
   * @memberof Grid.prototype
   * @returns {HTMLElement}
   */


  Grid.prototype.getElement = function () {
    return this._element;
  };
  /**
   * Get all items. Optionally you can provide specific targets (elements and
   * indices). Note that the returned array is not the same object used by the
   * instance so modifying it will not affect instance's items. All items that
   * are not found are omitted from the returned array.
   *
   * @public
   * @memberof Grid.prototype
   * @param {GridMultiItemQuery} [targets]
   * @returns {Item[]}
   */


  Grid.prototype.getItems = function (targets) {
    // Return all items immediately if no targets were provided or if the
    // instance is destroyed.
    if (this._isDestroyed || !targets && targets !== 0) {
      return this._items.slice(0);
    }

    var ret = [];
    var targetItems = toArray(targets);
    var item;
    var i; // If target items are defined return filtered results.

    for (i = 0; i < targetItems.length; i++) {
      item = this._getItem(targetItems[i]);
      item && ret.push(item);
    }

    return ret;
  };
  /**
   * Update the cached dimensions of the instance's items.
   *
   * @public
   * @memberof Grid.prototype
   * @param {GridMultiItemQuery} [items]
   * @returns {Grid}
   */


  Grid.prototype.refreshItems = function (items) {
    if (this._isDestroyed) return this;
    var targets = this.getItems(items);
    var i;

    for (i = 0; i < targets.length; i++) {
      targets[i]._refreshDimensions();
    }

    return this;
  };
  /**
   * Update the sort data of the instance's items.
   *
   * @public
   * @memberof Grid.prototype
   * @param {GridMultiItemQuery} [items]
   * @returns {Grid}
   */


  Grid.prototype.refreshSortData = function (items) {
    if (this._isDestroyed) return this;
    var targetItems = this.getItems(items);
    var i;

    for (i = 0; i < targetItems.length; i++) {
      targetItems[i]._refreshSortData();
    }

    return this;
  };
  /**
   * Synchronize the item elements to match the order of the items in the DOM.
   * This comes handy if you need to keep the DOM structure matched with the
   * order of the items. Note that if an item's element is not currently a child
   * of the container element (if it is dragged for example) it is ignored and
   * left untouched.
   *
   * @public
   * @memberof Grid.prototype
   * @returns {Grid}
   */


  Grid.prototype.synchronize = function () {
    if (this._isDestroyed) return this;
    var container = this._element;
    var items = this._items;
    var fragment;
    var element;
    var i; // Append all elements in order to the container element.

    if (items.length) {
      for (i = 0; i < items.length; i++) {
        element = items[i]._element;

        if (element.parentNode === container) {
          fragment = fragment || window.document.createDocumentFragment();
          fragment.appendChild(element);
        }
      }

      if (fragment) container.appendChild(fragment);
    } // Emit synchronize event.


    this._emit(eventSynchronize);

    return this;
  };
  /**
   * Calculate and apply item positions.
   *
   * @public
   * @memberof Grid.prototype
   * @param {Boolean} [instant=false]
   * @param {LayoutCallback} [onFinish]
   * @returns {Grid}
   */


  Grid.prototype.layout = function (instant, onFinish) {
    if (this._isDestroyed) return this;
    var inst = this;
    var element = this._element;

    var layout = this._updateLayout();

    var layoutId = layout.id;
    var itemsLength = layout.items.length;
    var counter = itemsLength;
    var isBorderBox;
    var item;
    var i; // The finish function, which will be used for checking if all the items
    // have laid out yet. After all items have finished their animations call
    // callback and emit layoutEnd event. Only emit layoutEnd event if there
    // hasn't been a new layout call during this layout.

    function tryFinish() {
      if (--counter > 0) return;
      var hasLayoutChanged = inst._layout.id !== layoutId;
      var callback = isFunction(instant) ? instant : onFinish;

      if (isFunction(callback)) {
        callback(hasLayoutChanged, layout.items.slice(0));
      }

      if (!hasLayoutChanged && inst._hasListeners(eventLayoutEnd)) {
        inst._emit(eventLayoutEnd, layout.items.slice(0));
      }
    } // If grid's width or height was modified, we need to update it's cached
    // dimensions. Also keep in mind that grid's cached width/height should
    // always equal to what elem.getBoundingClientRect() would return, so
    // therefore we need to add the grid element's borders to the dimensions if
    // it's box-sizing is border-box. Note that we support providing the
    // dimensions as a string here too so that one can define the unit of the
    // dimensions, in which case we don't do the border-box check.


    if (layout.setHeight && (0,_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(layout.height) === numberType$1 || layout.setWidth && (0,_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(layout.width) === numberType$1) {
      isBorderBox = getStyle(element, 'box-sizing') === 'border-box';
    }

    if (layout.setHeight) {
      if ((0,_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(layout.height) === numberType$1) {
        element.style.height = (isBorderBox ? layout.height + this._borderTop + this._borderBottom : layout.height) + 'px';
      } else {
        element.style.height = layout.height;
      }
    }

    if (layout.setWidth) {
      if ((0,_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(layout.width) === numberType$1) {
        element.style.width = (isBorderBox ? layout.width + this._borderLeft + this._borderRight : layout.width) + 'px';
      } else {
        element.style.width = layout.width;
      }
    } // Emit layoutStart event. Note that this is intentionally emitted after the
    // container element's dimensions are set, because otherwise there would be
    // no hook for reacting to container dimension changes.


    if (this._hasListeners(eventLayoutStart)) {
      this._emit(eventLayoutStart, layout.items.slice(0));
    } // If there are no items let's finish quickly.


    if (!itemsLength) {
      tryFinish();
      return this;
    } // If there are items let's position them.


    for (i = 0; i < itemsLength; i++) {
      item = layout.items[i];
      if (!item) continue; // Update item's position.

      item._left = layout.slots[i * 2];
      item._top = layout.slots[i * 2 + 1]; // Layout item if it is not dragged.

      item.isDragging() ? tryFinish() : item._layout.start(instant === true, tryFinish);
    }

    return this;
  };
  /**
   * Add new items by providing the elements you wish to add to the instance and
   * optionally provide the index where you want the items to be inserted into.
   * All elements that are not already children of the container element will be
   * automatically appended to the container element. If an element has it's CSS
   * display property set to "none" it will be marked as inactive during the
   * initiation process. As long as the item is inactive it will not be part of
   * the layout, but it will retain it's index. You can activate items at any
   * point with grid.show() method. This method will automatically call
   * grid.layout() if one or more of the added elements are visible. If only
   * hidden items are added no layout will be called. All the new visible items
   * are positioned without animation during their first layout.
   *
   * @public
   * @memberof Grid.prototype
   * @param {(HTMLElement|HTMLElement[])} elements
   * @param {Object} [options]
   * @param {Number} [options.index=-1]
   * @param {Boolean} [options.isActive]
   * @param {(Boolean|LayoutCallback|String)} [options.layout=true]
   * @returns {Item[]}
   */


  Grid.prototype.add = function (elements, options) {
    if (this._isDestroyed || !elements) return [];
    var newItems = toArray(elements);
    if (!newItems.length) return newItems;
    var opts = options || 0;
    var layout = opts.layout ? opts.layout : opts.layout === undefined;
    var items = this._items;
    var needsLayout = false;
    var item;
    var i; // Map provided elements into new grid items.

    for (i = 0; i < newItems.length; i++) {
      item = new Item(this, newItems[i], opts.isActive);
      newItems[i] = item; // If the item to be added is active, we need to do a layout. Also, we
      // need to mark the item with the skipNextAnimation flag to make it
      // position instantly (without animation) during the next layout. Without
      // the hack the item would animate to it's new position from the northwest
      // corner of the grid, which feels a bit buggy (imho).

      if (item._isActive) {
        needsLayout = true;
        item._layout._skipNextAnimation = true;
      }
    } // Add the new items to the items collection to correct index.


    arrayInsert(items, newItems, opts.index); // Emit add event.

    if (this._hasListeners(eventAdd)) {
      this._emit(eventAdd, newItems.slice(0));
    } // If layout is needed.


    if (needsLayout && layout) {
      this.layout(layout === instantLayout, isFunction(layout) ? layout : undefined);
    }

    return newItems;
  };
  /**
   * Remove items from the instance.
   *
   * @public
   * @memberof Grid.prototype
   * @param {GridMultiItemQuery} items
   * @param {Object} [options]
   * @param {Boolean} [options.removeElements=false]
   * @param {(Boolean|LayoutCallback|String)} [options.layout=true]
   * @returns {Item[]}
   */


  Grid.prototype.remove = function (items, options) {
    if (this._isDestroyed) return this;
    var opts = options || 0;
    var layout = opts.layout ? opts.layout : opts.layout === undefined;
    var needsLayout = false;
    var allItems = this.getItems();
    var targetItems = this.getItems(items);
    var indices = [];
    var item;
    var i; // Remove the individual items.

    for (i = 0; i < targetItems.length; i++) {
      item = targetItems[i];
      indices.push(allItems.indexOf(item));
      if (item._isActive) needsLayout = true;

      item._destroy(opts.removeElements);
    } // Emit remove event.


    if (this._hasListeners(eventRemove)) {
      this._emit(eventRemove, targetItems.slice(0), indices);
    } // If layout is needed.


    if (needsLayout && layout) {
      this.layout(layout === instantLayout, isFunction(layout) ? layout : undefined);
    }

    return targetItems;
  };
  /**
   * Show instance items.
   *
   * @public
   * @memberof Grid.prototype
   * @param {GridMultiItemQuery} items
   * @param {Object} [options]
   * @param {Boolean} [options.instant=false]
   * @param {ShowCallback} [options.onFinish]
   * @param {(Boolean|LayoutCallback|String)} [options.layout=true]
   * @returns {Grid}
   */


  Grid.prototype.show = function (items, options) {
    if (this._isDestroyed) return this;

    this._setItemsVisibility(items, true, options);

    return this;
  };
  /**
   * Hide instance items.
   *
   * @public
   * @memberof Grid.prototype
   * @param {GridMultiItemQuery} items
   * @param {Object} [options]
   * @param {Boolean} [options.instant=false]
   * @param {HideCallback} [options.onFinish]
   * @param {(Boolean|LayoutCallback|String)} [options.layout=true]
   * @returns {Grid}
   */


  Grid.prototype.hide = function (items, options) {
    if (this._isDestroyed) return this;

    this._setItemsVisibility(items, false, options);

    return this;
  };
  /**
   * Filter items. Expects at least one argument, a predicate, which should be
   * either a function or a string. The predicate callback is executed for every
   * item in the instance. If the return value of the predicate is truthy the
   * item in question will be shown and otherwise hidden. The predicate callback
   * receives the item instance as it's argument. If the predicate is a string
   * it is considered to be a selector and it is checked against every item
   * element in the instance with the native element.matches() method. All the
   * matching items will be shown and others hidden.
   *
   * @public
   * @memberof Grid.prototype
   * @param {(Function|String)} predicate
   * @param {Object} [options]
   * @param {Boolean} [options.instant=false]
   * @param {FilterCallback} [options.onFinish]
   * @param {(Boolean|LayoutCallback|String)} [options.layout=true]
   * @returns {Grid}
   */


  Grid.prototype.filter = function (predicate, options) {
    if (this._isDestroyed || !this._items.length) return this;
    var itemsToShow = [];
    var itemsToHide = [];
    var isPredicateString = (0,_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(predicate) === stringType;
    var isPredicateFn = isFunction(predicate);
    var opts = options || 0;
    var isInstant = opts.instant === true;
    var layout = opts.layout ? opts.layout : opts.layout === undefined;
    var onFinish = isFunction(opts.onFinish) ? opts.onFinish : null;
    var tryFinishCounter = -1;
    var tryFinish = noop;
    var item;
    var i; // If we have onFinish callback, let's create proper tryFinish callback.

    if (onFinish) {
      tryFinish = function tryFinish() {
        ++tryFinishCounter && onFinish(itemsToShow.slice(0), itemsToHide.slice(0));
      };
    } // Check which items need to be shown and which hidden.


    if (isPredicateFn || isPredicateString) {
      for (i = 0; i < this._items.length; i++) {
        item = this._items[i];

        if (isPredicateFn ? predicate(item) : elementMatches(item._element, predicate)) {
          itemsToShow.push(item);
        } else {
          itemsToHide.push(item);
        }
      }
    } // Show items that need to be shown.


    if (itemsToShow.length) {
      this.show(itemsToShow, {
        instant: isInstant,
        onFinish: tryFinish,
        layout: false
      });
    } else {
      tryFinish();
    } // Hide items that need to be hidden.


    if (itemsToHide.length) {
      this.hide(itemsToHide, {
        instant: isInstant,
        onFinish: tryFinish,
        layout: false
      });
    } else {
      tryFinish();
    } // If there are any items to filter.


    if (itemsToShow.length || itemsToHide.length) {
      // Emit filter event.
      if (this._hasListeners(eventFilter)) {
        this._emit(eventFilter, itemsToShow.slice(0), itemsToHide.slice(0));
      } // If layout is needed.


      if (layout) {
        this.layout(layout === instantLayout, isFunction(layout) ? layout : undefined);
      }
    }

    return this;
  };
  /**
   * Sort items. There are three ways to sort the items. The first is simply by
   * providing a function as the comparer which works identically to native
   * array sort. Alternatively you can sort by the sort data you have provided
   * in the instance's options. Just provide the sort data key(s) as a string
   * (separated by space) and the items will be sorted based on the provided
   * sort data keys. Lastly you have the opportunity to provide a presorted
   * array of items which will be used to sync the internal items array in the
   * same order.
   *
   * @public
   * @memberof Grid.prototype
   * @param {(Function|Item[]|String|String[])} comparer
   * @param {Object} [options]
   * @param {Boolean} [options.descending=false]
   * @param {(Boolean|LayoutCallback|String)} [options.layout=true]
   * @returns {Grid}
   */


  Grid.prototype.sort = function () {
    var sortComparer;
    var isDescending;
    var origItems;
    var indexMap;

    function parseCriteria(data) {
      return data.trim().split(' ').map(function (val) {
        return val.split(':');
      });
    }

    function getIndexMap(items) {
      var ret = {};

      for (var i = 0; i < items.length; i++) {
        ret[items[i]._id] = i;
      }

      return ret;
    }

    function compareIndices(itemA, itemB) {
      var indexA = indexMap[itemA._id];
      var indexB = indexMap[itemB._id];
      return isDescending ? indexB - indexA : indexA - indexB;
    }

    function defaultComparer(a, b) {
      var result = 0;
      var criteriaName;
      var criteriaOrder;
      var valA;
      var valB; // Loop through the list of sort criteria.

      for (var i = 0; i < sortComparer.length; i++) {
        // Get the criteria name, which should match an item's sort data key.
        criteriaName = sortComparer[i][0];
        criteriaOrder = sortComparer[i][1]; // Get items' cached sort values for the criteria. If the item has no sort
        // data let's update the items sort data (this is a lazy load mechanism).

        valA = (a._sortData ? a : a._refreshSortData())._sortData[criteriaName];
        valB = (b._sortData ? b : b._refreshSortData())._sortData[criteriaName]; // Sort the items in descending order if defined so explicitly. Otherwise
        // sort items in ascending order.

        if (criteriaOrder === 'desc' || !criteriaOrder && isDescending) {
          result = valB < valA ? -1 : valB > valA ? 1 : 0;
        } else {
          result = valA < valB ? -1 : valA > valB ? 1 : 0;
        } // If we have -1 or 1 as the return value, let's return it immediately.


        if (result) return result;
      } // If values are equal let's compare the item indices to make sure we
      // have a stable sort.


      if (!result) {
        if (!indexMap) indexMap = getIndexMap(origItems);
        result = compareIndices(a, b);
      }

      return result;
    }

    function customComparer(a, b) {
      var result = sortComparer(a, b); // If descending let's invert the result value.

      if (isDescending && result) result = -result; // If we have a valid result (not zero) let's return it right away.

      if (result) return result; // If result is zero let's compare the item indices to make sure we have a
      // stable sort.

      if (!indexMap) indexMap = getIndexMap(origItems);
      return compareIndices(a, b);
    }

    return function (comparer, options) {
      if (this._isDestroyed || this._items.length < 2) return this;
      var items = this._items;
      var opts = options || 0;
      var layout = opts.layout ? opts.layout : opts.layout === undefined;
      var i; // Setup parent scope data.

      sortComparer = comparer;
      isDescending = !!opts.descending;
      origItems = items.slice(0);
      indexMap = null; // If function is provided do a native array sort.

      if (isFunction(sortComparer)) {
        items.sort(customComparer);
      } // Otherwise if we got a string, let's sort by the sort data as provided in
      // the instance's options.
      else if ((0,_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(sortComparer) === stringType) {
        sortComparer = parseCriteria(comparer);
        items.sort(defaultComparer);
      } // Otherwise if we got an array, let's assume it's a presorted array of the
      // items and order the items based on it.
      else if (Array.isArray(sortComparer)) {
        if (sortComparer.length !== items.length) {
          throw new Error('[' + namespace + '] sort reference items do not match with grid items.');
        }

        for (i = 0; i < items.length; i++) {
          if (sortComparer.indexOf(items[i]) < 0) {
            throw new Error('[' + namespace + '] sort reference items do not match with grid items.');
          }

          items[i] = sortComparer[i];
        }

        if (isDescending) items.reverse();
      } // Otherwise let's just skip it, nothing we can do here.
      else {
        /** @todo Maybe throw an error here? */
        return this;
      } // Emit sort event.


      if (this._hasListeners(eventSort)) {
        this._emit(eventSort, items.slice(0), origItems);
      } // If layout is needed.


      if (layout) {
        this.layout(layout === instantLayout, isFunction(layout) ? layout : undefined);
      }

      return this;
    };
  }();
  /**
   * Move item to another index or in place of another item.
   *
   * @public
   * @memberof Grid.prototype
   * @param {GridSingleItemQuery} item
   * @param {GridSingleItemQuery} position
   * @param {Object} [options]
   * @param {String} [options.action="move"]
   *   - Accepts either "move" or "swap".
   *   - "move" moves the item in place of the other item.
   *   - "swap" swaps the position of the items.
   * @param {(Boolean|LayoutCallback|String)} [options.layout=true]
   * @returns {Grid}
   */


  Grid.prototype.move = function (item, position, options) {
    if (this._isDestroyed || this._items.length < 2) return this;
    var items = this._items;
    var opts = options || 0;
    var layout = opts.layout ? opts.layout : opts.layout === undefined;
    var isSwap = opts.action === actionSwap;
    var action = isSwap ? actionSwap : actionMove;

    var fromItem = this._getItem(item);

    var toItem = this._getItem(position);

    var fromIndex;
    var toIndex; // Make sure the items exist and are not the same.

    if (fromItem && toItem && fromItem !== toItem) {
      // Get the indices of the items.
      fromIndex = items.indexOf(fromItem);
      toIndex = items.indexOf(toItem); // Do the move/swap.

      if (isSwap) {
        arraySwap(items, fromIndex, toIndex);
      } else {
        arrayMove(items, fromIndex, toIndex);
      } // Emit move event.


      if (this._hasListeners(eventMove)) {
        this._emit(eventMove, {
          item: fromItem,
          fromIndex: fromIndex,
          toIndex: toIndex,
          action: action
        });
      } // If layout is needed.


      if (layout) {
        this.layout(layout === instantLayout, isFunction(layout) ? layout : undefined);
      }
    }

    return this;
  };
  /**
   * Send item to another Grid instance.
   *
   * @public
   * @memberof Grid.prototype
   * @param {GridSingleItemQuery} item
   * @param {Grid} grid
   * @param {GridSingleItemQuery} position
   * @param {Object} [options]
   * @param {HTMLElement} [options.appendTo=document.body]
   * @param {(Boolean|LayoutCallback|String)} [options.layoutSender=true]
   * @param {(Boolean|LayoutCallback|String)} [options.layoutReceiver=true]
   * @returns {Grid}
   */


  Grid.prototype.send = function (item, grid, position, options) {
    if (this._isDestroyed || grid._isDestroyed || this === grid) return this; // Make sure we have a valid target item.

    item = this._getItem(item);
    if (!item) return this;
    var opts = options || 0;
    var container = opts.appendTo || window.document.body;
    var layoutSender = opts.layoutSender ? opts.layoutSender : opts.layoutSender === undefined;
    var layoutReceiver = opts.layoutReceiver ? opts.layoutReceiver : opts.layoutReceiver === undefined; // Start the migration process.

    item._migrate.start(grid, position, container); // If migration was started successfully and the item is active, let's layout
    // the grids.


    if (item._migrate._isActive && item._isActive) {
      if (layoutSender) {
        this.layout(layoutSender === instantLayout, isFunction(layoutSender) ? layoutSender : undefined);
      }

      if (layoutReceiver) {
        grid.layout(layoutReceiver === instantLayout, isFunction(layoutReceiver) ? layoutReceiver : undefined);
      }
    }

    return this;
  };
  /**
   * Destroy the instance.
   *
   * @public
   * @memberof Grid.prototype
   * @param {Boolean} [removeElements=false]
   * @returns {Grid}
   */


  Grid.prototype.destroy = function (removeElements) {
    if (this._isDestroyed) return this;
    var container = this._element;

    var items = this._items.slice(0);

    var i; // Unbind window resize event listener.

    if (this._resizeHandler) {
      window.removeEventListener('resize', this._resizeHandler);
    } // Destroy items.


    for (i = 0; i < items.length; i++) {
      items[i]._destroy(removeElements);
    } // Restore container.


    removeClass(container, this._settings.containerClass);
    container.style.height = '';
    container.style.width = ''; // Emit destroy event and unbind all events.

    this._emit(eventDestroy);

    this._emitter.destroy(); // Remove reference from the grid instances collection.


    gridInstances[this._id] = undefined; // Flag instance as destroyed.

    this._isDestroyed = true;
    return this;
  };
  /**
   * Private prototype methods
   * *************************
   */

  /**
   * Get instance's item by element or by index. Target can also be an Item
   * instance in which case the function returns the item if it exists within
   * related Grid instance. If nothing is found with the provided target, null
   * is returned.
   *
   * @private
   * @memberof Grid.prototype
   * @param {GridSingleItemQuery} [target]
   * @returns {?Item}
   */


  Grid.prototype._getItem = function (target) {
    // If no target is specified or the instance is destroyed, return null.
    if (this._isDestroyed || !target && target !== 0) {
      return null;
    } // If target is number return the item in that index. If the number is lower
    // than zero look for the item starting from the end of the items array. For
    // example -1 for the last item, -2 for the second last item, etc.


    if ((0,_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(target) === numberType$1) {
      return this._items[target > -1 ? target : this._items.length + target] || null;
    } // If the target is an instance of Item return it if it is attached to this
    // Grid instance, otherwise return null.


    if (target instanceof Item) {
      return target._gridId === this._id ? target : null;
    } // In other cases let's assume that the target is an element, so let's try
    // to find an item that matches the element and return it. If item is not
    // found return null.

    /** @todo This could be made a lot faster by using Map/WeakMap of elements. */


    for (var i = 0; i < this._items.length; i++) {
      if (this._items[i]._element === target) {
        return this._items[i];
      }
    }

    return null;
  };
  /**
   * Recalculates and updates instance's layout data.
   *
   * @private
   * @memberof Grid.prototype
   * @returns {LayoutData}
   */


  Grid.prototype._updateLayout = function () {
    var layout = this._layout;
    var settings = this._settings.layout;
    var width;
    var height;
    var newLayout;
    var i; // Let's increment layout id.

    ++layout.id; // Let's update layout items

    layout.items.length = 0;

    for (i = 0; i < this._items.length; i++) {
      if (this._items[i]._isActive) layout.items.push(this._items[i]);
    } // Let's make sure we have the correct container dimensions.


    this._refreshDimensions(); // Calculate container width and height (without borders).


    width = this._width - this._borderLeft - this._borderRight;
    height = this._height - this._borderTop - this._borderBottom; // Calculate new layout.

    if (isFunction(settings)) {
      newLayout = settings(layout.items, width, height);
    } else {
      newLayout = packer.getLayout(layout.items, width, height, layout.slots, settings);
    } // Let's update the grid's layout.


    layout.slots = newLayout.slots;
    layout.setWidth = Boolean(newLayout.setWidth);
    layout.setHeight = Boolean(newLayout.setHeight);
    layout.width = newLayout.width;
    layout.height = newLayout.height;
    return layout;
  };
  /**
   * Emit a grid event.
   *
   * @private
   * @memberof Grid.prototype
   * @param {String} event
   * @param {...*} [arg]
   */


  Grid.prototype._emit = function () {
    if (this._isDestroyed) return;

    this._emitter.emit.apply(this._emitter, arguments);
  };
  /**
   * Check if there are any events listeners for an event.
   *
   * @private
   * @memberof Grid.prototype
   * @param {String} event
   * @returns {Boolean}
   */


  Grid.prototype._hasListeners = function (event) {
    var listeners = this._emitter._events[event];
    return !!(listeners && listeners.length);
  };
  /**
   * Update container's width, height and offsets.
   *
   * @private
   * @memberof Grid.prototype
   */


  Grid.prototype._updateBoundingRect = function () {
    var element = this._element;
    var rect = element.getBoundingClientRect();
    this._width = rect.width;
    this._height = rect.height;
    this._left = rect.left;
    this._top = rect.top;
  };
  /**
   * Update container's border sizes.
   *
   * @private
   * @memberof Grid.prototype
   * @param {Boolean} left
   * @param {Boolean} right
   * @param {Boolean} top
   * @param {Boolean} bottom
   */


  Grid.prototype._updateBorders = function (left, right, top, bottom) {
    var element = this._element;
    if (left) this._borderLeft = getStyleAsFloat(element, 'border-left-width');
    if (right) this._borderRight = getStyleAsFloat(element, 'border-right-width');
    if (top) this._borderTop = getStyleAsFloat(element, 'border-top-width');
    if (bottom) this._borderBottom = getStyleAsFloat(element, 'border-bottom-width');
  };
  /**
   * Refresh all of container's internal dimensions and offsets.
   *
   * @private
   * @memberof Grid.prototype
   */


  Grid.prototype._refreshDimensions = function () {
    this._updateBoundingRect();

    this._updateBorders(1, 1, 1, 1);
  };
  /**
   * Show or hide Grid instance's items.
   *
   * @private
   * @memberof Grid.prototype
   * @param {GridMultiItemQuery} items
   * @param {Boolean} toVisible
   * @param {Object} [options]
   * @param {Boolean} [options.instant=false]
   * @param {(ShowCallback|HideCallback)} [options.onFinish]
   * @param {(Boolean|LayoutCallback|String)} [options.layout=true]
   */


  Grid.prototype._setItemsVisibility = function (items, toVisible, options) {
    var grid = this;
    var targetItems = this.getItems(items);
    var opts = options || 0;
    var isInstant = opts.instant === true;
    var callback = opts.onFinish;
    var layout = opts.layout ? opts.layout : opts.layout === undefined;
    var counter = targetItems.length;
    var startEvent = toVisible ? eventShowStart : eventHideStart;
    var endEvent = toVisible ? eventShowEnd : eventHideEnd;
    var method = toVisible ? 'show' : 'hide';
    var needsLayout = false;
    var completedItems = [];
    var hiddenItems = [];
    var item;
    var i; // If there are no items call the callback, but don't emit any events.

    if (!counter) {
      if (isFunction(callback)) callback(targetItems);
      return;
    } // Emit showStart/hideStart event.


    if (this._hasListeners(startEvent)) {
      this._emit(startEvent, targetItems.slice(0));
    } // Show/hide items.


    for (i = 0; i < targetItems.length; i++) {
      item = targetItems[i]; // If inactive item is shown or active item is hidden we need to do
      // layout.

      if (toVisible && !item._isActive || !toVisible && item._isActive) {
        needsLayout = true;
      } // If inactive item is shown we also need to do a little hack to make the
      // item not animate it's next positioning (layout).


      if (toVisible && !item._isActive) {
        item._layout._skipNextAnimation = true;
      } // If a hidden item is being shown we need to refresh the item's
      // dimensions.


      if (toVisible && item._visibility._isHidden) {
        hiddenItems.push(item);
      } // Show/hide the item.


      item._visibility[method](isInstant, function (interrupted, item) {
        // If the current item's animation was not interrupted add it to the
        // completedItems array.
        if (!interrupted) completedItems.push(item); // If all items have finished their animations call the callback
        // and emit showEnd/hideEnd event.

        if (--counter < 1) {
          if (isFunction(callback)) callback(completedItems.slice(0));
          if (grid._hasListeners(endEvent)) grid._emit(endEvent, completedItems.slice(0));
        }
      });
    } // Refresh hidden items.


    if (hiddenItems.length) this.refreshItems(hiddenItems); // Layout if needed.

    if (needsLayout && layout) {
      this.layout(layout === instantLayout, isFunction(layout) ? layout : undefined);
    }
  };
  /**
   * Private helpers
   * ***************
   */

  /**
   * Merge default settings with user settings. The returned object is a new
   * object with merged values. The merging is a deep merge meaning that all
   * objects and arrays within the provided settings objects will be also merged
   * so that modifying the values of the settings object will have no effect on
   * the returned object.
   *
   * @param {Object} defaultSettings
   * @param {Object} [userSettings]
   * @returns {Object} Returns a new object.
   */


  function mergeSettings(defaultSettings, userSettings) {
    // Create a fresh copy of default settings.
    var ret = mergeObjects({}, defaultSettings); // Merge user settings to default settings.

    if (userSettings) {
      ret = mergeObjects(ret, userSettings);
    } // Handle visible/hidden styles manually so that the whole object is
    // overridden instead of the props.


    ret.visibleStyles = (userSettings || 0).visibleStyles || (defaultSettings || 0).visibleStyles;
    ret.hiddenStyles = (userSettings || 0).hiddenStyles || (defaultSettings || 0).hiddenStyles;
    return ret;
  }
  /**
   * Merge two objects recursively (deep merge). The source object's properties
   * are merged to the target object.
   *
   * @param {Object} target
   *   - The target object.
   * @param {Object} source
   *   - The source object.
   * @returns {Object} Returns the target object.
   */


  function mergeObjects(target, source) {
    var sourceKeys = Object.keys(source);
    var length = sourceKeys.length;
    var isSourceObject;
    var propName;
    var i;

    for (i = 0; i < length; i++) {
      propName = sourceKeys[i];
      isSourceObject = isPlainObject(source[propName]); // If target and source values are both objects, merge the objects and
      // assign the merged value to the target property.

      if (isPlainObject(target[propName]) && isSourceObject) {
        target[propName] = mergeObjects(mergeObjects({}, target[propName]), source[propName]);
        continue;
      } // If source's value is object and target's is not let's clone the object as
      // the target's value.


      if (isSourceObject) {
        target[propName] = mergeObjects({}, source[propName]);
        continue;
      } // If source's value is an array let's clone the array as the target's
      // value.


      if (Array.isArray(source[propName])) {
        target[propName] = source[propName].slice(0);
        continue;
      } // In all other cases let's just directly assign the source's value as the
      // target's value.


      target[propName] = source[propName];
    }

    return target;
  }

  return Grid;
});

/***/ }),

/***/ 642:
/***/ ((module, __unused_webpack___webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony import */ var _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* module decorator */ module = __webpack_require__.hmd(module);


/**
 * Template7 1.4.2
 * Mobile-first HTML template engine
 * 
 * http://www.idangero.us/template7/
 * 
 * Copyright 2019, Vladimir Kharlampidi
 * The iDangero.us
 * http://www.idangero.us/
 * 
 * Licensed under MIT
 * 
 * Released on: June 14, 2019
 */
(function (global, factory) {
  (typeof exports === "undefined" ? "undefined" : (0,_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(exports)) === 'object' && "object" !== 'undefined' ? module.exports = factory() : typeof define === 'function' && __webpack_require__.amdO ? define(factory) : (global = global || self, global.Template7 = factory());
})(undefined, function () {
  'use strict';

  var t7ctx;

  if (typeof window !== 'undefined') {
    t7ctx = window;
  } else if (typeof __webpack_require__.g !== 'undefined') {
    t7ctx = __webpack_require__.g;
  } else {
    t7ctx = undefined;
  }

  var Template7Context = t7ctx;
  var Template7Utils = {
    quoteSingleRexExp: new RegExp('\'', 'g'),
    quoteDoubleRexExp: new RegExp('"', 'g'),
    isFunction: function isFunction(func) {
      return typeof func === 'function';
    },
    escape: function escape(string) {
      if (string === void 0) string = '';
      return string.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#039;');
    },
    helperToSlices: function helperToSlices(string) {
      var quoteDoubleRexExp = Template7Utils.quoteDoubleRexExp;
      var quoteSingleRexExp = Template7Utils.quoteSingleRexExp;
      var helperParts = string.replace(/[{}#}]/g, '').trim().split(' ');
      var slices = [];
      var shiftIndex;
      var i;
      var j;

      for (i = 0; i < helperParts.length; i += 1) {
        var part = helperParts[i];
        var blockQuoteRegExp = void 0;
        var openingQuote = void 0;

        if (i === 0) {
          slices.push(part);
        } else if (part.indexOf('"') === 0 || part.indexOf('\'') === 0) {
          blockQuoteRegExp = part.indexOf('"') === 0 ? quoteDoubleRexExp : quoteSingleRexExp;
          openingQuote = part.indexOf('"') === 0 ? '"' : '\''; // Plain String

          if (part.match(blockQuoteRegExp).length === 2) {
            // One word string
            slices.push(part);
          } else {
            // Find closed Index
            shiftIndex = 0;

            for (j = i + 1; j < helperParts.length; j += 1) {
              part += " " + helperParts[j];

              if (helperParts[j].indexOf(openingQuote) >= 0) {
                shiftIndex = j;
                slices.push(part);
                break;
              }
            }

            if (shiftIndex) {
              i = shiftIndex;
            }
          }
        } else if (part.indexOf('=') > 0) {
          // Hash
          var hashParts = part.split('=');
          var hashName = hashParts[0];
          var hashContent = hashParts[1];

          if (!blockQuoteRegExp) {
            blockQuoteRegExp = hashContent.indexOf('"') === 0 ? quoteDoubleRexExp : quoteSingleRexExp;
            openingQuote = hashContent.indexOf('"') === 0 ? '"' : '\'';
          }

          if (hashContent.match(blockQuoteRegExp).length !== 2) {
            shiftIndex = 0;

            for (j = i + 1; j < helperParts.length; j += 1) {
              hashContent += " " + helperParts[j];

              if (helperParts[j].indexOf(openingQuote) >= 0) {
                shiftIndex = j;
                break;
              }
            }

            if (shiftIndex) {
              i = shiftIndex;
            }
          }

          var hash = [hashName, hashContent.replace(blockQuoteRegExp, '')];
          slices.push(hash);
        } else {
          // Plain variable
          slices.push(part);
        }
      }

      return slices;
    },
    stringToBlocks: function stringToBlocks(string) {
      var blocks = [];
      var i;
      var j;

      if (!string) {
        return [];
      }

      var stringBlocks = string.split(/({{[^{^}]*}})/);

      for (i = 0; i < stringBlocks.length; i += 1) {
        var block = stringBlocks[i];

        if (block === '') {
          continue;
        }

        if (block.indexOf('{{') < 0) {
          blocks.push({
            type: 'plain',
            content: block
          });
        } else {
          if (block.indexOf('{/') >= 0) {
            continue;
          }

          block = block.replace(/{{([#/])*([ ])*/, '{{$1').replace(/([ ])*}}/, '}}');

          if (block.indexOf('{#') < 0 && block.indexOf(' ') < 0 && block.indexOf('else') < 0) {
            // Simple variable
            blocks.push({
              type: 'variable',
              contextName: block.replace(/[{}]/g, '')
            });
            continue;
          } // Helpers


          var helperSlices = Template7Utils.helperToSlices(block);
          var helperName = helperSlices[0];
          var isPartial = helperName === '>';
          var helperContext = [];
          var helperHash = {};

          for (j = 1; j < helperSlices.length; j += 1) {
            var slice = helperSlices[j];

            if (Array.isArray(slice)) {
              // Hash
              helperHash[slice[0]] = slice[1] === 'false' ? false : slice[1];
            } else {
              helperContext.push(slice);
            }
          }

          if (block.indexOf('{#') >= 0) {
            // Condition/Helper
            var helperContent = '';
            var elseContent = '';
            var toSkip = 0;
            var shiftIndex = void 0;
            var foundClosed = false;
            var foundElse = false;
            var depth = 0;

            for (j = i + 1; j < stringBlocks.length; j += 1) {
              if (stringBlocks[j].indexOf('{{#') >= 0) {
                depth += 1;
              }

              if (stringBlocks[j].indexOf('{{/') >= 0) {
                depth -= 1;
              }

              if (stringBlocks[j].indexOf("{{#" + helperName) >= 0) {
                helperContent += stringBlocks[j];

                if (foundElse) {
                  elseContent += stringBlocks[j];
                }

                toSkip += 1;
              } else if (stringBlocks[j].indexOf("{{/" + helperName) >= 0) {
                if (toSkip > 0) {
                  toSkip -= 1;
                  helperContent += stringBlocks[j];

                  if (foundElse) {
                    elseContent += stringBlocks[j];
                  }
                } else {
                  shiftIndex = j;
                  foundClosed = true;
                  break;
                }
              } else if (stringBlocks[j].indexOf('else') >= 0 && depth === 0) {
                foundElse = true;
              } else {
                if (!foundElse) {
                  helperContent += stringBlocks[j];
                }

                if (foundElse) {
                  elseContent += stringBlocks[j];
                }
              }
            }

            if (foundClosed) {
              if (shiftIndex) {
                i = shiftIndex;
              }

              if (helperName === 'raw') {
                blocks.push({
                  type: 'plain',
                  content: helperContent
                });
              } else {
                blocks.push({
                  type: 'helper',
                  helperName: helperName,
                  contextName: helperContext,
                  content: helperContent,
                  inverseContent: elseContent,
                  hash: helperHash
                });
              }
            }
          } else if (block.indexOf(' ') > 0) {
            if (isPartial) {
              helperName = '_partial';

              if (helperContext[0]) {
                if (helperContext[0].indexOf('[') === 0) {
                  helperContext[0] = helperContext[0].replace(/[[\]]/g, '');
                } else {
                  helperContext[0] = "\"" + helperContext[0].replace(/"|'/g, '') + "\"";
                }
              }
            }

            blocks.push({
              type: 'helper',
              helperName: helperName,
              contextName: helperContext,
              hash: helperHash
            });
          }
        }
      }

      return blocks;
    },
    parseJsVariable: function parseJsVariable(expression, replace, object) {
      return expression.split(/([+ \-*/^()&=|<>!%:?])/g).reduce(function (arr, part) {
        if (!part) {
          return arr;
        }

        if (part.indexOf(replace) < 0) {
          arr.push(part);
          return arr;
        }

        if (!object) {
          arr.push(JSON.stringify(''));
          return arr;
        }

        var variable = object;

        if (part.indexOf(replace + ".") >= 0) {
          part.split(replace + ".")[1].split('.').forEach(function (partName) {
            if (partName in variable) {
              variable = variable[partName];
            } else {
              variable = undefined;
            }
          });
        }

        if (typeof variable === 'string' || Array.isArray(variable) || variable.constructor && variable.constructor === Object) {
          variable = JSON.stringify(variable);
        }

        if (variable === undefined) {
          variable = 'undefined';
        }

        arr.push(variable);
        return arr;
      }, []).join('');
    },
    parseJsParents: function parseJsParents(expression, parents) {
      return expression.split(/([+ \-*^()&=|<>!%:?])/g).reduce(function (arr, part) {
        if (!part) {
          return arr;
        }

        if (part.indexOf('../') < 0) {
          arr.push(part);
          return arr;
        }

        if (!parents || parents.length === 0) {
          arr.push(JSON.stringify(''));
          return arr;
        }

        var levelsUp = part.split('../').length - 1;
        var parentData = levelsUp > parents.length ? parents[parents.length - 1] : parents[levelsUp - 1];
        var variable = parentData;
        var parentPart = part.replace(/..\//g, '');
        parentPart.split('.').forEach(function (partName) {
          if (typeof variable[partName] !== 'undefined') {
            variable = variable[partName];
          } else {
            variable = 'undefined';
          }
        });

        if (variable === false || variable === true) {
          arr.push(JSON.stringify(variable));
          return arr;
        }

        if (variable === null || variable === 'undefined') {
          arr.push(JSON.stringify(''));
          return arr;
        }

        arr.push(JSON.stringify(variable));
        return arr;
      }, []).join('');
    },
    getCompileVar: function getCompileVar(name, ctx, data) {
      if (data === void 0) data = 'data_1';
      var variable = ctx;
      var parts;
      var levelsUp = 0;
      var newDepth;

      if (name.indexOf('../') === 0) {
        levelsUp = name.split('../').length - 1;
        newDepth = variable.split('_')[1] - levelsUp;
        variable = "ctx_" + (newDepth >= 1 ? newDepth : 1);
        parts = name.split('../')[levelsUp].split('.');
      } else if (name.indexOf('@global') === 0) {
        variable = 'Template7.global';
        parts = name.split('@global.')[1].split('.');
      } else if (name.indexOf('@root') === 0) {
        variable = 'root';
        parts = name.split('@root.')[1].split('.');
      } else {
        parts = name.split('.');
      }

      for (var i = 0; i < parts.length; i += 1) {
        var part = parts[i];

        if (part.indexOf('@') === 0) {
          var dataLevel = data.split('_')[1];

          if (levelsUp > 0) {
            dataLevel = newDepth;
          }

          if (i > 0) {
            variable += "[(data_" + dataLevel + " && data_" + dataLevel + "." + part.replace('@', '') + ")]";
          } else {
            variable = "(data_" + dataLevel + " && data_" + dataLevel + "." + part.replace('@', '') + ")";
          }
        } else if (Number.isFinite ? Number.isFinite(part) : Template7Context.isFinite(part)) {
          variable += "[" + part + "]";
        } else if (part === 'this' || part.indexOf('this.') >= 0 || part.indexOf('this[') >= 0 || part.indexOf('this(') >= 0) {
          variable = part.replace('this', ctx);
        } else {
          variable += "." + part;
        }
      }

      return variable;
    },
    getCompiledArguments: function getCompiledArguments(contextArray, ctx, data) {
      var arr = [];

      for (var i = 0; i < contextArray.length; i += 1) {
        if (/^['"]/.test(contextArray[i])) {
          arr.push(contextArray[i]);
        } else if (/^(true|false|\d+)$/.test(contextArray[i])) {
          arr.push(contextArray[i]);
        } else {
          arr.push(Template7Utils.getCompileVar(contextArray[i], ctx, data));
        }
      }

      return arr.join(', ');
    }
  };
  /* eslint no-eval: "off" */

  var Template7Helpers = {
    _partial: function _partial(partialName, options) {
      var ctx = this;
      var p = Template7Class.partials[partialName];

      if (!p || p && !p.template) {
        return '';
      }

      if (!p.compiled) {
        p.compiled = new Template7Class(p.template).compile();
      }

      Object.keys(options.hash).forEach(function (hashName) {
        ctx[hashName] = options.hash[hashName];
      });
      return p.compiled(ctx, options.data, options.root);
    },
    escape: function escape(context) {
      if (typeof context === 'undefined' || context === null) {
        return '';
      }

      if (typeof context !== 'string') {
        throw new Error('Template7: Passed context to "escape" helper should be a string');
      }

      return Template7Utils.escape(context);
    },
    "if": function if$1(context, options) {
      var ctx = context;

      if (Template7Utils.isFunction(ctx)) {
        ctx = ctx.call(this);
      }

      if (ctx) {
        return options.fn(this, options.data);
      }

      return options.inverse(this, options.data);
    },
    unless: function unless(context, options) {
      var ctx = context;

      if (Template7Utils.isFunction(ctx)) {
        ctx = ctx.call(this);
      }

      if (!ctx) {
        return options.fn(this, options.data);
      }

      return options.inverse(this, options.data);
    },
    each: function each(context, options) {
      var ctx = context;
      var ret = '';
      var i = 0;

      if (Template7Utils.isFunction(ctx)) {
        ctx = ctx.call(this);
      }

      if (Array.isArray(ctx)) {
        if (options.hash.reverse) {
          ctx = ctx.reverse();
        }

        for (i = 0; i < ctx.length; i += 1) {
          ret += options.fn(ctx[i], {
            first: i === 0,
            last: i === ctx.length - 1,
            index: i
          });
        }

        if (options.hash.reverse) {
          ctx = ctx.reverse();
        }
      } else {
        // eslint-disable-next-line
        for (var key in ctx) {
          i += 1;
          ret += options.fn(ctx[key], {
            key: key
          });
        }
      }

      if (i > 0) {
        return ret;
      }

      return options.inverse(this);
    },
    "with": function with$1(context, options) {
      var ctx = context;

      if (Template7Utils.isFunction(ctx)) {
        ctx = context.call(this);
      }

      return options.fn(ctx);
    },
    join: function join(context, options) {
      var ctx = context;

      if (Template7Utils.isFunction(ctx)) {
        ctx = ctx.call(this);
      }

      return ctx.join(options.hash.delimiter || options.hash.delimeter);
    },
    js: function js(expression, options) {
      var data = options.data;
      var func;
      var execute = expression;
      'index first last key'.split(' ').forEach(function (prop) {
        if (typeof data[prop] !== 'undefined') {
          var re1 = new RegExp("this.@" + prop, 'g');
          var re2 = new RegExp("@" + prop, 'g');
          execute = execute.replace(re1, JSON.stringify(data[prop])).replace(re2, JSON.stringify(data[prop]));
        }
      });

      if (options.root && execute.indexOf('@root') >= 0) {
        execute = Template7Utils.parseJsVariable(execute, '@root', options.root);
      }

      if (execute.indexOf('@global') >= 0) {
        execute = Template7Utils.parseJsVariable(execute, '@global', Template7Context.Template7.global);
      }

      if (execute.indexOf('../') >= 0) {
        execute = Template7Utils.parseJsParents(execute, options.parents);
      }

      if (execute.indexOf('return') >= 0) {
        func = "(function(){" + execute + "})";
      } else {
        func = "(function(){return (" + execute + ")})";
      }

      return eval(func).call(this);
    },
    js_if: function js_if(expression, options) {
      var data = options.data;
      var func;
      var execute = expression;
      'index first last key'.split(' ').forEach(function (prop) {
        if (typeof data[prop] !== 'undefined') {
          var re1 = new RegExp("this.@" + prop, 'g');
          var re2 = new RegExp("@" + prop, 'g');
          execute = execute.replace(re1, JSON.stringify(data[prop])).replace(re2, JSON.stringify(data[prop]));
        }
      });

      if (options.root && execute.indexOf('@root') >= 0) {
        execute = Template7Utils.parseJsVariable(execute, '@root', options.root);
      }

      if (execute.indexOf('@global') >= 0) {
        execute = Template7Utils.parseJsVariable(execute, '@global', Template7Context.Template7.global);
      }

      if (execute.indexOf('../') >= 0) {
        execute = Template7Utils.parseJsParents(execute, options.parents);
      }

      if (execute.indexOf('return') >= 0) {
        func = "(function(){" + execute + "})";
      } else {
        func = "(function(){return (" + execute + ")})";
      }

      var condition = eval(func).call(this);

      if (condition) {
        return options.fn(this, options.data);
      }

      return options.inverse(this, options.data);
    }
  };
  Template7Helpers.js_compare = Template7Helpers.js_if;
  var Template7Options = {};
  var Template7Partials = {};

  var Template7Class = function Template7Class(template) {
    var t = this;
    t.template = template;
  };

  var staticAccessors = {
    options: {
      configurable: true
    },
    partials: {
      configurable: true
    },
    helpers: {
      configurable: true
    }
  };

  Template7Class.prototype.compile = function compile(template, depth) {
    if (template === void 0) template = this.template;
    if (depth === void 0) depth = 1;
    var t = this;

    if (t.compiled) {
      return t.compiled;
    }

    if (typeof template !== 'string') {
      throw new Error('Template7: Template must be a string');
    }

    var stringToBlocks = Template7Utils.stringToBlocks;
    var getCompileVar = Template7Utils.getCompileVar;
    var getCompiledArguments = Template7Utils.getCompiledArguments;
    var blocks = stringToBlocks(template);
    var ctx = "ctx_" + depth;
    var data = "data_" + depth;

    if (blocks.length === 0) {
      return function empty() {
        return '';
      };
    }

    function getCompileFn(block, newDepth) {
      if (block.content) {
        return t.compile(block.content, newDepth);
      }

      return function empty() {
        return '';
      };
    }

    function getCompileInverse(block, newDepth) {
      if (block.inverseContent) {
        return t.compile(block.inverseContent, newDepth);
      }

      return function empty() {
        return '';
      };
    }

    var resultString = '';

    if (depth === 1) {
      resultString += "(function (" + ctx + ", " + data + ", root) {\n";
    } else {
      resultString += "(function (" + ctx + ", " + data + ") {\n";
    }

    if (depth === 1) {
      resultString += 'function isArray(arr){return Array.isArray(arr);}\n';
      resultString += 'function isFunction(func){return (typeof func === \'function\');}\n';
      resultString += 'function c(val, ctx) {if (typeof val !== "undefined" && val !== null) {if (isFunction(val)) {return val.call(ctx);} else return val;} else return "";}\n';
      resultString += 'root = root || ctx_1 || {};\n';
    }

    resultString += 'var r = \'\';\n';
    var i;

    for (i = 0; i < blocks.length; i += 1) {
      var block = blocks[i]; // Plain block

      if (block.type === 'plain') {
        // eslint-disable-next-line
        resultString += "r +='" + block.content.replace(/\r/g, '\\r').replace(/\n/g, '\\n').replace(/'/g, '\\' + '\'') + "';";
        continue;
      }

      var variable = void 0;
      var compiledArguments = void 0; // Variable block

      if (block.type === 'variable') {
        variable = getCompileVar(block.contextName, ctx, data);
        resultString += "r += c(" + variable + ", " + ctx + ");";
      } // Helpers block


      if (block.type === 'helper') {
        var parents = void 0;

        if (ctx !== 'ctx_1') {
          var level = ctx.split('_')[1];
          var parentsString = "ctx_" + (level - 1);

          for (var j = level - 2; j >= 1; j -= 1) {
            parentsString += ", ctx_" + j;
          }

          parents = "[" + parentsString + "]";
        } else {
          parents = "[" + ctx + "]";
        }

        var dynamicHelper = void 0;

        if (block.helperName.indexOf('[') === 0) {
          block.helperName = getCompileVar(block.helperName.replace(/[[\]]/g, ''), ctx, data);
          dynamicHelper = true;
        }

        if (dynamicHelper || block.helperName in Template7Helpers) {
          compiledArguments = getCompiledArguments(block.contextName, ctx, data);
          resultString += "r += (Template7Helpers" + (dynamicHelper ? "[" + block.helperName + "]" : "." + block.helperName) + ").call(" + ctx + ", " + (compiledArguments && compiledArguments + ", ") + "{hash:" + JSON.stringify(block.hash) + ", data: " + data + " || {}, fn: " + getCompileFn(block, depth + 1) + ", inverse: " + getCompileInverse(block, depth + 1) + ", root: root, parents: " + parents + "});";
        } else if (block.contextName.length > 0) {
          throw new Error("Template7: Missing helper: \"" + block.helperName + "\"");
        } else {
          variable = getCompileVar(block.helperName, ctx, data);
          resultString += "if (" + variable + ") {";
          resultString += "if (isArray(" + variable + ")) {";
          resultString += "r += (Template7Helpers.each).call(" + ctx + ", " + variable + ", {hash:" + JSON.stringify(block.hash) + ", data: " + data + " || {}, fn: " + getCompileFn(block, depth + 1) + ", inverse: " + getCompileInverse(block, depth + 1) + ", root: root, parents: " + parents + "});";
          resultString += '}else {';
          resultString += "r += (Template7Helpers.with).call(" + ctx + ", " + variable + ", {hash:" + JSON.stringify(block.hash) + ", data: " + data + " || {}, fn: " + getCompileFn(block, depth + 1) + ", inverse: " + getCompileInverse(block, depth + 1) + ", root: root, parents: " + parents + "});";
          resultString += '}}';
        }
      }
    }

    resultString += '\nreturn r;})';

    if (depth === 1) {
      // eslint-disable-next-line
      t.compiled = eval(resultString);
      return t.compiled;
    }

    return resultString;
  };

  staticAccessors.options.get = function () {
    return Template7Options;
  };

  staticAccessors.partials.get = function () {
    return Template7Partials;
  };

  staticAccessors.helpers.get = function () {
    return Template7Helpers;
  };

  Object.defineProperties(Template7Class, staticAccessors);

  function Template7() {
    var args = [],
        len = arguments.length;

    while (len--) {
      args[len] = arguments[len];
    }

    var template = args[0];
    var data = args[1];

    if (args.length === 2) {
      var instance = new Template7Class(template);
      var rendered = instance.compile()(data);
      instance = null;
      return rendered;
    }

    return new Template7Class(template);
  }

  Template7.registerHelper = function registerHelper(name, fn) {
    Template7Class.helpers[name] = fn;
  };

  Template7.unregisterHelper = function unregisterHelper(name) {
    Template7Class.helpers[name] = undefined;
    delete Template7Class.helpers[name];
  };

  Template7.registerPartial = function registerPartial(name, template) {
    Template7Class.partials[name] = {
      template: template
    };
  };

  Template7.unregisterPartial = function unregisterPartial(name) {
    if (Template7Class.partials[name]) {
      Template7Class.partials[name] = undefined;
      delete Template7Class.partials[name];
    }
  };

  Template7.compile = function compile(template, options) {
    var instance = new Template7Class(template, options);
    return instance.compile();
  };

  Template7.options = Template7Class.options;
  Template7.helpers = Template7Class.helpers;
  Template7.partials = Template7Class.partials;
  return Template7;
});

/***/ }),

/***/ 782:
/***/ (() => {

/**
 * jQuery.fn.sortElements
 * --------------
 * @author James Padolsey (http://james.padolsey.com)
 * @version 0.11
 * @updated 18-MAR-2010
 * --------------
 * @param Function comparator:
 *   Exactly the same behaviour as [1,2,3].sort(comparator)
 *   
 * @param Function getSortable
 *   A function that should return the element that is
 *   to be sorted. The comparator will run on the
 *   current collection, but you may want the actual
 *   resulting sort to occur on a parent or another
 *   associated element.
 *   
 *   E.g. $('td').sortElements(comparator, function(){
 *      return this.parentNode; 
 *   })
 *   
 *   The <td>'s parent (<tr>) will be sorted instead
 *   of the <td> itself.
 */
jQuery.fn.sortElements = function () {
  var sort = [].sort;
  return function (comparator, getSortable) {
    getSortable = getSortable || function () {
      return this;
    };

    var placements = this.map(function () {
      var sortElement = getSortable.call(this),
          parentNode = sortElement.parentNode,
          // Since the element itself will change position, we have
      // to have some way of storing it's original position in
      // the DOM. The easiest way is to have a 'flag' node:
      nextSibling = parentNode.insertBefore(document.createTextNode(''), sortElement.nextSibling);
      return function () {
        if (parentNode === this) {
          throw new Error("You can't sort elements if any one is a descendant of another.");
        } // Insert before flag:


        parentNode.insertBefore(this, nextSibling); // Remove flag:

        parentNode.removeChild(nextSibling);
      };
    });
    return sort.call(this, comparator).each(function (i) {
      placements[i].call(getSortable.call(this));
    });
  };
}();

/***/ }),

/***/ 2:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ _typeof)
/* harmony export */ });
function _typeof(obj) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof(obj);
}

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/amd options */
/******/ 	(() => {
/******/ 		__webpack_require__.amdO = {};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/harmony module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.hmd = (module) => {
/******/ 			module = Object.create(module);
/******/ 			if (!module.children) module.children = [];
/******/ 			Object.defineProperty(module, 'exports', {
/******/ 				enumerable: true,
/******/ 				set: () => {
/******/ 					throw new Error('ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: ' + module.id);
/******/ 				}
/******/ 			});
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/typeof.js
var esm_typeof = __webpack_require__(2);
;// CONCATENATED MODULE: ./src/components/_global/js/utils/global-vars.js
/*
 * Global variables from front pages
 *
 * @private
 */
var //If the file is in the root directory, you can leave it empty.
//If in another directory, you can write: "/blog"
templateUrl, //Eg. https://uiux.cc
homeUrl, //Eg. https://uiux.cc/wp-admin/admin-ajax.php
ajaxUrl;

if (typeof APP_ROOTPATH === 'undefined') {
  templateUrl = '';
  homeUrl = '';
  ajaxUrl = '';
} else {
  templateUrl = APP_ROOTPATH.templateUrl.replace(/\/\s*$/, '');
  homeUrl = APP_ROOTPATH.homeUrl.replace(/\/\s*$/, '');
  ajaxUrl = APP_ROOTPATH.ajaxUrl.replace(/\/\s*$/, '');
}


;// CONCATENATED MODULE: ./src/components/_global/js/utils/browser.js
/*
 * Determine whether it is a special browser
 *
 * @private
 */
// Add feature test for passive event listener support
var supportsPassive = false;

try {
  document.addEventListener("test", null, {
    get passive() {
      supportsPassive = true;
    }

  });
} catch (e) {}

var UixBrowser = {
  isMobile: /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),
  isAndroid: /(android)/i.test(navigator.userAgent),
  isPC: !navigator.userAgent.match(/(iPhone|iPod|Android|ios|Mobile)/i),
  isSafari: !!navigator.userAgent.match(/Version\/[\d\.]+.*Safari/),

  /*Test to 9, 10. */
  isIE: !!window.ActiveXObject || "ActiveXObject" in window,

  /*Test to 6 ~ 11 (not edge) */
  supportsPassive: supportsPassive
};
;// CONCATENATED MODULE: ./src/components/_global/js/utils/module-instance.js


/*
 * Core scripts for current site
 *
 * @private
 * @description Used for all modules from ./src/components/[__]/js
 * @requires ./examples/assets/js/min/jquery.waitforimages.min.js
 * @requires ./examples/assets/js/min/video.min.js
 * @requires ./examples/assets/js/min/TweenMax.min.js
 */
var UixModuleInstance = function ($, window, document) {
  var _APP = {},
      components = {
    documentReady: [],
    pageLoaded: []
  };

  if ($('img').length == 0) {
    $('body').prepend('<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="" style="display:none">');
  }

  if ($.isFunction($.fn.waitForImages)) {
    $('body').waitForImages(pageLoaded);
  } else {
    $(window).on('load', pageLoaded);
  }

  $(document).ready(documentReady);

  function documentReady(context) {
    context = (0,esm_typeof/* default */.Z)(context) == ( true ? "undefined" : 0) ? $ : context;
    components.documentReady.forEach(function (component) {
      component(context);
    });
  }

  function pageLoaded(context) {
    context = (0,esm_typeof/* default */.Z)(context) == "object" ? $ : context;
    components.pageLoaded.forEach(function (component) {
      component(context);
    });
  }

  _APP.setContext = function (contextSelector) {
    var context = $;

    if ((0,esm_typeof/* default */.Z)(contextSelector) !== ( true ? "undefined" : 0)) {
      return function (selector) {
        return $(contextSelector).find(selector);
      };
    }

    return context;
  };

  _APP.components = components;
  _APP.documentReady = documentReady;
  _APP.pageLoaded = pageLoaded;
  return _APP;
}($, window, document);
;// CONCATENATED MODULE: ./src/components/_global/js/utils/GUID.js
/*
 * Create GUID / UUID
 *
 * @private
 * @description This function can be used separately in HTML pages or custom JavaScript.
 * @return {String}                        - The globally-unique identifiers.
 */
var UixGUID = UixGUID || function () {
  function t() {}

  return t.version = "0.0.1", t.create = function () {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
      var r = Math.random() * 16 | 0,
          v = c == 'x' ? r : r & 0x3 | 0x8;
      return v.toString(16);
    });
  }, //
  t;
}();
;// CONCATENATED MODULE: ./src/components/_global/js/utils/math.js
/*
 * Evaluating a string as a mathematical expression in JavaScript
 *
 * @private
 * @description This function can be used separately in HTML pages or custom JavaScript.
 * @return {String}            - New calculation result.
 */
var UixMath = UixMath || function () {
  function t() {}

  return t.version = "0.0.1", t.evaluate = function (s) {
    var chars = s.replace(/\s/g, '').split("");
    var n = [],
        op = [],
        index = 0,
        oplast = true;
    n[index] = ""; // Parse the expression

    for (var c = 0; c < chars.length; c++) {
      if (isNaN(parseInt(chars[c])) && chars[c] !== "." && !oplast) {
        op[index] = chars[c];
        index++;
        n[index] = "";
        oplast = true;
      } else {
        n[index] += chars[c];
        oplast = false;
      }
    } // Calculate the expression


    s = parseFloat(n[0]);

    for (var o = 0; o < op.length; o++) {
      var num = parseFloat(n[o + 1]);

      switch (op[o]) {
        case "+":
          s = s + num;
          break;

        case "-":
          s = s - num;
          break;

        case "*":
          s = s * num;
          break;

        case "/":
          s = s / num;
          break;
      }
    }

    return s;
  }, //
  t;
}();
;// CONCATENATED MODULE: ./src/components/_global/js/utils/css-property.js


/*
 * Get the CSS property
 *
 * @private
 * @description This function can be used separately in HTML pages or custom JavaScript.
 * @param  {!Element} el     - The Element for which to get the computed style. Using class name or ID to locate.
 * @return {String|Object}   - The value of property.
 */
var UixCssProperty = UixCssProperty || function () {
  function t() {}

  return t.version = "0.0.1", t.getTransitionDuration = function (el) {
    if ((0,esm_typeof/* default */.Z)(el) === ( true ? "undefined" : 0)) {
      return 0;
    }

    var style = window.getComputedStyle(el),
        duration = style.webkitTransitionDuration,
        delay = style.webkitTransitionDelay;

    if ((0,esm_typeof/* default */.Z)(duration) != ( true ? "undefined" : 0)) {
      // fix miliseconds vs seconds
      duration = duration.indexOf("ms") > -1 ? parseFloat(duration) : parseFloat(duration) * 1000;
      delay = delay.indexOf("ms") > -1 ? parseFloat(delay) : parseFloat(delay) * 1000;
      return duration;
    } else {
      return 0;
    }
  }, //
  t.getAbsoluteCoordinates = function (el) {
    var windowWidth = window.innerWidth,
        leftPos = null,
        topPos = null;

    if (!document.getElementsByTagName('body')[0].className.match(/rtl/)) {
      leftPos = el.offsetLeft == 0 ? el.parentElement.offsetLeft : el.offsetLeft;
      topPos = el.offsetTop == 0 ? el.parentElement.offsetTop : el.offsetTop;
    } else {
      // width and height in pixels, including padding and border
      // Corresponds to jQuery outerWidth(), outerHeight()
      leftPos = el.offsetLeft == 0 ? windowWidth - (el.parentElement.offsetLeft + el.parentElement.offsetWidth) : windowWidth - (el.offsetLeft + el.offsetWidth);
      topPos = el.offsetTop == 0 ? windowWidth - (el.parentElement.offsetTop + el.parentElement.offsetHeight) : windowWidth - (el.offsetTop + el.offsetHeight);
    }

    return {
      'left': leftPos,
      'top': topPos
    };
  }, //
  t;
}();
;// CONCATENATED MODULE: ./src/components/_global/js/utils/performance.js
/*
* Debounce
*
* @param  {Function} fn    - A function to be executed within the time limit.
* @param  {Number} limit   - Waiting time.
* @return {Function}       - Returns a new function.
*/
var UixDebounce = function UixDebounce(fn) {
  var limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 300;
  var timer;
  return function () {
    //Every time this returned function is called, the timer is cleared to ensure that fn is not executed
    clearTimeout(timer); // When the returned function is called for the last time (that is the user stops a continuous operation)
    // Execute fn after another delay milliseconds

    timer = setTimeout(function () {
      fn.apply(this, arguments);
    }, limit);
  };
};
/*
* Throttle
*
* @param  {Function} fn    - A function to be executed within the time limit.
* @param  {Number} limit   - Waiting time.
* @return {Function}       - Returns a new function.
*/

var UixThrottle = function UixThrottle(fn) {
  var limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 300;
  var waiting = false;
  return function () {
    if (!waiting) {
      fn.apply(this, arguments);
      waiting = true;
      setTimeout(function () {
        waiting = false;
      }, limit);
    }
  };
};
;// CONCATENATED MODULE: ./src/components/_global/js/index.js
/**

	TABLE OF CONTENTS
	---------------------------


	1.Base
    2.Body And Header
    3.Common Height
    4.Get all custom attributes of an element like "data-*"
    5.Loader
    6.Mega Menu
    7.Mobile Menu
    8.Navigation
    9.Specify a background image
    10.Videos
    11.Theme Scripts
    12.Accordion Background Images
    13.Accordion
    14.Advanced Slider (Basic)
    15.Advanced Slider (Special Effects)
    16.Ajax Push Content
    17.Ajax Page Loader (Loading A Page via Ajax Into Div)
    18.Back to Top
    19.Circle Layout
    20.Counter
    21.Dropdown Menu
    22.Dropdown Menu 2 (Multi-level drop-down navigation)
    23.Cascading DropDown List
    24.Flexslider (Third-party plugin)
    25.Floating Side Element
    26.Form Progress
    27.Form
    28.Gallery
    29.Hybrid Content Slider
    30.Hover Delay Interaction
    31.Image Shapes
    32.Infinite Scrolling Element
    33.Lava-Lamp Style Menu
    34.Custom Lightbox
    35.Bulleted List
    36.Posts List With Ajax
    37.Full Width Column to Edge
    38.Login Templates
    39.Modal Dialog
    40.Mousewheel Interaction
    41.Multiple Items Carousel
    42.Full Page/One Page Transition
    43.Full Page/One Page Transition 2
    44.Parallax
    45.Periodical Scroll
    46.Pricing
    47.Progress Bar
    48.Progress Line
    49.Retina Graphics for Website
    50.Rotating Elements
    51.Scroll Reveal
    52.Scrollspy Animate
    53.Show More Less
    54.Skew Based On Velocity of Scroll
    55.Smooth Scrolling When Clicking An Anchor Link
    56.Smooth Scrolling Page
    57.Sticky Elements
    58.SVG Map (China)
    59.SVG Map (World)
    60.SVG Mask Slider
    61.Swiper
    62.3D Background 1 with three.js
    63.3D Background 2 with three.js
    64.3D Background 3 with three.js
    65.3D Background
    66.3D Carousel
    67.3D Gallery with three.js
    68.3D Image Transition with three.js
    69.3D Model
    70.3D Pages
    71.3D Particle Effect
    72.3D Sphere Rotation
    73.3D Object Anim When Click
    74.3D Mouse Interaction with three.js
    75.3D Mouse Interaction with three.js
    76.3D Shatter Slider
    77.3D Explosive Particle Slider
    78.3D Liquid Scrollspy Slider
    79.3D Filmic Effects
    80.Simulate HTML Layout with threejs
    81.Responsive Table
    82.Table Sorter
    83.Tabs
    84.Team Focus
    85.Text effect
    86.Timeline
    87.Vertical Menu
    88.WordPress Core Scripts


*/

/*
 *************************************
 * <!-- Base -->
 *************************************
 */

/* !!! To build a table of contents (TOC), you need to import this scss file into JS */








;// CONCATENATED MODULE: ./src/components/_global/js/fn/UixModuleFilter.js


/*
 * Method of deleting or adding a module
 *
 * @global
 * @description This function can be used separately in HTML pages or custom JavaScript.
 * @param  {Boolean|String} destroy       - If it is a string, it means destroying this module from UixModuleInstance
 * @param  {Object} add                     - New module data via JSON.
 * @param  {String} add.moduleName        - The name of the module (the default is all uppercase).
 * @param  {Boolean} add.pageLoaded       - Window loading module method. If true or 1, the module will execute after the page is loaded.
 * @param  {Number} add.version           - The new module version number.
 * @param  {Function} add.callback        - The new module script of function.
 * @return {Void}      
 *
 * @Usage:
 * !!! The code is to be inserted in front of the uix-kit core script.
	
	
<script>
window.MAIN = null;
( function( $ ) {
"use strict";
    $( document ).ready( function() {
		$( document ).UixModuleFilter( { 
		   'destroy' : 'MAIN',
		   'add'     : {
							moduleName    : 'YOUR_MODULE_NAME',
							pageLoaded    : true,
							version       : '0.0.1',
							callback      : function() {
								//the module will execute after the page is loaded.

							}
						}
		} );
    } );
} ) ( jQuery );
</script>

 *
 * 
 */


(function ($) {
  'use strict';

  $.fn.UixModuleFilter = function (options) {
    // This is the easiest way to have default options.
    var settings = $.extend({
      destroy: false,
      add: {
        moduleName: 'OLD_MODULE_NAME',
        pageLoaded: false,
        version: '0.0.1',
        callback: function callback() {}
      }
    }, options);
    this.each(function () {
      //remove a module
      //-------------------------------------	
      if (settings.destroy && Object.prototype.toString.call(settings.destroy) == '[object String]') {
        var moduleName = settings.destroy;

        if ((0,esm_typeof/* default */.Z)(UixModuleInstance[moduleName]) != ( true ? "undefined" : 0)) {
          delete UixModuleInstance[moduleName];
        }
      } //add or replace a module
      //-------------------------------------	


      if (settings.add && Object.prototype.toString.call(settings.add) == '[object Object]' && settings.add.hasOwnProperty('pageLoaded')) {
        var _moduleName2 = settings.add.moduleName; //delete the old module if exist

        if ((0,esm_typeof/* default */.Z)(UixModuleInstance[_moduleName2]) != ( true ? "undefined" : 0)) {
          console.log('The module already exists, please destroy the old module or change the new module name.');
        } else {
          //loading mode "documentReady"
          if (!settings.add.pageLoaded || settings.add.pageLoaded == 0) {
            var _moduleName = function (module, $, window, document) {
              module[_moduleName2] = module[_moduleName2] || {};
              module[_moduleName2].version = settings.add.version;

              module[_moduleName2].documentReady = function ($) {
                settings.add.callback();
              };

              module.components.documentReady.push(module[_moduleName2].documentReady);
              return _moduleName;
            }(UixModuleInstance, jQuery, window, document);

            UixModuleInstance[_moduleName2].documentReady($);
          } //loading mode "pageLoaded"


          if (settings.add.pageLoaded || settings.add.pageLoaded == 1) {
            var _moduleName3 = function (module, $, window, document) {
              module[_moduleName2] = module[_moduleName2] || {};
              module[_moduleName2].version = settings.add.version;

              module[_moduleName2].pageLoaded = function () {
                settings.add.callback();
              };

              module.components.pageLoaded.push(module[_moduleName2].pageLoaded);
              return _moduleName3;
            }(UixModuleInstance, jQuery, window, document);

            UixModuleInstance[_moduleName2].pageLoaded();
          }
        }
      }
    });
  };
})(jQuery);
;// CONCATENATED MODULE: ./src/components/_global/js/fn/UixApplyAsyncScripts.js
/*
 * Apply some asynchronism scripts
 *
 * @global
 * @description This function can be used separately in HTML pages or custom JavaScript.
 * @param  {Boolean} scrollReveal          - Run script of module "Scroll Reveal". a page commonly used to
 *                                           load asynchronous information
 * @param  {Boolean} ajaxPostList          - Run script of module "Posts List With Ajax". a page commonly used to
 *                                           load asynchronous information
 * @param  {Boolean} ajaxDDList            - Run script of module "Cascading DropDown List".
 * @param  {Boolean} counterAnim           - Run script of module "Counter".
 * @return {Void}
 *
 * @Usage:
    
	
<script>
( function( $ ) {
"use strict";
    $( document ).ready( function() {
		$( document ).UixApplyAsyncScripts({
			scrollReveal    : true,
			ajaxPostList    : true,
			ajaxDDList      : true,
			counterAnim     : true,
			lightBox        : true 
		});
    } );
} ) ( jQuery );
</script>

 

 *
 * 
 */


(function ($) {
  'use strict';

  $.fn.UixApplyAsyncScripts = function (options) {
    // This is the easiest way to have default options.
    var settings = $.extend({
      scrollReveal: true,
      // @from ./src/components/scroll-reveal
      ajaxPostList: true,
      // @from ./src/components/list-posts
      ajaxDDList: true,
      // @from ./src/components/cascading-dropdown-list
      counterAnim: true,
      // @from ./src/components/counter
      lightBox: true // @from ./src/components/lightbox

    }, options);
    this.each(function () {
      //----
      if (UixModuleInstance.MAIN) UixModuleInstance.MAIN.pageLoaded(); //Theme Scripts

      if (UixModuleInstance.COMMON_HEIGHT) UixModuleInstance.COMMON_HEIGHT.pageLoaded(); //Common Height

      if (UixModuleInstance.ADVANCED_SLIDER) UixModuleInstance.ADVANCED_SLIDER.pageLoaded(); //Advanced Slider (Basic)

      if (UixModuleInstance.ADVANCED_SLIDER_FILTER) UixModuleInstance.ADVANCED_SLIDER_FILTER.pageLoaded(); //Advanced Slider

      if (UixModuleInstance.FULL_WIDTH_COLUMN_TO_EDGE) UixModuleInstance.FULL_WIDTH_COLUMN_TO_EDGE.pageLoaded(); //Full Width Column to Edge

      if (UixModuleInstance.STICKY_EL) UixModuleInstance.STICKY_EL.pageLoaded(); //Sticky Elements

      if (UixModuleInstance.TEXT_EFFECT) UixModuleInstance.TEXT_EFFECT.pageLoaded(); //Text effect

      if (UixModuleInstance.TIMELINE) UixModuleInstance.TIMELINE.pageLoaded(); //Timeline

      if (UixModuleInstance.HYBRID_CONTENT_SLIDER) UixModuleInstance.HYBRID_CONTENT_SLIDER.pageLoaded(); //Hybrid Content Slider
      //----

      if (UixModuleInstance.MAIN) UixModuleInstance.MAIN.documentReady($); //Theme Scripts

      if (UixModuleInstance.TABLE) UixModuleInstance.TABLE.documentReady($); //Responsive Table

      if (UixModuleInstance.TABLE_SORTER) UixModuleInstance.TABLE_SORTER.documentReady($); //Table Sorter

      if (UixModuleInstance.MODAL_DIALOG) UixModuleInstance.MODAL_DIALOG.documentReady($); //Modal Dialog

      if (UixModuleInstance.PARALLAX) UixModuleInstance.PARALLAX.documentReady($); //Parallax

      if (UixModuleInstance.VIDEOS) UixModuleInstance.VIDEOS.documentReady($); //Videos

      if (UixModuleInstance.BODY_AND_HEADER) UixModuleInstance.BODY_AND_HEADER.documentReady($); //Header Area

      if (UixModuleInstance.SET_BG) UixModuleInstance.SET_BG.documentReady($); //Specify a background image

      if (UixModuleInstance.GET_CUSTOM_ATTRS) UixModuleInstance.GET_CUSTOM_ATTRS.documentReady($); //Get all custom attributes of an element like "data-*"

      if (UixModuleInstance.PAGINATION) UixModuleInstance.PAGINATION.documentReady($); //Pagination

      if (UixModuleInstance.FORM) UixModuleInstance.FORM.documentReady($); //Form

      if (UixModuleInstance.FLEXSLIDER) UixModuleInstance.FLEXSLIDER.documentReady($); //Flexslider (Third-party plugin)

      if (UixModuleInstance.RETINA) UixModuleInstance.RETINA.documentReady($); //Retina Graphics for Website

      if (UixModuleInstance.SHOW_MORELESS) UixModuleInstance.SHOW_MORELESS.documentReady($); //Show More Less

      if (UixModuleInstance.DROPDOWN_MENU) UixModuleInstance.DROPDOWN_MENU.documentReady($); //Dropdown Menu

      if (UixModuleInstance.DROPDOWN_MENU2) UixModuleInstance.DROPDOWN_MENU2.documentReady($); //Dropdown Menu2

      if (UixModuleInstance.ACCORDION) UixModuleInstance.ACCORDION.documentReady($); //Accordion

      if (UixModuleInstance.GALLERY) UixModuleInstance.GALLERY.documentReady($); //Gallery

      if (UixModuleInstance.IMAGE_SHAPES) UixModuleInstance.IMAGE_SHAPES.documentReady($); //Image Shapes

      if (UixModuleInstance.PERIODICAL_SCROLL) UixModuleInstance.PERIODICAL_SCROLL.documentReady($); //Periodical Scroll

      if (UixModuleInstance.PRICING) UixModuleInstance.PRICING.documentReady($); //Pricing

      if (UixModuleInstance.PROGRESS_BAR) UixModuleInstance.PROGRESS_BAR.documentReady($); //Progress Bar

      if (UixModuleInstance.PROGRESS_LINE) UixModuleInstance.PROGRESS_LINE.documentReady($); //Progress Line

      if (UixModuleInstance.ROTATING_EL) UixModuleInstance.ROTATING_EL.documentReady($); //Rotating Elements

      if (UixModuleInstance.SMOOTH_SCROLLING_ANCHORLINK) UixModuleInstance.SMOOTH_SCROLLING_ANCHORLINK.documentReady($); //Smooth Scrolling When Clicking An Anchor Link

      if (UixModuleInstance.SWIPER) UixModuleInstance.SWIPER.documentReady($); //SWIPER (Third-party plugin)

      if (UixModuleInstance.TABS) UixModuleInstance.TABS.documentReady($); //Tabs

      if (UixModuleInstance.TEAM_FOCUS) UixModuleInstance.TEAM_FOCUS.documentReady($); //Team Focus

      if (UixModuleInstance.LAVA_LAMP_STYLE_MENU) UixModuleInstance.LAVA_LAMP_STYLE_MENU.documentReady($); //Lava-Lamp Style Menu

      if (UixModuleInstance.CIRCLE_LAYOUT) UixModuleInstance.CIRCLE_LAYOUT.documentReady($); //Circle Layout

      if (UixModuleInstance.MULTI_ITEMS_CAROUSEL) UixModuleInstance.MULTI_ITEMS_CAROUSEL.documentReady($); //Multiple Items Carousel

      if (UixModuleInstance.THREE_BACKGROUND) UixModuleInstance.THREE_BACKGROUND.documentReady($); //3D Background

      if (UixModuleInstance.THREE_CAROUSEL) UixModuleInstance.THREE_CAROUSEL.documentReady($); //3D Carousel

      if (UixModuleInstance.THREE_LIQUID_SCROLLSPY_SLIDER) UixModuleInstance.THREE_LIQUID_SCROLLSPY_SLIDER.documentReady($); //3D Liquid Scrollspy Slider
      //---- Prevent overlay clicks on asynchronous requests
      //---- Commonly used for AJAX modules that are clicked by button
      //Scroll Reveal

      if (settings.scrollReveal) {
        if (UixModuleInstance.SCROLL_REVEAL) UixModuleInstance.SCROLL_REVEAL.documentReady($);
      } //Posts List With Ajax


      if (settings.ajaxPostList) {
        if (UixModuleInstance.POST_LIST_AJAX) UixModuleInstance.POST_LIST_AJAX.documentReady($);
      } //Cascading DropDown List


      if (settings.ajaxDDList) {
        if (UixModuleInstance.CASCADING_DD_LIST) UixModuleInstance.CASCADING_DD_LIST.documentReady($);
      } //Counter


      if (settings.counterAnim) {
        if (UixModuleInstance.COUNTER) UixModuleInstance.COUNTER.documentReady($);
      } //Custom Lightbox


      if (settings.lightBox) {
        if (UixModuleInstance.LIGHTBOX) UixModuleInstance.LIGHTBOX.pageLoaded();
      } //----Uix Shortcodes (WordPress Plugin)


      if ($.isFunction($.uix_sc_init)) {
        $.uix_sc_init();
      }
    });
  };
})(jQuery);
;// CONCATENATED MODULE: ./src/components/_global/js/fn/UixApplyAsyncAllScripts.js
/*
 * Apply all the asynchronism scripts
 *
 * @global
 * @description This function can be used separately in HTML pages or custom JavaScript.
 * @param  {Boolean} runAll          - Run all module scripts.
 * @return {Void}
 *
 * @Usage:
    
<script>
( function( $ ) {
"use strict";
    $( document ).ready( function() {
		$( document ).UixApplyAsyncAllScripts();
    } );
} ) ( jQuery );
</script>
	

 *
 * 
 */


(function ($) {
  'use strict';

  $.fn.UixApplyAsyncAllScripts = function (options) {
    // This is the easiest way to have default options.
    var settings = $.extend({
      runAll: true
    }, options);
    this.each(function () {
      var scipts_pageLoaded = UixModuleInstance.components.pageLoaded,
          scipts_documentReady = UixModuleInstance.components.documentReady;

      if (settings.runAll) {
        for (var i = 0; i < scipts_pageLoaded.length; i++) {
          scipts_pageLoaded[i]();
        }

        for (var j = 0; j < scipts_documentReady.length; j++) {
          scipts_documentReady[j]($);
        }
      } //Uix Shortcodes


      if ($.isFunction($.uix_sc_init)) {
        $.uix_sc_init();
      }
    });
  };
})(jQuery);
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/createClass.js
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/classCallCheck.js
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
;// CONCATENATED MODULE: ./src/components/_global/js/modules/body-and-header.js



/* 
 *************************************
 * <!-- Body And Header -->
 *************************************
 */

var BODY_AND_HEADER = function (module, $, window, document) {
  if (window.BODY_AND_HEADER === null) return false;
  module.BODY_AND_HEADER = module.BODY_AND_HEADER || {};
  module.BODY_AND_HEADER.version = '0.0.8';

  module.BODY_AND_HEADER.documentReady = function ($) {
    //Prevent this module from loading in other pages
    if ($('body').hasClass('onepage')) return false;
    var windowWidth = window.innerWidth,
        windowHeight = window.innerHeight; //-------- Header initialize

    headerInit(windowWidth);

    function headerInit(w) {
      var $headerPlaceholder = $('.uix-header__placeholder.js-uix-header__placeholder-autoheight');

      if (w > 768) {
        $headerPlaceholder.css('height', $('.uix-header__container').outerHeight(true) + 'px');
        $('body').removeClass('is-mobile');
      } else {
        $headerPlaceholder.css('height', 0);
        $('body').addClass('is-mobile');
      }
    }

    function windowUpdate() {
      // Check window width has actually changed and it's not just iOS triggering a resize event on scroll
      if (window.innerWidth != windowWidth) {
        // Update the window width for next time
        windowWidth = window.innerWidth; // Do stuff here

        headerInit(windowWidth);
      }
    } // Add function to the window that should be resized


    var debounceFuncWindow = UixDebounce(windowUpdate, 50);
    window.removeEventListener('resize', debounceFuncWindow);
    window.addEventListener('resize', debounceFuncWindow); //-------- Sticky header area

    var $el = $('.uix-header__container, .uix-header__placeholder');

    function scrollUpdate() {
      var scrolled = $(window).scrollTop(),
          spyTop = 220;

      if (scrolled >= spyTop) {
        $el.addClass('is-fixed');
      } else {
        $el.removeClass('is-fixed');
      }
    } // Add function to the element that should be used as the scrollable area.


    var throttleFunc = UixThrottle(scrollUpdate, 5);
    window.removeEventListener('scroll', throttleFunc);
    window.removeEventListener('touchmove', throttleFunc);
    window.addEventListener('scroll', throttleFunc);
    window.addEventListener('touchmove', throttleFunc);
    throttleFunc();
  };

  module.components.documentReady.push(module.BODY_AND_HEADER.documentReady);
  return /*#__PURE__*/_createClass(function BODY_AND_HEADER() {
    _classCallCheck(this, BODY_AND_HEADER);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/_global/js/modules/common-height.js



/* 
 *************************************
 * <!-- Common Height -->
 
 *
 * Note: 
 *
 * Automatically sets the div height of the grid system to the height of the 
 * outer container when ".js-uix-common-height" class on ".row" or ".uix-core-grid__row" div.
 *
 *************************************
 */

var COMMON_HEIGHT = function (module, $, window, document) {
  if (window.COMMON_HEIGHT === null) return false;
  module.COMMON_HEIGHT = module.COMMON_HEIGHT || {};
  module.COMMON_HEIGHT.version = '0.0.4';

  module.COMMON_HEIGHT.pageLoaded = function () {
    var windowWidth = window.innerWidth,
        windowHeight = window.innerHeight;
    commonHeightInit(windowWidth);

    function windowUpdate() {
      // Check window width has actually changed and it's not just iOS triggering a resize event on scroll
      if (window.innerWidth != windowWidth) {
        // Update the window width for next time
        windowWidth = window.innerWidth; // Do stuff here

        commonHeightInit(windowWidth);
      }
    } // Add function to the window that should be resized


    var debounceFuncWindow = UixDebounce(windowUpdate, 50);
    window.removeEventListener('resize', debounceFuncWindow);
    window.addEventListener('resize', debounceFuncWindow);

    function commonHeightInit(w) {
      $('.js-uix-common-height').each(function () {
        var $this = $(this);
        var element = $this;
        var selectors = '[class*=col-], [class*=uix-core-grid__col-]'; //Bootstrap grid system and Custom uix grid system

        var maxHeight = 0; // Select and loop the elements you want to equalise

        element.children(selectors).each(function () {
          var element = $(this); //Solve the problem that the image cannot be read accurately

          element.find('img').each(function () {
            var imgOuter = $(this).parent('a').css('display');

            if (imgOuter == 'inline') {
              $(this).parent('a').css('display', 'inline-block');
            }
          });

          if (element.hasClass('max-height')) {
            // if has max-height
            maxHeight = element.outerHeight();
          } else {
            // if this box is higher than the cached highest then store it
            if (element.height() > maxHeight) {
              maxHeight = element.outerHeight();
            }
          }
        }); // Set the height of all those children to whichever was highest 

        if (w > 768) {
          element.children(selectors).each(function () {
            $(this).css('height', maxHeight);
          });
        } else {
          element.children(selectors).each(function () {
            $(this).css('height', 'auto');
          });
        }
      });
    }
  };

  module.components.pageLoaded.push(module.COMMON_HEIGHT.pageLoaded);
  return /*#__PURE__*/_createClass(function COMMON_HEIGHT() {
    _classCallCheck(this, COMMON_HEIGHT);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
// EXTERNAL MODULE: ./src/components/_third-party-plugins/Miscellaneous/attrExt.js
var attrExt = __webpack_require__(319);
;// CONCATENATED MODULE: ./src/components/_global/js/modules/custom-data-attrs.js



/* 
 *************************************
 * <!-- Get all custom attributes of an element like "data-*" -->
 *************************************
 */


var GET_CUSTOM_ATTRS = function (module, $, window, document) {
  if (window.GET_CUSTOM_ATTRS === null) return false;
  module.GET_CUSTOM_ATTRS = module.GET_CUSTOM_ATTRS || {};
  module.GET_CUSTOM_ATTRS.version = '0.0.1';

  module.GET_CUSTOM_ATTRS.documentReady = function ($) {
    $('[data-my-custom-datas]').each(function () {
      var $this = $(this); //Get all attributes of an element and push the new attributes like "data-*"

      var curAttrs = $this.attr(),
          customPostData = '';
      $.each(curAttrs, function (i, val) {
        if (i.indexOf('data-custom-field-') >= 0) {
          customPostData += '"' + i.replace('data-custom-field-', '') + '": ' + '"' + val + '", ';
        }
      });
      customPostData = customPostData.replace(/,\s*$/, '');
    });
  };

  module.components.documentReady.push(module.GET_CUSTOM_ATTRS.documentReady);
  return /*#__PURE__*/_createClass(function GET_CUSTOM_ATTRS() {
    _classCallCheck(this, GET_CUSTOM_ATTRS);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/_global/js/modules/loader.js




/* 
 *************************************
 * <!-- Loader -->
 *************************************
 */

var LOADER = function (module, $, window, document) {
  if (window.LOADER === null) return false;
  module.LOADER = module.LOADER || {};
  module.LOADER.version = '0.0.5';

  module.LOADER.documentReady = function ($) {
    // Disable devices scaling
    //-------------------------------------	
    document.addEventListener('touchstart', function (event) {
      if (event.touches.length > 1) {
        event.preventDefault();
      }
    });
    var lastTouchEnd = 0;
    document.addEventListener('touchend', function (event) {
      var now = new Date().getTime();

      if (now - lastTouchEnd <= 300) {
        event.preventDefault();
      }

      lastTouchEnd = now;
    }, false); // Loader Process
    //-------------------------------------	
    // Detect if video.load is successful or not 

    var videos = [];
    var videosTotal = 0;
    var videosLoaded = 0;
    $('.uix-video__slider > video').each(function () {
      videos.push($(this));
    });
    videosTotal = videos.length;
    console.log('videosTotal: ' + videosTotal + ', videosLoaded: ' + videosLoaded); // Loading progress event

    var loadedPercent = 0;
    var imgTotal = 0;

    var loadingAnim = function loadingAnim(per) {
      $('.uix-loader-progress > span').text($('.uix-loader-progress').data('txt').replace(/\{progress\}/g, per));
      TweenMax.to('.uix-loader-progress__line', 0.3, {
        width: per / 100.0 * window.innerWidth
      });
    };

    $('body').waitForImages().progress(function (loaded, count, success) {
      imgTotal = count;
      var per = parseInt(loaded / (count - (1 - videosTotal)) * 100); //

      if ($('img').length <= 1) {
        per = 100;
      } //


      if (isNaN(per)) per = 100; //

      loadedPercent = per; //animation classes for loader

      for (var i = 1; i < 10; i++) {
        if (per < i * 10) $('body').addClass('loaded' + i);
      } //loading animation


      loadingAnim(per);
    }).done(function () {
      //Event after loading is complete
      // Main scene
      console.log('loadedPercent: ' + loadedPercent + ', imageTotal: ' + imgTotal);
      mainObjLoader(loadedPercent, imgTotal);
    });
    /*
     * Main Object Loader
     *
     * @param  {Number} loadedPercent  - The percentage value after the page loads the image.
     * @param  {Number} imgTotal       - The total number of imags.
     * @return {Void}
     */

    function mainObjLoader(loadedPercent, imgTotal) {
      var remainedPercentComplete = 0;

      var loadedFun = function loadedFun() {
        //loading animation
        loadingAnim(100); //animation classes for loader

        $('body').addClass('loaded10'); // Remove loader

        TweenMax.to('.uix-loader, .uix-loader-progress, .uix-loader-progress__line', 0.5, {
          css: {
            opacity: 0,
            display: 'none'
          }
        }); //page animation when elements loaded
        //...
      }; //


      if (loadedPercent < 100) {
        videos.forEach(function (element) {
          var _src = element.find('source:first').attr('src');

          if ((0,esm_typeof/* default */.Z)(_src) === ( true ? "undefined" : 0)) _src = element.attr('src');
          var video = document.getElementById(element.attr('id')),
              videoURL = _src;
          video.addEventListener('loadedmetadata', function (e) {
            //Video has started loading successfully
            videosLoaded++; //get remained percent

            remainedPercentComplete = (1 - videosLoaded / videosTotal) * (100 - loadedPercent); //current percent

            var currentPercent = loadedPercent + (100 - loadedPercent - remainedPercentComplete); //loading animation

            loadingAnim(currentPercent); // All videos loaded

            if (currentPercent == 100) {
              loadedFun();
            } //debug


            console.log('remainedPercentComplete: ' + remainedPercentComplete + ', currentPercent: ' + currentPercent);
            console.log('videosTotal: ' + videosTotal + ', videosLoaded: ' + videosLoaded);
          }, false);
          video.src = videoURL;
        });
      } else {
        // All videos loaded
        if (remainedPercentComplete == 0) {
          loadedFun();
        }
      }
    }
  };

  module.components.documentReady.push(module.LOADER.documentReady);
  return /*#__PURE__*/_createClass(function LOADER() {
    _classCallCheck(this, LOADER);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/_global/js/modules/mega-menu.js



/* 
 *************************************
 * <!-- Mega Menu -->
 *************************************
 */

var MEGA_MENU = function (module, $, window, document) {
  if (window.MEGA_MENU === null) return false;
  module.MEGA_MENU = module.MEGA_MENU || {};
  module.MEGA_MENU.version = '0.0.5';

  module.MEGA_MENU.pageLoaded = function () {
    var windowWidth = window.innerWidth,
        windowHeight = window.innerHeight; // Using delay is for more accurate calculation

    setTimeout(function () {
      megaMenuInit(windowWidth);
    }, 500);

    function windowUpdate() {
      // Check window width has actually changed and it's not just iOS triggering a resize event on scroll
      if (window.innerWidth != windowWidth) {
        // Update the window width for next time
        windowWidth = window.innerWidth; // Do stuff here

        megaMenuInit(windowWidth);
      }
    } // Add function to the window that should be resized


    var debounceFuncWindow = UixDebounce(windowUpdate, 50);
    window.removeEventListener('resize', debounceFuncWindow);
    window.addEventListener('resize', debounceFuncWindow); // Initialize mega menu

    function megaMenuInit(w) {
      var $menuWrap = $('.uix-menu__container:not(.is-mobile)'),
          maxWidth = 1140,
          //The maximum width of the mega menu wrapper
      //This value is equal to the $nav-mega-li-w variable in the SCSS
      perDefaultW = 270; //Default width of each column
      //New XL container for Bootstrap 5.x

      if (w > 1430) maxWidth = 1278; //Full width container

      maxWidth = windowWidth - 15; // Remove the html tag for mega menu item

      $menuWrap.find('li.multi-column  > ul .multi-column-title').each(function () {
        var megaOldItem = $(this).html();

        if (megaOldItem != '') {
          $(this).html(megaOldItem.replace(/<[^>]+>/g, ''));
        }
      });

      if (w > 768) {
        $menuWrap.find('li.multi-column').each(function (index) {
          var $rootLi = $(this),
              colTotal = $rootLi.find('> ul > li').length,
              itemWidth = $rootLi.find('> ul > li').first().width(),
              $megaDiv = $rootLi.find('> ul.sub-menu');
          var megaPerWidth = null,
              rootLiLeft = null; // Get width or other style data of element when Not Visible (Display: None)

          var megaDivWidth = $megaDiv.width(); // Add mega arrow

          if ($rootLi.find('.uix-menu__arrow-mega').length < 1) $rootLi.prepend('<span class="uix-menu__arrow-mega"></span>'); // Detecting if the right or left of the div is touching the browser window edge.

          if (colTotal > 0) {
            rootLiLeft = UixCssProperty.getAbsoluteCoordinates($megaDiv[0]).left; //Determine the mega menu wrapper within document width, in order to limit the width of each column for mega menu

            if (maxWidth > w) maxWidth = w;

            if (megaDivWidth + 20 > maxWidth) {
              megaDivWidth = maxWidth;
              megaPerWidth = maxWidth / colTotal - 2.888; //Resetting the width of each column

              $megaDiv.find('> li').css({
                'width': megaPerWidth + 'px'
              }); //Resetting the width of each <li> tag

              $megaDiv.find('> li ul li').css({
                'width': megaPerWidth + 'px'
              });

              if (!$('body').hasClass('rtl')) {
                $megaDiv.css({
                  'margin-left': -rootLiLeft + (w - megaDivWidth) / 2 + 'px'
                });
              } else {
                $megaDiv.css({
                  'margin-right': -rootLiLeft + (w - megaDivWidth) / 2 + 'px'
                });
              }
            } else {
              //Resetting the width of each column
              $megaDiv.find('> li').css({
                'width': perDefaultW + 'px'
              }); //Resetting the width of each <li> tag

              $megaDiv.find('> li ul li').css({
                'width': perDefaultW + 'px'
              });
              var chkWidth = rootLiLeft + megaDivWidth;

              if (chkWidth > w) {
                if (!$('body').hasClass('rtl')) {
                  $megaDiv.css({
                    'margin-left': -(chkWidth - w) + 'px'
                  });
                } else {
                  $megaDiv.css({
                    'margin-right': -(chkWidth - w) + 'px'
                  });
                } //If the CSS sets the offset of ul::before
                //								const $megaDiv_offset = megaDivWidth/2 - 0;
                //								
                //								if ( ! $( 'body' ).hasClass( 'rtl' ) ) {
                //									$megaDiv.css( {
                //										'margin-left' : - ( chkWidth - w ) + $megaDiv_offset + 'px'
                //									} );
                //								} else {
                //									$megaDiv.css( {
                //										'margin-right' : - ( chkWidth - w ) + $megaDiv_offset + 'px'
                //									} );
                //								}	

              }
            }
          }
        });
      }
    }
  };

  module.components.pageLoaded.push(module.MEGA_MENU.pageLoaded);
  return /*#__PURE__*/_createClass(function MEGA_MENU() {
    _classCallCheck(this, MEGA_MENU);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/_global/js/modules/mobile-menu.js




/* 
 *************************************
 * <!-- Mobile Menu -->
 *************************************
 */

var MOBILE_MENU = function (module, $, window, document) {
  if (window.MOBILE_MENU === null) return false;
  module.MOBILE_MENU = module.MOBILE_MENU || {};
  module.MOBILE_MENU.version = '0.0.9';

  module.MOBILE_MENU.documentReady = function ($) {
    var windowWidth = window.innerWidth,
        windowHeight = window.innerHeight; //-------- Show Toolbar when viewing site for WordPress

    var $el = $('.admin-bar .uix-menu-mobile__toggle');

    function scrollUpdate() {
      var scrolled = $(window).scrollTop(),
          spyTop = 46;

      if (scrolled >= spyTop) {
        $el.addClass('is-fixed');
      } else {
        $el.removeClass('is-fixed');
      }
    } // Add function to the element that should be used as the scrollable area.


    var throttleFunc = UixThrottle(scrollUpdate, 5);
    window.removeEventListener('scroll', throttleFunc);
    window.removeEventListener('touchmove', throttleFunc);
    window.addEventListener('scroll', throttleFunc);
    window.addEventListener('touchmove', throttleFunc);
    throttleFunc(); //-------- Mobile Menu

    var $toggle = $('.uix-menu-mobile__toggle'),
        $toggleBody = $('body'); //-------- Add mobile menu to your website

    $('nav.uix-menu__container').clone().addClass('is-mobile').appendTo('body'); //Wait until previous .appendTo() is complete

    $.when($('.uix-menu__container.is-mobile').length > 0).then(function () {
      $toggle.on('touchstart click', function (e) {
        e.preventDefault(); //Prevents further propagation of the current event in the capturing and bubbling phases.

        e.stopPropagation();
        $(this).toggleClass('is-active');

        if ($(this).hasClass('is-active')) {
          //Add mobile brand
          var logoURL = $('.uix-brand--mobile img').attr('src');

          if ((0,esm_typeof/* default */.Z)(logoURL) !== ( true ? "undefined" : 0) && logoURL != '') {
            if (logoURL.indexOf('blank.gif') >= 0) $('.mobile-inner').css('margin-top', '-70px');
          } //Toggle effect


          $toggleBody.addClass('js-uix-menu-opened');
        } else {
          $toggleBody.removeClass('js-uix-menu-opened');
        }
      }); //Mobile menu mask event

      $('.uix-menu-mobile__mask').on('click', function () {
        $toggle.removeClass('is-active');
        $toggleBody.removeClass('js-uix-menu-opened');
      }); // Fires drop-menu event 

      var $drMenuLi = $('.uix-menu__container.is-mobile ul li');
      $drMenuLi.find('> a').on('click', function (e) {
        var arrowText = $(this).find('.uix-menu__arrow-mobile').text().replace(/(.).*\1/g, "$1"),
            $sub = $(this).next('ul');

        if ($sub.length > 0) {
          e.preventDefault(); //Its value is not a boolean but a string

          var expanded = $(this).attr('aria-expanded') == 'true' ? false : true;

          if (expanded) {
            //Hide other all sibling <ul> of the selected element
            var $e = $(this).parent('li').siblings().find('> a');
            $e.removeClass('is-opened').attr('aria-expanded', false);
            $e.parent('li').find('.uix-menu__arrow-mobile').removeClass('is-opened');
            $e.parent('li').removeClass('is-opened');
            $(this).addClass('is-opened').attr('aria-expanded', true);
            $(this).parent('li').find('.uix-menu__arrow-mobile').addClass('is-opened');
            $(this).parent('li').addClass('is-opened');
            TweenMax.to($e.next('ul'), 0.5, {
              height: 0
            }); //to open
            // - temporarilty set height:auto
            // - tween from height:0

            TweenMax.set($sub, {
              height: 'auto'
            });
            TweenMax.from($sub, 0.5, {
              height: 0
            });
          } else {
            $(this).removeClass('is-opened').attr('aria-expanded', false);
            $(this).parent('li').find('.uix-menu__arrow-mobile').removeClass('is-opened');
            $(this).parent('li').removeClass('is-opened'); //to close

            TweenMax.to($sub, 0.5, {
              height: 0
            });
          }

          return false;
        }
      });
      mobileMenuInit(windowWidth);

      function windowUpdate() {
        // Check window width has actually changed and it's not just iOS triggering a resize event on scroll
        if (window.innerWidth != windowWidth) {
          // Update the window width for next time
          windowWidth = window.innerWidth; // Do stuff here

          $toggleBody.removeClass('js-uix-menu-opened');
          $toggle.removeClass('is-active');
          mobileMenuInit(windowWidth);
        }
      } // Add function to the window that should be resized


      var debounceFuncWindow = UixDebounce(windowUpdate, 50);
      window.removeEventListener('resize', debounceFuncWindow);
      window.addEventListener('resize', debounceFuncWindow);
    });
    /*
     * Initialize mobile menu
     *
     * @param  {Number} w                  - Returns width of browser viewport.
     * @return {Void}
     */

    function mobileMenuInit(w) {
      if (w <= 768) {
        $('.uix-menu__container.is-mobile .uix-menu > li').each(function () {
          if ($(this).find('ul').length > 0) {
            if ($(this).find('.uix-menu__arrow-mobile').length < 1) $(this).prepend('<em class="uix-menu__arrow-mobile"></em>');
            $(this).find('ul ul').addClass('sub-sub');
            $(this).find(' > a').attr('href', 'javascript:void(0);');
          }
        });
      }
    }
  };

  module.components.documentReady.push(module.MOBILE_MENU.documentReady);
  return /*#__PURE__*/_createClass(function MOBILE_MENU() {
    _classCallCheck(this, MOBILE_MENU);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/_global/js/modules/navigation.js




/* 
 *************************************
 * <!-- Navigation -->
 *************************************
 */

var NAVIGATION = function (module, $, window, document) {
  if (window.NAVIGATION === null) return false;
  module.NAVIGATION = module.NAVIGATION || {};
  module.NAVIGATION.version = '0.1.0';

  module.NAVIGATION.documentReady = function ($) {
    var ulForDesktop = '.uix-menu__container:not(.is-mobile) ul.uix-menu'; //-------- Menu selected (if it exists "data-current" property in <ul>)

    var curMenuIndex = $(ulForDesktop).data('current');

    if ((0,esm_typeof/* default */.Z)(curMenuIndex) !== ( true ? "undefined" : 0)) {
      $(ulForDesktop + ' > li:eq(' + curMenuIndex + ')').addClass('is-active');
    } //-------- Menu Hover


    var mTop = 15;
    $(ulForDesktop + ' > li.multi-column > ul li ul').addClass('multi');
    $(ulForDesktop + ' > li:not(.multi-column) ul, .uix-menu__container:not(.is-mobile) li.multi-column > ul.sub-menu > li > ul, ' + ulForDesktop + ' li.multi-column > ul').css('margin-top', mTop + 'px');
    $(ulForDesktop + ' li').on('mouseenter', function () {
      TweenMax.set($(this).find(' > ul.sub-menu:not(.multi), .uix-menu__arrow-mega'), {
        css: {
          opacity: 0,
          display: 'block',
          marginTop: mTop + 'px'
        },
        onComplete: function onComplete() {
          TweenMax.to(this.target, 0.3, {
            css: {
              opacity: 1,
              marginTop: 0
            },
            ease: Power2.easeOut
          });
        }
      });
    }).on('mouseleave', function () {
      TweenMax.to($(this).find(' > ul.sub-menu:not(.multi), .uix-menu__arrow-mega'), 0.3, {
        css: {
          opacity: 0,
          marginTop: mTop + 'px'
        },
        onComplete: function onComplete() {
          TweenMax.set(this.target, {
            css: {
              display: 'none'
            }
          });
        }
      });
    }); //-------- Add Sub-menu Arrow

    $(ulForDesktop + ' li').each(function () {
      if ($(this).find('ul').length > 0) {
        $(this).prepend('<span class="uix-menu__arrow"></span>');
      }
    }); //-------- Sticky primary navigation

    var $el = $('.uix-menu__container:not(.is-mobile)');

    function scrollUpdate() {
      var scrolled = $(window).scrollTop(),
          spyTop = 220;

      if (scrolled >= spyTop) {
        $el.addClass('is-fixed');
      } else {
        $el.removeClass('is-fixed');
      }
    } // Add function to the element that should be used as the scrollable area.


    var throttleFunc = UixThrottle(scrollUpdate, 5);
    window.removeEventListener('scroll', throttleFunc);
    window.removeEventListener('touchmove', throttleFunc);
    window.addEventListener('scroll', throttleFunc);
    window.addEventListener('touchmove', throttleFunc);
    throttleFunc();
  };

  module.components.documentReady.push(module.NAVIGATION.documentReady);
  return /*#__PURE__*/_createClass(function NAVIGATION() {
    _classCallCheck(this, NAVIGATION);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/_global/js/fn/UixParallax.js
/* 
 *************************************
 * Parallax Effect
 *
 * @param  {Number} speed       - The speed of movement between elements.
 * @param  {String} transition  - Transition time can simulate easing effect.
 * @param  {Object} bg            - Specify the background display. Default value: { enable: true, xPos: '50%' }
 * @return {Void}
 *
 *************************************
 */


(function ($) {
  'use strict';

  $.fn.UixParallax = function (options) {
    // This is the easiest way to have default options.
    var settings = $.extend({
      speed: 0.25,
      offsetTop: 0,
      transition: 'all 0.4s cubic-bezier(0, 0, 0.34, 0.96) 0s',
      bg: {
        enable: true,
        xPos: '50%'
      }
    }, options);
    this.each(function () {
      var bgEff = settings.bg,
          $this = $(this),
          bgXpos = '50%',
          offsetTop = parseFloat(settings.offsetTop),
          speed = -parseFloat(settings.speed);

      if (bgEff) {
        bgEff = settings.bg.enable;
        bgXpos = settings.bg.xPos;
      } //Prohibit transition delay


      $this.css({
        'transition': 'none'
      }); //Initialize the position of the background

      if (bgEff) {
        //background parallax
        TweenMax.set($this, {
          backgroundPosition: bgXpos + ' ' + (-$this[0].getBoundingClientRect().top * speed + -offsetTop) + 'px'
        });
      } else {
        //element parallax
        TweenMax.set($this, {
          y: 0
        });
      }

      function scrollUpdate() {
        var spyTop = $this[0].getBoundingClientRect().top;

        if (bgEff) {
          //background parallax
          TweenMax.set($this, {
            css: {
              'background-position': bgXpos + ' ' + (0 - (spyTop * speed + offsetTop)) + 'px',
              'transition': settings.transition
            }
          });
        } else {
          //element parallax
          TweenMax.set($this, {
            css: {
              'transform': 'matrix(1, 0, 0, 1, 0, ' + (0 - (spyTop * speed + offsetTop)) + ')',
              'transition': settings.transition
            }
          });
        }
      } // Add function to the element that should be used as the scrollable area.


      var throttleFunc = UixThrottle(scrollUpdate, 5);
      window.removeEventListener('scroll', throttleFunc);
      window.removeEventListener('touchmove', throttleFunc);
      window.addEventListener('scroll', throttleFunc);
      window.addEventListener('touchmove', throttleFunc); // Prevent calculation errors caused by unloaded completion

      if (document.readyState != 'loading') {
        throttleFunc();
      } else if (document.addEventListener) {
        document.addEventListener('DOMContentLoaded', throttleFunc);
      } else {
        document.attachEvent('onreadystatechange', function () {
          if (document.readyState != 'loading') throttleFunc();
        });
      }
    });
  };
})(jQuery);
;// CONCATENATED MODULE: ./src/components/_global/js/modules/set-background.js




/* 
 *************************************
 * <!-- Specify a background image -->
 *************************************
 */


var SET_BG = function (module, $, window, document) {
  if (window.SET_BG === null) return false;
  module.SET_BG = module.SET_BG || {};
  module.SET_BG.version = '0.0.8';

  module.SET_BG.documentReady = function ($) {
    var windowWidth = window.innerWidth,
        windowHeight = window.innerHeight; //  Initialize

    setBGInit();

    function windowUpdate() {
      // Check window width has actually changed and it's not just iOS triggering a resize event on scroll
      if (window.innerWidth != windowWidth) {
        // Update the window width for next time
        windowWidth = window.innerWidth; // Do stuff here

        setBGInit();
      }
    } // Add function to the window that should be resized


    var debounceFuncWindow = UixDebounce(windowUpdate, 50);
    window.removeEventListener('resize', debounceFuncWindow);
    window.addEventListener('resize', debounceFuncWindow);
    /*
     * Initialize background using "data-bg" attribute.
     *
     * @return {Void}
     */

    function setBGInit() {
      $('[data-bg]').each(function () {
        var $this = $(this);
        var config = $this.data('bg');

        if ((0,esm_typeof/* default */.Z)(config) === ( true ? "undefined" : 0)) {
          config = {
            "src": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
            "position": "top left",
            "size": "cover",
            "repeat": "no-repeat",
            "offsetTop": 0,
            "fill": false,
            "parallax": 0,
            "transition": "none 0s ease 0s",
            "move": false // {"dir":"left","duration":"10s","easing":"linear","loop":true}

          };
        }

        if (config) {
          var dataImg = config.src,
              dataPos = config.position,
              dataSize = config.size,
              dataRepeat = config.repeat,
              dataEasing = config.transition,
              dataOffsetTop = config.offsetTop,
              dataParallax = config.parallax,
              dataMove = config.move;
          if ((0,esm_typeof/* default */.Z)(dataPos) === ( true ? "undefined" : 0)) dataPos = 'top left';
          if ((0,esm_typeof/* default */.Z)(dataSize) === ( true ? "undefined" : 0)) dataSize = 'cover';
          if ((0,esm_typeof/* default */.Z)(dataRepeat) === ( true ? "undefined" : 0)) dataRepeat = 'no-repeat';
          if ((0,esm_typeof/* default */.Z)(dataOffsetTop) === ( true ? "undefined" : 0)) dataOffsetTop = 0;
          if ((0,esm_typeof/* default */.Z)(dataEasing) === ( true ? "undefined" : 0)) dataEasing = 'none 0s ease 0s';
          if ((0,esm_typeof/* default */.Z)(dataMove) === ( true ? "undefined" : 0)) dataMove = false; //Using parallax

          if (dataParallax && (0,esm_typeof/* default */.Z)(dataParallax) != ( true ? "undefined" : 0) && dataParallax != 0) {
            dataPos = dataPos.replace('top', '50%');
          } //background animation


          var moveAnim = 'none',
              moveAnimLoop = 'infinite',
              moveEasing = 'linear',
              moveKeyframesTop = '@keyframes js-uix-cssanim--move-t{from{background-position:0 0;}to{background-position:0 -19999px;}',
              moveKeyframesBottom = '@keyframes js-uix-cssanim--move-b{from{background-position:0 0;}to{background-position:0 19999px;}',
              moveKeyframesLeft = '@keyframes js-uix-cssanim--move-l{from{background-position:0 0;}to{background-position:-19999px 0;}',
              moveKeyframesRight = '@keyframes js-uix-cssanim--move-r{from{background-position:0 0;}to{background-position:19999px 0;}';

          if (dataMove && Object.prototype.toString.call(dataMove) == '[object Object]') {
            if (!dataMove.loop) moveAnimLoop = '1 forwards';
            dataPos = '0 0';

            switch (dataMove.dir) {
              case 'top':
                moveAnim = 'js-uix-cssanim--move-t ' + parseInt(dataMove.speed) + 's ' + moveEasing + ' ' + moveAnimLoop;
                break;

              case 'bottom':
                moveAnim = 'js-uix-cssanim--move-b ' + parseInt(dataMove.speed) + 's ' + moveEasing + ' ' + moveAnimLoop;
                break;

              case 'left':
                moveAnim = 'js-uix-cssanim--move-l ' + parseInt(dataMove.speed) + 's ' + moveEasing + ' ' + moveAnimLoop;
                break;

              case 'right':
                moveAnim = 'js-uix-cssanim--move-r ' + parseInt(dataMove.speed) + 's ' + moveEasing + ' ' + moveAnimLoop;
                break;
            } //  CSS3 animation keyframe attributes inline


            if ($('#js-uix-cssanim--move-t').length == 0) {
              $('<style id="js-uix-cssanim--move-t">').text(moveKeyframesTop).appendTo('head');
            }

            if ($('#js-uix-cssanim--move-b').length == 0) {
              $('<style id="js-uix-cssanim--move-b">').text(moveKeyframesBottom).appendTo('head');
            }

            if ($('#js-uix-cssanim--move-l').length == 0) {
              $('<style id="js-uix-cssanim--move-l">').text(moveKeyframesLeft).appendTo('head');
            }

            if ($('#js-uix-cssanim--move-r').length == 0) {
              $('<style id="js-uix-cssanim--move-r">').text(moveKeyframesRight).appendTo('head');
            }
          } //-----


          if ((0,esm_typeof/* default */.Z)(dataImg) != ( true ? "undefined" : 0) && dataImg != '') {
            if (config.fill) {
              //Show Image Under Text
              if (Modernizr.cssanimations) {
                $this.css({
                  'background': 'url(' + dataImg + ') ' + dataRepeat + '',
                  'background-size': dataSize,
                  '-webkit-background-clip': 'text',
                  '-webkit-text-fill-color': 'transparent',
                  'animation': moveAnim
                });
              }
            } else {
              $this.css({
                'background-image': 'url(' + dataImg + ')',
                'background-position': dataPos,
                'background-size': dataSize,
                'background-repeat': dataRepeat,
                'animation': moveAnim
              });
            } //Using parallax


            if (dataParallax && (0,esm_typeof/* default */.Z)(dataParallax) != ( true ? "undefined" : 0) && dataParallax != 0) {
              $this.UixParallax({
                'speed': dataParallax,
                'transition': dataEasing,
                'offsetTop': dataOffsetTop,
                'bg': {
                  enable: true,
                  xPos: '50%'
                }
              });
            }
          }
        }
      });
    }
  };

  module.components.documentReady.push(module.SET_BG.documentReady);
  return /*#__PURE__*/_createClass(function SET_BG() {
    _classCallCheck(this, SET_BG);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/_global/js/modules/videos.js




/* 
 *************************************
 * <!-- Videos -->
 *************************************
 */

var VIDEOS = function (module, $, window, document) {
  if (window.VIDEOS === null) return false;
  module.VIDEOS = module.VIDEOS || {};
  module.VIDEOS.version = '0.1.3';

  module.VIDEOS.documentReady = function ($) {
    var windowWidth = window.innerWidth,
        windowHeight = window.innerHeight;
    /* 
     ---------------------------
     Video Embed
     ---------------------------
     */

    $('.uix-video').each(function () {
      var $this = $(this);
      var curVideoID = $this.find('video').attr('id'),
          coverPlayBtnID = 'videocover-' + curVideoID,
          videoWrapperW = $this.closest('[data-embed-video-wrapper]').width();
      var dataAuto = $this.data('embed-video-autoplay'),
          dataLoop = $this.data('embed-video-loop'),
          dataControls = $this.data('embed-video-controls'),
          dataW = $this.data('embed-video-width'),
          dataH = $this.data('embed-video-height'); //Push a new ID to video
      //Solve the problem that ajax asynchronous loading does not play

      $this.find('.video-js').attr('id', curVideoID);

      if ((0,esm_typeof/* default */.Z)(dataAuto) === ( true ? "undefined" : 0)) {
        dataAuto = true;
      }

      if ((0,esm_typeof/* default */.Z)(dataLoop) === ( true ? "undefined" : 0)) {
        dataLoop = true;
      }

      if ((0,esm_typeof/* default */.Z)(dataControls) === ( true ? "undefined" : 0)) {
        dataControls = false;
      }

      if ((0,esm_typeof/* default */.Z)(dataW) === ( true ? "undefined" : 0) || dataW == 'auto') {
        dataW = videoWrapperW;
      }

      if ((0,esm_typeof/* default */.Z)(dataH) === ( true ? "undefined" : 0) || dataH == 'auto') {
        dataH = videoWrapperW / 1.77777777777778;
      } //Display cover and play buttons when some mobile device browsers cannot automatically play video


      if ($('#' + coverPlayBtnID).length == 0) {
        $('<div id="' + coverPlayBtnID + '" class="uix-video__cover"><span class="uix-video__cover__placeholder" style="background-image:url(' + $this.find('video').attr('poster') + ')"></span><span class="uix-video__cover__playbtn"></span></div>').insertBefore($this);
        var btnEv = Modernizr.touchevents ? 'touchstart' : 'click';
        $('#' + coverPlayBtnID + ' .uix-video__cover__playbtn').on(btnEv, function (e) {
          e.preventDefault();
          myPlayer.play();
          $('#' + coverPlayBtnID).hide();
        }); //Prevent some devices from automatically playing video and trigger with buttons

        if (!dataAuto || UixBrowser.isAndroid) {
          $('#' + coverPlayBtnID + ' .uix-video__cover__playbtn').show();
        }
      }
      /* ---------  HTML5 video autoplay on mobile revisited  */


      if (windowWidth <= 768) {
        $this.find('.video-js').attr({
          'playsinline': 'true'
        });
      }

      var myPlayer = videojs(curVideoID, {
        width: dataW,
        height: dataH,
        loop: dataLoop,
        autoplay: dataAuto
      }, function onPlayerReady() {
        var initVideo = function initVideo(obj) {
          //Get Video Dimensions
          var curW = obj.videoWidth(),
              curH = obj.videoHeight(),
              newW = curW,
              newH = curH;
          newW = videoWrapperW; //Scaled/Proportional Content 

          newH = curH * (newW / curW);

          if (!isNaN(newW) && !isNaN(newH)) {
            obj.height(newH);
            obj.width(newW);
          } //Show this video wrapper


          $this.css('visibility', 'visible'); //Hide loading effect

          $this.find('.vjs-loading-spinner, .vjs-big-play-button').hide();
        };

        initVideo(this);
        /* ---------  Video initialize */

        this.on('loadedmetadata', function () {
          initVideo(this);
        });
        /* ---------  Set, tell the player it's in fullscreen  */

        if (dataAuto) {
          this.muted(true); //Fix an error of Video auto play is not working in browser

          this.play();
        }
        /* ---------  Disable control bar play button click */


        if (!dataControls) {
          this.controls(false);
        }
        /* ---------  Determine if the video is auto played from mobile devices  */


        var autoPlayOK = false;
        this.on('timeupdate', function () {
          var duration = this.duration();

          if (duration > 0) {
            autoPlayOK = true;

            if (this.currentTime() > 0) {
              autoPlayOK = true;
              this.off('timeupdate'); //Hide cover and play buttons when the video automatically played

              $('#' + coverPlayBtnID).hide();
            }
          }
        });
      });
    });
    /* 
     ---------------------------
     Video Popup Interaction
     ---------------------------
     */

    var modalDialogTrigger = '[data-video-win]'; //Add video container

    $(modalDialogTrigger).each(function () {
      var $this = $(this);
      var videoSrcIfm = '',
          videoSrcMp4 = $this.data('video-mp4'),
          videoSrcWebm = $this.data('video-webm'),
          videoSrcOgv = $this.data('video-ogv'),
          videoPoster = $this.data('video-poster'),
          videoContainerMid = $this.data('modal-id'),
          videoContainerVid = videoContainerMid + '--videopush';

      if ((0,esm_typeof/* default */.Z)(videoSrcMp4) === ( true ? "undefined" : 0)) {
        videoSrcMp4 = '';
      }

      if ((0,esm_typeof/* default */.Z)(videoSrcWebm) === ( true ? "undefined" : 0)) {
        videoSrcWebm = '';
      }

      if ((0,esm_typeof/* default */.Z)(videoSrcOgv) === ( true ? "undefined" : 0)) {
        videoSrcOgv = '';
      }

      if ($this.find('[data-video-iframe]').length > 0) {
        videoSrcIfm = $this.find('[data-video-iframe]').html();
      } //Add modal dialog


      if ($('#' + videoContainerMid).length == 0) {
        var v = '',
            vmp4 = '',
            vwebm = '',
            vogv = '';

        if (videoSrcMp4 != '') {
          vmp4 = '<source src="' + videoSrcMp4 + '" type="video/mp4">';
        }

        if (videoSrcWebm != '') {
          vwebm = '<source src="' + videoSrcWebm + '" type="video/webm">';
        }

        if (videoSrcOgv != '') {
          vogv = '<source src="' + videoSrcOgv + '" type="video/ogv">';
        }

        v += '<div class="uix-modal-box is-fullscreen is-video" role="dialog" tabindex="-1" aria-hidden="true" id="' + videoContainerMid + '">';
        v += '<button type="button" class="uix-modal-box__close" data-modal-close-trigger="true"></button>';
        v += '<div class="uix-modal-box__content" role="document">';
        v += '<div class="uix-modal-box__video-waiting"></div><div class="uix-modal-box__video-container" data-video-player-init="0">';

        if ($this.find('[data-video-iframe]').length > 0 && videoSrcIfm != '') {
          //If iframe
          v += '<div id="' + videoContainerVid + '" class="ratio ratio-16x9">';
          v += videoSrcIfm;
          v += '</div>';
        } else {
          //If local video
          v += '<video id="' + videoContainerVid + '" class="video-js vjs-default-skin" controls poster="' + videoPoster + '">';
          v += vmp4 + vwebm + vogv;
          v += '</video>';
        }

        v += '</div>';
        v += '</div>';
        v += '</div>'; //Wait until previous .append() is complete

        $(v).appendTo('body');
      }
    }); //Check out: http://docs.videojs.com/tutorial-player-workflows.html

    $(document).off('click.VIDEOS').on('click.VIDEOS', modalDialogTrigger, function () {
      var vid = $(this).data('modal-id') + '--videopush',
          newMaxW = windowWidth - 80,
          newMaxH = windowHeight - 80,
          $vContainer = $('#' + vid).closest('.uix-modal-box__video-container'),
          $vLoader = $vContainer.prev('.uix-modal-box__video-waiting'),
          myPlayerInit = $vContainer.data('video-player-init');
      var $ifm = false; //----- Hidden/Display the wrapper of video

      var displayVC = function displayVC() {
        TweenMax.set($vContainer, {
          alpha: 1
        });
        $vLoader.removeClass('is-active');
      };

      var hiddenVC = function hiddenVC() {
        TweenMax.set($vContainer, {
          alpha: 0
        });
        $vLoader.addClass('is-active');
      }; //----- Embed iframe


      if ($('#' + vid).find('iframe').length > 0) {
        $ifm = $('#' + vid).find('iframe');
      } else {
        hiddenVC();
      }

      if ($ifm && (0,esm_typeof/* default */.Z)($ifm) === 'object') {
        if ($ifm.length > 0) {
          var curW = $ifm.width(),
              curH = $ifm.height(),
              newW = curW,
              newH = curH;

          if (curH > newMaxH) {
            newH = newMaxH; //Scaled/Proportional Content 

            newW = curW * (newH / curH);
          }

          if (newW > newMaxW) {
            newW = newMaxW; //Scaled/Proportional Content 

            newH = curH * (newW / curW);
          }

          $ifm.css({
            'left': (newMaxW - newW) / 2 + 'px',
            'top': (newMaxH - newH) / 2 + 'px',
            'height': newH + 'px',
            'width': newW + 'px'
          });

          if (windowWidth <= 768) {
            $ifm.css({
              'top': 0
            }).parent('.ratio').css({
              'top': (newMaxH - newH) / 2 + 'px'
            });
          }
        }

        return false;
      } //----- HTML5 video autoplay on mobile revisited


      if (windowWidth <= 768) {
        $('#' + vid).attr({
          'playsinline': 'true'
        });
      } //----- Embed local video


      var myPlayer = videojs(vid, {
        width: 1,
        height: 1,
        autoplay: true,
        loop: true
      }, function onPlayerReady() {
        var initVideo = function initVideo(obj) {
          //Get Video Dimensions
          var curW = obj.videoWidth(),
              curH = obj.videoHeight(),
              newW = curW,
              newH = curH; //Resise modal

          if (curH > newMaxH) {
            newH = newMaxH; //Scaled/Proportional Content 

            newW = curW * (newH / curH);
          }

          if (newW > newMaxW) {
            newW = newMaxW; //Scaled/Proportional Content 

            newH = curH * (newW / curW);
          }

          obj.height(newH);
          obj.width(newW); //In order to allow CSS to support video centering

          $vContainer.find(' > div.video-js').css({
            'width': newW + 'px'
          }); //Vertically center the video area

          var mt = parseFloat(windowHeight - newH) / 2 - 50;
          $vContainer.css({
            'transform': 'translateY(' + mt + 'px)'
          }); //Display the wrapper of video

          displayVC();
        };

        initVideo(this);
        /* ---------  Video Modal initialize */

        this.on('loadedmetadata', function () {
          initVideo(this); //If a player instance has already been created for this variable.

          $vContainer.data('video-player-init', 1);
        });
        /* ---------  Set, tell the player it's in fullscreen  */
        //this.exitFullscreen();
        //this.requestFullscreen();

        this.play();
        /* ---------  Disable control bar play button click */
        //this.controls( false );

        /* ---------  Display video playback progress  */

        this.on('timeupdate', function () {
          var duration = this.duration(),
              progressAmount = '0%';

          if (duration > 0) {
            progressAmount = this.currentTime() / duration * 100 + "%";
          } //console.log( progressAmount );

        });
        /* ---------  Callback for when a video has ended */

        this.on('ended', function () {//console.log( 'video is done!' );
        });
      });
      /* ---------  Display the wrapper of video  */

      if (myPlayerInit === 1) {
        displayVC();
      }
      /* ---------  Close the modal  */


      $(document).off('click.VIDEOS_CLOSE').on('click.VIDEOS_CLOSE', '.uix-modal-box [data-modal-close-trigger], .uix-modal-mask:not(.js-uix-disabled)', function () {
        myPlayer.ready(function () {
          this.pause();
        });
      });
    });
  };

  module.components.documentReady.push(module.VIDEOS.documentReady);
  return /*#__PURE__*/_createClass(function VIDEOS() {
    _classCallCheck(this, VIDEOS);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/_main/js/index.js



/* 
 *************************************
 * <!-- Theme Scripts  -->
 *************************************
 */


var MAIN = function (module, $, window, document) {
  if (window.MAIN === null) return false;
  module.MAIN = module.MAIN || {};
  module.MAIN.version = '0.0.1';

  module.MAIN.documentReady = function ($) {
    /* 
     ---------------------------
     Function Here
     ---------------------------
     */
    //your code here...
  };

  module.MAIN.pageLoaded = function () {
    /* 
     ---------------------------
     Function Here
     ---------------------------
     */
    //your code here...
  };

  module.components.documentReady.push(module.MAIN.documentReady);
  module.components.pageLoaded.push(module.MAIN.pageLoaded);
  return /*#__PURE__*/_createClass(function MAIN() {
    _classCallCheck(this, MAIN);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/accordion-img/js/index.js




/* 
 *************************************
 * <!-- Accordion Background Images -->
 *************************************
 */


var ACCORDION_BG = function (module, $, window, document) {
  if (window.ACCORDION_BG === null) return false;
  module.ACCORDION_BG = module.ACCORDION_BG || {};
  module.ACCORDION_BG.version = '0.0.7';

  module.ACCORDION_BG.documentReady = function ($) {
    var windowWidth = window.innerWidth,
        windowHeight = window.innerHeight;
    if (windowWidth <= 768) return false;
    $('.uix-accordion-img').each(function () {
      var $this = $(this);
      var aEvent = $this.data('event'),
          outReset = $this.data('out-reset'),
          activeIndex = $this.data('actived-item'),
          offsetVal = $this.data('offset'),
          dir = $this.data('direction'),
          closeBtn = $this.data('close-btn'),
          $li = $this.find('> ul').children('li'),
          total = $li.length;

      if ((0,esm_typeof/* default */.Z)(activeIndex) === ( true ? "undefined" : 0)) {
        activeIndex = false;
      }

      if ((0,esm_typeof/* default */.Z)(aEvent) === ( true ? "undefined" : 0)) {
        aEvent = 'click';
      }

      if ((0,esm_typeof/* default */.Z)(outReset) === ( true ? "undefined" : 0)) {
        outReset = true;
      }

      if ((0,esm_typeof/* default */.Z)(offsetVal) === ( true ? "undefined" : 0)) {
        offsetVal = '60%';
      } //Initialize the width or height of each item


      itemInit();
      $li.on(aEvent, function (e) {
        //Prevents further propagation of the current event in the capturing and bubbling phases.
        e.stopPropagation(); //Apply click method to outer div but not inner div

        if (e.target.className == 'uix-accordion-img__content__info' || e.target.className == 'uix-accordion-img__content') {
          if ($(this).hasClass('is-active')) {
            $(this).addClass('is-active');
          } else {
            $li.addClass('active-sub');
            $(this).addClass('is-active');
            $(this).siblings().removeClass('is-active');

            if (dir == 'verticle') {
              $li.css('height', (100 - parseFloat(offsetVal)) / (total - 1) + '%');
              $(this).css('height', offsetVal);
            } else {
              $li.css('width', (100 - parseFloat(offsetVal)) / (total - 1) + '%');
              $(this).css('width', offsetVal);
            }
          }
        }
      });

      if (outReset) {
        $this.on('mouseleave', function (e) {
          itemInit();
        });
      }

      if ((0,esm_typeof/* default */.Z)(closeBtn) != ( true ? "undefined" : 0) && closeBtn != false && closeBtn != '') {
        $(closeBtn).off('click').on('click', function (e) {
          e.preventDefault();
          itemInit();
        });
      }
      /*
       * Active the target item
       *
          * @param  {Number} index     - The index value of the item to be activated.
       * @return {Void}
       */


      function itemActiveItem(index) {
        if (index >= 0) {
          if (dir == 'verticle') {
            $li.css('height', (100 - parseFloat(offsetVal)) / (total - 1) + '%');
            $li.eq(index).css('height', offsetVal).addClass('is-active');
          } else {
            $li.css('width', (100 - parseFloat(offsetVal)) / (total - 1) + '%');
            $li.eq(index).css('width', offsetVal).addClass('is-active');
          }
        }
      }

      itemActiveItem(parseFloat(activeIndex));
      /*
       * Initialize the width or height of each item
       *
       * @return {Void}
       */

      function itemInit() {
        if (dir == 'verticle') {
          $li.removeClass('is-active active-sub').css('height', 100 / total + '%');
        } else {
          $li.removeClass('is-active active-sub').css('width', 100 / total + '%');
        }
      }
    });
  };

  module.components.documentReady.push(module.ACCORDION_BG.documentReady);
  return /*#__PURE__*/_createClass(function ACCORDION_BG() {
    _classCallCheck(this, ACCORDION_BG);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/accordion/js/index.js




/* 
 *************************************
 * <!-- Accordion -->
 *************************************
 */


var ACCORDION = function (module, $, window, document) {
  if (window.ACCORDION === null) return false;
  module.ACCORDION = module.ACCORDION || {};
  module.ACCORDION.version = '0.0.3';

  module.ACCORDION.documentReady = function ($) {
    $('.uix-accordion').each(function () {
      var $this = $(this);
      var $li = $this.children('dl'),
          $titlebox = $this.find('dt');
      var aEvent = $this.data('event'),
          firstShow = $this.data('first-show');

      var openItem = function openItem(obj) {
        //to open
        // - temporarilty set height:auto
        // - tween from height:0
        TweenMax.set(obj, {
          height: 'auto'
        });
        TweenMax.from(obj, 0.5, {
          height: 0
        });
      };

      if ((0,esm_typeof/* default */.Z)(aEvent) === ( true ? "undefined" : 0)) {
        aEvent = 'click';
      }

      if ((0,esm_typeof/* default */.Z)(firstShow) === ( true ? "undefined" : 0)) {
        firstShow = false;
      }

      if (firstShow) {
        $li.first().addClass('is-active').attr('aria-expanded', true);
        openItem($li.first().find('dd'));
      }

      $li.off(aEvent).on(aEvent, function (e) {
        //Prevents further propagation of the current event in the capturing and bubbling phases.
        e.stopPropagation(); //Its value is not a boolean but a string

        var expanded = $(this).attr('aria-expanded') == 'true' ? false : true,
            $content = $(this).find('dd');

        if (expanded) {
          //Hide other all sibling <dt> of the selected element
          var $e = $(this).siblings();
          $e.removeClass('is-active').attr('aria-expanded', false);
          $(this).addClass('is-active').attr('aria-expanded', true);
          TweenMax.to($e.find('dd'), 0.5, {
            height: 0
          }); //to open

          openItem($content);
        } else {
          if (e.type == 'click') {
            $(this).removeClass('is-active').attr('aria-expanded', false); //to close

            TweenMax.to($content, 0.5, {
              height: 0
            });
          }
        }
      });
    });
  };

  module.components.documentReady.push(module.ACCORDION.documentReady);
  return /*#__PURE__*/_createClass(function ACCORDION() {
    _classCallCheck(this, ACCORDION);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/advanced-slider/js/basic.js




/* 
 *************************************
 * <!-- Advanced Slider (Basic) -->
 *************************************
 */


var ADVANCED_SLIDER = function (module, $, window, document) {
  if (window.ADVANCED_SLIDER === null) return false;
  module.ADVANCED_SLIDER = module.ADVANCED_SLIDER || {};
  module.ADVANCED_SLIDER.version = '0.2.7';

  module.ADVANCED_SLIDER.pageLoaded = function () {
    var windowWidth = window.innerWidth,
        windowHeight = window.innerHeight;
    var animDelay = 0;
    var $sliderWrapper = $('.uix-advanced-slider');
    sliderInit(false);

    function windowUpdate() {
      // Check window width has actually changed and it's not just iOS triggering a resize event on scroll
      if (window.innerWidth != windowWidth) {
        // Update the window width for next time
        windowWidth = window.innerWidth; // Do stuff here

        sliderInit(true);
      }
    } // Add function to the window that should be resized


    var debounceFuncWindow = UixDebounce(windowUpdate, 50);
    window.removeEventListener('resize', debounceFuncWindow);
    window.addEventListener('resize', debounceFuncWindow);
    /*
     * Initialize slideshow
     *
     * @param  {Boolean} resize            - Determine whether the window size changes.
     * @return {Void}
     */

    function sliderInit(resize) {
      $sliderWrapper.each(function () {
        var $this = $(this);
        var $items = $this.find('.uix-advanced-slider__item'),
            $first = $items.first(),
            activated = $this.data('activated');
        var nativeItemW, nativeItemH;

        if ((0,esm_typeof/* default */.Z)(activated) === ( true ? "undefined" : 0) || activated === 0) {
          //Get parameter configuration from the data-* attribute of HTML
          var dataControlsPagination = $this.data('controls-pagination'),
              dataControlsArrows = $this.data('controls-arrows'),
              dataDraggable = $this.data('draggable'),
              dataDraggableCursor = $this.data('draggable-cursor'),
              dataCountTotal = $this.data('count-total'),
              dataCountCur = $this.data('count-now');
          if ((0,esm_typeof/* default */.Z)(dataControlsPagination) === ( true ? "undefined" : 0)) dataControlsPagination = '.uix-advanced-slider__pagination';
          if ((0,esm_typeof/* default */.Z)(dataControlsArrows) === ( true ? "undefined" : 0) || dataControlsArrows == false) dataControlsArrows = '.uix-advanced-slider__arrows';
          if ((0,esm_typeof/* default */.Z)(dataDraggable) === ( true ? "undefined" : 0)) dataDraggable = false;
          if ((0,esm_typeof/* default */.Z)(dataDraggableCursor) === ( true ? "undefined" : 0) || dataDraggableCursor == false) dataDraggableCursor = 'move';
          if ((0,esm_typeof/* default */.Z)(dataCountTotal) === ( true ? "undefined" : 0)) dataCountTotal = 'p.count em.count';
          if ((0,esm_typeof/* default */.Z)(dataCountCur) === ( true ? "undefined" : 0)) dataCountCur = 'p.count em.current'; //Autoplay parameters

          var dataAuto = $this.data('auto'),
              dataTiming = $this.data('timing'),
              dataLoop = $this.data('loop');
          if ((0,esm_typeof/* default */.Z)(dataAuto) === ( true ? "undefined" : 0)) dataAuto = false;
          if ((0,esm_typeof/* default */.Z)(dataTiming) === ( true ? "undefined" : 0)) dataTiming = 10000;
          if ((0,esm_typeof/* default */.Z)(dataLoop) === ( true ? "undefined" : 0)) dataLoop = false; //Autoplay times

          var playTimes; //A function called "timer" once every second (like a digital watch).

          $this[0].animatedSlides; //Get the duration of the animation from CSS/SCSS
          //-------------------------------------	

          animDelay = UixCssProperty.getTransitionDuration($first[0]); //Initialize the properties of each Item
          //-------------------------------------	

          $items.each(function (index) {
            var _item = $(this);

            _item.delay(animDelay * index).queue('fx', function () {
              $(this).addClass('is-loaded').dequeue();
            });
          }); //Initialize the first item container
          //-------------------------------------		

          $items.addClass('next');
          setTimeout(function () {
            $first.addClass('is-active');
          }, animDelay);

          if ($first.find('video').length > 0) {
            //Returns the dimensions (intrinsic height and width ) of the video
            var video = document.getElementById($first.find('video').attr('id'));
            var videoURL = $first.find('source:first').attr('src');
            if ((0,esm_typeof/* default */.Z)(videoURL) === ( true ? "undefined" : 0)) videoURL = $first.attr('src');
            video.addEventListener('loadedmetadata', function (e) {
              $this.css('height', this.videoHeight * ($this.width() / this.videoWidth) + 'px');
              nativeItemW = this.videoWidth;
              nativeItemH = this.videoHeight; //Initialize all the items to the stage

              addItemsToStage($this, nativeItemW, nativeItemH, dataControlsPagination, dataControlsArrows, dataLoop, dataDraggable, dataDraggableCursor, dataCountTotal, dataCountCur);
            }, false);
            video.src = videoURL;
          } else {
            var imgURL = $first.find('img').attr('src');

            if ((0,esm_typeof/* default */.Z)(imgURL) != ( true ? "undefined" : 0)) {
              var img = new Image();

              img.onload = function () {
                $this.css('height', $this.width() * (this.height / this.width) + 'px');
                nativeItemW = this.width;
                nativeItemH = this.height; //Initialize all the items to the stage

                addItemsToStage($this, nativeItemW, nativeItemH, dataControlsPagination, dataControlsArrows, dataLoop, dataDraggable, dataDraggableCursor, dataCountTotal, dataCountCur);
              };

              img.src = imgURL;
            }
          } //Autoplay Slider
          //-------------------------------------		


          if (!resize) {
            if (dataAuto && !isNaN(parseFloat(dataTiming)) && isFinite(dataTiming)) {
              sliderAutoPlay(playTimes, dataTiming, dataLoop, $this, dataCountTotal, dataCountCur, dataControlsPagination, dataControlsArrows);

              var autoplayEnter = function autoplayEnter() {
                clearInterval($this[0].animatedSlides);
              };

              var autoplayLeave = function autoplayLeave() {
                sliderAutoPlay(playTimes, dataTiming, dataLoop, $this, dataCountTotal, dataCountCur, dataControlsPagination, dataControlsArrows);
              }; // Do not use the `off()` method, otherwise it will cause the second mouseenter to be invalid


              $this.on('mouseenter', autoplayEnter);
              $this.on('mouseleave', autoplayLeave); // To determine if it is a touch screen.

              if (Modernizr.touchevents) {
                $this.on('pointerenter', autoplayEnter);
                $this.on('pointerleave', autoplayLeave);
              }
            }
          } //Prevents front-end javascripts that are activated with AJAX to repeat loading.


          $this.data('activated', 1);
        } //endif activated

      });
    }
    /*
    * Trigger slider autoplay
    *
    * @param  {Function} playTimes            - Number of times.
    * @param  {Number} timing                 - Autoplay interval.
    * @param  {Boolean} loop                  - Gives the slider a seamless infinite loop.
    * @param  {Element} slider                 - Selector of the slider .
     * @param  {String} countTotalID           - Total number ID or class of counter.
     * @param  {String} countCurID             - Current number ID or class of counter.
     * @param  {String} paginationID           - Navigation ID for paging control of each slide.
     * @param  {String} arrowsID               - Previous/Next arrow navigation ID.
    * @return {Void}                          - The constructor.
    */


    function sliderAutoPlay(playTimes, timing, loop, slider, countTotalID, countCurID, paginationID, arrowsID) {
      var items = slider.find('.uix-advanced-slider__item'),
          total = items.length;
      slider[0].animatedSlides = setInterval(function () {
        playTimes = parseFloat(items.filter('.is-active').index());
        playTimes++;

        if (!loop) {
          if (playTimes < total && playTimes >= 0) sliderUpdates(playTimes, slider, 'next', countTotalID, countCurID, paginationID, arrowsID, loop);
        } else {
          if (playTimes == total) playTimes = 0;
          if (playTimes < 0) playTimes = total - 1;
          sliderUpdates(playTimes, slider, 'next', countTotalID, countCurID, paginationID, arrowsID, loop);
        }
      }, timing);
    }
    /*
    * Initialize all the items to the stage
    *
    * @param  {Element} slider                 - Current selector of each slider.
    * @param  {Number} nativeItemW            - Returns the intrinsic width of the image/video.
    * @param  {Number} nativeItemH            - Returns the intrinsic height of the image/video.
     * @param  {String} paginationID           - Navigation ID for paging control of each slide.
     * @param  {String} arrowsID               - Previous/Next arrow navigation ID.
     * @param  {Boolean} loop                  - Gives the slider a seamless infinite loop. 
     * @param  {Boolean} draggable             - Allow drag and drop on the slider.
     * @param  {String} draggableCursor        - Drag & Drop Change icon/cursor while dragging.
     * @param  {String} countTotalID           - Total number ID or class of counter.
     * @param  {String} countCurID             - Current number ID or class of counter.
    * @return {Void}
    */


    function addItemsToStage(slider, nativeItemW, nativeItemH, paginationID, arrowsID, loop, draggable, draggableCursor, countTotalID, countCurID) {
      var $this = slider,
          $items = $this.find('.uix-advanced-slider__item'),
          $first = $items.first(),
          itemsTotal = $items.length; //If arrows does not exist on the page, it will be added by default, 
      //and the drag and drop function will be activated.

      if ($(arrowsID).length == 0) {
        $('body').prepend('<div style="display:none;" class="uix-advanced-slider__arrows ' + arrowsID.replace('#', '').replace('.', '') + '"><a href="#" class="uix-advanced-slider__arrows--prev"></a><a href="#" class="uix-advanced-slider__arrows--next"></a></div>');
      } //Add identifiers for the first and last items


      $items.last().addClass('last');
      $items.first().addClass('first'); //Prevent bubbling

      if (itemsTotal == 1) {
        $(paginationID).hide();
        $(arrowsID).hide();
      } // Fires local videos asynchronously with slider switch.
      //-------------------------------------


      normalSliderVideoInit($items, false); //Pagination dots 
      //-------------------------------------	

      var _dot = '',
          _dotActive = '';
      _dot += '<ul>';

      for (var i = 0; i < itemsTotal; i++) {
        _dotActive = i == 0 ? 'class="is-active"' : '';
        _dot += '<li><a ' + _dotActive + ' data-index="' + i + '" href="javascript:"></a></li>';
      }

      _dot += '</ul>';
      if ($(paginationID).html() == '') $(paginationID).html(_dot);
      $(paginationID).find('li a').off('click').on('click', function (e) {
        e.preventDefault(); //Prevent buttons' events from firing multiple times

        var $btn = $(this);
        if ($btn.attr('aria-disabled') == 'true') return false;
        $(paginationID).find('li a').attr('aria-disabled', 'true');
        $(paginationID).find('li a').delay(animDelay).queue(function (next) {
          $(paginationID).find('li a').attr('aria-disabled', 'false');
          next();
        }); //

        if (!$(this).hasClass('is-active')) {
          //Determine the direction
          var curDir = 'prev';

          if ($(this).attr('data-index') > parseFloat($items.filter('.is-active').index())) {
            curDir = 'next';
          }

          sliderUpdates($(this).attr('data-index'), $this, curDir, countTotalID, countCurID, paginationID, arrowsID, loop); //Pause the auto play event

          clearInterval($this[0].animatedSlides);
        }
      }); //Next/Prev buttons
      //-------------------------------------		

      var _prev = $(arrowsID).find('.uix-advanced-slider__arrows--prev'),
          _next = $(arrowsID).find('.uix-advanced-slider__arrows--next');

      $(arrowsID).find('a').attr('href', 'javascript:');
      $(arrowsID).find('a').removeClass('is-disabled');

      if (!loop) {
        _prev.addClass('is-disabled');
      }

      _prev.off('click').on('click', function (e) {
        e.preventDefault(); //Pause the auto play event

        clearInterval($this[0].animatedSlides); //Move animation

        prevMove();
      });

      _next.off('click').on('click', function (e) {
        e.preventDefault(); //Pause the auto play event

        clearInterval($this[0].animatedSlides); //Move animation

        nextMove();
      });

      function prevMove() {
        //Prevent buttons' events from firing multiple times
        if (_prev.attr('aria-disabled') == 'true') return false;

        _prev.attr('aria-disabled', 'true');

        _prev.delay(animDelay).queue(function (next) {
          _prev.attr('aria-disabled', 'false');

          next();
        }); //


        if (_prev.hasClass('is-disabled')) return false; //

        sliderUpdates(parseFloat($items.filter('.is-active').index()) - 1, $this, 'prev', countTotalID, countCurID, paginationID, arrowsID, loop);
      }

      function nextMove() {
        //Prevent buttons' events from firing multiple times
        if (_next.attr('aria-disabled') == 'true') return false;

        _next.attr('aria-disabled', 'true');

        _next.delay(animDelay).queue(function (next) {
          _next.attr('aria-disabled', 'false');

          next();
        }); //


        if (_next.hasClass('is-disabled')) return false; //

        sliderUpdates(parseFloat($items.filter('.is-active').index()) + 1, $this, 'next', countTotalID, countCurID, paginationID, arrowsID, loop);
      } //Added touch method to mobile device and desktop
      //-------------------------------------	


      var $dragTrigger = $this.find('.uix-advanced-slider__inner');
      var mouseX, mouseY;
      var isMoving = false; //Avoid images causing mouseup to fail

      $dragTrigger.find('img').css({
        'pointer-events': 'none',
        'user-select': 'none'
      }); //Make the cursor a move icon when a user hovers over an item

      if (draggable && draggableCursor != '' && draggableCursor != false) $dragTrigger.css('cursor', draggableCursor); //draggable for touch devices

      if (Modernizr.touchevents) draggable = true;

      if (draggable) {
        $dragTrigger[0].removeEventListener('mousedown', dragStart);
        document.removeEventListener('mouseup', dragEnd);
        $dragTrigger[0].removeEventListener('touchstart', dragStart);
        document.removeEventListener('touchend', dragEnd); //

        $dragTrigger[0].addEventListener('mousedown', dragStart);
        $dragTrigger[0].addEventListener('touchstart', dragStart);
      }

      function dragStart(e) {
        //Do not use "e.preventDefault()" to avoid prevention page scroll on drag in IOS and Android
        var touches = e.touches;

        if (touches && touches.length) {
          mouseX = touches[0].clientX;
          mouseY = touches[0].clientY;
        } else {
          mouseX = e.clientX;
          mouseY = e.clientY;
        }

        document.addEventListener('mouseup', dragEnd);
        document.addEventListener('mousemove', dragProcess);
        document.addEventListener('touchend', dragEnd);
        document.addEventListener('touchmove', dragProcess);
      }

      function dragProcess(e) {
        var touches = e.touches;
        var offsetX, offsetY;

        if (touches && touches.length) {
          offsetX = mouseX - touches[0].clientX, offsetY = mouseY - touches[0].clientY;
        } else {
          offsetX = mouseX - e.clientX, offsetY = mouseY - e.clientY;
        } //--- left


        if (offsetX >= 50) {
          if (!isMoving) {
            isMoving = true;
            nextMove();
          }
        } //--- right


        if (offsetX <= -50) {
          if (!isMoving) {
            isMoving = true;
            prevMove();
          }
        } //--- up


        if (offsetY >= 50) {} //--- down


        if (offsetY <= -50) {}
      }

      function dragEnd(e) {
        document.removeEventListener('mousemove', dragProcess);
        document.removeEventListener('touchmove', dragProcess); //restore move action status

        setTimeout(function () {
          isMoving = false;
        }, animDelay);
      }
    }
    /*
     * Transition Between Slides
     *
     * @param  {Number} elementIndex           - Index of current slider.
     * @param  {Element} slider                 - Selector of the slider .
     * @param  {String} dir                    - Switching direction indicator.
           * @param  {String} countTotalID           - Total number ID or class of counter.
           * @param  {String} countCurID             - Current number ID or class of counter.
           * @param  {String} paginationID           - Navigation ID for paging control of each slide.
           * @param  {String} arrowsID               - Previous/Next arrow navigation ID.
           * @param  {Boolean} loop                  - Gives the slider a seamless infinite loop.
     * @return {Void}
     */


    function sliderUpdates(elementIndex, slider, dir, countTotalID, countCurID, paginationID, arrowsID, loop) {
      var $items = slider.find('.uix-advanced-slider__item'),
          total = $items.length; //Prevent bubbling

      if (total == 1) {
        $(paginationID).hide();
        $(arrowsID).hide();
        return false;
      } //Transition Interception
      //-------------------------------------


      if (loop) {
        if (elementIndex == total) elementIndex = 0;
        if (elementIndex < 0) elementIndex = total - 1;
      } else {
        $(arrowsID).find('a').removeClass('is-disabled');
        if (elementIndex == total - 1) $(arrowsID).find('.uix-advanced-slider__arrows--next').addClass('is-disabled');
        if (elementIndex == 0) $(arrowsID).find('.uix-advanced-slider__arrows--prev').addClass('is-disabled');
      } // To determine if it is a touch screen.


      if (Modernizr.touchevents) {
        if (elementIndex == total) elementIndex = total - 1;
        if (elementIndex < 0) elementIndex = 0; //Prevent bubbling

        if (!loop) {
          //first item
          if (elementIndex == 0) {
            $(arrowsID).find('.uix-advanced-slider__arrows--prev').addClass('is-disabled');
          } //last item


          if (elementIndex == total - 1) {
            $(arrowsID).find('.uix-advanced-slider__arrows--next').addClass('is-disabled');
          }
        }
      } // call the current item
      //-------------------------------------


      var $current = $items.eq(elementIndex); //Determine the direction and add class to switching direction indicator.

      var dirIndicatorClass = '';
      if (dir == 'prev') dirIndicatorClass = 'prev';
      if (dir == 'next') dirIndicatorClass = 'next'; //Add transition class to Controls Pagination

      $(paginationID).find('li a').removeClass('leave');
      $(paginationID).find('li a.is-active').removeClass('is-active').addClass('leave');
      $(paginationID).find('li a[data-index="' + elementIndex + '"]').addClass('is-active').removeClass('leave'); //Add transition class to each item

      $items.removeClass('leave prev next');
      $items.addClass(dirIndicatorClass);
      slider.find('.uix-advanced-slider__item.is-active').removeClass('is-active').addClass('leave ' + dirIndicatorClass);
      $current.addClass('is-active ' + dirIndicatorClass).removeClass('leave'); //Display counter
      //-------------------------------------

      $(countTotalID).text(total);
      $(countCurID).text(parseFloat(elementIndex) + 1); // Fires local videos asynchronously with slider switch.
      //-------------------------------------

      normalSliderVideoInit($items, false);
      normalSliderVideoInit($current, true); //Reset the default height of item
      //-------------------------------------	

      itemDefaultInit(slider, $current);
    }
    /*
     * Initialize the default height of item
     *
           * @param  {Element} slider                 - Selector of the slider .
     * @param  {Element} currentLlement         - Current selector of each slider.
     * @return {Void}
     */


    function itemDefaultInit(slider, currentLlement) {
      if (currentLlement.find('video').length > 0) {
        //Returns the dimensions (intrinsic height and width ) of the video
        var video = document.getElementById(currentLlement.find('video').attr('id'));
        var videoURL = currentLlement.find('source:first').attr('src');
        if ((0,esm_typeof/* default */.Z)(videoURL) === ( true ? "undefined" : 0)) videoURL = currentLlement.attr('src');
        video.addEventListener('loadedmetadata', function (e) {
          slider.css('height', this.videoHeight * (currentLlement.closest('.uix-advanced-slider__outline').width() / this.videoWidth) + 'px');
        }, false);
        video.src = videoURL;
      } else {
        var imgURL = currentLlement.find('img').attr('src');

        if ((0,esm_typeof/* default */.Z)(imgURL) != ( true ? "undefined" : 0)) {
          var img = new Image();

          img.onload = function () {
            slider.css('height', currentLlement.closest('.uix-advanced-slider__outline').width() * (this.height / this.width) + 'px');
          };

          img.src = imgURL;
        }
      }
    }
    /*
     * Initialize embedded local video.
     *
     * @param  {Element} wrapper          - The outermost video container, which can contain multiple videos
     * @param  {Boolean} play            - Forced to trigger pause or play events.
     * @return {Void}
     */


    function normalSliderVideoInit(wrapper, play) {
      wrapper.find('.uix-video__slider').each(function () {
        var $this = $(this);
        var videoWrapperW = $this.closest('.uix-advanced-slider__outline').width(),
            curVideoID = $this.find('video').attr('id') + '-slider-videopush',
            coverPlayBtnID = 'videocover-' + curVideoID,
            $replayBtn = $('#' + curVideoID + '-replay-btn');
        var dataControls = $this.data('embed-video-controls'),
            dataAuto = $this.data('embed-video-autoplay'),
            dataLoop = $this.data('embed-video-loop'),
            dataW = $this.data('embed-video-width'),
            dataH = $this.data('embed-video-height'); //Push a new ID to video
        //Solve the problem that ajax asynchronous loading does not play

        $this.find('.video-js').attr('id', curVideoID);

        if ((0,esm_typeof/* default */.Z)(dataAuto) === ( true ? "undefined" : 0)) {
          dataAuto = true;
        }

        if ((0,esm_typeof/* default */.Z)(dataLoop) === ( true ? "undefined" : 0)) {
          dataLoop = true;
        }

        if ((0,esm_typeof/* default */.Z)(dataControls) === ( true ? "undefined" : 0)) {
          dataControls = false;
        }

        if ((0,esm_typeof/* default */.Z)(dataW) === ( true ? "undefined" : 0) || dataW == 'auto') {
          dataW = videoWrapperW;
        }

        if ((0,esm_typeof/* default */.Z)(dataH) === ( true ? "undefined" : 0) || dataH == 'auto') {
          dataH = videoWrapperW / 1.77777777777778;
        } //Display cover and play buttons when some mobile device browsers cannot automatically play video


        if ($('#' + coverPlayBtnID).length == 0) {
          $('<div id="' + coverPlayBtnID + '" class="uix-video__cover"><span class="uix-video__cover__placeholder" style="background-image:url(' + $this.find('video').attr('poster') + ')"></span><span class="uix-video__cover__playbtn"></span></div>').insertBefore($this);
          var btnEv = Modernizr.touchevents ? 'touchstart' : 'click';
          $('#' + coverPlayBtnID + ' .uix-video__cover__playbtn').on(btnEv, function (e) {
            e.preventDefault();
            myPlayer.play();
            $('#' + coverPlayBtnID).hide();
          });
        } //Add replay button to video 


        if ($replayBtn.length == 0) {
          $this.after('<span class="uix-video__btn-play" id="' + curVideoID + '-replay-btn"></span>');
        } //HTML5 video autoplay on mobile revisited


        if (dataAuto && windowWidth <= 768) {
          $this.find('.video-js').attr({
            'autoplay': 'true',
            'muted': 'true',
            'playsinline': 'true'
          });
        }

        var myPlayer = videojs(curVideoID, {
          width: dataW,
          height: dataH,
          loop: dataLoop,
          autoplay: dataAuto
        }, function onPlayerReady() {
          var initVideo = function initVideo(obj) {
            //Get Video Dimensions
            var curW = obj.videoWidth(),
                curH = obj.videoHeight(),
                newW = curW,
                newH = curH;
            newW = videoWrapperW; //Scaled/Proportional Content 

            newH = curH * (newW / curW);

            if (!isNaN(newW) && !isNaN(newH)) {
              obj.height(newH);
              obj.width(newW);
              $this.css('height', newH);
            } //Show this video wrapper


            $this.css('visibility', 'visible'); //Hide loading effect

            $this.find('.vjs-loading-spinner, .vjs-big-play-button').hide();
          };
          /* ---------  Video initialize */


          this.on('loadedmetadata', function () {
            initVideo(this);
          });
          /* ---------  Display the play button  */

          if (!dataAuto) $this.find('.vjs-big-play-button').show();
          $this.find('.vjs-big-play-button').off('click').on('click', function () {
            $(this).hide();
          });
          /* ---------  Set, tell the player it's in fullscreen  */

          if (dataAuto) {
            //Fix an error of Video auto play is not working in browser
            this.muted(true); //Prevent autoplay error: Uncaught (in promise) DOMException

            var promise = this.play();

            if (promise !== undefined) {
              promise.then(function () {// Autoplay started!
              })["catch"](function (error) {
                // Autoplay was prevented.
                $('#' + coverPlayBtnID).show();
                $('#' + coverPlayBtnID + ' .uix-video__cover__playbtn').show();
                console.log('Autoplay was prevented.');
              });
            }
          }
          /* ---------  Disable control bar play button click */


          if (!dataControls) {
            this.controls(false);
          }
          /* ---------  Determine if the video is auto played from mobile devices  */


          var autoPlayOK = false;
          this.on('timeupdate', function () {
            var duration = this.duration();

            if (duration > 0) {
              autoPlayOK = true;

              if (this.currentTime() > 0) {
                autoPlayOK = true;
                this.off('timeupdate'); //Hide cover and play buttons when the video automatically played

                $('#' + coverPlayBtnID).hide();
              }
            }
          });
          /* ---------  Pause the video when it is not current slider  */

          if (!play) {
            this.pause();
            this.currentTime(0);
          } else {
            //Unmute, because there is interaction, you can turn on the audio.
            this.muted(false);

            if (dataAuto) {
              this.currentTime(0); //Prevent autoplay error: Uncaught (in promise) DOMException

              var _promise = this.play();

              if (_promise !== undefined) {
                _promise.then(function () {// Autoplay started!
                })["catch"](function (error) {
                  // Autoplay was prevented.
                  $('#' + coverPlayBtnID).show();
                  $('#' + coverPlayBtnID + ' .uix-video__cover__playbtn').show();
                  console.log('Autoplay was prevented.');
                });
              } //Hidden replay button


              $replayBtn.hide(); //Should the video go to the beginning when it ends

              this.on('ended', function () {
                if (dataLoop) {
                  this.currentTime(0);
                  this.play();
                } else {
                  //Replay this video
                  this.currentTime(0);
                  $replayBtn.show().off('click').on('click', function (e) {
                    e.preventDefault();
                    this.play();
                    $replayBtn.hide();
                  });
                }
              });
            }
          }
        });
      });
    }
  };

  module.components.pageLoaded.push(module.ADVANCED_SLIDER.pageLoaded);
  return /*#__PURE__*/_createClass(function ADVANCED_SLIDER() {
    _classCallCheck(this, ADVANCED_SLIDER);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
// EXTERNAL MODULE: ./src/components/_third-party-plugins/GSAP/esm/TweenLite.js
var esm_TweenLite = __webpack_require__(696);
;// CONCATENATED MODULE: ./src/components/_third-party-plugins/GSAP/esm/PixiPlugin.js
/*!
 * VERSION: 0.3.0
 * DATE: 2019-05-13
 * UPDATES AND DOCS AT: http://greensock.com
 *
 * @license Copyright (c) 2008-2019, GreenSock. All rights reserved.
 * PixiPlugin is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 *
 * @author: Jack Doyle, jack@greensock.com
 */

/* eslint-disable */


var _numExp = /(\d|\.)+/g,
    _relNumExp = /(?:\d|\-\d|\.\d|\-\.\d|\+=\d|\-=\d|\+=.\d|\-=\.\d)+/g,
    _colorLookup = {
  aqua: [0, 255, 255],
  lime: [0, 255, 0],
  silver: [192, 192, 192],
  black: [0, 0, 0],
  maroon: [128, 0, 0],
  teal: [0, 128, 128],
  blue: [0, 0, 255],
  navy: [0, 0, 128],
  white: [255, 255, 255],
  fuchsia: [255, 0, 255],
  olive: [128, 128, 0],
  yellow: [255, 255, 0],
  orange: [255, 165, 0],
  gray: [128, 128, 128],
  purple: [128, 0, 128],
  green: [0, 128, 0],
  red: [255, 0, 0],
  pink: [255, 192, 203],
  cyan: [0, 255, 255],
  transparent: [255, 255, 255, 0]
},
    _hue = function _hue(h, m1, m2) {
  h = h < 0 ? h + 1 : h > 1 ? h - 1 : h;
  return (h * 6 < 1 ? m1 + (m2 - m1) * h * 6 : h < 0.5 ? m2 : h * 3 < 2 ? m1 + (m2 - m1) * (2 / 3 - h) * 6 : m1) * 255 + 0.5 | 0;
},

/**
 * @private Parses a color (like #9F0, #FF9900, rgb(255,51,153) or hsl(108, 50%, 10%)) into an array with 3 elements for red, green, and blue or if "format" parameter is "hsl", it will populate the array with hue, saturation, and lightness values. Or if "format" is "number", it'll return a number like 0xFF0000 instead of an array. If a relative value is found in an hsl() or hsla() string, it will preserve those relative prefixes and all the values in the array will be strings instead of numbers (in all other cases it will be populated with numbers).
 * @param {(string|number)} v The value the should be parsed which could be a string like #9F0 or rgb(255,102,51) or rgba(255,0,0,0.5) or it could be a number like 0xFF00CC or even a named color like red, blue, purple, etc.
 * @param {(string)} format If "hsl", an hsl() or hsla() value will be returned instead of rgb() or rgba(). Or if "number", then a numeric value will be returned, like 0xFF0000. Default is rgb.
 * @return {(array|number)} An array containing red, green, and blue (and optionally alpha) in that order, or if the format parameter was "hsl", the array will contain hue, saturation and lightness (and optionally alpha) in that order. Or if "format" is defined as "number", it'll return a number like 0xFF0000. Always numbers unless there's a relative prefix found in an hsl() or hsla() string and "format" is "hsl".
 */
_parseColor = function _parseColor(v, format) {
  var toHSL = format === "hsl",
      a,
      r,
      g,
      b,
      h,
      s,
      l,
      max,
      min,
      d,
      wasHSL;

  if (!v) {
    a = _colorLookup.black;
  } else if (typeof v === "number") {
    a = [v >> 16, v >> 8 & 255, v & 255];
  } else {
    if (v.charAt(v.length - 1) === ",") {
      //sometimes a trailing comma is included and we should chop it off (typically from a comma-delimited list of values like a textShadow:"2px 2px 2px blue, 5px 5px 5px rgb(255,0,0)" - in this example "blue," has a trailing comma. We could strip it out inside parseComplex() but we'd need to do it to the beginning and ending values plus it wouldn't provide protection from other potential scenarios like if the user passes in a similar value.
      v = v.substr(0, v.length - 1);
    }

    if (_colorLookup[v]) {
      a = _colorLookup[v];
    } else if (v.charAt(0) === "#") {
      if (v.length === 4) {
        //for shorthand like #9F0
        r = v.charAt(1);
        g = v.charAt(2);
        b = v.charAt(3);
        v = "#" + r + r + g + g + b + b;
      }

      v = parseInt(v.substr(1), 16);
      a = [v >> 16, v >> 8 & 255, v & 255];
    } else if (v.substr(0, 3) === "hsl") {
      a = wasHSL = v.match(_numExp);

      if (!toHSL) {
        h = Number(a[0]) % 360 / 360;
        s = Number(a[1]) / 100;
        l = Number(a[2]) / 100;
        g = l <= 0.5 ? l * (s + 1) : l + s - l * s;
        r = l * 2 - g;

        if (a.length > 3) {
          a[3] = Number(v[3]);
        }

        a[0] = _hue(h + 1 / 3, r, g);
        a[1] = _hue(h, r, g);
        a[2] = _hue(h - 1 / 3, r, g);
      } else if (v.indexOf("=") !== -1) {
        //if relative values are found, just return the raw strings with the relative prefixes in place.
        return v.match(_relNumExp);
      }
    } else {
      a = v.match(_numExp) || _colorLookup.transparent;
    }

    a[0] = Number(a[0]);
    a[1] = Number(a[1]);
    a[2] = Number(a[2]);

    if (a.length > 3) {
      a[3] = Number(a[3]);
    }
  }

  if (toHSL && !wasHSL) {
    r = a[0] / 255;
    g = a[1] / 255;
    b = a[2] / 255;
    max = Math.max(r, g, b);
    min = Math.min(r, g, b);
    l = (max + min) / 2;

    if (max === min) {
      h = s = 0;
    } else {
      d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      h = max === r ? (g - b) / d + (g < b ? 6 : 0) : max === g ? (b - r) / d + 2 : (r - g) / d + 4;
      h *= 60;
    }

    a[0] = h + 0.5 | 0;
    a[1] = s * 100 + 0.5 | 0;
    a[2] = l * 100 + 0.5 | 0;
  }

  return format === "number" ? a[0] << 16 | a[1] << 8 | a[2] : a;
},
    _formatColors = function _formatColors(s, toHSL) {
  var colors = (s + "").match(_colorExp) || [],
      charIndex = 0,
      parsed = "",
      i,
      color,
      temp;

  if (!colors.length) {
    return s;
  }

  for (i = 0; i < colors.length; i++) {
    color = colors[i];
    temp = s.substr(charIndex, s.indexOf(color, charIndex) - charIndex);
    charIndex += temp.length + color.length;
    color = _parseColor(color, toHSL ? "hsl" : "rgb");

    if (color.length === 3) {
      color.push(1);
    }

    parsed += temp + (toHSL ? "hsla(" + color[0] + "," + color[1] + "%," + color[2] + "%," + color[3] : "rgba(" + color.join(",")) + ")";
  }

  return parsed + s.substr(charIndex);
},
    _colorStringFilter,
    PixiPlugin_TweenLite = (esm_TweenLite/* _gsScope.GreenSockGlobals */.ML.GreenSockGlobals || esm_TweenLite/* _gsScope */.ML).TweenLite,
    _colorExp = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3}){1,2}\\b",
    //we'll dynamically build this Regular Expression to conserve file size. After building it, it will be able to find rgb(), rgba(), # (hexadecimal), and named color values like red, blue, purple, etc.
_idMatrix = [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0],
    _lumR = 0.212671,
    _lumG = 0.715160,
    _lumB = 0.072169,
    _applyMatrix = function _applyMatrix(m, m2) {
  var temp = [],
      i = 0,
      z = 0,
      y,
      x;

  for (y = 0; y < 4; y++) {
    for (x = 0; x < 5; x++) {
      z = x === 4 ? m[i + 4] : 0;
      temp[i + x] = m[i] * m2[x] + m[i + 1] * m2[x + 5] + m[i + 2] * m2[x + 10] + m[i + 3] * m2[x + 15] + z;
    }

    i += 5;
  }

  return temp;
},
    _setSaturation = function _setSaturation(m, n) {
  var inv = 1 - n,
      r = inv * _lumR,
      g = inv * _lumG,
      b = inv * _lumB;
  return _applyMatrix([r + n, g, b, 0, 0, r, g + n, b, 0, 0, r, g, b + n, 0, 0, 0, 0, 0, 1, 0], m);
},
    _colorize = function _colorize(m, color, amount) {
  var c = _parseColor(color),
      r = c[0] / 255,
      g = c[1] / 255,
      b = c[2] / 255,
      inv = 1 - amount;

  return _applyMatrix([inv + amount * r * _lumR, amount * r * _lumG, amount * r * _lumB, 0, 0, amount * g * _lumR, inv + amount * g * _lumG, amount * g * _lumB, 0, 0, amount * b * _lumR, amount * b * _lumG, inv + amount * b * _lumB, 0, 0, 0, 0, 0, 1, 0], m);
},
    _setHue = function _setHue(m, n) {
  n *= Math.PI / 180;
  var c = Math.cos(n),
      s = Math.sin(n);
  return _applyMatrix([_lumR + c * (1 - _lumR) + s * -_lumR, _lumG + c * -_lumG + s * -_lumG, _lumB + c * -_lumB + s * (1 - _lumB), 0, 0, _lumR + c * -_lumR + s * 0.143, _lumG + c * (1 - _lumG) + s * 0.14, _lumB + c * -_lumB + s * -0.283, 0, 0, _lumR + c * -_lumR + s * -(1 - _lumR), _lumG + c * -_lumG + s * _lumG, _lumB + c * (1 - _lumB) + s * _lumB, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1], m);
},
    _setContrast = function _setContrast(m, n) {
  return _applyMatrix([n, 0, 0, 0, 0.5 * (1 - n), 0, n, 0, 0, 0.5 * (1 - n), 0, 0, n, 0, 0.5 * (1 - n), 0, 0, 0, 1, 0], m);
},
    _getFilter = function _getFilter(t, type) {
  var filterClass = esm_TweenLite/* _gsScope.PIXI.filters */.ML.PIXI.filters[type],
      filters = t.filters || [],
      i = filters.length,
      filter;

  if (!filterClass) {
    throw "PixiPlugin error: " + type + " isn't present.";
  }

  while (--i > -1) {
    if (filters[i] instanceof filterClass) {
      return filters[i];
    }
  }

  filter = new filterClass();

  if (type === "BlurFilter") {
    filter.blur = 0;
  }

  filters.push(filter);
  t.filters = filters;
  return filter;
},
    _addColorMatrixFilterCacheTween = function _addColorMatrixFilterCacheTween(p, pg, cache, vars) {
  //we cache the ColorMatrixFilter components in a _gsColorMatrixFilter object attached to the target object so that it's easy to grab the current value at any time.
  pg._addTween(cache, p, cache[p], vars[p], p);

  pg._overwriteProps.push(p);
},
    _applyBrightnessToMatrix = function _applyBrightnessToMatrix(brightness, matrix) {
  var temp = new esm_TweenLite/* _gsScope.PIXI.filters.ColorMatrixFilter */.ML.PIXI.filters.ColorMatrixFilter();
  temp.matrix = matrix;
  temp.brightness(brightness, true);
  return temp.matrix;
},
    _CMFdefaults = {
  contrast: 1,
  saturation: 1,
  colorizeAmount: 0,
  colorize: "rgb(255,255,255)",
  hue: 0,
  brightness: 1
},
    _parseColorMatrixFilter = function _parseColorMatrixFilter(t, v, pg) {
  var filter = _getFilter(t, "ColorMatrixFilter"),
      cache = t._gsColorMatrixFilter = t._gsColorMatrixFilter || {
    contrast: 1,
    saturation: 1,
    colorizeAmount: 0,
    colorize: "rgb(255,255,255)",
    hue: 0,
    brightness: 1
  },
      combine = v.combineCMF && !("colorMatrixFilter" in v && !v.colorMatrixFilter),
      i,
      matrix,
      startMatrix;

  startMatrix = filter.matrix;

  if (v.resolution) {
    filter.resolution = v.resolution;
  }

  if (v.matrix && v.matrix.length === startMatrix.length) {
    matrix = v.matrix;

    if (cache.contrast !== 1) {
      _addColorMatrixFilterCacheTween("contrast", pg, cache, _CMFdefaults);
    }

    if (cache.hue) {
      _addColorMatrixFilterCacheTween("hue", pg, cache, _CMFdefaults);
    }

    if (cache.brightness !== 1) {
      _addColorMatrixFilterCacheTween("brightness", pg, cache, _CMFdefaults);
    }

    if (cache.colorizeAmount) {
      _addColorMatrixFilterCacheTween("colorize", pg, cache, _CMFdefaults);

      _addColorMatrixFilterCacheTween("colorizeAmount", pg, cache, _CMFdefaults);
    }

    if (cache.saturation !== 1) {
      _addColorMatrixFilterCacheTween("saturation", pg, cache, _CMFdefaults);
    }
  } else {
    matrix = _idMatrix.slice();

    if (v.contrast != null) {
      matrix = _setContrast(matrix, Number(v.contrast));

      _addColorMatrixFilterCacheTween("contrast", pg, cache, v);
    } else if (cache.contrast !== 1) {
      if (combine) {
        matrix = _setContrast(matrix, cache.contrast);
      } else {
        _addColorMatrixFilterCacheTween("contrast", pg, cache, _CMFdefaults);
      }
    }

    if (v.hue != null) {
      matrix = _setHue(matrix, Number(v.hue));

      _addColorMatrixFilterCacheTween("hue", pg, cache, v);
    } else if (cache.hue) {
      if (combine) {
        matrix = _setHue(matrix, cache.hue);
      } else {
        _addColorMatrixFilterCacheTween("hue", pg, cache, _CMFdefaults);
      }
    }

    if (v.brightness != null) {
      matrix = _applyBrightnessToMatrix(Number(v.brightness), matrix);

      _addColorMatrixFilterCacheTween("brightness", pg, cache, v);
    } else if (cache.brightness !== 1) {
      if (combine) {
        matrix = _applyBrightnessToMatrix(cache.brightness, matrix);
      } else {
        _addColorMatrixFilterCacheTween("brightness", pg, cache, _CMFdefaults);
      }
    }

    if (v.colorize != null) {
      v.colorizeAmount = "colorizeAmount" in v ? Number(v.colorizeAmount) : 1;
      matrix = _colorize(matrix, v.colorize, v.colorizeAmount);

      _addColorMatrixFilterCacheTween("colorize", pg, cache, v);

      _addColorMatrixFilterCacheTween("colorizeAmount", pg, cache, v);
    } else if (cache.colorizeAmount) {
      if (combine) {
        matrix = _colorize(matrix, cache.colorize, cache.colorizeAmount);
      } else {
        _addColorMatrixFilterCacheTween("colorize", pg, cache, _CMFdefaults);

        _addColorMatrixFilterCacheTween("colorizeAmount", pg, cache, _CMFdefaults);
      }
    }

    if (v.saturation != null) {
      matrix = _setSaturation(matrix, Number(v.saturation));

      _addColorMatrixFilterCacheTween("saturation", pg, cache, v);
    } else if (cache.saturation !== 1) {
      if (combine) {
        matrix = _setSaturation(matrix, cache.saturation);
      } else {
        _addColorMatrixFilterCacheTween("saturation", pg, cache, _CMFdefaults);
      }
    }
  }

  i = matrix.length;

  while (--i > -1) {
    if (matrix[i] !== startMatrix[i]) {
      pg._addTween(startMatrix, i, startMatrix[i], matrix[i], "colorMatrixFilter");
    }
  }

  pg._overwriteProps.push("colorMatrixFilter");
},
    _addColorTween = function _addColorTween(target, p, value, colorSetter, plugin) {
  var pt = colorSetter._firstPT = {
    _next: colorSetter._firstPT,
    t: target,
    p: p,
    proxy: {},
    f: typeof target[p] === "function"
  };
  pt.proxy[p] = "rgb(" + _parseColor(!pt.f ? target[p] : target[p.indexOf("set") || typeof target["get" + p.substr(3)] !== "function" ? p : "get" + p.substr(3)]()).join(",") + ")";

  plugin._addTween(pt.proxy, p, "get", typeof value === "number" ? "rgb(" + _parseColor(value, false).join(",") + ")" : value, p, null, null, _colorStringFilter);
},
    //to improve performance, when a color is sensed, we hijack the setRatio() method of the plugin instance with a new function that this method spits back. This is a special method that handles parsing color values on-the-fly and turns them into numeric values which PixiJS requires. In other words, instead of "rgb(255, 0, 0)", PixiJS wants 0xFF0000. This also works with hsl() values.
_buildColorSetter = function _buildColorSetter(tween, plugin) {
  var setRatio = plugin.setRatio,
      //save the original (super) setRatio() function
  func = function func(v) {
    var pt = func._firstPT,
        val;
    setRatio.call(plugin, v);

    while (pt) {
      val = _parseColor(pt.proxy[pt.p], "number");

      if (pt.f) {
        pt.t[pt.p](val);
      } else {
        pt.t[pt.p] = val;
      }

      pt = pt._next;
    }

    if (func.graphics) {
      //in order for PixiJS to actually redraw GraphicsData, we've gotta increment the "dirty" and "clearDirty" values. If we don't do this, the values will be tween properly, but not rendered.
      func.graphics.dirty++;
      func.graphics.clearDirty++;
    }
  };

  plugin.setRatio = func;
  return func;
},
    _colorProps = {
  tint: 1,
  lineColor: 1,
  fillColor: 1
},
    _xyContexts = "position,scale,skew,pivot,anchor,tilePosition,tileScale".split(","),
    _contexts = {
  x: "position",
  y: "position",
  tileX: "tilePosition",
  tileY: "tilePosition"
},
    _colorMatrixFilterProps = {
  colorMatrixFilter: 1,
  saturation: 1,
  contrast: 1,
  hue: 1,
  colorize: 1,
  colorizeAmount: 1,
  brightness: 1,
  combineCMF: 1
},
    _DEG2RAD = Math.PI / 180,
    _degreesToRadians = function _degreesToRadians(value) {
  return typeof value === "string" && value.charAt(1) === "=" ? value.substr(0, 2) + parseFloat(value.substr(2)) * _DEG2RAD : value * _DEG2RAD;
},
    i,
    p; //context setup...


for (i = 0; i < _xyContexts.length; i++) {
  p = _xyContexts[i];
  _contexts[p + "X"] = p;
  _contexts[p + "Y"] = p;
} //color parsing setup...


for (p in _colorLookup) {
  _colorExp += "|" + p + "\\b";
}

_colorExp = new RegExp(_colorExp + ")", "gi");

_colorStringFilter = function _colorStringFilter(a) {
  var combined = a[0] + " " + a[1],
      toHSL;
  _colorExp.lastIndex = 0;

  if (_colorExp.test(combined)) {
    toHSL = combined.indexOf("hsl(") !== -1 || combined.indexOf("hsla(") !== -1;
    a[0] = _formatColors(a[0], toHSL);
    a[1] = _formatColors(a[1], toHSL);
  }
};

if (!PixiPlugin_TweenLite.defaultStringFilter) {
  PixiPlugin_TweenLite.defaultStringFilter = _colorStringFilter;
}

var PixiPlugin = esm_TweenLite/* _gsScope._gsDefine.plugin */.ML._gsDefine.plugin({
  propName: "pixi",
  priority: 0,
  API: 2,
  global: true,
  version: "0.3.0",
  init: function init(target, values, tween, index) {
    if (!target instanceof esm_TweenLite/* _gsScope.PIXI.DisplayObject */.ML.PIXI.DisplayObject) {
      return false;
    }

    var isV4 = esm_TweenLite/* _gsScope.PIXI.VERSION.charAt */.ML.PIXI.VERSION.charAt(0) === "4",
        context,
        axis,
        value,
        colorMatrix,
        filter,
        p,
        padding,
        colorSetter,
        i,
        data,
        pt;

    for (p in values) {
      context = _contexts[p];
      value = values[p];

      if (typeof value === "function") {
        value = value(index || 0, target);
      }

      if (context) {
        axis = p.charAt(p.length - 1).toLowerCase().indexOf("x") !== -1 ? "x" : "y";

        this._addTween(target[context], axis, target[context][axis], context === "skew" ? _degreesToRadians(value) : value, p);
      } else if (p === "scale" || p === "anchor" || p === "pivot" || p === "tileScale") {
        this._addTween(target[p], "x", target[p].x, value, p + "X");

        this._addTween(target[p], "y", target[p].y, value, p + "Y");
      } else if (p === "rotation") {
        //PIXI expects rotation in radians, but as a convenience we let folks define it in degrees and we do the conversion.
        this._addTween(target, p, target.rotation, _degreesToRadians(value), p);
      } else if (_colorMatrixFilterProps[p]) {
        if (!colorMatrix) {
          _parseColorMatrixFilter(target, values.colorMatrixFilter || values, this);

          colorMatrix = true;
        }
      } else if (p === "blur" || p === "blurX" || p === "blurY" || p === "blurPadding") {
        filter = _getFilter(target, "BlurFilter");

        this._addTween(filter, p, filter[p], value, p);

        if (values.blurPadding !== 0) {
          padding = values.blurPadding || Math.max(filter[p], value) * 2;
          i = target.filters.length;

          while (--i > -1) {
            target.filters[i].padding = Math.max(target.filters[i].padding, padding); //if we don't expand the padding on all the filters, it can look clipped.
          }
        }
      } else if (_colorProps[p]) {
        if (!colorSetter) {
          colorSetter = _buildColorSetter(tween, this);
        }

        if ((p === "lineColor" || p === "fillColor") && target instanceof esm_TweenLite/* _gsScope.PIXI.Graphics */.ML.PIXI.Graphics) {
          data = (target.geometry || target).graphicsData; //"geometry" was introduced in PIXI version 5

          i = data.length;

          while (--i > -1) {
            _addColorTween(isV4 ? data[i] : data[i][p.substr(0, 4) + "Style"], isV4 ? p : "color", value, colorSetter, this);
          }

          colorSetter.graphics = target.geometry || target;
        } else {
          _addColorTween(target, p, value, colorSetter, this);
        }
      } else if (p === "autoAlpha") {
        this._firstPT = pt = {
          t: {
            setRatio: function setRatio() {
              target.visible = !!target.alpha;
            }
          },
          p: "setRatio",
          s: 0,
          c: 1,
          f: 1,
          pg: 0,
          n: "visible",
          pr: 0,
          m: 0,
          _next: this._firstPT
        };

        if (pt._next) {
          pt._next._prev = pt;
        }

        this._addTween(target, "alpha", target.alpha, value, "alpha");

        this._overwriteProps.push("alpha", "visible");
      } else {
        this._addTween(target, p, target[p], value, p);
      }

      this._overwriteProps.push(p);
    }

    return true;
  }
});

PixiPlugin.colorProps = _colorProps;
PixiPlugin.parseColor = _parseColor;
PixiPlugin.formatColors = _formatColors;
PixiPlugin.colorStringFilter = _colorStringFilter;

PixiPlugin.registerPIXI = function (PIXI) {
  esm_TweenLite/* _gsScope.PIXI */.ML.PIXI = PIXI;
};


;// CONCATENATED MODULE: ./src/components/advanced-slider/js/special.js




/* 
 *************************************
 * <!-- Advanced Slider (Special Effects) -->
 *************************************
 */



var ADVANCED_SLIDER_FILTER = function (module, $, window, document) {
  if (window.ADVANCED_SLIDER_FILTER === null) return false;
  module.ADVANCED_SLIDER_FILTER = module.ADVANCED_SLIDER_FILTER || {};
  module.ADVANCED_SLIDER_FILTER.version = '0.3.6';

  module.ADVANCED_SLIDER_FILTER.pageLoaded = function () {
    // Remove pixi.js banner from the console
    PIXI.utils.skipHello();
    var windowWidth = window.innerWidth,
        windowHeight = window.innerHeight;
    var animSpeed = 1000;
    var $sliderWrapper = $('.uix-advanced-slider-sp');
    var //Save different canvas heights as an array
    canvasHeights = [],
        //Basic webGL renderers 
    rendererOuterID = 'uix-advanced-slider-sp__canvas-container',
        rendererCanvasID = 'uix-advanced-slider-sp__canvas',
        renderer,
        //PIXI
    renderer__filter,
        rendererCanvasID__filter = rendererCanvasID,
        stage__filter,
        container__items,
        displacementSprite,
        displacementFilter;
    sliderInit(false);

    function windowUpdate() {
      // Check window width has actually changed and it's not just iOS triggering a resize event on scroll
      if (window.innerWidth != windowWidth) {
        // Update the window width for next time
        windowWidth = window.innerWidth; // Do stuff here

        sliderInit(true);
      }
    } // Add function to the window that should be resized


    var debounceFuncWindow = UixDebounce(windowUpdate, 50);
    window.removeEventListener('resize', debounceFuncWindow);
    window.addEventListener('resize', debounceFuncWindow);
    /*
     * Initialize slideshow
     *
     * @param  {Boolean} resize            - Determine whether the window size changes.
     * @return {Void}
     */

    function sliderInit(resize) {
      $sliderWrapper.each(function () {
        var $this = $(this);
        var $items = $this.find('.uix-advanced-slider-sp__item'),
            $first = $items.first(),
            activated = $this.data('activated');
        var nativeItemW, nativeItemH;

        if ((0,esm_typeof/* default */.Z)(activated) === ( true ? "undefined" : 0) || activated === 0) {
          //Get parameter configuration from the data-* attribute of HTML
          var dataControlsPagination = $this.data('controls-pagination'),
              dataControlsArrows = $this.data('controls-arrows'),
              dataDraggable = $this.data('draggable'),
              dataDraggableCursor = $this.data('draggable-cursor'),
              dataCountTotal = $this.data('count-total'),
              dataCountCur = $this.data('count-now'),
              dataSpeed = $this.data('speed'),
              dataFilterTexture = $this.data('filter-texture');
          if ((0,esm_typeof/* default */.Z)(dataControlsPagination) === ( true ? "undefined" : 0)) dataControlsPagination = '.uix-advanced-slider-sp__pagination';
          if ((0,esm_typeof/* default */.Z)(dataControlsArrows) === ( true ? "undefined" : 0) || dataControlsArrows == false) dataControlsArrows = '.uix-advanced-slider-sp__arrows';
          if ((0,esm_typeof/* default */.Z)(dataDraggable) === ( true ? "undefined" : 0)) dataDraggable = false;
          if ((0,esm_typeof/* default */.Z)(dataDraggableCursor) === ( true ? "undefined" : 0) || dataDraggableCursor == false) dataDraggableCursor = 'move';
          if ((0,esm_typeof/* default */.Z)(dataCountTotal) === ( true ? "undefined" : 0)) dataCountTotal = 'p.count em.count';
          if ((0,esm_typeof/* default */.Z)(dataCountCur) === ( true ? "undefined" : 0)) dataCountCur = 'p.count em.current';
          if ((0,esm_typeof/* default */.Z)(dataFilterTexture) === ( true ? "undefined" : 0) || !dataFilterTexture || dataFilterTexture == '') dataFilterTexture = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7'; //Autoplay parameters

          var dataAuto = $this.data('auto'),
              dataTiming = $this.data('timing'),
              dataLoop = $this.data('loop');
          if ((0,esm_typeof/* default */.Z)(dataAuto) === ( true ? "undefined" : 0)) dataAuto = false;
          if ((0,esm_typeof/* default */.Z)(dataTiming) === ( true ? "undefined" : 0)) dataTiming = 10000;
          if ((0,esm_typeof/* default */.Z)(dataLoop) === ( true ? "undefined" : 0)) dataLoop = false; //Autoplay times

          var playTimes; //A function called "timer" once every second (like a digital watch).

          $this[0].animatedSlides; //Get the animation speed
          //-------------------------------------	

          if ((0,esm_typeof/* default */.Z)(dataSpeed) != ( true ? "undefined" : 0) && dataSpeed != false) {
            animSpeed = dataSpeed;
          } //Display all images
          //-------------------------------------	


          if (!Modernizr.webgl) {
            $this.find('img').css('visibility', 'visible');
          } //Initialize the first item container
          //-------------------------------------		


          $items.addClass('next');
          $first.addClass('is-active');
          TweenMax.set($items, {
            alpha: 0,
            onComplete: function onComplete() {
              TweenMax.to($first, animSpeed / 1000, {
                alpha: 1,
                delay: animSpeed / 1000
              });
            }
          });

          if ($first.find('video').length > 0) {
            //Returns the dimensions (intrinsic height and width ) of the video
            var video = document.getElementById($first.find('video').attr('id'));
            var videoURL = $first.find('source:first').attr('src');
            if ((0,esm_typeof/* default */.Z)(videoURL) === ( true ? "undefined" : 0)) videoURL = $first.attr('src');

            if ((0,esm_typeof/* default */.Z)(videoURL) != ( true ? "undefined" : 0)) {
              video.addEventListener('loadedmetadata', function (e) {
                $this.css('height', this.videoHeight * ($this.width() / this.videoWidth) + 'px');
                nativeItemW = this.videoWidth;
                nativeItemH = this.videoHeight; //Initialize all the items to the stage

                addItemsToStage($this, nativeItemW, nativeItemH, dataControlsPagination, dataControlsArrows, dataLoop, dataDraggable, dataDraggableCursor, dataCountTotal, dataCountCur, dataFilterTexture);
              }, false);
              video.src = videoURL;
            }
          } else {
            var imgURL = $first.find('img').attr('src');

            if ((0,esm_typeof/* default */.Z)(imgURL) != ( true ? "undefined" : 0)) {
              var img = new Image();

              img.onload = function () {
                $this.css('height', $this.width() * (this.height / this.width) + 'px');
                nativeItemW = this.width;
                nativeItemH = this.height; //Initialize all the items to the stage

                addItemsToStage($this, nativeItemW, nativeItemH, dataControlsPagination, dataControlsArrows, dataLoop, dataDraggable, dataDraggableCursor, dataCountTotal, dataCountCur, dataFilterTexture);
              };

              img.src = imgURL;
            }
          } //Autoplay Slider
          //-------------------------------------		


          if (!resize) {
            if (dataAuto && !isNaN(parseFloat(dataTiming)) && isFinite(dataTiming)) {
              sliderAutoPlay(playTimes, dataTiming, dataLoop, $this, dataCountTotal, dataCountCur, dataControlsPagination, dataControlsArrows);

              var autoplayEnter = function autoplayEnter() {
                clearInterval($this[0].animatedSlides);
              };

              var autoplayLeave = function autoplayLeave() {
                sliderAutoPlay(playTimes, dataTiming, dataLoop, $this, dataCountTotal, dataCountCur, dataControlsPagination, dataControlsArrows);
              }; // Do not use the `off()` method, otherwise it will cause the second mouseenter to be invalid


              $this.on('mouseenter', autoplayEnter);
              $this.on('mouseleave', autoplayLeave); // To determine if it is a touch screen.

              if (Modernizr.touchevents) {
                $this.on('pointerenter', autoplayEnter);
                $this.on('pointerleave', autoplayLeave);
              }
            }
          } //Prevents front-end javascripts that are activated with AJAX to repeat loading.


          $this.data('activated', 1);
        } //endif activated

      });
    }
    /*
    * Trigger slider autoplay
    *
    * @param  {Function} playTimes            - Number of times.
    * @param  {Number} timing                 - Autoplay interval.
    * @param  {Boolean} loop                  - Gives the slider a seamless infinite loop.
    * @param  {Element} slider                 - Selector of the slider .
    * @param  {String} countTotalID           - Total number ID or class of counter.
    * @param  {String} countCurID             - Current number ID or class of counter.
    * @param  {String} paginationID           - Navigation ID for paging control of each slide.
    * @param  {String} arrowsID               - Previous/Next arrow navigation ID.
    * @return {Void}                          - The constructor.
    */


    function sliderAutoPlay(playTimes, timing, loop, slider, countTotalID, countCurID, paginationID, arrowsID) {
      var items = slider.find('.uix-advanced-slider-sp__item'),
          total = items.length;
      slider[0].animatedSlides = setInterval(function () {
        playTimes = parseFloat(items.filter('.is-active').index());
        playTimes++;

        if (!loop) {
          if (playTimes < total && playTimes >= 0) sliderUpdates(playTimes, slider, 'next', countTotalID, countCurID, paginationID, arrowsID, loop);
        } else {
          if (playTimes == total) playTimes = 0;
          if (playTimes < 0) playTimes = total - 1; //Prevent problems with styles when switching in positive order

          if (playTimes == 0) {
            sliderUpdates(playTimes, slider, 'prev', countTotalID, countCurID, paginationID, arrowsID, loop);
          } else {
            sliderUpdates(playTimes, slider, 'next', countTotalID, countCurID, paginationID, arrowsID, loop);
          }
        }
      }, timing);
    }
    /*
     * Initialize all the items to the stage
     *
     * @param  {Element} slider                 - Current selector of each slider.
     * @param  {Number} nativeItemW            - Returns the intrinsic width of the image/video.
     * @param  {Number} nativeItemH            - Returns the intrinsic height of the image/video.
           * @param  {String} paginationID           - Navigation ID for paging control of each slide.
           * @param  {String} arrowsID               - Previous/Next arrow navigation ID.
           * @param  {Boolean} loop                  - Gives the slider a seamless infinite loop. 
           * @param  {Boolean} draggable             - Allow drag and drop on the slider.
           * @param  {String} draggableCursor        - Drag & Drop Change icon/cursor while dragging.
           * @param  {String} countTotalID           - Total number ID or class of counter.
           * @param  {String} countCurID             - Current number ID or class of counter.
           * @param  {String} filterTexture          - The texture used for the displacement map.
     * @return {Void}
     */


    function addItemsToStage(slider, nativeItemW, nativeItemH, paginationID, arrowsID, loop, draggable, draggableCursor, countTotalID, countCurID, filterTexture) {
      var $this = slider,
          $items = $this.find('.uix-advanced-slider-sp__item'),
          $first = $items.first(),
          itemsTotal = $items.length; //If arrows does not exist on the page, it will be added by default, 
      //and the drag and drop function will be activated.

      if ($(arrowsID).length == 0) {
        $('body').prepend('<div style="display:none;" class="uix-advanced-slider-sp__arrows ' + arrowsID.replace('#', '').replace('.', '') + '"><a href="#" class="uix-advanced-slider-sp__arrows--prev"></a><a href="#" class="uix-advanced-slider-sp__arrows--next"></a></div>');
      } //Add identifiers for the first and last items


      $items.last().addClass('last');
      $items.first().addClass('first'); //Prevent bubbling

      if (itemsTotal == 1) {
        $(paginationID).hide();
        $(arrowsID).hide();
      }

      if (Modernizr.webgl) {
        //Load slides to canvas
        //-------------------------------------	
        if ($('#' + rendererCanvasID).length == 0) {
          $this.prepend('<div id="' + rendererOuterID + '" class="uix-advanced-slider-sp__canvas-container"><canvas id="' + rendererCanvasID + '"></canvas></div>');
        } //Save different canvas heights as an array
        //-------------------------------------	


        $this.find('.uix-advanced-slider-sp__item').each(function (index) {
          var $thisItem = $(this);

          if ($thisItem.find('video').length > 0) {
            //Returns the dimensions (intrinsic height and width ) of the video
            var video = document.getElementById($thisItem.find('video').attr('id'));
            var videoURL = $thisItem.find('video source:first').attr('src');
            if ((0,esm_typeof/* default */.Z)(videoURL) === ( true ? "undefined" : 0)) videoURL = $thisItem.attr('src');
            video.addEventListener('loadedmetadata', function (e) {
              var curW = this.videoWidth,
                  curH = this.videoHeight,
                  newW = curW,
                  newH = curH;
              newW = $this.width(); //Scaled/Proportional Content 

              newH = curH * (newW / curW); //Save different canvas heights as an array

              if (canvasHeights.length < itemsTotal) {
                canvasHeights.push(newH);
              }
            }, false);
            video.src = videoURL;
          } else {
            var imgURL = $thisItem.find('img').attr('src'),
                imgCur = new Image();

            imgCur.onload = function () {
              var curW_img = this.width,
                  curH_img = this.height,
                  newW_img = curW_img,
                  newH_img = curH_img;
              newW_img = $this.width(); //Scaled/Proportional Content 

              newH_img = curH_img * (newW_img / curW_img); //Save different canvas heights as an array

              if (canvasHeights.length < itemsTotal) {
                canvasHeights.push(newH_img);
              }
            };

            imgCur.src = imgURL;
          }
        }); //$this.find( '.uix-advanced-slider-sp__item' ).each
        //Basic webGL renderers 
        //-------------------------------------

        renderer = new PIXI.Application({
          width: $this.width(),
          height: $this.height(),
          transparent: true,
          antialias: true,
          autoResize: true,
          view: document.getElementById(rendererCanvasID)
        });
        renderer__filter = new PIXI.autoDetectRenderer({
          width: $this.width(),
          height: $this.height(),
          transparent: true,
          view: document.getElementById(rendererCanvasID__filter)
        }); //
        //

        stage__filter = new PIXI.Container();
        container__items = new PIXI.Container();
        displacementSprite = /^.*\.(avi|AVI|wmv|WMV|flv|FLV|mpg|MPG|mp4|MP4)/.test(filterTexture) ? new PIXI.Sprite(PIXI.Texture.from(filterTexture)) : new PIXI.Sprite.from(filterTexture);
        displacementFilter = new PIXI.filters.DisplacementFilter(displacementSprite); //----------------------------------------------------------------------------------
        //--------------------------------- Brightness Effect -------------------------------	
        //----------------------------------------------------------------------------------
        //Usage of returning sprite object: renderer.stage.children[index]

        if ($this.hasClass('uix-advanced-slider-sp--eff-brightness')) {
          $this.find('.uix-advanced-slider-sp__item').each(function (index) {
            var $thisItem = $(this); //Load sprite from each slider to canvas
            //-------------------------------------

            var curSprite;

            if ($thisItem.find('video').length > 0) {
              // create a video texture from a path
              var videoURL = $thisItem.find('source:first').attr('src');
              if ((0,esm_typeof/* default */.Z)(videoURL) === ( true ? "undefined" : 0)) videoURL = $thisItem.attr('src');
              var texture = PIXI.Texture.from(videoURL);
              curSprite = new PIXI.Sprite(texture); // pause the video

              var videoSource = texture.baseTexture.resource.source;
              videoSource.autoplay = false;
              videoSource.pause();
              videoSource.currentTime = 0;
              videoSource.muted = true; //Returns the dimensions (intrinsic height and width ) of the video

              var video = document.getElementById($thisItem.find('video').attr('id'));
              video.addEventListener('loadedmetadata', function (e) {
                //At the same time change the height of the canvas
                renderer.view.style.width = $this.width() + 'px';
                renderer.view.style.height = canvasHeights[index] + 'px';
              }, false);
              video.src = videoURL;
            } else {
              var imgURL = $thisItem.find('img').attr('src'),
                  imgCur = new Image();
              curSprite = new PIXI.Sprite.from(imgURL);

              imgCur.onload = function () {
                //At the same time change the height of the canvas
                renderer.view.style.width = $this.width() + 'px';
                renderer.view.style.height = canvasHeights[index] + 'px';
              };

              imgCur.src = imgURL;
            } // center the sprite's anchor point


            curSprite.anchor.set(0); // sprite size

            curSprite.width = renderer.view.width;
            curSprite.height = renderer.view.height; //Avoid error texture rendering errors ***!Important***

            TweenMax.set(curSprite, {
              alpha: 0
            }); //Render updated scene
            //-------------------------------------   

            renderer.stage.addChild(curSprite);
          }); //Initialize the default height of canvas
          //-------------------------------------	

          setTimeout(function () {
            canvasDefaultInit($this, $first);
          }, animSpeed);
        } // end effect
        //----------------------------------------------------------------------------------
        //--------------------------------- Liquid Distortion Effect -----------------------
        //----------------------------------------------------------------------------------
        //Usage of returning sprite object: container__items.children[index]


        if ($this.hasClass('uix-advanced-slider-sp--eff-liquid')) {
          $this.find('.uix-advanced-slider-sp__item').each(function (index) {
            var $thisItem = $(this); //Load sprite from each slider to canvas
            //-------------------------------------

            var curSprite,
                canvasRatio = $this.width() / nativeItemW;

            if ($thisItem.find('video').length > 0) {
              // create a video texture from a path
              var videoURL = $thisItem.find('source:first').attr('src');
              if ((0,esm_typeof/* default */.Z)(videoURL) === ( true ? "undefined" : 0)) videoURL = $thisItem.attr('src');
              var texture = PIXI.Texture.from(videoURL);
              curSprite = new PIXI.Sprite(texture); // pause the video

              var videoSource = texture.baseTexture.resource.source;
              videoSource.autoplay = false;
              videoSource.pause();
              videoSource.currentTime = 0;
              videoSource.muted = true; //Returns the dimensions (intrinsic height and width ) of the video

              var video = document.getElementById($thisItem.find('video').attr('id'));
              video.addEventListener('loadedmetadata', function (e) {
                //At the same time change the height of the canvas
                renderer.view.style.width = $this.width() + 'px';
                renderer.view.style.height = canvasHeights[index] + 'px';
              }, false);
              video.src = videoURL;
            } else {
              var imgURL = $thisItem.find('img').attr('src'),
                  imgCur = new Image();
              curSprite = new PIXI.Sprite.from(imgURL);

              imgCur.onload = function () {
                //At the same time change the height of the canvas
                renderer.view.style.width = $this.width() + 'px';
                renderer.view.style.height = canvasHeights[index] + 'px';
              };

              imgCur.src = imgURL;
            } // center the sprite's anchor point


            curSprite.anchor.set(0); // sprite size

            curSprite.width = renderer.view.width;
            curSprite.height = renderer.view.height; //Need to scale according to the screen

            curSprite.scale.set(canvasRatio); //Render updated scene
            //-------------------------------------   

            container__items.addChild(curSprite); //Add child container to the main container 
            //-------------------------------------

            stage__filter.addChild(container__items); // Enable Interactions

            stage__filter.interactive = true; //Set the filter to stage and set some default values for the animation
            //-------------------------------------
            //A texture stores the information that represents an image

            displacementSprite.texture.baseTexture.wrapMode = PIXI.WRAP_MODES.REPEAT;
            stage__filter.filters = [displacementFilter]; //Add filter container to the main container
            //-------------------------------------				

            displacementSprite.anchor.set(0.5);
            displacementSprite.x = renderer__filter.width / 2;
            displacementSprite.y = renderer__filter.height / 2;
            displacementSprite.scale.x = 1;
            displacementSprite.scale.y = 1; // PIXI tries to fit the filter bounding box to the renderer so we optionally bypass

            displacementFilter.autoFit = false;
            stage__filter.addChild(displacementSprite); //Animation Effects
            //-------------------------------------

            var ticker = new PIXI.Ticker();
            ticker.autoStart = true;
            ticker.add(function (delta) {
              // Render updated scene
              renderer__filter.render(stage__filter);
            });
          }); //Initialize the default height of canvas
          //-------------------------------------	

          setTimeout(function () {
            canvasDefaultInit($this, $first);
          }, animSpeed);
        } // end effect
        //----------------------------------------------------------------------------------
        //--------------------------------- Liquid Distortion Effect 2 -----------------------
        //----------------------------------------------------------------------------------
        //Usage of returning sprite object: container__items.children[index]


        if ($this.hasClass('uix-advanced-slider-sp--eff-liquid2')) {
          $this.find('.uix-advanced-slider-sp__item').each(function (index) {
            var $thisItem = $(this); //Load sprite from each slider to canvas
            //-------------------------------------

            var curSprite,
                canvasRatio = $this.width() / nativeItemW;

            if ($thisItem.find('video').length > 0) {
              // create a video texture from a path
              var videoURL = $thisItem.find('source:first').attr('src');
              if ((0,esm_typeof/* default */.Z)(videoURL) === ( true ? "undefined" : 0)) videoURL = $thisItem.attr('src');
              var texture = PIXI.Texture.from(videoURL);
              curSprite = new PIXI.Sprite(texture); // pause the video

              var videoSource = texture.baseTexture.resource.source;
              videoSource.autoplay = false;
              videoSource.pause();
              videoSource.currentTime = 0;
              videoSource.muted = true; //Returns the dimensions (intrinsic height and width ) of the video

              var video = document.getElementById($thisItem.find('video').attr('id'));
              video.addEventListener('loadedmetadata', function (e) {
                //At the same time change the height of the canvas
                renderer.view.style.width = $this.width() + 'px';
                renderer.view.style.height = canvasHeights[index] + 'px';
              }, false);
              video.src = videoURL;
            } else {
              var imgURL = $thisItem.find('img').attr('src'),
                  imgCur = new Image();
              curSprite = new PIXI.Sprite.from(imgURL);

              imgCur.onload = function () {
                //At the same time change the height of the canvas
                renderer.view.style.width = $this.width() + 'px';
                renderer.view.style.height = canvasHeights[index] + 'px';
              };

              imgCur.src = imgURL;
            } // center the sprite's anchor point


            curSprite.anchor.set(0); // sprite size

            curSprite.width = renderer.view.width;
            curSprite.height = renderer.view.height; //Need to scale according to the screen

            curSprite.scale.set(canvasRatio); //Avoid error texture rendering errors ***!Important***

            TweenMax.set(curSprite, {
              alpha: 0
            }); //Render updated scene
            //-------------------------------------   

            container__items.addChild(curSprite); //Add child container to the main container 
            //-------------------------------------

            stage__filter.addChild(container__items); // Enable Interactions

            stage__filter.interactive = true; //Set the filter to stage and set some default values for the animation
            //-------------------------------------
            //A texture stores the information that represents an image

            displacementSprite.texture.baseTexture.wrapMode = PIXI.WRAP_MODES.CLAMP;
            stage__filter.filters = [displacementFilter]; //Add filter container to the main container
            //-------------------------------------				

            displacementSprite.anchor.set(0.5);
            displacementSprite.x = renderer__filter.width / 2;
            displacementSprite.y = renderer__filter.height / 2; // PIXI tries to fit the filter bounding box to the renderer so we optionally bypass

            displacementFilter.autoFit = false;
            stage__filter.addChild(displacementSprite); //Animation Effects
            //-------------------------------------

            var ticker = new PIXI.Ticker();
            ticker.autoStart = true;
            ticker.add(function (delta) {
              // Render updated scene
              renderer__filter.render(stage__filter);
            });
          }); //Initialize the default height of canvas
          //-------------------------------------	

          setTimeout(function () {
            canvasDefaultInit($this, $first);
          }, animSpeed);
        } // end effect
        //----------------------------------------------------------------------------------
        //--------------------------------- Liquid Distortion Effect 3 -----------------------
        //----------------------------------------------------------------------------------
        //Usage of returning sprite object: container__items.children[index]


        if ($this.hasClass('uix-advanced-slider-sp--eff-liquid3')) {
          $this.find('.uix-advanced-slider-sp__item').each(function (index) {
            var $thisItem = $(this); //Load sprite from each slider to canvas
            //-------------------------------------

            var curSprite,
                canvasRatio = $this.width() / nativeItemW;

            if ($thisItem.find('video').length > 0) {
              // create a video texture from a path
              var videoURL = $thisItem.find('source:first').attr('src');
              if ((0,esm_typeof/* default */.Z)(videoURL) === ( true ? "undefined" : 0)) videoURL = $thisItem.attr('src');
              var texture = PIXI.Texture.from(videoURL);
              curSprite = new PIXI.Sprite(texture); // pause the video

              var videoSource = texture.baseTexture.resource.source;
              videoSource.autoplay = false;
              videoSource.pause();
              videoSource.currentTime = 0;
              videoSource.muted = true; //Returns the dimensions (intrinsic height and width ) of the video

              var video = document.getElementById($thisItem.find('video').attr('id'));
              video.addEventListener('loadedmetadata', function (e) {
                //At the same time change the height of the canvas
                renderer.view.style.width = $this.width() + 'px';
                renderer.view.style.height = canvasHeights[index] + 'px';
              }, false);
              video.src = videoURL;
            } else {
              var imgURL = $thisItem.find('img').attr('src'),
                  imgCur = new Image();
              curSprite = new PIXI.Sprite.from(imgURL);

              imgCur.onload = function () {
                //At the same time change the height of the canvas
                renderer.view.style.width = $this.width() + 'px';
                renderer.view.style.height = canvasHeights[index] + 'px';
              };

              imgCur.src = imgURL;
            } // center the sprite's anchor point


            curSprite.anchor.set(0); // sprite size

            curSprite.width = renderer.view.width;
            curSprite.height = renderer.view.height; //Need to scale according to the screen

            curSprite.scale.set(canvasRatio); //Avoid error texture rendering errors ***!Important***

            TweenMax.set(curSprite, {
              alpha: 0
            }); //Render updated scene
            //-------------------------------------   

            container__items.addChild(curSprite); //Add child container to the main container 
            //-------------------------------------

            stage__filter.addChild(container__items); // Enable Interactions

            stage__filter.interactive = true; //Set the filter to stage and set some default values for the animation
            //-------------------------------------
            //A texture stores the information that represents an image

            displacementSprite.texture.baseTexture.wrapMode = PIXI.WRAP_MODES.REPEAT;
            stage__filter.filters = [displacementFilter]; //Add filter container to the main container
            //-------------------------------------				

            displacementSprite.anchor.set(0.5);
            displacementSprite.x = renderer__filter.width / 2;
            displacementSprite.y = renderer__filter.height / 2; // PIXI tries to fit the filter bounding box to the renderer so we optionally bypass

            displacementFilter.autoFit = false;
            stage__filter.addChild(displacementSprite); //Animation Effects
            //-------------------------------------

            var ticker = new PIXI.Ticker();
            ticker.autoStart = true;
            ticker.add(function (delta) {
              //Need the displacementSprite.texture.baseTexture.wrapMode is "PIXI.WRAP_MODES.REPEAT"
              displacementSprite.x += 1 * delta;
              displacementSprite.y += 0.3; // Render updated scene

              renderer__filter.render(stage__filter);
            });
          }); //Initialize the default height of canvas
          //-------------------------------------	

          setTimeout(function () {
            canvasDefaultInit($this, $first);
          }, animSpeed);
        } // end effect
        //----------------------------------------------------------------------------------
        //--------------------------------- Parallax Effect -------------------------------
        //----------------------------------------------------------------------------------
        //Usage of returning sprite object: container__items.children[index]


        if ($this.hasClass('uix-advanced-slider-sp--eff-parallax')) {
          $this.find('.uix-advanced-slider-sp__item').each(function (index) {
            var $thisItem = $(this); //Load sprite from each slider to canvas
            //-------------------------------------

            var curSprite,
                canvasRatio = $this.width() / nativeItemW;

            if ($thisItem.find('video').length > 0) {
              // create a video texture from a path
              var videoURL = $thisItem.find('source:first').attr('src');
              if ((0,esm_typeof/* default */.Z)(videoURL) === ( true ? "undefined" : 0)) videoURL = $thisItem.attr('src');
              var texture = PIXI.Texture.from(videoURL);
              curSprite = new PIXI.Sprite(texture); // pause the video

              var videoSource = texture.baseTexture.resource.source;
              videoSource.autoplay = false;
              videoSource.pause();
              videoSource.currentTime = 0;
              videoSource.muted = true; //Returns the dimensions (intrinsic height and width ) of the video

              var video = document.getElementById($thisItem.find('video').attr('id'));
              video.addEventListener('loadedmetadata', function (e) {
                //At the same time change the height of the canvas
                renderer.view.style.width = $this.width() + 'px';
                renderer.view.style.height = canvasHeights[index] + 'px';
              }, false);
              video.src = videoURL;
            } else {
              var imgURL = $thisItem.find('img').attr('src'),
                  imgCur = new Image();
              curSprite = new PIXI.Sprite.from(imgURL);

              imgCur.onload = function () {
                //At the same time change the height of the canvas
                renderer.view.style.width = $this.width() + 'px';
                renderer.view.style.height = canvasHeights[index] + 'px';
              };

              imgCur.src = imgURL;
            } // center the sprite's anchor point


            curSprite.anchor.set(0); // sprite size

            curSprite.width = renderer.view.width;
            curSprite.height = renderer.view.height; //Need to scale according to the screen

            curSprite.scale.set(canvasRatio); //Avoid error texture rendering errors ***!Important***

            TweenMax.set(curSprite, {
              alpha: 0
            }); //Render updated scene
            //-------------------------------------   

            container__items.addChild(curSprite); //Add child container to the main container 
            //-------------------------------------

            stage__filter.addChild(container__items); // Enable Interactions

            stage__filter.interactive = true; // Create mask
            //-------------------------------------
            //current mask

            var curSpriteMask = new PIXI.Graphics();
            curSpriteMask.lineStyle(0);
            curSpriteMask.beginFill(0xFFFFFF);
            curSpriteMask.moveTo(0, 0);
            curSpriteMask.lineTo(renderer.view.width, 0);
            curSpriteMask.lineTo(renderer.view.width, renderer.view.height);
            curSpriteMask.lineTo(0, renderer.view.height);
            curSpriteMask.endFill();
            curSpriteMask.position.x = 0;
            curSpriteMask.position.y = 0;
            curSprite.mask = curSpriteMask;
            stage__filter.addChild(curSpriteMask); //Do not add to the container
            //Animation Effects
            //-------------------------------------

            var ticker = new PIXI.Ticker();
            ticker.autoStart = true;
            ticker.add(function (delta) {
              // Render updated scene
              renderer__filter.render(stage__filter);
            });
          }); //Initialize the default height of canvas
          //-------------------------------------	

          setTimeout(function () {
            canvasDefaultInit($this, $first);
          }, animSpeed);
        } // end effect
        //Canvas Interactions
        //-------------------------------------


        transitionInteractions(0, itemsTotal - 1, $this, 'in', 'next');
      } // Fires local videos asynchronously with slider switch.
      //-------------------------------------


      if (!Modernizr.webgl) normalSliderVideoInit($items, false); //Pagination dots 
      //-------------------------------------	

      var _dot = '',
          _dotActive = '';
      _dot += '<ul>';

      for (var i = 0; i < itemsTotal; i++) {
        _dotActive = i == 0 ? 'class="is-active"' : '';
        _dot += '<li><a ' + _dotActive + ' data-index="' + i + '" href="javascript:"></a></li>';
      }

      _dot += '</ul>';
      if ($(paginationID).html() == '') $(paginationID).html(_dot);
      $(paginationID).find('li a').off('click').on('click', function (e) {
        e.preventDefault(); //Prevent buttons' events from firing multiple times

        var $btn = $(this);
        if ($btn.attr('aria-disabled') == 'true') return false;
        $(paginationID).find('li a').attr('aria-disabled', 'true');
        $(paginationID).find('li a').delay(animSpeed).queue(function (next) {
          $(paginationID).find('li a').attr('aria-disabled', 'false');
          next();
        }); //

        if (!$(this).hasClass('is-active')) {
          //Determine the direction
          var curDir = 'prev';

          if ($(this).attr('data-index') > parseFloat($items.filter('.is-active').index())) {
            curDir = 'next';
          } //Canvas Interactions


          transitionInteractions($items.filter('.is-active').index(), $items.filter('.leave').index(), $this, 'out', curDir); //Update the current and previous/next items

          sliderUpdates($(this).attr('data-index'), $this, curDir, countTotalID, countCurID, paginationID, arrowsID, loop); //Pause the auto play event

          clearInterval($this[0].animatedSlides);
        }
      }); //Next/Prev buttons
      //-------------------------------------		

      var _prev = $(arrowsID).find('.uix-advanced-slider-sp__arrows--prev'),
          _next = $(arrowsID).find('.uix-advanced-slider-sp__arrows--next');

      $(arrowsID).find('a').attr('href', 'javascript:');
      $(arrowsID).find('a').removeClass('is-disabled');

      if (!loop) {
        _prev.addClass('is-disabled');
      }

      _prev.off('click').on('click', function (e) {
        e.preventDefault(); //Pause the auto play event

        clearInterval($this[0].animatedSlides); //Move animation

        prevMove();
      });

      _next.off('click').on('click', function (e) {
        e.preventDefault(); //Pause the auto play event

        clearInterval($this[0].animatedSlides); //Move animation

        nextMove();
      });

      function prevMove() {
        //Prevent buttons' events from firing multiple times
        if (_prev.attr('aria-disabled') == 'true') return false;

        _prev.attr('aria-disabled', 'true');

        _prev.delay(animSpeed).queue(function (next) {
          _prev.attr('aria-disabled', 'false');

          next();
        }); //


        if (_prev.hasClass('is-disabled')) return false; //Canvas Interactions

        transitionInteractions($items.filter('.is-active').index(), $items.filter('.leave').index(), $this, 'out', 'prev'); //Update the current and previous items

        sliderUpdates(parseFloat($items.filter('.is-active').index()) - 1, $this, 'prev', countTotalID, countCurID, paginationID, arrowsID, loop);
      }

      function nextMove() {
        //Prevent buttons' events from firing multiple times
        if (_next.attr('aria-disabled') == 'true') return false;

        _next.attr('aria-disabled', 'true');

        _next.delay(animSpeed).queue(function (next) {
          _next.attr('aria-disabled', 'false');

          next();
        }); //


        if (_next.hasClass('is-disabled')) return false; //Canvas Interactions

        transitionInteractions($items.filter('.is-active').index(), $items.filter('.leave').index(), $this, 'out', 'next'); //Update the current and next items

        sliderUpdates(parseFloat($items.filter('.is-active').index()) + 1, $this, 'next', countTotalID, countCurID, paginationID, arrowsID, loop);
      } //Added touch method to mobile device and desktop
      //-------------------------------------	


      var $dragTrigger = $this.find('.uix-advanced-slider-sp__inner');
      var mouseX, mouseY;
      var isMoving = false; //Avoid images causing mouseup to fail

      $dragTrigger.find('img').css({
        'pointer-events': 'none',
        'user-select': 'none'
      }); //Make the cursor a move icon when a user hovers over an item

      if (draggable && draggableCursor != '' && draggableCursor != false) $dragTrigger.css('cursor', draggableCursor); //draggable for touch devices

      if (Modernizr.touchevents) draggable = true;

      if (draggable) {
        $dragTrigger[0].removeEventListener('mousedown', dragStart);
        document.removeEventListener('mouseup', dragEnd);
        $dragTrigger[0].removeEventListener('touchstart', dragStart);
        document.removeEventListener('touchend', dragEnd); //

        $dragTrigger[0].addEventListener('mousedown', dragStart);
        $dragTrigger[0].addEventListener('touchstart', dragStart);
      }

      function dragStart(e) {
        //Do not use "e.preventDefault()" to avoid prevention page scroll on drag in IOS and Android
        var touches = e.touches;

        if (touches && touches.length) {
          mouseX = touches[0].clientX;
          mouseY = touches[0].clientY;
        } else {
          mouseX = e.clientX;
          mouseY = e.clientY;
        }

        document.addEventListener('mouseup', dragEnd);
        document.addEventListener('mousemove', dragProcess);
        document.addEventListener('touchend', dragEnd);
        document.addEventListener('touchmove', dragProcess);
      }

      function dragProcess(e) {
        var touches = e.touches;
        var offsetX, offsetY;

        if (touches && touches.length) {
          offsetX = mouseX - touches[0].clientX, offsetY = mouseY - touches[0].clientY;
        } else {
          offsetX = mouseX - e.clientX, offsetY = mouseY - e.clientY;
        } //--- left


        if (offsetX >= 50) {
          if (!isMoving) {
            isMoving = true;
            nextMove();
          }
        } //--- right


        if (offsetX <= -50) {
          if (!isMoving) {
            isMoving = true;
            prevMove();
          }
        } //--- up


        if (offsetY >= 50) {} //--- down


        if (offsetY <= -50) {}
      }

      function dragEnd(e) {
        document.removeEventListener('mousemove', dragProcess);
        document.removeEventListener('touchmove', dragProcess); //restore move action status

        setTimeout(function () {
          isMoving = false;
        }, animSpeed);
      }
    }
    /*
     * Transition Between Slides
     *
     * @param  {Number} elementIndex           - Index of current slider.
     * @param  {Element} slider                 - Selector of the slider .
     * @param  {String} dir                    - Switching direction indicator.
           * @param  {String} countTotalID           - Total number ID or class of counter.
           * @param  {String} countCurID             - Current number ID or class of counter.
           * @param  {String} paginationID           - Navigation ID for paging control of each slide.
           * @param  {String} arrowsID               - Previous/Next arrow navigation ID.
           * @param  {Boolean} loop                  - Gives the slider a seamless infinite loop.
     * @return {Void}
     */


    function sliderUpdates(elementIndex, slider, dir, countTotalID, countCurID, paginationID, arrowsID, loop) {
      var $items = slider.find('.uix-advanced-slider-sp__item'),
          total = $items.length; //Prevent bubbling

      if (total == 1) {
        $(paginationID).hide();
        $(arrowsID).hide();
        return false;
      } //Transition Interception
      //-------------------------------------


      if (loop) {
        if (elementIndex == total) elementIndex = 0;
        if (elementIndex < 0) elementIndex = total - 1;
      } else {
        $(arrowsID).find('a').removeClass('is-disabled');
        if (elementIndex == total - 1) $(arrowsID).find('.uix-advanced-slider-sp__arrows--next').addClass('is-disabled');
        if (elementIndex == 0) $(arrowsID).find('.uix-advanced-slider-sp__arrows--prev').addClass('is-disabled');
      } // To determine if it is a touch screen.
      //-------------------------------------


      if (Modernizr.touchevents) {
        if (elementIndex == total) elementIndex = total - 1;
        if (elementIndex < 0) elementIndex = 0; //Prevent bubbling

        if (!loop) {
          //first item
          if (elementIndex == 0) {
            $(arrowsID).find('.uix-advanced-slider-sp__arrows--prev').addClass('is-disabled');
          } //last item


          if (elementIndex == total - 1) {
            $(arrowsID).find('.uix-advanced-slider-sp__arrows--next').addClass('is-disabled');
          }
        }
      } // call the current item
      //-------------------------------------


      var $current = $items.eq(elementIndex); //Determine the direction and add class to switching direction indicator.
      //-------------------------------------

      var dirIndicatorClass = '';
      if (dir == 'prev') dirIndicatorClass = 'prev';
      if (dir == 'next') dirIndicatorClass = 'next'; //Add transition class to Controls Pagination
      //-------------------------------------

      $(paginationID).find('li a').removeClass('leave');
      $(paginationID).find('li a.is-active').removeClass('is-active').addClass('leave');
      $(paginationID).find('li a[data-index="' + elementIndex + '"]').addClass('is-active').removeClass('leave'); //Add transition class to each item
      //-------------------------------------	

      $items.removeClass('leave prev next');
      $items.addClass(dirIndicatorClass);
      slider.find('.uix-advanced-slider-sp__item.is-active').removeClass('is-active').addClass('leave ' + dirIndicatorClass);
      $current.addClass('is-active ' + dirIndicatorClass).removeClass('leave'); //Display counter
      //-------------------------------------

      $(countTotalID).text(total);
      $(countCurID).text(parseFloat(elementIndex) + 1); // Fires local videos asynchronously with slider switch.
      //-------------------------------------

      if (!Modernizr.webgl) {
        normalSliderVideoInit($items, false);
        normalSliderVideoInit($current, true);
      } //Reset the default height of canvas
      //-------------------------------------	


      setTimeout(function () {
        canvasDefaultInit(slider, $current);
      }, animSpeed); //Canvas Interactions
      //-------------------------------------
      //-- Brightness Effect

      if (slider.hasClass('uix-advanced-slider-sp--eff-brightness')) {} //-- Liquid Distortion Effect


      if (slider.hasClass('uix-advanced-slider-sp--eff-liquid')) {} //-- Liquid Distortion Effect 2


      if (slider.hasClass('uix-advanced-slider-sp--eff-liquid2')) {} //-- Liquid Distortion Effect 3


      if (slider.hasClass('uix-advanced-slider-sp--eff-liquid3')) {} //-- Parallax Effect 


      if (slider.hasClass('uix-advanced-slider-sp--eff-parallax')) {
        if (loop) {
          if (elementIndex == 0) dir = 'prev';
        }
      }

      transitionInteractions(elementIndex, $items.filter('.leave').index(), slider, 'in', dir);
    }
    /*
     * Fixed image width adaptation problem for Advanced Slider (on HTML tag <canvas>)
     *
     * @param  {Number} w                - The width that the canvas will be set.
     * @param  {Number} h                - The height that the canvas will be set.
     * @return {Void}
     */


    function fixCanvasTagSize(w, h) {
      TweenMax.to(['#' + rendererCanvasID, '.uix-advanced-slider-sp__wrapper', '.uix-advanced-slider-sp__inner', '.uix-advanced-slider-sp__canvas-container'], animSpeed / 1000, {
        width: w,
        height: h
      });
    }
    /*
     * Initialize the default height of canvas
     *
           * @param  {Element} slider                 - Selector of the slider .
     * @param  {Element} currentLlement         - Current selector of each slider.
     * @return {Void}
     */


    function canvasDefaultInit(slider, currentLlement) {
      if (currentLlement.find('video').length > 0) {
        //Returns the dimensions (intrinsic height and width ) of the video
        var video = document.getElementById(currentLlement.find('video').attr('id'));
        var videoURL = currentLlement.find('source:first').attr('src');
        if ((0,esm_typeof/* default */.Z)(videoURL) === ( true ? "undefined" : 0)) videoURL = currentLlement.attr('src');
        video.addEventListener('loadedmetadata', function (e) {
          //At the same time change the height of the canvas and slider container
          var h = this.videoHeight * (currentLlement.closest('.uix-advanced-slider__outline').width() / this.videoWidth);

          if (Modernizr.webgl) {
            renderer.view.style.height = h + 'px';
          } //---


          slider.css('height', h + 'px');
        }, false);
        video.src = videoURL;
      } else {
        var imgURL = currentLlement.find('img').attr('src');

        if ((0,esm_typeof/* default */.Z)(imgURL) != ( true ? "undefined" : 0)) {
          var img = new Image();

          img.onload = function () {
            if (Modernizr.webgl) {
              renderer.view.style.height = currentLlement.find('img').height() + 'px';
            } //---


            slider.css('height', currentLlement.closest('.uix-advanced-slider__outline').width() * (this.height / this.width) + 'px');
          };

          img.src = imgURL;
        }
      }
    }
    /*
     * Canvas Transition Interactions
     * @http://pixijs.download/dev/docs/index.html
     *
     * @param  {Number} elementIndex           - Index of current slider.
     * @param  {Number} prevElementIndex       - Index of previous slider.
     * @param  {Element} slider                 - Selector of the slider.
     * @param  {String} goType                 - The type of entry and exit between two items.  
                                                 Optional values: in, out
     * @param  {String} dir                    - Switching direction indicator.	 
     * @return {Void}
     */


    function transitionInteractions(elementIndex, prevElementIndex, slider, goType, dir) {
      if (Modernizr.webgl) {
        var $myRenderer = $('#' + rendererOuterID),
            $current = slider.find('.uix-advanced-slider-sp__item').eq(elementIndex),
            $allItems = slider.find('.uix-advanced-slider-sp__item'),
            imgSel = $current.find('img'),
            curImgURL = imgSel.attr('src'),
            stageW = slider.width(),
            stageH = slider.height(),
            spTotal = slider.find('.uix-advanced-slider-sp__item').length;
        elementIndex = parseFloat(elementIndex);
        prevElementIndex = parseFloat(prevElementIndex); //----------------------------------------------------------------------------------
        //--------------------------------- Brightness Effect -------------------------------	
        //----------------------------------------------------------------------------------

        if (slider.hasClass('uix-advanced-slider-sp--eff-brightness')) {
          //Hide description container of item
          //-------------------------------------
          TweenMax.to($allItems, animSpeed / 1000, {
            alpha: 0
          }); //Display wrapper of canvas (transitions between slides)
          //-------------------------------------	

          if (goType == 'out') {
            //Current item leaving action
            TweenMax.to(renderer.stage.children[elementIndex], animSpeed / 1000, {
              pixi: {
                brightness: 5
              },
              alpha: 1
            });
          } else {
            //Current item entry action
            TweenMax.to($myRenderer, animSpeed / 1000, {
              alpha: 0,
              onComplete: function onComplete() {
                var curSp = renderer.stage.children[elementIndex];
                TweenMax.to(this.target, animSpeed / 1000, {
                  alpha: 1
                }); //display the current item

                for (var k = 0; k < spTotal; k++) {
                  var obj = renderer.stage.children[k];
                  TweenMax.set(obj, {
                    alpha: 0
                  }); //pause all videos

                  if (obj._texture.baseTexture.imageType == null) {
                    var videoSource = obj.texture.baseTexture.resource.source; // play the video

                    videoSource.currentTime = 0;
                    videoSource.autoplay = false;
                    if (Object.prototype.toString.call(videoSource.pause) == '[object Function]') videoSource.pause();
                    videoSource.muted = true;
                  }
                } //play current video


                if (curSp._texture.baseTexture.imageType == null) {
                  var videoSource2 = curSp.texture.baseTexture.resource.source; // play the video

                  videoSource2.currentTime = 0;
                  videoSource2.autoplay = true;
                  if (Object.prototype.toString.call(videoSource2.play) == '[object Function]') videoSource2.play();
                  videoSource2.muted = false;
                } //Reset the height of the canvas when each item is switched
                //Fixed image width adaptation problem for Advanced Slider (on HTML tag <canvas>)
                //console.log( 'width: ' + windowWidth + ' | height: ' + canvasHeights[ elementIndex ] + ' | index: ' + elementIndex );


                fixCanvasTagSize(windowWidth, canvasHeights[elementIndex]); //display filters

                TweenMax.set(curSp, {
                  pixi: {
                    brightness: 5
                  },
                  alpha: 1,
                  onComplete: function onComplete() {
                    TweenMax.to(this.target, animSpeed / 1000, {
                      pixi: {
                        brightness: 1
                      }
                    });
                    TweenMax.to($current, animSpeed / 1000, {
                      alpha: 1
                    });
                  }
                });
              }
            });
          }
        } // end effect
        //----------------------------------------------------------------------------------
        //--------------------------------- Liquid Distortion Effect -----------------------
        //----------------------------------------------------------------------------------


        if (slider.hasClass('uix-advanced-slider-sp--eff-liquid')) {
          //Hide description container of item
          //-------------------------------------
          TweenMax.to($allItems, animSpeed / 1000, {
            alpha: 0
          });
          var curSp = container__items.children[elementIndex],
              prevSp = container__items.children[prevElementIndex]; //Display the current item
          //-------------------------------------

          if (!slider.hasClass('js-init-ok')) {
            for (var k = 0; k < spTotal; k++) {
              var obj = container__items.children[k];
              TweenMax.set(obj, {
                alpha: 0
              });
            } //Avoid repeated initialization


            slider.addClass('js-init-ok');
          } //Display wrapper of canvas (transitions between slides)
          //-------------------------------------	


          if (goType == 'out') {//Current item leaving action
          } else {
            //Video sprite initialization
            //Need to ensure that the video tag exists
            setTimeout(function () {
              for (var _k = 0; _k < spTotal; _k++) {
                var _obj = container__items.children[_k]; //pause all videos

                if (_obj._texture.baseTexture.imageType == null) {
                  var videoSource = _obj.texture.baseTexture.resource.source; // play the video

                  videoSource.currentTime = 0;
                  videoSource.autoplay = false;
                  if (Object.prototype.toString.call(videoSource.pause) == '[object Function]') videoSource.pause();
                  videoSource.muted = true;
                }
              } //play current video


              if (curSp._texture.baseTexture.imageType == null) {
                var videoSource2 = curSp.texture.baseTexture.resource.source; // play the video

                videoSource2.currentTime = 0;
                videoSource2.autoplay = true;
                if (Object.prototype.toString.call(videoSource2.play) == '[object Function]') videoSource2.play();
                videoSource2.muted = false;
              } //Reset the height of the canvas when each item is switched
              //Fixed image width adaptation problem for Advanced Slider (on HTML tag <canvas>)
              //console.log( 'width: ' + windowWidth + ' | height: ' + canvasHeights[ elementIndex ] + ' | index: ' + elementIndex );


              fixCanvasTagSize(windowWidth, canvasHeights[elementIndex]);
            }, 100); //Current item entry action

            var baseTimeline = new TimelineMax({
              onComplete: function onComplete() {
                displacementSprite.scale.set(1);
              },
              onUpdate: function onUpdate() {
                displacementSprite.rotation += baseTimeline.progress() * 0.02;
                displacementSprite.scale.set(baseTimeline.progress() * 3);
              }
            });
            baseTimeline.clear();

            if (baseTimeline.isActive()) {
              return;
            }

            baseTimeline.to(displacementFilter.scale, animSpeed / 1000, {
              x: 300,
              y: 300,
              ease: Power1.easeOut
            }).to(prevSp, animSpeed / 2 / 1000, {
              alpha: 0,
              ease: Power2.easeOut
            }, animSpeed / 3 / 1000).to(curSp, animSpeed / 2 / 1000, {
              alpha: 1,
              ease: Power2.easeOut
            }, animSpeed / 2 / 1000).to(displacementFilter.scale, animSpeed / 1000, {
              x: 0,
              y: 0,
              ease: Power2.easeOut
            }, animSpeed / 2 / 1000).to($current, animSpeed / 1000, {
              alpha: 1,
              ease: Power2.easeOut
            }, 'final'); //Add new ripple each time mouse
            //-------------------------------------

            slider[0].addEventListener("mousedown", function (e) {
              TweenMax.to(displacementFilter.scale, 1, {
                x: "+=" + Math.sin(e.pageX) * 100 + "",
                y: "+=" + Math.cos(e.pageY) * 100 + ""
              });
              rotateSpite();
            });
            slider[0].addEventListener("mouseup", function (e) {
              TweenMax.to(displacementFilter.scale, 1, {
                x: 0,
                y: 0
              });
            });

            var rotateSpite = function rotateSpite() {
              displacementFilter.rotation += 0.001;
            };
          }
        } // end effect
        //----------------------------------------------------------------------------------
        //--------------------------------- Liquid Distortion Effect 2 -----------------------
        //----------------------------------------------------------------------------------


        if (slider.hasClass('uix-advanced-slider-sp--eff-liquid2')) {
          //Hide description container of item
          //-------------------------------------
          TweenMax.to($allItems, animSpeed / 1000, {
            alpha: 0
          }); //Display wrapper of canvas (transitions between slides)
          //-------------------------------------	

          if (goType == 'out') {
            //Current item leaving action
            TweenMax.to(displacementSprite.scale, 1, {
              x: 10
            });
          } else {
            //Current item entry action
            TweenMax.to($myRenderer, animSpeed / 1000, {
              alpha: 0,
              onComplete: function onComplete() {
                var curSp = container__items.children[elementIndex];
                TweenMax.to(this.target, animSpeed / 1000, {
                  alpha: 1
                }); //display the current item

                for (var _k2 = 0; _k2 < spTotal; _k2++) {
                  var _obj2 = container__items.children[_k2];
                  TweenMax.set(_obj2, {
                    alpha: 0
                  }); //pause all videos

                  if (_obj2._texture.baseTexture.imageType == null) {
                    var videoSource = _obj2.texture.baseTexture.resource.source; // play the video

                    videoSource.currentTime = 0;
                    videoSource.autoplay = false;
                    if (Object.prototype.toString.call(videoSource.pause) == '[object Function]') videoSource.pause();
                    videoSource.muted = true;
                  }
                } //play current video


                if (curSp._texture.baseTexture.imageType == null) {
                  var videoSource2 = curSp.texture.baseTexture.resource.source; // play the video

                  videoSource2.currentTime = 0;
                  videoSource2.autoplay = true;
                  if (Object.prototype.toString.call(videoSource2.play) == '[object Function]') videoSource2.play();
                  videoSource2.muted = false;
                } //Reset the height of the canvas when each item is switched
                //Fixed image width adaptation problem for Advanced Slider (on HTML tag <canvas>)
                //console.log( 'width: ' + windowWidth + ' | height: ' + canvasHeights[ elementIndex ] + ' | index: ' + elementIndex );


                fixCanvasTagSize(windowWidth, canvasHeights[elementIndex]); //display filters
                //sprite

                var baseTimeline = new TimelineMax({
                  delay: 0,
                  paused: false,
                  repeat: 0,
                  onRepeat: function onRepeat() {},
                  onComplete: function onComplete() {
                    TweenMax.to(displacementSprite.scale, 1, {
                      x: 1,
                      y: 1
                    });
                    TweenMax.to(displacementSprite, 1, {
                      rotation: 0
                    });
                  },
                  onUpdate: function onUpdate() {
                    displacementSprite.scale.set(baseTimeline.progress() * 13);
                    displacementSprite.rotation += baseTimeline.progress() * 0.02;
                  }
                });
                baseTimeline.clear(); //filter

                baseTimeline.to(displacementFilter.scale, animSpeed / 1000, {
                  y: "+=" + 200 + "",
                  ease: Power3.easeOut
                }).to(curSp, animSpeed / 2 / 1000, {
                  alpha: 1,
                  ease: Power3.easeOut
                }, animSpeed / 2 / 1000).to(displacementFilter.scale, animSpeed / 1000, {
                  y: 0,
                  ease: Power3.easeOut
                }, animSpeed / 2 / 1000).to($current, animSpeed / 1000, {
                  alpha: 1,
                  ease: Power2.easeOut
                }, 'final');
              }
            }); //Add new ripple each time mouse is clicked/mousemoved
            //-------------------------------------

            document.addEventListener("mousemove", function (e) {
              TweenMax.to(displacementFilter.scale, 1, {
                x: e.pageX / 2 + ""
              });
            });
          }
        } // end effect
        //----------------------------------------------------------------------------------
        //--------------------------------- Liquid Distortion Effect 3 -----------------------
        //----------------------------------------------------------------------------------


        if (slider.hasClass('uix-advanced-slider-sp--eff-liquid3')) {
          //Hide description container of item
          //-------------------------------------
          TweenMax.to($allItems, animSpeed / 1000, {
            alpha: 0
          }); //Display wrapper of canvas (transitions between slides)
          //-------------------------------------	

          if (goType == 'out') {
            //Current item leaving action
            TweenMax.to(displacementSprite, 1, {
              x: 23,
              y: 10
            });
          } else {
            //Current item entry action
            TweenMax.to($myRenderer, animSpeed / 1000, {
              alpha: 0,
              onComplete: function onComplete() {
                var curSp = container__items.children[elementIndex];
                TweenMax.to(this.target, animSpeed / 1000, {
                  alpha: 1
                }); //display the current item

                for (var _k3 = 0; _k3 < spTotal; _k3++) {
                  var _obj3 = container__items.children[_k3];
                  TweenMax.set(_obj3, {
                    alpha: 0
                  }); //pause all videos

                  if (_obj3._texture.baseTexture.imageType == null) {
                    var videoSource = _obj3.texture.baseTexture.resource.source; // play the video

                    videoSource.currentTime = 0;
                    videoSource.autoplay = false;
                    if (Object.prototype.toString.call(videoSource.pause) == '[object Function]') videoSource.pause();
                    videoSource.muted = true;
                  }
                } //play current video


                if (curSp._texture.baseTexture.imageType == null) {
                  var videoSource2 = curSp.texture.baseTexture.resource.source; // play the video

                  videoSource2.currentTime = 0;
                  videoSource2.autoplay = true;
                  if (Object.prototype.toString.call(videoSource2.play) == '[object Function]') videoSource2.play();
                  videoSource2.muted = false;
                } //Reset the height of the canvas when each item is switched
                //Fixed image width adaptation problem for Advanced Slider (on HTML tag <canvas>)
                //console.log( 'width: ' + windowWidth + ' | height: ' + canvasHeights[ elementIndex ] + ' | index: ' + elementIndex );


                fixCanvasTagSize(windowWidth, canvasHeights[elementIndex]); //display filters
                //sprite

                var baseTimeline = new TimelineMax({
                  delay: 0,
                  paused: false,
                  repeat: 0,
                  onRepeat: function onRepeat() {},
                  onComplete: function onComplete() {},
                  onUpdate: function onUpdate() {}
                });
                baseTimeline.clear(); //filter

                baseTimeline.to(displacementFilter.scale, animSpeed / 1000, {
                  y: "+=" + 50 + "",
                  ease: Power3.easeOut
                }).to(curSp, animSpeed / 2 / 1000, {
                  alpha: 1,
                  ease: Power3.easeOut
                }, animSpeed / 2 / 1000).to(displacementFilter.scale, animSpeed / 1000, {
                  y: 0,
                  ease: Power3.easeOut
                }, animSpeed / 2 / 1000).to($current, animSpeed / 1000, {
                  alpha: 1,
                  ease: Power2.easeOut
                }, 'final');
              }
            });
          }
        } // end effect
        //----------------------------------------------------------------------------------
        //--------------------------------- Parallax Effect -----------------------------
        //----------------------------------------------------------------------------------


        if (slider.hasClass('uix-advanced-slider-sp--eff-parallax')) {
          //Hide description container of item
          //-------------------------------------
          TweenMax.to($allItems, animSpeed / 1000, {
            alpha: 0
          }); //Prevent text overlap when switching quickly

          $allItems.attr('data-text-eff-enable', 0);
          $current.attr('data-text-eff-enable', 1);
          var curSpParallax = container__items.children[elementIndex],
              prevSpParallax = container__items.children[prevElementIndex]; //Display the current item
          //-------------------------------------

          if (!slider.hasClass('js-init-ok')) {
            for (var m = 0; m < spTotal; m++) {
              var objParallax = container__items.children[m];
              TweenMax.set(objParallax.mask, {
                x: renderer.view.width
              });
            } //Avoid repeated initialization


            slider.addClass('js-init-ok');
          } //Display wrapper of canvas (transitions between slides)
          //-------------------------------------	


          if (goType == 'out') {//Current item leaving action
          } else {
            //Video sprite initialization
            //Need to ensure that the video tag exists
            setTimeout(function () {
              for (var _m = 0; _m < spTotal; _m++) {
                var _obj4 = container__items.children[_m]; //pause all videos

                if (_obj4._texture.baseTexture.imageType == null) {
                  var videoSource = _obj4.texture.baseTexture.resource.source; // play the video

                  videoSource.currentTime = 0;
                  videoSource.autoplay = false;
                  if (Object.prototype.toString.call(videoSource.pause) == '[object Function]') videoSource.pause();
                  videoSource.muted = true;
                }
              } //play current video


              if (curSpParallax._texture.baseTexture.imageType == null) {
                var videoSource2 = curSpParallax.texture.baseTexture.resource.source; // play the video

                videoSource2.currentTime = 0;
                videoSource2.autoplay = true;
                if (Object.prototype.toString.call(videoSource2.play) == '[object Function]') videoSource2.play();
                videoSource2.muted = false;
              } //Reset the height of the canvas when each item is switched
              //Fixed image width adaptation problem for Advanced Slider (on HTML tag <canvas>)
              //console.log( 'width: ' + windowWidth + ' | height: ' + canvasHeights[ elementIndex ] + ' | index: ' + elementIndex );


              fixCanvasTagSize(windowWidth, canvasHeights[elementIndex]);
            }, 100); //Current item entry action

            var restoreX,
                offsetX = renderer.view.width / 6,
                parallaxSpeed = animSpeed / 1000,
                restoreItems = function restoreItems() {
              //restore other items besides the current item
              for (var n = 0; n < spTotal; n++) {
                var _objParallax = container__items.children[n];
                if (elementIndex != n) _objParallax.mask.x = restoreX;
              }
            },
                goNextItem = function goNextItem() {
              // Paralax effect on current slide
              TweenMax.set(curSpParallax, {
                alpha: 1,
                //Avoid error texture rendering errors ***!Important***
                onComplete: function onComplete() {
                  TweenMax.to(this.target, parallaxSpeed, {
                    x: 0,
                    ease: Power2.easeInOut
                  });
                }
              }); // Current Mask animation

              TweenMax.to(curSpParallax.mask, parallaxSpeed, {
                x: 0,
                ease: Power4.easeInOut,
                onComplete: function onComplete() {
                  restoreItems();
                }
              });
              setTimeout(function () {
                //text effect
                if ($.isFunction($.fn.UixTextEff)) {
                  $current.find('[data-text-eff]').each(function (index) {
                    $(document).UixTextEff({
                      selectors: '[data-text-eff="' + $(this).data('text-eff') + '"]',
                      scrollSpy: false
                    });
                  });
                } //Prevent text overlap when switching quickly


                $allItems.each(function () {
                  if ($(this).attr('data-text-eff-enable') == 1) {
                    TweenMax.to($(this), parallaxSpeed, {
                      alpha: 1,
                      delay: parallaxSpeed / 2
                    });
                  } else {
                    TweenMax.to($(this), parallaxSpeed, {
                      alpha: 0,
                      delay: parallaxSpeed / 2
                    });
                  }
                });
              }, parallaxSpeed * 1000 / 2);
            }; // Direction handler


            if (dir == 'next') {
              curSpParallax.x = offsetX;
              curSpParallax.mask.x = renderer.view.width;
              restoreX = renderer.view.width; // Paralax effect on current slide

              TweenMax.to(prevSpParallax, parallaxSpeed, {
                x: -offsetX,
                ease: Power2.easeInOut
              });
            } else {
              curSpParallax.x = -offsetX;
              curSpParallax.mask.x = -(renderer.view.width + curSpParallax.x);
              restoreX = -renderer.view.width; // Paralax effect on previous slide

              TweenMax.to(prevSpParallax, parallaxSpeed, {
                x: offsetX,
                ease: Power2.easeInOut
              }); // Previous Mask animation

              TweenMax.to(prevSpParallax.mask, parallaxSpeed, {
                x: renderer.view.width,
                ease: Power4.easeInOut
              });
            }

            goNextItem();
          }
        } // end effect		

      } else {
        slider.find('.uix-advanced-slider-sp__item canvas').hide();
      }
    }
    /*
     * Initialize embedded local video.
     *
     * @param  {Element} wrapper          - The outermost video container, which can contain multiple videos
     * @param  {Boolean} play            - Forced to trigger pause or play events.
     * @return {Void}
     */


    function normalSliderVideoInit(wrapper, play) {
      wrapper.find('.uix-video__slider').each(function () {
        var $this = $(this);
        var videoWrapperW = $this.closest('.uix-advanced-slider__outline').width(),
            curVideoID = $this.find('video').attr('id') + '-slider-videopush',
            coverPlayBtnID = 'videocover-' + curVideoID,
            $replayBtn = $('#' + curVideoID + '-replay-btn');
        var dataControls = $this.data('embed-video-controls'),
            dataAuto = $this.data('embed-video-autoplay'),
            dataLoop = $this.data('embed-video-loop'),
            dataW = $this.data('embed-video-width'),
            dataH = $this.data('embed-video-height'); //Push a new ID to video
        //Solve the problem that ajax asynchronous loading does not play

        $this.find('.video-js').attr('id', curVideoID);

        if ((0,esm_typeof/* default */.Z)(dataAuto) === ( true ? "undefined" : 0)) {
          dataAuto = true;
        }

        if ((0,esm_typeof/* default */.Z)(dataLoop) === ( true ? "undefined" : 0)) {
          dataLoop = true;
        }

        if ((0,esm_typeof/* default */.Z)(dataControls) === ( true ? "undefined" : 0)) {
          dataControls = false;
        }

        if ((0,esm_typeof/* default */.Z)(dataW) === ( true ? "undefined" : 0) || dataW == 'auto') {
          dataW = videoWrapperW;
        }

        if ((0,esm_typeof/* default */.Z)(dataH) === ( true ? "undefined" : 0) || dataH == 'auto') {
          dataH = videoWrapperW / 1.77777777777778;
        } //Display cover and play buttons when some mobile device browsers cannot automatically play video


        if ($('#' + coverPlayBtnID).length == 0) {
          $('<div id="' + coverPlayBtnID + '" class="uix-video__cover"><span class="uix-video__cover__placeholder" style="background-image:url(' + $this.find('video').attr('poster') + ')"></span><span class="uix-video__cover__playbtn"></span></div>').insertBefore($this);
          var btnEv = Modernizr.touchevents ? 'touchstart' : 'click';
          $('#' + coverPlayBtnID + ' .uix-video__cover__playbtn').on(btnEv, function (e) {
            e.preventDefault();
            myPlayer.play();
            $('#' + coverPlayBtnID).hide();
          });
        } //Add replay button to video 


        if ($replayBtn.length == 0) {
          $this.after('<span class="uix-video__btn-play" id="' + curVideoID + '-replay-btn"></span>');
        } //HTML5 video autoplay on mobile revisited


        if (dataAuto && windowWidth <= 768) {
          $this.find('.video-js').attr({
            'autoplay': 'true',
            'muted': 'true',
            'playsinline': 'true'
          });
        }

        var myPlayer = videojs(curVideoID, {
          width: dataW,
          height: dataH,
          loop: dataLoop,
          autoplay: dataAuto
        }, function onPlayerReady() {
          var initVideo = function initVideo(obj) {
            //Get Video Dimensions
            var curW = obj.videoWidth(),
                curH = obj.videoHeight(),
                newW = curW,
                newH = curH;
            newW = videoWrapperW; //Scaled/Proportional Content 

            newH = curH * (newW / curW);

            if (!isNaN(newW) && !isNaN(newH)) {
              obj.height(newH);
              obj.width(newW);
              $this.css('height', newH);
            } //Show this video wrapper


            $this.css('visibility', 'visible'); //Hide loading effect

            $this.find('.vjs-loading-spinner, .vjs-big-play-button').hide();
          };
          /* ---------  Video initialize */


          this.on('loadedmetadata', function () {
            initVideo(this);
          });
          /* ---------  Display the play button  */

          if (!dataAuto) $this.find('.vjs-big-play-button').show();
          $this.find('.vjs-big-play-button').off('click').on('click', function () {
            $(this).hide();
          });
          /* ---------  Set, tell the player it's in fullscreen  */

          if (dataAuto) {
            //Fix an error of Video auto play is not working in browser
            this.muted(true); //Prevent autoplay error: Uncaught (in promise) DOMException

            var promise = this.play();

            if (promise !== undefined) {
              promise.then(function () {// Autoplay started!
              })["catch"](function (error) {
                // Autoplay was prevented.
                $('#' + coverPlayBtnID).show();
                $('#' + coverPlayBtnID + ' .uix-video__cover__playbtn').show();
                console.log('Autoplay was prevented.');
              });
            }
          }
          /* ---------  Disable control bar play button click */


          if (!dataControls) {
            this.controls(false);
          }
          /* ---------  Determine if the video is auto played from mobile devices  */


          var autoPlayOK = false;
          this.on('timeupdate', function () {
            var duration = this.duration();

            if (duration > 0) {
              autoPlayOK = true;

              if (this.currentTime() > 0) {
                autoPlayOK = true;
                this.off('timeupdate'); //Hide cover and play buttons when the video automatically played

                $('#' + coverPlayBtnID).hide();
              }
            }
          });
          /* ---------  Pause the video when it is not current slider  */

          if (!play) {
            this.pause();
            this.currentTime(0);
          } else {
            //Unmute, because there is interaction, you can turn on the audio.
            this.muted(false);

            if (dataAuto) {
              this.currentTime(0); //Prevent autoplay error: Uncaught (in promise) DOMException

              var _promise = this.play();

              if (_promise !== undefined) {
                _promise.then(function () {// Autoplay started!
                })["catch"](function (error) {
                  // Autoplay was prevented.
                  $('#' + coverPlayBtnID).show();
                  $('#' + coverPlayBtnID + ' .uix-video__cover__playbtn').show();
                  console.log('Autoplay was prevented.');
                });
              } //Hidden replay button


              $replayBtn.hide(); //Should the video go to the beginning when it ends

              this.on('ended', function () {
                if (dataLoop) {
                  this.currentTime(0);
                  this.play();
                } else {
                  //Replay this video
                  this.currentTime(0);
                  $replayBtn.show().off('click').on('click', function (e) {
                    e.preventDefault();
                    this.play();
                    $replayBtn.hide();
                  });
                }
              });
            }
          }
        });
      });
    }
  };

  module.components.pageLoaded.push(module.ADVANCED_SLIDER_FILTER.pageLoaded);
  return /*#__PURE__*/_createClass(function ADVANCED_SLIDER_FILTER() {
    _classCallCheck(this, ADVANCED_SLIDER_FILTER);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/AJAX-push/js/index.js




/* 
 *************************************
 * <!-- Ajax Push Content  -->
 *************************************
 */


var AJAX_PUSH_CONTENT = function (module, $, window, document) {
  if (window.AJAX_PUSH_CONTENT === null) return false;
  module.AJAX_PUSH_CONTENT = module.AJAX_PUSH_CONTENT || {};
  module.AJAX_PUSH_CONTENT.version = '0.1.9';

  module.AJAX_PUSH_CONTENT.documentReady = function ($) {
    // trigger of AJAX request
    var AJAXPageLinks = '[data-ajax-push-content]'; //all images from pages

    var sources = []; //Added timer to prevent page loading errors for a long time

    var timeClockInit;
    /* Need to set it as a global variable for history */

    var ajaxConfig = {
      "container": "#my-ajax-demo-push-container",
      "target": "#my-ajax-demo-target-container",
      "loading": "<div class=\"my-loader\"><span><i class=\"fa fa-spinner fa-spin\"></i> loading <em id=\"app-loading\" data-txt=\"{progress}%\"></em>...</span></div>",
      "method": "POST"
    },
        thisPageTitle = document.title; // The progress of each page load, using global variables to accurately determine

    var loadedProgress = 0; //loading animation

    var loadingAnim = function loadingAnim(per) {
      $('#app-loading').text($('#app-loading').data('txt').replace(/\{progress\}/g, per));
    }; //Click event


    $(document).off('click.AJAX_PUSH_CONTENT').on('click.AJAX_PUSH_CONTENT', AJAXPageLinks, function (event) {
      event.preventDefault(); // The progress of each page load

      loadedProgress = 0; //

      var $this = $(this);
      var curURL = $this.attr('href'),
          config = $this.data('ajax-push-content');

      if ((0,esm_typeof/* default */.Z)(config) == ( true ? "undefined" : 0)) {
        config = ajaxConfig;
      } //The currently URL of link


      if ((0,esm_typeof/* default */.Z)(curURL) === ( true ? "undefined" : 0)) {
        curURL = $this.closest('a').attr('href');
      } //Prevent multiple request on click


      if ($this.data('request-running')) {
        return;
      }

      $this.data('request-running', true); // Modify the URL without reloading the page

      if (history.pushState) {
        history.pushState(null, null, curURL);
      } else {
        location.hash = curURL;
      } //Click on this link element using an AJAX request


      pushAction($(config.container), config.target, config.loading, curURL, config.method, $this);
      return false;
    }); //Detect URL change & Fire click event

    window.addEventListener('popstate', function (e) {
      var eleTarget = null,
          goURL = location.href;
      $(AJAXPageLinks).each(function () {
        //don't use $( this ).attr( 'href' )
        if (this.href === location.href) {
          eleTarget = this;
          goURL = this.href;
        }
      }); //Empty content that does not exist

      if (eleTarget == null) {
        $(AJAXPageLinks).each(function () {
          var curConfig = $(this).data('ajax-push-content');

          if ((0,esm_typeof/* default */.Z)(curConfig) != ( true ? "undefined" : 0)) {
            $(curConfig.container).html('');
          }
        });
      } //Push new content to target container


      var backConfig = $(eleTarget).data('ajax-push-content');

      if ((0,esm_typeof/* default */.Z)(backConfig) != ( true ? "undefined" : 0)) {
        pushAction($(backConfig.container), backConfig.target, backConfig.loading, goURL, backConfig.method, $(eleTarget));
      } // Output history button
      //console.log(  $( eleTarget ).data( 'ajax-push-content' ) );

    });
    /*
     * Move Animation
     *
     * @param  {Element} container       - The target container to which the content will be added.
     * @param  {String|Boolean} target  - The instance ID or class name returned from the callback data. If it is "false", the push content is empty.
     * @param  {String} loading         - Content of loading area.
     * @param  {String} url             - The target URL via AJAX. 
     * @param  {String} method          - The HTTP method to use for the request (e.g. "POST", "GET", "PUT")
     * @param  {?Element|Boolean} btn     - Current trigger button. Avoid button events if "false".
     * @return {Void}
     */

    function pushAction(container, target, loading, url, method, btn) {
      if (container.length == 0) return false;

      if ((0,esm_typeof/* default */.Z)(method) === ( true ? "undefined" : 0) || method == '') {
        method = 'POST';
      } // Add a request or response interceptor


      var axiosInterceptor = axios.interceptors.request.use(function (config) {
        // Do something before request is sent
        //Display loader
        showLoader(container, loading); //

        return config;
      }, function (error) {
        return Promise.reject(error);
      }); // To send data in the application/x-www-form-urlencoded format instead

      var formData = new FormData();
      var defaultPostData = {
        action: 'load_singlepages_ajax_content'
      };

      for (var k in defaultPostData) {
        formData.append(k, defaultPostData[k]);
      } // Create a request event


      axios({
        timeout: 15000,
        method: method,
        url: url,
        data: formData,
        responseType: 'text'
      }).then(function (response) {
        var htmlCode = response.data; //A function to be called if the request succeeds

        var pushContent = !target ? '' : $(htmlCode).find(target).html(); //Display loading image when AJAX call is in progress
        //Remove existing images

        sources = []; //Push all images from page

        $(htmlCode).find('img').each(function () {
          sources.push({
            "url": this.src,
            "id": 'img-' + UixGUID.create(),
            "type": 'img'
          });
        }); //Push all videos from page

        $(htmlCode).find('.uix-video__slider > video').each(function () {
          var _src = $(this).find('source:first').attr('src');

          if ((0,esm_typeof/* default */.Z)(_src) === ( true ? "undefined" : 0)) _src = $(this).attr('src');
          sources.push({
            "url": _src,
            "id": 'video-' + UixGUID.create(),
            "type": 'video'
          });
        }); //Execute after all images have loaded

        var per;
        var perInit = 1;

        if (sources.length == 0) {
          per = 100; //loading animation

          loadingAnim(per); //Remove loader

          hideLoader(container, $(htmlCode).filter('title').text(), btn, htmlCode);
        }

        var loadImages = function loadImages() {
          var promises = [];

          var _loop = function _loop(i) {
            if (sources[i].type == 'img') {
              ///////////
              // IMAGE //
              ///////////   
              promises.push(new Promise(function (resolve, reject) {
                var img = document.createElement("img");
                img.src = sources[i].url;

                img.onload = function (image) {
                  //Compatible with safari and firefox
                  if ((0,esm_typeof/* default */.Z)(image.path) === ( true ? "undefined" : 0)) {
                    return resolve(image.target.currentSrc);
                  } else {
                    return resolve(image.path[0].currentSrc);
                  }
                };
              }).then(textureLoaded));
            } else {
              ///////////
              // VIDEO //
              ///////////    
              promises.push(new Promise(function (resolve, reject) {
                $('#' + sources[i].id).one('loadedmetadata', resolve);
                return resolve(sources[i].url);
              }).then(textureLoaded));
            }
          };

          for (var i = 0; i < sources.length; i++) {
            _loop(i);
          }

          return Promise.all(promises);
        };

        var textureLoaded = function textureLoaded(url) {
          //loading
          per = parseInt(100 * (perInit / sources.length));
          console.log('progress: ' + per + '%');
          if (isNaN(per)) per = 100; // The progress of each page load

          loadedProgress = per; //loading animation

          loadingAnim(per);
          var texture = null;
          perInit++;
          return per;
        };

        var func = function func() {
          ajaxSucceeds(container, pushContent, $(htmlCode).filter('title').text(), btn);
        }; //images loaded
        //Must be placed behind the loadImages()


        loadImages().then(function (images) {
          clearInterval(timeClockInit);
          func();
        }); //Calculating page load time

        var timeLimit = 10,
            timeStart = new Date().getTime(); //Prevent duplicate runs when returning to this page

        if (timeClockInit) {
          clearInterval(timeClockInit);
        }

        timeClockInit = setInterval(function () {
          //Converting milliseconds to minutes and seconds
          var _time = (new Date().getTime() - timeStart) / 1000;

          if (_time >= timeLimit) {
            console.log('Page load timeout!'); //Remove loader

            if (htmlCode.indexOf('<body') >= 0) {
              window.location.href = location.href;
            } else {
              hideLoader(container, $(htmlCode).filter('title').text(), btn, htmlCode);
            } // clear loader event


            clearInterval(timeClockInit);
            func();
          }
        }, 500);
      })["catch"](function (error) {
        if (error.response) {
          // The request was made and the server responded with a status code
          // that falls out of the range of 2xx
          var status = error.response.status;
          console.log(status);
          if (status == 404 || status == 405) window.location.href = url;
        } else if (error.request) {
          // The request was made but no response was received
          // `error.request` is an instance of XMLHttpRequest in the browser and an instance of
          // http.ClientRequest in node.js
          console.log(error.request); //

          window.location.href = url;
        } else {
          // If there was a problem, we need to
          // dispatch the error condition
          console.log(error.message);
        }
      }); // Remove an interceptor later

      axios.interceptors.request.eject(axiosInterceptor);
    }
    /*
     * A function to be called if the request succeeds
     *
     * @param  {String} container    - The target container to which the content will be added.
     * @param  {String} content      - The data returned from the server
     * @param  {String} title        - The title of a requested page.
     * @param  {?Element} btn          - Current trigger button.
     * @return {Void}
     */


    function ajaxSucceeds(container, content, title, btn) {
      //If the page resource is not loaded, then the following code is not executed
      if (loadedProgress < 100) return false; //Remove loader

      hideLoader(container, title, btn, content);
    }
    /*
     * Remove loader
     *
           * @param  {Element} container - The instance returned from the request succeeds
           * @param  {String} title      - The title of a requested page.
     * @param  {?Element} btn      - Current trigger button.
           * @param  {String} content    - The data returned from the server
     * @return {Void}
     */


    function hideLoader(container, title, btn, content) {
      TweenMax.to(container.find('.ajax-content-loader'), 0.5, {
        alpha: 0,
        onComplete: function onComplete() {
          TweenMax.set(this.target, {
            css: {
              'display': 'none'
            }
          }); //The data returned from the server

          container.html(content).promise().done(function () {
            // Apply some asynchronism scripts
            $(document).UixApplyAsyncScripts(); //Change the page title

            if (title) {
              document.title = title;
            } //Prevent multiple request on click


            if (btn) {
              btn.data('request-running', false);
            }
          });
        },
        //Determine the direction of a jQuery scroll event
        //Fix an issue for mousewheel event is too fast.
        delay: 0.5
      });
    }
    /*
     * Display loader
     *
     * @param  {Element} container       - The target container to which the content will be added.
     * @param  {String} loading         - Content of loading area.
     * @return {Void}
     */


    function showLoader(container, loading) {
      TweenMax.to(container.find('.ajax-content-loader'), 0.3, {
        css: {
          opacity: 1
        },
        ease: Power2.easeOut
      });
      container.html('<div class="ajax-content-loader">' + loading + '</div>').promise().done(function () {
        //loading animation
        loadingAnim(0); //loader effect from AJAX request

        TweenMax.set(container.find('.ajax-content-loader'), {
          css: {
            'display': 'block'
          },
          onComplete: function onComplete() {
            TweenMax.to(this.target, 0.5, {
              alpha: 1
            });
          }
        });
      });
    }
  };

  module.components.documentReady.push(module.AJAX_PUSH_CONTENT.documentReady);
  return /*#__PURE__*/_createClass(function AJAX_PUSH_CONTENT() {
    _classCallCheck(this, AJAX_PUSH_CONTENT);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/AJAX/js/index.js




/* 
 *************************************
 * <!-- Ajax Page Loader (Loading A Page via Ajax Into Div)  -->
 *************************************
 */



var AJAX_PAGE_LOADER = function (module, $, window, document) {
  if (window.AJAX_PAGE_LOADER === null) return false;
  module.AJAX_PAGE_LOADER = module.AJAX_PAGE_LOADER || {};
  module.AJAX_PAGE_LOADER.version = '0.2.1';

  module.AJAX_PAGE_LOADER.documentReady = function ($) {
    var windowWidth = window.innerWidth,
        windowHeight = window.innerHeight; //all images from pages

    var sources = []; //Added timer to prevent page loading errors for a long time

    var timeClockInit; //Determine the direction of a jQuery scroll event
    //Fix an issue for mousewheel event is too fast.

    var quietPeriod = 500,
        //Do not change it
    animationTime = 1000,
        //According to page transition animation changes
    loaderRemoveDelay = 500,
        AJAXPageLinks = '[data-ajax-page]',
        $navs = $(AJAXPageLinks).parent().parent().find('li'),
        total = $navs.length,
        $sectionsContainer = $('.uix-ajax-load__fullpage-container'),
        ajaxContainer = '.ajax-container',
        curAjaxPageID = $(ajaxContainer).data('ajax-page-id');
    var lastAnimation = 0; // The progress of each page load, using global variables to accurately determine

    var loadedProgress = 0; //loading animation

    var loadingAnim = function loadingAnim(per) {
      $('#app-loading').text($('#app-loading').data('txt').replace(/\{progress\}/g, per));
    }; //Prevent this module from loading in other pages


    if ($sectionsContainer.length == 0) return false;
    /* 
     ====================================================
     *  Navigation Interaction
     ====================================================
     */
    //Activate the first item

    if ($('.js-uix-ajax-load__container').length == 0) {
      moveTo($(ajaxContainer), false, 'down', 0, false);
    } else {
      //Activate navigation from AJAX request
      if ((0,esm_typeof/* default */.Z)(curAjaxPageID) != ( true ? "undefined" : 0)) $navs.eq(curAjaxPageID).addClass('is-active');
    }
    /* 
     ====================================================
     *  AJAX Interaction
     ====================================================
     */

    /*
     * Initialize the clickable ajax links
     *
     * @return {Void}
     */


    function ajaxInit() {
      if (windowWidth <= 768) {
        $(AJAXPageLinks).data('mobile-running', true);
      } else {
        $(AJAXPageLinks).data('mobile-running', false);
      }
    }

    ajaxInit();

    function windowUpdate() {
      // Check window width has actually changed and it's not just iOS triggering a resize event on scroll
      if (window.innerWidth != windowWidth) {
        // Update the window width for next time
        windowWidth = window.innerWidth; // Do stuff here

        ajaxInit();
      }
    } // Add function to the window that should be resized


    var debounceFuncWindow = UixDebounce(windowUpdate, 50);
    window.removeEventListener('resize', debounceFuncWindow);
    window.addEventListener('resize', debounceFuncWindow);
    /*
     * Call AJAX on click event for "single pages links"
     *
     */

    $(document).off('click.AJAX_PAGE_LOADER').on('click.AJAX_PAGE_LOADER', AJAXPageLinks, function (e) {
      //Prevents third-party plug-ins from triggering
      if ($(this).data('mobile-running')) {
        return;
      }

      e.preventDefault(); // The progress of each page load

      loadedProgress = 0; //

      var $this = $(this);
      var curIndex = $this.attr('data-index');
      var curURL = $this.attr('href'); //The currently URL of link

      if ((0,esm_typeof/* default */.Z)(curURL) === ( true ? "undefined" : 0)) {
        curURL = $this.closest('a').attr('href');
      } //Prevent multiple request on click


      if ($(AJAXPageLinks).data('request-running')) {
        return;
      }

      $(AJAXPageLinks).data('request-running', true); // Modify the URL without reloading the page

      if (history.pushState) {
        history.pushState(null, null, curURL);
      } else {
        location.hash = curURL;
      } //Click on this link element using an AJAX request


      var dir = $navs.filter('.is-active').find('> a').attr('data-index') > curIndex ? 'up' : 'down';
      moveTo($(ajaxContainer), curURL, dir, curIndex, false);
      return false;
    }); //Detect URL change & Fire click event

    window.addEventListener('popstate', function (e) {
      var eleTarget = null,
          goURL = location.href;
      $(AJAXPageLinks).each(function () {
        //don't use $( this ).attr( 'href' )
        if (this.href === location.href) {
          eleTarget = this;
          goURL = this.href;
        }
      }); //Empty content that does not exist

      if (eleTarget == null) {
        moveTo($(ajaxContainer), false, 'down', 0, false);
      } //Push new content to target container


      var pageIndex = $(eleTarget).data('index'); //Push new content to target container

      if ((0,esm_typeof/* default */.Z)(pageIndex) != ( true ? "undefined" : 0)) {
        moveTo($(ajaxContainer), goURL, 'down', pageIndex, false);
      } // Output history button
      //console.log(  $( eleTarget ).data( 'index' ) );

    });
    /*
     * Scroll initialize
     *
     * @param  {Event} event        - The wheel event is fired when a wheel button of a pointing device (usually a mouse) is rotated. 
     * @param  {String} dir          - Gets a value that indicates the amount that the mouse wheel has changed.
     * @return {Void}
     */

    function scrollMoveInit(event, dir) {
      var timeNow = new Date().getTime(); // Cancel scroll if currently animating or within quiet period

      if (timeNow - lastAnimation < quietPeriod + animationTime) {
        return;
      }

      if (dir == 'down') {
        //scroll down
        moveTo($(ajaxContainer), false, 'down', false, true);
      } else {
        //scroll up
        moveTo($(ajaxContainer), false, 'up', false, true);
      }

      lastAnimation = timeNow;
    }
    /*
     * Move Animation
     *
     * @param  {Element} container    - The instance returned from the request succeeds 
     * @param  {String} url          - The target URL via AJAX.
     * @param  {String} dir          - Rolling direction indicator.
     * @param  {Number} customIndex  - User-specified index value, located on the corresponding AJAX hyperlink.
     * @param  {Boolean} wheel       - Whether to enable mouse wheel control.
     * @return {Void}
     */


    function moveTo(container, url, dir, customIndex, wheel) {
      var index = parseFloat($navs.filter('.is-active').find('> a').attr('data-index'));
      var isNumeric = /^[-+]?(\d+|\d+\.\d*|\d*\.\d+)$/;
      var nextIndex = null; //If there is a custom index, it is enabled first

      if (isNumeric.test(customIndex)) {
        nextIndex = customIndex;
      } else {
        if (dir == 'down' || dir === false) {
          nextIndex = index + 1;
        } else {
          nextIndex = index - 1;
        }
      }

      if (nextIndex <= parseFloat(total - 1) && nextIndex >= 0) {
        if (nextIndex > parseFloat(total - 1)) nextIndex = parseFloat(total - 1);
        if (nextIndex < 0) nextIndex = 0; //Prevents third-party plug-ins from triggering

        if ($navs.eq(nextIndex).find('> a').data('mobile-running')) {
          return;
        } //Activate navigation from AJAX request


        $navs.removeClass('is-active');
        $navs.eq(nextIndex).addClass('is-active'); //Use automatic indexing when no URLs come in.

        if (!url || (0,esm_typeof/* default */.Z)(url) === ( true ? "undefined" : 0)) {
          url = $navs.eq(nextIndex).find('> a').attr('href');
        } // Modify the URL without reloading the page when mouse wheel


        if (wheel) {
          var turl = $navs.eq(nextIndex).find('> a').attr('href');

          if (history.pushState) {
            history.pushState(null, null, url);
          } else {
            location.hash = turl;
          }
        } //Click on this link element using an AJAX request
        // Add a request or response interceptor


        var axiosInterceptor = axios.interceptors.request.use(function (config) {
          // Do something before request is sent
          //Display loader
          showLoader(); //

          return config;
        }, function (error) {
          return Promise.reject(error);
        }); // To send data in the application/x-www-form-urlencoded format instead

        var formData = new FormData();
        var defaultPostData = {
          action: 'load_singlepages_ajax_content'
        };

        for (var k in defaultPostData) {
          formData.append(k, defaultPostData[k]);
        }
        /*
        // For multiple form fields data acquisition
        const formData = new FormData();
        const oldFormData = $this.serializeArray();
        oldFormData.forEach(function(item){
            formData.append(item.name, item.value);
        });
        formData.append('action', 'load_singlepages_ajax_content');
        */
        // Create a request event


        axios({
          timeout: 15000,
          method: (0,esm_typeof/* default */.Z)(container.data('ajax-method')) === ( true ? "undefined" : 0) ? 'POST' : container.data('ajax-method'),
          url: url,
          data: formData,
          responseType: 'text'
        }).then(function (response) {
          var htmlCode = response.data; //A function to be called if the request succeeds
          //Display loading image when AJAX call is in progress
          //Remove existing images

          sources = []; //Push all images from page

          $(htmlCode).find('img').each(function () {
            sources.push({
              "url": this.src,
              "id": 'img-' + UixGUID.create(),
              "type": 'img'
            });
          }); //Push all videos from page

          $(htmlCode).find('.uix-video__slider > video').each(function () {
            var _src = $(this).find('source:first').attr('src');

            if ((0,esm_typeof/* default */.Z)(_src) === ( true ? "undefined" : 0)) _src = $(this).attr('src');
            sources.push({
              "url": _src,
              "id": 'video-' + UixGUID.create(),
              "type": 'video'
            });
          }); //Execute after all images have loaded

          var per;
          var perInit = 1;

          if (sources.length == 0) {
            per = 100; //loading animation

            loadingAnim(per); //Remove loader

            var oldContent = container.html();
            hideLoader(container, $(htmlCode).filter('title').text(), dir, oldContent, htmlCode);
          }

          var loadImages = function loadImages() {
            var promises = [];

            var _loop = function _loop(i) {
              if (sources[i].type == 'img') {
                ///////////
                // IMAGE //
                ///////////   
                promises.push(new Promise(function (resolve, reject) {
                  var img = document.createElement("img");
                  img.src = sources[i].url;

                  img.onload = function (image) {
                    //Compatible with safari and firefox
                    if ((0,esm_typeof/* default */.Z)(image.path) === ( true ? "undefined" : 0)) {
                      return resolve(image.target.currentSrc);
                    } else {
                      return resolve(image.path[0].currentSrc);
                    }
                  };
                }).then(textureLoaded));
              } else {
                ///////////
                // VIDEO //
                ///////////    
                promises.push(new Promise(function (resolve, reject) {
                  $('#' + sources[i].id).one('loadedmetadata', resolve);
                  return resolve(sources[i].url);
                }).then(textureLoaded));
              }
            };

            for (var i = 0; i < sources.length; i++) {
              _loop(i);
            }

            return Promise.all(promises);
          };

          var textureLoaded = function textureLoaded(url) {
            //loading
            per = parseInt(100 * (perInit / sources.length));
            console.log('progress: ' + per + '%');
            if (isNaN(per)) per = 100; // The progress of each page load

            loadedProgress = per; //loading animation

            loadingAnim(per);
            var texture = null;
            perInit++;
            return per;
          };

          var func = function func() {
            ajaxSucceeds(dir, container, $(htmlCode).find('.js-uix-ajax-load__container').html(), $(htmlCode).filter('title').text());
          }; //images loaded
          //Must be placed behind the loadImages()


          loadImages().then(function (images) {
            clearInterval(timeClockInit);
            func();
          }); //Calculating page load time

          var timeLimit = 10,
              timeStart = new Date().getTime(); //Prevent duplicate runs when returning to this page

          if (timeClockInit) {
            clearInterval(timeClockInit);
          }

          timeClockInit = setInterval(function () {
            //Converting milliseconds to minutes and seconds
            var _time = (new Date().getTime() - timeStart) / 1000;

            if (_time >= timeLimit) {
              console.log('Page load timeout!'); //Remove loader

              if (htmlCode.indexOf('<body') >= 0) {
                window.location.href = location.href;
              } else {
                var _oldContent = container.html();

                hideLoader(container, $(htmlCode).filter('title').text(), dir, _oldContent, htmlCode);
              } // clear loader event


              clearInterval(timeClockInit);
              func();
            }
          }, 500);
        })["catch"](function (error) {
          if (error.response) {
            // The request was made and the server responded with a status code
            // that falls out of the range of 2xx
            var status = error.response.status;
            console.log(status);
            if (status == 404 || status == 405) window.location.href = url;
          } else if (error.request) {
            // The request was made but no response was received
            // `error.request` is an instance of XMLHttpRequest in the browser and an instance of
            // http.ClientRequest in node.js
            console.log(error.request); //

            window.location.href = url;
          } else {
            // If there was a problem, we need to
            // dispatch the error condition
            console.log(error.message);
          }
        }); // Remove an interceptor later

        axios.interceptors.request.eject(axiosInterceptor);
      }
    }
    /*
     * A function to be called if the request succeeds
     *
     * @param  {String} dir       - Gets a value that indicates the amount that the mouse wheel has changed.
     * @param  {Element} container - The instance returned from the request succeeds
     * @param  {String} content   - The data returned from the server
     * @param  {String} title        - The title of a requested page.
     * @return {Void}
     */


    function ajaxSucceeds(dir, container, content, title) {
      //If the page resource is not loaded, then the following code is not executed
      if (loadedProgress < 100) return false; //Remove loader

      var oldContent = container.html();
      hideLoader(container, title, dir, oldContent, content);
    }
    /*
     * Remove loader
     *
           * @param  {Element} container - The instance returned from the request succeeds
           * @param  {String} title     - The title of a requested page.
     * @param  {String} dir       - Gets a value that indicates the amount that the mouse wheel has changed.
     * @param  {String} oldContent   - The old data returned from the server
           * @param  {String} content   - The data returned from the server
     * @return {Void}
     */


    function hideLoader(container, title, dir, oldContent, content) {
      TweenMax.to('.uix-ajax-load__loader', 0.5, {
        alpha: 0,
        onComplete: function onComplete() {
          TweenMax.set(this.target, {
            css: {
              'display': 'none'
            }
          }); //The data returned from the server

          container.html(content).promise().done(function () {
            //Transition effect between two elements.
            eleTransitionEff(dir, oldContent, content); //Change the page title

            if (title) {
              document.title = title;
            } //Prevent multiple request on click


            $(AJAXPageLinks).data('request-running', false);
          });
        },
        delay: loaderRemoveDelay / 1000
      });
    }
    /*
     * Display loader
     *
     * @return {Void}
     */


    function showLoader() {
      //loading animation
      loadingAnim(0); //loader effect from AJAX request

      TweenMax.set('.uix-ajax-load__loader', {
        css: {
          'display': 'block'
        },
        onComplete: function onComplete() {
          TweenMax.to(this.target, 0.5, {
            alpha: 1
          });
        }
      });
    }
    /*
     * Transition effect between two elements.
     *
     * @param  {String} dir            - Gets a value that indicates the amount that the mouse wheel has changed.
     * @param  {String} oldContent     - A string of HTML to set as the content of matched old element.
     * @param  {String} newContent     - A string of HTML to set as the content of matched new element.
     * @return {Void}
     */


    function eleTransitionEff(dir, oldContent, newContent) {
      var $originalItem = $sectionsContainer.find('> section'),
          $cloneItem = $originalItem.clone(); //Reset the original element

      $originalItem.css({
        'z-index': 1
      }); //Clone the last element to the first position

      $cloneItem.prependTo($sectionsContainer).css({
        'z-index': 2,
        'transform': 'translateY(' + (dir == 'down' || dir === false ? windowHeight : -windowHeight) + 'px)'
      }) //Add the latest content to the new container
      .find(ajaxContainer).html(newContent);
      $originalItem.first().find(ajaxContainer).html(oldContent).promise().done(function () {
        TweenMax.to($originalItem.first(), animationTime / 1000, {
          y: dir == 'down' || dir === false ? -windowHeight / 2 : windowHeight / 2,
          ease: Power2.easeOut
        });
        TweenMax.to($cloneItem, animationTime / 1000, {
          y: 0,
          ease: Power2.easeOut,
          onComplete: function onComplete() {
            //Remove duplicate elements
            $originalItem.first().remove(); // Apply some asynchronism scripts

            $(document).UixApplyAsyncScripts();
          }
        });
      });
    }
    /* 
     ====================================================
     *  Mouse Wheel Method
     ====================================================
     */


    var startY = 0;

    var onTouchStart = function onTouchStart(e) {
      var touches = e.touches;

      if (touches && touches.length) {
        startY = touches[0].pageY;
      }
    };

    var onDeviceWheel = function onDeviceWheel(e) {
      //Gets a value that indicates the amount that the mouse wheel has changed.
      var dir,
          delta,
          mobileDeltaY = null;
      var touches = e.touches;

      if (touches && touches.length) {
        mobileDeltaY = startY - touches[0].pageY;
      } else {
        delta = Math.max(-1, Math.min(1, -e.deltaY));
      }

      if (mobileDeltaY != null) {
        if (mobileDeltaY >= 50) {
          //--- swipe up
          dir = 'up';
        }

        if (mobileDeltaY <= -50) {
          //--- swipe down
          dir = 'down';
        }
      } else {
        if (delta < 0) {
          //scroll down
          dir = 'down';
        } else {
          //scroll up
          dir = 'up';
        }
      }

      scrollMoveInit(e, dir);
    };

    window.addEventListener('wheel', onDeviceWheel, UixBrowser.supportsPassive ? {
      passive: true
    } : false);
    window.addEventListener('touchstart', onTouchStart, UixBrowser.supportsPassive ? {
      passive: true
    } : false);
    window.addEventListener('touchmove', onDeviceWheel, UixBrowser.supportsPassive ? {
      passive: true
    } : false);
  };

  module.components.documentReady.push(module.AJAX_PAGE_LOADER.documentReady);
  return /*#__PURE__*/_createClass(function AJAX_PAGE_LOADER() {
    _classCallCheck(this, AJAX_PAGE_LOADER);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/_third-party-plugins/GSAP/esm/ScrollToPlugin.js


/*!
 * VERSION: 1.9.2
 * DATE: 2019-02-07
 * UPDATES AND DOCS AT: http://greensock.com
 *
 * @license Copyright (c) 2008-2019, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 * 
 * @author: Jack Doyle, jack@greensock.com
 **/

/* eslint-disable */


var _doc = (esm_TweenLite/* _gsScope.document */.ML.document || {}).documentElement,
    _window = esm_TweenLite/* _gsScope */.ML,
    _max = function _max(element, axis) {
  var dim = axis === "x" ? "Width" : "Height",
      scroll = "scroll" + dim,
      client = "client" + dim,
      body = document.body;
  return element === _window || element === _doc || element === body ? Math.max(_doc[scroll], body[scroll]) - (_window["inner" + dim] || _doc[client] || body[client]) : element[scroll] - element["offset" + dim];
},
    _unwrapElement = function _unwrapElement(value) {
  if (typeof value === "string") {
    value = TweenLite.selector(value);
  }

  if (value.length && value !== _window && value[0] && value[0].style && !value.nodeType) {
    value = value[0];
  }

  return value === _window || value.nodeType && value.style ? value : null;
},
    _buildGetter = function _buildGetter(e, axis) {
  //pass in an element and an axis ("x" or "y") and it'll return a getter function for the scroll position of that element (like scrollTop or scrollLeft, although if the element is the window, it'll use the pageXOffset/pageYOffset or the documentElement's scrollTop/scrollLeft or document.body's. Basically this streamlines things and makes a very fast getter across browsers.
  var p = "scroll" + (axis === "x" ? "Left" : "Top");

  if (e === _window) {
    if (e.pageXOffset != null) {
      p = "page" + axis.toUpperCase() + "Offset";
    } else if (_doc[p] != null) {
      e = _doc;
    } else {
      e = document.body;
    }
  }

  return function () {
    return e[p];
  };
},
    _getOffset = function _getOffset(element, container) {
  var rect = _unwrapElement(element).getBoundingClientRect(),
      b = document.body,
      isRoot = !container || container === _window || container === b,
      cRect = isRoot ? {
    top: _doc.clientTop - (window.pageYOffset || _doc.scrollTop || b.scrollTop || 0),
    left: _doc.clientLeft - (window.pageXOffset || _doc.scrollLeft || b.scrollLeft || 0)
  } : container.getBoundingClientRect(),
      offsets = {
    x: rect.left - cRect.left,
    y: rect.top - cRect.top
  };

  if (!isRoot && container) {
    //only add the current scroll position if it's not the window/body.
    offsets.x += _buildGetter(container, "x")();
    offsets.y += _buildGetter(container, "y")();
  }

  return offsets;
  /*	PREVIOUS
  var rect = _unwrapElement(element).getBoundingClientRect(),
  	isRoot = (!container || container === _window || container === document.body),
  	cRect = (isRoot ? _doc : container).getBoundingClientRect(),
  	offsets = {x: rect.left - cRect.left, y: rect.top - cRect.top};
  if (!isRoot && container) { //only add the current scroll position if it's not the window/body.
  	offsets.x += _buildGetter(container, "x")();
  	offsets.y += _buildGetter(container, "y")();
  }
  return offsets;
  */
},
    _parseVal = function _parseVal(value, target, axis, currentVal) {
  var type = (0,esm_typeof/* default */.Z)(value);

  return !isNaN(value) ? parseFloat(value) : type === "string" && value.charAt(1) === "=" ? parseInt(value.charAt(0) + "1", 10) * parseFloat(value.substr(2)) + currentVal : value === "max" ? _max(target, axis) : Math.min(_max(target, axis), _getOffset(value, target)[axis]);
},
    ScrollToPlugin = esm_TweenLite/* _gsScope._gsDefine.plugin */.ML._gsDefine.plugin({
  propName: "scrollTo",
  API: 2,
  global: true,
  version: "1.9.2",
  //called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.
  init: function init(target, value, tween) {
    this._wdw = target === _window;
    this._target = target;
    this._tween = tween;

    if ((0,esm_typeof/* default */.Z)(value) !== "object") {
      value = {
        y: value
      }; //if we don't receive an object as the parameter, assume the user intends "y".

      if (typeof value.y === "string" && value.y !== "max" && value.y.charAt(1) !== "=") {
        value.x = value.y;
      }
    } else if (value.nodeType) {
      value = {
        y: value,
        x: value
      };
    }

    this.vars = value;
    this._autoKill = value.autoKill !== false;
    this.getX = _buildGetter(target, "x");
    this.getY = _buildGetter(target, "y");
    this.x = this.xPrev = this.getX();
    this.y = this.yPrev = this.getY();

    if (value.x != null) {
      this._addTween(this, "x", this.x, _parseVal(value.x, target, "x", this.x) - (value.offsetX || 0), "scrollTo_x", true);

      this._overwriteProps.push("scrollTo_x");
    } else {
      this.skipX = true;
    }

    if (value.y != null) {
      this._addTween(this, "y", this.y, _parseVal(value.y, target, "y", this.y) - (value.offsetY || 0), "scrollTo_y", true);

      this._overwriteProps.push("scrollTo_y");
    } else {
      this.skipY = true;
    }

    return true;
  },
  //called each time the values should be updated, and the ratio gets passed as the only parameter (typically it's a value between 0 and 1, but it can exceed those when using an ease like Elastic.easeOut or Back.easeOut, etc.)
  set: function set(v) {
    this._super.setRatio.call(this, v);

    var x = this._wdw || !this.skipX ? this.getX() : this.xPrev,
        y = this._wdw || !this.skipY ? this.getY() : this.yPrev,
        yDif = y - this.yPrev,
        xDif = x - this.xPrev,
        threshold = ScrollToPlugin.autoKillThreshold;

    if (this.x < 0) {
      //can't scroll to a position less than 0! Might happen if someone uses a Back.easeOut or Elastic.easeOut when scrolling back to the top of the page (for example)
      this.x = 0;
    }

    if (this.y < 0) {
      this.y = 0;
    }

    if (this._autoKill) {
      //note: iOS has a bug that throws off the scroll by several pixels, so we need to check if it's within 7 pixels of the previous one that we set instead of just looking for an exact match.
      if (!this.skipX && (xDif > threshold || xDif < -threshold) && x < _max(this._target, "x")) {
        this.skipX = true; //if the user scrolls separately, we should stop tweening!
      }

      if (!this.skipY && (yDif > threshold || yDif < -threshold) && y < _max(this._target, "y")) {
        this.skipY = true; //if the user scrolls separately, we should stop tweening!
      }

      if (this.skipX && this.skipY) {
        this._tween.kill();

        if (this.vars.onAutoKill) {
          this.vars.onAutoKill.apply(this.vars.onAutoKillScope || this._tween, this.vars.onAutoKillParams || []);
        }
      }
    }

    if (this._wdw) {
      _window.scrollTo(!this.skipX ? this.x : x, !this.skipY ? this.y : y);
    } else {
      if (!this.skipY) {
        this._target.scrollTop = this.y;
      }

      if (!this.skipX) {
        this._target.scrollLeft = this.x;
      }
    }

    this.xPrev = this.x;
    this.yPrev = this.y;
  }
}),
    ScrollToPlugin_p = ScrollToPlugin.prototype;

ScrollToPlugin.max = _max;
ScrollToPlugin.getOffset = _getOffset;
ScrollToPlugin.buildGetter = _buildGetter;
ScrollToPlugin.autoKillThreshold = 7;

ScrollToPlugin_p._kill = function (lookup) {
  if (lookup.scrollTo_x) {
    this.skipX = true;
  }

  if (lookup.scrollTo_y) {
    this.skipY = true;
  }

  return this._super._kill.call(this, lookup);
};


;// CONCATENATED MODULE: ./src/components/back-to-top/js/index.js



/* 
 *************************************
 * <!-- Back to Top -->
 *************************************
 */



var BACK_TO_TOP = function (module, $, window, document) {
  if (window.BACK_TO_TOP === null) return false;
  module.BACK_TO_TOP = module.BACK_TO_TOP || {};
  module.BACK_TO_TOP.version = '0.1.0';

  module.BACK_TO_TOP.documentReady = function ($) {
    var windowWidth = window.innerWidth,
        windowHeight = window.innerHeight;
    $('<a href="#" id="uix-to-top"><i class="fa fa-arrow-up" aria-hidden="true"></i></a>').appendTo('body');
    $.when($('#uix-to-top').length > 0).then(function () {
      //-------- Sticky button of back to top 
      var $el = $('#uix-to-top');

      function scrollUpdate() {
        var scrolled = $(window).scrollTop(),
            spyTop = windowHeight / 2;

        if (scrolled >= spyTop) {
          $el.addClass('is-active');
        } else {
          $el.removeClass('is-active');
        }
      } // Add function to the element that should be used as the scrollable area.


      var throttleFunc = UixThrottle(scrollUpdate, 5);
      window.removeEventListener('scroll', throttleFunc);
      window.removeEventListener('touchmove', throttleFunc);
      window.addEventListener('scroll', throttleFunc);
      window.addEventListener('touchmove', throttleFunc);
      throttleFunc(); //-------- Click event of back button

      $el.off('click').on('click', function (e) {
        e.preventDefault();
        TweenMax.to(window, 0.5, {
          scrollTo: {
            y: 0,
            //y: "max" --> vertical scroll to bottom
            autoKill: false
          },
          ease: Power2.easeOut
        });
        return false;
      });
    });
  };

  module.components.documentReady.push(module.BACK_TO_TOP.documentReady);
  return /*#__PURE__*/_createClass(function BACK_TO_TOP() {
    _classCallCheck(this, BACK_TO_TOP);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/circle-layout/js/index.js




/* 
 *************************************
 * <!-- Circle Layout -->
 *************************************
 */


var CIRCLE_LAYOUT = function (module, $, window, document) {
  if (window.CIRCLE_LAYOUT === null) return false;
  module.CIRCLE_LAYOUT = module.CIRCLE_LAYOUT || {};
  module.CIRCLE_LAYOUT.version = '0.0.1';

  module.CIRCLE_LAYOUT.documentReady = function ($) {
    $('.js-uix-circle-layout').each(function (id) {
      var $this = $(this);
      var $ul = $this.find('> ul'),
          $li = $ul.find('> li'),
          liWidth = $li.first().outerWidth(),
          liHeight = $li.first().outerHeight();
      var display = $this.data('circle-layout-display'),
          radius = $this.data('circle-layout-radius'),
          radius2 = $this.data('circle-layout-radius-c'),
          rotation = $this.data('circle-layout-rotation');

      if ((0,esm_typeof/* default */.Z)(display) === ( true ? "undefined" : 0)) {
        display = 5;
      }

      if ((0,esm_typeof/* default */.Z)(radius) === ( true ? "undefined" : 0)) {
        radius = 180;
      }

      if ((0,esm_typeof/* default */.Z)(radius2) === ( true ? "undefined" : 0)) {
        radius2 = 110;
      }

      if ((0,esm_typeof/* default */.Z)(rotation) === ( true ? "undefined" : 0)) {
        rotation = 0;
      }

      $this.css({
        'width': radius * 2 + 'px'
      });
      $ul.css({
        'width': radius * 2 + 'px',
        'height': radius * 2 + 'px',
        'transform': 'rotate(' + parseFloat(rotation) + 'deg)'
      });
      $ul.next('div').css({
        'width': radius2 * 2 + 'px',
        'height': radius2 * 2 + 'px'
      }); //Layout components in a circle layout

      var step = 2 * Math.PI / display,
          pad = $ul.width();
      var angle = 0,
          transitionDelay = 0;
      $li.each(function () {
        //Can'nt use arrow function here!!!
        // 'this' works differently with arrow fucntions
        var el = $(this),
            x = radius * Math.cos(angle) - liWidth / 2,
            y = radius * Math.sin(angle) - liHeight / 2;
        el.css({
          'transform': 'translate(' + parseFloat(x + liWidth / 2) + 'px,' + parseFloat(pad / 2 + y + liHeight / 2) + 'px)',
          'transition-delay': transitionDelay + "s"
        }).find('> a').css({
          'transform': 'rotate(' + parseFloat(-rotation) + 'deg)'
        });
        angle += step;
        transitionDelay += 0.15;
      });
    });
  };

  module.components.documentReady.push(module.CIRCLE_LAYOUT.documentReady);
  return /*#__PURE__*/_createClass(function CIRCLE_LAYOUT() {
    _classCallCheck(this, CIRCLE_LAYOUT);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
// EXTERNAL MODULE: ./src/components/counter/js/fn/count-to.js
var count_to = __webpack_require__(798);
;// CONCATENATED MODULE: ./src/components/counter/js/index.js




/* 
 *************************************
 * <!-- Counter -->
 *************************************
 */


var COUNTER = function (module, $, window, document) {
  if (window.COUNTER === null) return false;
  module.COUNTER = module.COUNTER || {};
  module.COUNTER.version = '0.0.6';

  module.COUNTER.documentReady = function ($) {
    var $scrollElements = $('[data-counter-number]');
    $scrollElements.each(function () {
      var viewport = 1;
      var $el = $(this); //

      var scrollUpdate = function scrollUpdate() {
        var spyTop = $el[0].getBoundingClientRect().top; //Prevent asynchronous loading of repeated calls

        var actived = $el.data('activated');

        if (spyTop < window.innerHeight * viewport) {
          if ((0,esm_typeof/* default */.Z)(actived) === ( true ? "undefined" : 0)) {
            $el.UixCountTo(); //Prevents front-end javascripts that are activated in the background to repeat loading.

            $el.data('activated', 1);
          } //endif actived

        }
      }; // Add function to the element that should be used as the scrollable area.


      var throttleFunc = UixThrottle(scrollUpdate, 5);
      window.removeEventListener('scroll', throttleFunc);
      window.removeEventListener('touchmove', throttleFunc);
      window.addEventListener('scroll', throttleFunc);
      window.addEventListener('touchmove', throttleFunc);
      throttleFunc();
    }); //end each        
  };

  module.components.documentReady.push(module.COUNTER.documentReady);
  return /*#__PURE__*/_createClass(function COUNTER() {
    _classCallCheck(this, COUNTER);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/dropdown-menu/js/index.js




/* 
 *************************************
 * <!-- Dropdown Menu -->
 *************************************
 */


var DROPDOWN_MENU = function (module, $, window, document) {
  if (window.DROPDOWN_MENU === null) return false;
  module.DROPDOWN_MENU = module.DROPDOWN_MENU || {};
  module.DROPDOWN_MENU.version = '0.0.7';

  module.DROPDOWN_MENU.documentReady = function ($) {
    //Initialize option status
    $('.uix-dropdown-menu').each(function () {
      var v = $(this).find('input[type="hidden"]').val(),
          selectedIndex = $(this).find('ul > li > a[data-value="' + v + '"]').parent().index(),
          $li = $(this).find('ul > li');
      $li.removeClass('is-active');
      $li.eq(selectedIndex).addClass('is-active');
      $(this).find('> summary > span').html($li.eq(selectedIndex).find('> a').data('display-text'));
    }); //Create a trigger of Dropdown Menu on Click
    //Use $( document ) to support other click events for ajax

    $(document).off('click.DROPDOWN_MENU').on('click.DROPDOWN_MENU', '.uix-dropdown-menu > summary', function (e) {
      // stop propagation of this event, it will never reach body in bubbling phase.
      e.stopPropagation();
      var $this = $(this).parent('.uix-dropdown-menu');
      $this.toggleClass('is-opened');
    });
    $(document).off('click.DROPDOWN_MENU_LINK').on('click.DROPDOWN_MENU_LINK', '.uix-dropdown-menu li a', function (e) {
      // stop propagation of this event, it will never reach body in bubbling phase.
      e.stopPropagation();
      var $this = $(this).closest('.uix-dropdown-menu');

      if ($this.hasClass('is-opened')) {
        $this.removeAttr('open').removeClass('is-opened');
      }

      if ((0,esm_typeof/* default */.Z)($(this).attr('data-value')) != ( true ? "undefined" : 0) && $(this).attr('data-value') != '') {
        $this.find('input[type="hidden"]').val($(this).attr('data-value'));
      }

      if ((0,esm_typeof/* default */.Z)($(this).data('display-text')) != ( true ? "undefined" : 0) && $(this).data('display-text') != '') {
        $this.find('> summary > span').html($(this).data('display-text'));
      } // update active status


      $this.find('li').removeClass('is-active');
      $(this).parent().addClass('is-active');
    }); //Close the target
    //Do not add off() to this

    $(document.body).on('click', function (e) {
      //Apply click method to outer div but not inner div
      if (!$(e.target.offsetParent).hasClass('uix-dropdown-menu')) {
        $('.uix-dropdown-menu').removeAttr('open').removeClass('is-opened');
      }
    });
  };

  module.components.documentReady.push(module.DROPDOWN_MENU.documentReady);
  return /*#__PURE__*/_createClass(function DROPDOWN_MENU() {
    _classCallCheck(this, DROPDOWN_MENU);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/dropdown-menu2/js/index.js



/* 
 *************************************
 * <!-- Dropdown Menu 2 (Multi-level drop-down navigation) -->
 *************************************
 */


var DROPDOWN_MENU2 = function (module, $, window, document) {
  if (window.DROPDOWN_MENU2 === null) return false;
  module.DROPDOWN_MENU2 = module.DROPDOWN_MENU2 || {};
  module.DROPDOWN_MENU2.version = '0.0.5';

  module.DROPDOWN_MENU2.documentReady = function ($) {
    var $verticalMenuLi = $('.uix-vertical-menu li');
    $verticalMenuLi.find('> a').off('click').on('click', function (e) {
      var $sub = $(this).next('ul');

      if ($sub.length > 0) {
        e.preventDefault(); //Its value is not a boolean but a string

        var expanded = $(this).attr('aria-expanded') == 'true' ? false : true;

        if (expanded) {
          //Hide other all sibling <ul> of the selected element
          var $e = $(this).parent('li').siblings().find('> a');
          $e.removeClass('is-active').attr('aria-expanded', false);
          $(this).addClass('is-active').attr('aria-expanded', true);
          TweenMax.to($e.next('ul'), 0.5, {
            height: 0
          }); //to open
          // - temporarilty set height:auto
          // - tween from height:0

          TweenMax.set($sub, {
            height: 'auto'
          });
          TweenMax.from($sub, 0.5, {
            height: 0
          });
        } else {
          $(this).removeClass('is-active').attr('aria-expanded', false); //to close

          TweenMax.to($sub, 0.5, {
            height: 0
          });
        }

        return false;
      }
    }); //Add multilevel indicator arrow

    if ($verticalMenuLi.find('> a .uix-vertical-menu__arrow').length == 0) {
      $verticalMenuLi.find('> a').append('<span class="uix-vertical-menu__arrow"></span>');
    }

    $verticalMenuLi.each(function () {
      var len = $(this).find('ul').length;

      if (len == 0) {
        $(this).children('a').children('.uix-vertical-menu__arrow').hide();
      }
    });
  };

  module.components.documentReady.push(module.DROPDOWN_MENU2.documentReady);
  return /*#__PURE__*/_createClass(function DROPDOWN_MENU2() {
    _classCallCheck(this, DROPDOWN_MENU2);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/cascading-dropdown-list/js/index.js




/* 
 *************************************
 * <!-- Cascading DropDown List -->
 *************************************
 */


var CASCADING_DD_LIST = function (module, $, window, document) {
  if (window.CASCADING_DD_LIST === null) return false;
  module.CASCADING_DD_LIST = module.CASCADING_DD_LIST || {};
  module.CASCADING_DD_LIST.version = '0.2.1';

  module.CASCADING_DD_LIST.documentReady = function ($) {
    var curControls = '.uix-cascading-dropdown-list';
    var wrapperDepth = $(curControls).length === 0 ? 1 : $(curControls).length + 1;
    $(curControls).each(function () {
      wrapperDepth--;
      var cid = UixGUID.create();
      var $control = $(this);
      var actived = $control.data('activated');
      $control.attr('id', 'app-' + cid); //

      var ajaxURL = $control.data('cascading-dd-json'),
          ajaxMethod = $control.data('cascading-dd-method'),
          loadingTmpl = $control.data('cascading-dd-loading-tmpl');
      if ((0,esm_typeof/* default */.Z)(ajaxURL) === ( true ? "undefined" : 0)) ajaxURL = '';
      if ((0,esm_typeof/* default */.Z)(ajaxMethod) === ( true ? "undefined" : 0)) ajaxMethod = 'POST';
      if ((0,esm_typeof/* default */.Z)(loadingTmpl) === ( true ? "undefined" : 0)) loadingTmpl = '<div>loading...</div>';

      if ((0,esm_typeof/* default */.Z)(actived) === ( true ? "undefined" : 0)) {
        // Methods
        //------------------------------------------
        var loadingAnim = function loadingAnim() {
          var $loadingWrapper = $control.find('.uix-cascading-dropdown-list__loading__wrapper');

          if ($control.data('loading')) {
            $loadingWrapper.html(loadingTmpl);
          } else {
            $loadingWrapper.html('');
          }
        }; //


        var handleInitControl = function handleInitControl() {
          var firstLevelItems = [];
          $control.data('ajaxOptions').forEach(function (item) {
            firstLevelItems.push({
              "id": item.id,
              "name": item.name
            });
          }); //

          $control.data({
            'data': [$control.data('ajaxOptions')],
            'firstLevelItems': [firstLevelItems]
          }); // update result to input

          $resInput.val('');
        }; //


        var queryResultOfJSON = function queryResultOfJSON(data, targetVal, returnType) {
          var callbackValueNested = [];
          var lastFirstLevelName = '';
          var loop = true;
          var resDepth = 0;

          var getIndexOf = function getIndexOf(arr, val) {
            for (var i = 0; i < arr.length; i++) {
              if (arr[i].id.toString() === val.toString()) {
                return i;
              }
            }

            return -1;
          };

          var searchJsonStr = function searchJsonStr(list, depth) {
            // `depth` is very important, it is used to accurately judge the final result
            if (typeof depth === 'undefined') {
              depth = 0;
            } else {
              depth++;
            } //    


            for (var i = 0; i < list.length; i++) {
              var row = list[i];
              var callbackValue = returnType === 'key' ? row.id.toString() : row.name.toString();

              if (loop) {
                // get first-level item
                if (getIndexOf(data, row.id) !== -1) {
                  callbackValueNested.push(callbackValue);
                  lastFirstLevelName = callbackValue;
                } // get child-level item


                if (row.children) {
                  callbackValueNested.push(callbackValue);
                }
              } //check the value


              if (row.id.toString() === targetVal.toString()) {
                callbackValueNested.push(callbackValue);
                loop = false;
                resDepth = depth;
                break;
              } // Note: Recursion must be placed here


              if (loop) {
                if (row.children) {
                  searchJsonStr(row.children, depth);
                }
              }
            }
          };

          searchJsonStr(data); // (1) Remove duplicate values
          //------------------------------------------

          callbackValueNested = callbackValueNested.filter(function (item, index, arr) {
            return arr.indexOf(item, 0) === index;
          }); // (2) Delete needless first-level
          //------------------------------------------

          var resAll = callbackValueNested.slice(callbackValueNested.indexOf(lastFirstLevelName), callbackValueNested.length); // (3) Returns result
          //------------------------------------------

          if (resAll.length > 1) {
            // Get first-level item
            resAll.splice(1); // Get child-level item

            var resChild = callbackValueNested.slice(-resDepth); // Get the last elements in reverse
            // Combine

            resAll = resAll.concat(resChild);
          }

          return resAll;
        }; //


        var setValue = function setValue(arr, targetVal) {
          // update result to input
          $resInput.val(targetVal); //search JSON key that contains specific string

          $control.data({
            'selectedData': {
              labels: queryResultOfJSON(arr, targetVal, 'value'),
              values: queryResultOfJSON(arr, targetVal, 'key')
            }
          });
        }; //


        var handleClickItem = function handleClickItem(resValue, index, level) {
          console.log('resValue: ', resValue, ' | index: ', index, ' | level: ', level); // update value

          setValue($control.data('ajaxOptions'), resValue.id); // active the selected item

          var markCurrent = function markCurrent(arr, index) {
            for (var i = 0; i < arr.length; i++) {
              if (i === index) {
                arr[i].current = true;
              } else {
                arr[i].current = false;
              }
            }
          }; // deactivate all items


          var markAllItems = function markAllItems(arr) {
            for (var i = 0; i < arr.length; i++) {
              arr[i].current = false;
            }
          }; //


          var newData = $control.data('data'); // such as: [Array(6), Array(3)]
          //console.log( 'newData: ', newData );
          // All the elements from start(array.length - start) to the end of the array will be deleted.

          newData.splice(level + 1);

          if (resValue.children) {
            var childList = resValue.children;
            markAllItems(childList);
            newData[level + 1] = childList;
          } //


          $control.data({
            'data': newData
          });
          markCurrent(newData[level], index);
        }; //


        var handleDisplayOptions = function handleDisplayOptions(e) {
          e.preventDefault();
          $control.data({
            'isShow': !$control.data('isShow')
          });
        }; // If clicked on outside of element


        var handleClickOutside = function handleClickOutside(event) {
          if (event.target.className != '' && event.target.className.indexOf('uix-cascading-dropdown-list__trigger') < 0 && event.target.className.indexOf('uix-cascading-dropdown-list__items') < 0 && event.target.className.indexOf('uix-cascading-dropdown-list__opt') < 0) {
            $control.data({
              'isShow': false
            });
          }
        }; // Rendering component


        var render = function render() {
          var isShow = $control.data('isShow');
          var data = $control.data('data'); //for wrapper

          if (isShow) {
            var items = '';
            data.map(function (item, level) {
              var options = '';
              item.map(function (option, optionIndex) {
                options += '<div class="' + (option.current ? 'uix-cascading-dropdown-list__opt is-active' : 'uix-cascading-dropdown-list__opt') + '" data-level="' + level + '" data-value=\'' + JSON.stringify(option) + '\' data-index="' + optionIndex + '">' + option.name + '</div>';
              });
              items += '<li>' + options + '</li>';
            });
            $listWrapper.html("\n                        <div class=\"uix-cascading-dropdown-list__items\">\n                            <ul>\n                                " + items + "\n                            </ul>\n            \n                        </div>\n                        ");
          } else {
            $listWrapper.html('');
          } //for options


          var selectedData = $control.data('selectedData');
          var displayInfo = '';

          if (selectedData.labels) {
            selectedData.labels.map(function (item, i, arr) {
              var _input = '<input name="' + fieldName + '-node[]" type="hidden" value="' + selectedData.values[i] + '"/>';

              if (arr.length - 1 === i) {
                displayInfo += '<span>' + item + '' + _input + '</span>';
              } else {
                displayInfo += '<span>' + item + '' + _input + '</span><svg viewBox="0 0 22 22" width="8"><path d="m345.44 248.29l-194.29 194.28c-12.359 12.365-32.397 12.365-44.75 0-12.354-12.354-12.354-32.391 0-44.744l171.91-171.91-171.91-171.9c-12.354-12.359-12.354-32.394 0-44.748 12.354-12.359 32.391-12.359 44.75 0l194.29 194.28c6.177 6.18 9.262 14.271 9.262 22.366 0 8.099-3.091 16.196-9.267 22.373" transform="matrix(.03541-.00013.00013.03541 2.98 3.02)" fill="#a5a5a5"/></svg>';
              }
            });
          }

          $eachResWrapper.html(displayInfo);
        }; // Initialize status
        //------------------------------------------


        //Initialize HTML structure
        $control.append("\n                    <em class=\"uix-cascading-dropdown-list__result\"></em>\n                    <span class=\"uix-cascading-dropdown-list__items__wrapper\"></span>\n                    <span class=\"uix-cascading-dropdown-list__loading__wrapper\"></span>    \n                "); //

        var $listWrapper = $control.find('.uix-cascading-dropdown-list__items__wrapper');
        var $resInput = $control.find('input.uix-cascading-dropdown-list__res');
        var $eachResWrapper = $control.find('.uix-cascading-dropdown-list__result');
        var fieldName = typeof $resInput.attr('name') === 'undefined' ? 'auto-name-' + cid : $resInput.attr('name');
        var defaultVal = $resInput.val(); //the default value is STRING

        /*
        // If the final result is a comma separated string, like this: `value1,value2`
        if (defaultVal) {
            defaultVal.trim().replace(/^\,|\,$/g, '').split(',').forEach((item, index) => {
                 // do something
            });
        }
        */
        //init data

        $control.data({
          'ajaxOptions': [],
          'firstLevelItems': [],
          'loading': true,
          //for variable field
          'data': [],
          'selectedData': {
            labels: [],
            values: []
          },
          'isShow': false
        }); //loading

        loadingAnim(); //Initialize input

        $resInput.attr({
          'type': 'hidden',
          'name': fieldName
        }); //Initialize wrapper depth

        $control.css('z-index', wrapperDepth); // Get data of asynchronous request
        //------------------------------------------

        var req = ajaxMethod.toLowerCase() === 'get' ? axios.get(ajaxURL) : axios.post(ajaxURL);
        var allData = null;
        req.then(function (res) {
          allData = res.data;
          $control.data({
            'loading': false
          }); //loading

          loadingAnim();

          if (allData !== undefined) {
            $control.data({
              'ajaxOptions': allData
            }); //Initialize options 

            handleInitControl(); //Set a default value

            if (defaultVal) setValue(allData, defaultVal); //Rendering component

            render();
          }
        }); // Mouse Events
        //------------------------------------------
        //Trigger event 

        $(document).off('click.CASCADING_DROPDOWNLIST_TRIGGER' + cid).on('click.CASCADING_DROPDOWNLIST_TRIGGER' + cid, "#".concat('app-' + cid, " .uix-cascading-dropdown-list__trigger"), function (e) {
          handleDisplayOptions(e); //Rendering component

          render();
        }); //Options event

        $(document).off('click.CASCADING_DROPDOWNLIST_OPTIONS_OPEN' + cid).on('click.CASCADING_DROPDOWNLIST_OPTIONS_OPEN' + cid, "#".concat('app-' + cid, " .uix-cascading-dropdown-list__opt"), function (e) {
          var _level = $(this).data('level');

          var _value = $(this).data('value');

          var _index = $(this).data('index');

          handleClickItem(_value, _index, _level); //Rendering component

          render();
        }); //Hide options event
        //Do not add off() to this

        $(document).on('click.CASCADING_DROPDOWNLIST_CLOSE', function (e) {
          handleClickOutside(e); //Rendering component

          render();
        }); //------------------------------------------
        //Prevents front-end javascripts that are activated in the background to repeat loading.

        $control.data('activated', 1);
      } //endif actived			

    });
  };

  module.components.documentReady.push(module.CASCADING_DD_LIST.documentReady);
  return /*#__PURE__*/_createClass(function CASCADING_DD_LIST() {
    _classCallCheck(this, CASCADING_DD_LIST);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/flexslider/js/third-party/jquery.flexslider.js


/*
 * jQuery FlexSlider v2.7.0
 * Copyright 2012 WooThemes
 * Contributing Author: Tyler Smith
 */
(function ($) {
  var focused = true; //FlexSlider: Object Instance

  $.flexslider = function (el, options) {
    var slider = $(el); // making variables public
    //if rtl value was not passed and html is in rtl..enable it by default.

    if (typeof options.rtl == 'undefined' && $('html').attr('dir') == 'rtl') {
      options.rtl = true;
    }

    slider.vars = $.extend({}, $.flexslider.defaults, options);
    var namespace = slider.vars.namespace,
        msGesture = window.navigator && window.navigator.msPointerEnabled && window.MSGesture,
        touch = ("ontouchstart" in window || msGesture || window.DocumentTouch && document instanceof DocumentTouch) && slider.vars.touch,
        // deprecating this idea, as devices are being released with both of these events
    eventType = "click touchend MSPointerUp keyup",
        watchedEvent = "",
        watchedEventClearTimer,
        vertical = slider.vars.direction === "vertical",
        reverse = slider.vars.reverse,
        carousel = slider.vars.itemWidth > 0,
        fade = slider.vars.animation === "fade",
        asNav = slider.vars.asNavFor !== "",
        methods = {}; // Store a reference to the slider object

    $.data(el, "flexslider", slider); // Private slider methods

    methods = {
      init: function init() {
        slider.animating = false; // Get current slide and make sure it is a number

        slider.currentSlide = parseInt(slider.vars.startAt ? slider.vars.startAt : 0, 10);

        if (isNaN(slider.currentSlide)) {
          slider.currentSlide = 0;
        }

        slider.animatingTo = slider.currentSlide;
        slider.atEnd = slider.currentSlide === 0 || slider.currentSlide === slider.last;
        slider.containerSelector = slider.vars.selector.substr(0, slider.vars.selector.search(' '));
        slider.slides = $(slider.vars.selector, slider);
        slider.container = $(slider.containerSelector, slider);
        slider.count = slider.slides.length; // SYNC:

        slider.syncExists = $(slider.vars.sync).length > 0; // SLIDE:

        if (slider.vars.animation === "slide") {
          slider.vars.animation = "swing";
        }

        slider.prop = vertical ? "top" : slider.vars.rtl ? "marginRight" : "marginLeft";
        slider.args = {}; // SLIDESHOW:

        slider.manualPause = false;
        slider.stopped = false; //PAUSE WHEN INVISIBLE

        slider.started = false;
        slider.startTimeout = null; // TOUCH/USECSS:

        slider.transitions = !slider.vars.video && !fade && slider.vars.useCSS && function () {
          var obj = document.createElement('div'),
              props = ['perspectiveProperty', 'WebkitPerspective', 'MozPerspective', 'OPerspective', 'msPerspective'];

          for (var i in props) {
            if (obj.style[props[i]] !== undefined) {
              slider.pfx = props[i].replace('Perspective', '').toLowerCase();
              slider.prop = "-" + slider.pfx + "-transform";
              return true;
            }
          }

          return false;
        }();

        slider.ensureAnimationEnd = ''; // CONTROLSCONTAINER:

        if (slider.vars.controlsContainer !== "") slider.controlsContainer = $(slider.vars.controlsContainer).length > 0 && $(slider.vars.controlsContainer); // MANUAL:

        if (slider.vars.manualControls !== "") slider.manualControls = $(slider.vars.manualControls).length > 0 && $(slider.vars.manualControls); // CUSTOM DIRECTION NAV:

        if (slider.vars.customDirectionNav !== "") slider.customDirectionNav = $(slider.vars.customDirectionNav).length === 2 && $(slider.vars.customDirectionNav); // RANDOMIZE:

        if (slider.vars.randomize) {
          slider.slides.sort(function () {
            return Math.round(Math.random()) - 0.5;
          });
          slider.container.empty().append(slider.slides);
        }

        slider.doMath(); // INIT

        slider.setup("init"); // CONTROLNAV:

        if (slider.vars.controlNav) {
          methods.controlNav.setup();
        } // DIRECTIONNAV:


        if (slider.vars.directionNav) {
          methods.directionNav.setup();
        } // KEYBOARD:


        if (slider.vars.keyboard && ($(slider.containerSelector).length === 1 || slider.vars.multipleKeyboard)) {
          $(document).bind('keyup', function (event) {
            var keycode = event.keyCode;

            if (!slider.animating && (keycode === 39 || keycode === 37)) {
              var target = slider.vars.rtl ? keycode === 37 ? slider.getTarget('next') : keycode === 39 ? slider.getTarget('prev') : false : keycode === 39 ? slider.getTarget('next') : keycode === 37 ? slider.getTarget('prev') : false;
              slider.flexAnimate(target, slider.vars.pauseOnAction);
            }
          });
        } // MOUSEWHEEL:


        if (slider.vars.mousewheel) {
          slider.bind('mousewheel', function (event, delta, deltaX, deltaY) {
            event.preventDefault();
            var target = delta < 0 ? slider.getTarget('next') : slider.getTarget('prev');
            slider.flexAnimate(target, slider.vars.pauseOnAction);
          });
        } // PAUSEPLAY


        if (slider.vars.pausePlay) {
          methods.pausePlay.setup();
        } //PAUSE WHEN INVISIBLE


        if (slider.vars.slideshow && slider.vars.pauseInvisible) {
          methods.pauseInvisible.init();
        } // SLIDSESHOW


        if (slider.vars.slideshow) {
          if (slider.vars.pauseOnHover) {
            slider.hover(function () {
              if (!slider.manualPlay && !slider.manualPause) {
                slider.pause();
              }
            }, function () {
              if (!slider.manualPause && !slider.manualPlay && !slider.stopped) {
                slider.play();
              }
            });
          } // initialize animation
          //If we're visible, or we don't use PageVisibility API


          if (!slider.vars.pauseInvisible || !methods.pauseInvisible.isHidden()) {
            slider.vars.initDelay > 0 ? slider.startTimeout = setTimeout(slider.play, slider.vars.initDelay) : slider.play();
          }
        } // ASNAV:


        if (asNav) {
          methods.asNav.setup();
        } // TOUCH


        if (touch && slider.vars.touch) {
          methods.touch();
        } // FADE&&SMOOTHHEIGHT || SLIDE:


        if (!fade || fade && slider.vars.smoothHeight) {
          $(window).bind("resize orientationchange focus", methods.resize);
        }

        slider.find("img").attr("draggable", "false"); // API: start() Callback

        setTimeout(function () {
          slider.vars.start(slider);
        }, 200);
      },
      asNav: {
        setup: function setup() {
          slider.asNav = true;
          slider.animatingTo = Math.floor(slider.currentSlide / slider.move);
          slider.currentItem = slider.currentSlide;
          slider.slides.removeClass(namespace + "active-slide").eq(slider.currentItem).addClass(namespace + "active-slide");

          if (!msGesture) {
            slider.slides.on(eventType, function (e) {
              e.preventDefault();
              var $slide = $(this),
                  target = $slide.index();
              var posFromX;

              if (slider.vars.rtl) {
                posFromX = -1 * ($slide.offset().right - $(slider).scrollLeft()); // Find position of slide relative to right of slider container
              } else {
                posFromX = $slide.offset().left - $(slider).scrollLeft(); // Find position of slide relative to left of slider container
              }

              if (posFromX <= 0 && $slide.hasClass(namespace + 'active-slide')) {
                slider.flexAnimate(slider.getTarget("prev"), true);
              } else if (!$(slider.vars.asNavFor).data('flexslider').animating && !$slide.hasClass(namespace + "active-slide")) {
                slider.direction = slider.currentItem < target ? "next" : "prev";
                slider.flexAnimate(target, slider.vars.pauseOnAction, false, true, true);
              }
            });
          } else {
            el._slider = slider;
            slider.slides.each(function () {
              var that = this;
              that._gesture = new MSGesture();
              that._gesture.target = that;
              that.addEventListener("MSPointerDown", function (e) {
                e.preventDefault();

                if (e.currentTarget._gesture) {
                  e.currentTarget._gesture.addPointer(e.pointerId);
                }
              }, false);
              that.addEventListener("MSGestureTap", function (e) {
                e.preventDefault();
                var $slide = $(this),
                    target = $slide.index();

                if (!$(slider.vars.asNavFor).data('flexslider').animating && !$slide.hasClass('active')) {
                  slider.direction = slider.currentItem < target ? "next" : "prev";
                  slider.flexAnimate(target, slider.vars.pauseOnAction, false, true, true);
                }
              });
            });
          }
        }
      },
      controlNav: {
        setup: function setup() {
          if (!slider.manualControls) {
            methods.controlNav.setupPaging();
          } else {
            // MANUALCONTROLS:
            methods.controlNav.setupManual();
          }
        },
        setupPaging: function setupPaging() {
          var type = slider.vars.controlNav === "thumbnails" ? 'control-thumbs' : 'control-paging',
              j = 1,
              item,
              slide;
          slider.controlNavScaffold = $('<ol class="' + namespace + 'control-nav ' + namespace + type + '"></ol>');

          if (slider.pagingCount > 1) {
            for (var i = 0; i < slider.pagingCount; i++) {
              slide = slider.slides.eq(i);

              if (undefined === slide.attr('data-thumb-alt')) {
                slide.attr('data-thumb-alt', '');
              }

              var altText = '' !== slide.attr('data-thumb-alt') ? altText = ' alt="' + slide.attr('data-thumb-alt') + '"' : '';
              item = slider.vars.controlNav === "thumbnails" ? '<img src="' + slide.attr('data-thumb') + '"' + altText + '/>' : '<a href="#">' + j + '</a>';

              if ('thumbnails' === slider.vars.controlNav && true === slider.vars.thumbCaptions) {
                var captn = slide.attr('data-thumbcaption');

                if ('' !== captn && undefined !== captn) {
                  item += '<span class="' + namespace + 'caption">' + captn + '</span>';
                }
              }

              slider.controlNavScaffold.append('<li>' + item + '</li>');
              j++;
            }
          } // CONTROLSCONTAINER:


          slider.controlsContainer ? $(slider.controlsContainer).append(slider.controlNavScaffold) : slider.append(slider.controlNavScaffold);
          methods.controlNav.set();
          methods.controlNav.active();
          slider.controlNavScaffold.delegate('a, img', eventType, function (event) {
            event.preventDefault();

            if (watchedEvent === "" || watchedEvent === event.type) {
              var $this = $(this),
                  target = slider.controlNav.index($this);

              if (!$this.hasClass(namespace + 'active')) {
                slider.direction = target > slider.currentSlide ? "next" : "prev";
                slider.flexAnimate(target, slider.vars.pauseOnAction);
              }
            } // setup flags to prevent event duplication


            if (watchedEvent === "") {
              watchedEvent = event.type;
            }

            methods.setToClearWatchedEvent();
          });
        },
        setupManual: function setupManual() {
          slider.controlNav = slider.manualControls;
          methods.controlNav.active();
          slider.controlNav.bind(eventType, function (event) {
            event.preventDefault();

            if (watchedEvent === "" || watchedEvent === event.type) {
              var $this = $(this),
                  target = slider.controlNav.index($this);

              if (!$this.hasClass(namespace + 'active')) {
                target > slider.currentSlide ? slider.direction = "next" : slider.direction = "prev";
                slider.flexAnimate(target, slider.vars.pauseOnAction);
              }
            } // setup flags to prevent event duplication


            if (watchedEvent === "") {
              watchedEvent = event.type;
            }

            methods.setToClearWatchedEvent();
          });
        },
        set: function set() {
          var selector = slider.vars.controlNav === "thumbnails" ? 'img' : 'a';
          slider.controlNav = $('.' + namespace + 'control-nav li ' + selector, slider.controlsContainer ? slider.controlsContainer : slider);
        },
        active: function active() {
          slider.controlNav.removeClass(namespace + "active").eq(slider.animatingTo).addClass(namespace + "active");
        },
        update: function update(action, pos) {
          if (slider.pagingCount > 1 && action === "add") {
            slider.controlNavScaffold.append($('<li><a href="#">' + slider.count + '</a></li>'));
          } else if (slider.pagingCount === 1) {
            slider.controlNavScaffold.find('li').remove();
          } else {
            slider.controlNav.eq(pos).closest('li').remove();
          }

          methods.controlNav.set();
          slider.pagingCount > 1 && slider.pagingCount !== slider.controlNav.length ? slider.update(pos, action) : methods.controlNav.active();
        }
      },
      directionNav: {
        setup: function setup() {
          var directionNavScaffold = $('<ul class="' + namespace + 'direction-nav"><li class="' + namespace + 'nav-prev"><a class="' + namespace + 'prev" href="#">' + slider.vars.prevText + '</a></li><li class="' + namespace + 'nav-next"><a class="' + namespace + 'next" href="#">' + slider.vars.nextText + '</a></li></ul>'); // CUSTOM DIRECTION NAV:

          if (slider.customDirectionNav) {
            slider.directionNav = slider.customDirectionNav; // CONTROLSCONTAINER:
          } else if (slider.controlsContainer) {
            $(slider.controlsContainer).append(directionNavScaffold);
            slider.directionNav = $('.' + namespace + 'direction-nav li a', slider.controlsContainer);
          } else {
            slider.append(directionNavScaffold);
            slider.directionNav = $('.' + namespace + 'direction-nav li a', slider);
          }

          methods.directionNav.update();
          slider.directionNav.bind(eventType, function (event) {
            event.preventDefault();
            var target;

            if (watchedEvent === "" || watchedEvent === event.type) {
              target = $(this).hasClass(namespace + 'next') ? slider.getTarget('next') : slider.getTarget('prev');
              slider.flexAnimate(target, slider.vars.pauseOnAction);
            } // setup flags to prevent event duplication


            if (watchedEvent === "") {
              watchedEvent = event.type;
            }

            methods.setToClearWatchedEvent();
          });
        },
        update: function update() {
          var disabledClass = namespace + 'disabled';

          if (slider.pagingCount === 1) {
            slider.directionNav.addClass(disabledClass).attr('tabindex', '-1');
          } else if (!slider.vars.animationLoop) {
            if (slider.animatingTo === 0) {
              slider.directionNav.removeClass(disabledClass).filter('.' + namespace + "prev").addClass(disabledClass).attr('tabindex', '-1');
            } else if (slider.animatingTo === slider.last) {
              slider.directionNav.removeClass(disabledClass).filter('.' + namespace + "next").addClass(disabledClass).attr('tabindex', '-1');
            } else {
              slider.directionNav.removeClass(disabledClass).removeAttr('tabindex');
            }
          } else {
            slider.directionNav.removeClass(disabledClass).removeAttr('tabindex');
          }
        }
      },
      pausePlay: {
        setup: function setup() {
          var pausePlayScaffold = $('<div class="' + namespace + 'pauseplay"><a href="#"></a></div>'); // CONTROLSCONTAINER:

          if (slider.controlsContainer) {
            slider.controlsContainer.append(pausePlayScaffold);
            slider.pausePlay = $('.' + namespace + 'pauseplay a', slider.controlsContainer);
          } else {
            slider.append(pausePlayScaffold);
            slider.pausePlay = $('.' + namespace + 'pauseplay a', slider);
          }

          methods.pausePlay.update(slider.vars.slideshow ? namespace + 'pause' : namespace + 'play');
          slider.pausePlay.bind(eventType, function (event) {
            event.preventDefault();

            if (watchedEvent === "" || watchedEvent === event.type) {
              if ($(this).hasClass(namespace + 'pause')) {
                slider.manualPause = true;
                slider.manualPlay = false;
                slider.pause();
              } else {
                slider.manualPause = false;
                slider.manualPlay = true;
                slider.play();
              }
            } // setup flags to prevent event duplication


            if (watchedEvent === "") {
              watchedEvent = event.type;
            }

            methods.setToClearWatchedEvent();
          });
        },
        update: function update(state) {
          state === "play" ? slider.pausePlay.removeClass(namespace + 'pause').addClass(namespace + 'play').html(slider.vars.playText) : slider.pausePlay.removeClass(namespace + 'play').addClass(namespace + 'pause').html(slider.vars.pauseText);
        }
      },
      touch: function touch() {
        var startX,
            startY,
            offset,
            cwidth,
            dx,
            startT,
            onTouchStart,
            onTouchMove,
            _onTouchEnd,
            scrolling = false,
            localX = 0,
            localY = 0,
            accDx = 0;

        if (!msGesture) {
          onTouchStart = function onTouchStart(e) {
            if (slider.animating) {
              e.preventDefault();
            } else if (window.navigator.msPointerEnabled || e.touches.length === 1) {
              slider.pause(); // CAROUSEL:

              cwidth = vertical ? slider.h : slider.w;
              startT = Number(new Date()); // CAROUSEL:
              // Local vars for X and Y points.

              localX = e.touches[0].pageX;
              localY = e.touches[0].pageY;
              offset = carousel && reverse && slider.animatingTo === slider.last ? 0 : carousel && reverse ? slider.limit - (slider.itemW + slider.vars.itemMargin) * slider.move * slider.animatingTo : carousel && slider.currentSlide === slider.last ? slider.limit : carousel ? (slider.itemW + slider.vars.itemMargin) * slider.move * slider.currentSlide : reverse ? (slider.last - slider.currentSlide + slider.cloneOffset) * cwidth : (slider.currentSlide + slider.cloneOffset) * cwidth;
              startX = vertical ? localY : localX;
              startY = vertical ? localX : localY;
              el.addEventListener('touchmove', onTouchMove, false);
              el.addEventListener('touchend', _onTouchEnd, false);
            }
          };

          onTouchMove = function onTouchMove(e) {
            // Local vars for X and Y points.
            localX = e.touches[0].pageX;
            localY = e.touches[0].pageY;
            dx = vertical ? startX - localY : (slider.vars.rtl ? -1 : 1) * (startX - localX);
            scrolling = vertical ? Math.abs(dx) < Math.abs(localX - startY) : Math.abs(dx) < Math.abs(localY - startY);
            var fxms = 500;

            if (!scrolling || Number(new Date()) - startT > fxms) {
              e.preventDefault();

              if (!fade && slider.transitions) {
                if (!slider.vars.animationLoop) {
                  dx = dx / (slider.currentSlide === 0 && dx < 0 || slider.currentSlide === slider.last && dx > 0 ? Math.abs(dx) / cwidth + 2 : 1);
                }

                slider.setProps(offset + dx, "setTouch");
              }
            }
          };

          _onTouchEnd = function onTouchEnd(e) {
            // finish the touch by undoing the touch session
            el.removeEventListener('touchmove', onTouchMove, false);

            if (slider.animatingTo === slider.currentSlide && !scrolling && !(dx === null)) {
              var updateDx = reverse ? -dx : dx,
                  target = updateDx > 0 ? slider.getTarget('next') : slider.getTarget('prev');

              if (slider.canAdvance(target) && (Number(new Date()) - startT < 550 && Math.abs(updateDx) > 50 || Math.abs(updateDx) > cwidth / 2)) {
                slider.flexAnimate(target, slider.vars.pauseOnAction);
              } else {
                if (!fade) {
                  slider.flexAnimate(slider.currentSlide, slider.vars.pauseOnAction, true);
                }
              }
            }

            el.removeEventListener('touchend', _onTouchEnd, false);
            startX = null;
            startY = null;
            dx = null;
            offset = null;
          };

          el.addEventListener('touchstart', onTouchStart, false);
        } else {
          var onMSPointerDown = function onMSPointerDown(e) {
            e.stopPropagation();

            if (slider.animating) {
              e.preventDefault();
            } else {
              slider.pause();

              el._gesture.addPointer(e.pointerId);

              accDx = 0;
              cwidth = vertical ? slider.h : slider.w;
              startT = Number(new Date()); // CAROUSEL:

              offset = carousel && reverse && slider.animatingTo === slider.last ? 0 : carousel && reverse ? slider.limit - (slider.itemW + slider.vars.itemMargin) * slider.move * slider.animatingTo : carousel && slider.currentSlide === slider.last ? slider.limit : carousel ? (slider.itemW + slider.vars.itemMargin) * slider.move * slider.currentSlide : reverse ? (slider.last - slider.currentSlide + slider.cloneOffset) * cwidth : (slider.currentSlide + slider.cloneOffset) * cwidth;
            }
          };

          var onMSGestureChange = function onMSGestureChange(e) {
            e.stopPropagation();
            var slider = e.target._slider;

            if (!slider) {
              return;
            }

            var transX = -e.translationX,
                transY = -e.translationY; //Accumulate translations.

            accDx = accDx + (vertical ? transY : transX);
            dx = (slider.vars.rtl ? -1 : 1) * accDx;
            scrolling = vertical ? Math.abs(accDx) < Math.abs(-transX) : Math.abs(accDx) < Math.abs(-transY);

            if (e.detail === e.MSGESTURE_FLAG_INERTIA) {
              setImmediate(function () {
                el._gesture.stop();
              });
              return;
            }

            if (!scrolling || Number(new Date()) - startT > 500) {
              e.preventDefault();

              if (!fade && slider.transitions) {
                if (!slider.vars.animationLoop) {
                  dx = accDx / (slider.currentSlide === 0 && accDx < 0 || slider.currentSlide === slider.last && accDx > 0 ? Math.abs(accDx) / cwidth + 2 : 1);
                }

                slider.setProps(offset + dx, "setTouch");
              }
            }
          };

          var onMSGestureEnd = function onMSGestureEnd(e) {
            e.stopPropagation();
            var slider = e.target._slider;

            if (!slider) {
              return;
            }

            if (slider.animatingTo === slider.currentSlide && !scrolling && !(dx === null)) {
              var updateDx = reverse ? -dx : dx,
                  target = updateDx > 0 ? slider.getTarget('next') : slider.getTarget('prev');

              if (slider.canAdvance(target) && (Number(new Date()) - startT < 550 && Math.abs(updateDx) > 50 || Math.abs(updateDx) > cwidth / 2)) {
                slider.flexAnimate(target, slider.vars.pauseOnAction);
              } else {
                if (!fade) {
                  slider.flexAnimate(slider.currentSlide, slider.vars.pauseOnAction, true);
                }
              }
            }

            startX = null;
            startY = null;
            dx = null;
            offset = null;
            accDx = 0;
          };

          el.style.msTouchAction = "none";
          el._gesture = new MSGesture();
          el._gesture.target = el;
          el.addEventListener("MSPointerDown", onMSPointerDown, false);
          el._slider = slider;
          el.addEventListener("MSGestureChange", onMSGestureChange, false);
          el.addEventListener("MSGestureEnd", onMSGestureEnd, false);
        }
      },
      resize: function resize() {
        if (!slider.animating && slider.is(':visible')) {
          if (!carousel) {
            slider.doMath();
          }

          if (fade) {
            // SMOOTH HEIGHT:
            methods.smoothHeight();
          } else if (carousel) {
            //CAROUSEL:
            slider.slides.width(slider.computedW);
            slider.update(slider.pagingCount);
            slider.setProps();
          } else if (vertical) {
            //VERTICAL:
            slider.viewport.height(slider.h);
            slider.setProps(slider.h, "setTotal");
          } else {
            // SMOOTH HEIGHT:
            if (slider.vars.smoothHeight) {
              methods.smoothHeight();
            }

            slider.newSlides.width(slider.computedW);
            slider.setProps(slider.computedW, "setTotal");
          }
        }
      },
      smoothHeight: function smoothHeight(dur) {
        if (!vertical || fade) {
          var $obj = fade ? slider : slider.viewport;
          dur ? $obj.animate({
            "height": slider.slides.eq(slider.animatingTo).innerHeight()
          }, dur) : $obj.innerHeight(slider.slides.eq(slider.animatingTo).innerHeight());
        }
      },
      sync: function sync(action) {
        var $obj = $(slider.vars.sync).data("flexslider"),
            target = slider.animatingTo;

        switch (action) {
          case "animate":
            $obj.flexAnimate(target, slider.vars.pauseOnAction, false, true);
            break;

          case "play":
            if (!$obj.playing && !$obj.asNav) {
              $obj.play();
            }

            break;

          case "pause":
            $obj.pause();
            break;
        }
      },
      uniqueID: function uniqueID($clone) {
        // Append _clone to current level and children elements with id attributes
        $clone.filter('[id]').add($clone.find('[id]')).each(function () {
          var $this = $(this);
          $this.attr('id', $this.attr('id') + '_clone');
        });
        return $clone;
      },
      pauseInvisible: {
        visProp: null,
        init: function init() {
          var visProp = methods.pauseInvisible.getHiddenProp();

          if (visProp) {
            var evtname = visProp.replace(/[H|h]idden/, '') + 'visibilitychange';
            document.addEventListener(evtname, function () {
              if (methods.pauseInvisible.isHidden()) {
                if (slider.startTimeout) {
                  clearTimeout(slider.startTimeout); //If clock is ticking, stop timer and prevent from starting while invisible
                } else {
                  slider.pause(); //Or just pause
                }
              } else {
                if (slider.started) {
                  slider.play(); //Initiated before, just play
                } else {
                  if (slider.vars.initDelay > 0) {
                    setTimeout(slider.play, slider.vars.initDelay);
                  } else {
                    slider.play(); //Didn't init before: simply init or wait for it
                  }
                }
              }
            });
          }
        },
        isHidden: function isHidden() {
          var prop = methods.pauseInvisible.getHiddenProp();

          if (!prop) {
            return false;
          }

          return document[prop];
        },
        getHiddenProp: function getHiddenProp() {
          var prefixes = ['webkit', 'moz', 'ms', 'o']; // if 'hidden' is natively supported just return it

          if ('hidden' in document) {
            return 'hidden';
          } // otherwise loop over all the known prefixes until we find one


          for (var i = 0; i < prefixes.length; i++) {
            if (prefixes[i] + 'Hidden' in document) {
              return prefixes[i] + 'Hidden';
            }
          } // otherwise it's not supported


          return null;
        }
      },
      setToClearWatchedEvent: function setToClearWatchedEvent() {
        clearTimeout(watchedEventClearTimer);
        watchedEventClearTimer = setTimeout(function () {
          watchedEvent = "";
        }, 3000);
      }
    }; // public methods

    slider.flexAnimate = function (target, pause, override, withSync, fromNav) {
      if (!slider.vars.animationLoop && target !== slider.currentSlide) {
        slider.direction = target > slider.currentSlide ? "next" : "prev";
      }

      if (asNav && slider.pagingCount === 1) slider.direction = slider.currentItem < target ? "next" : "prev";

      if (!slider.animating && (slider.canAdvance(target, fromNav) || override) && slider.is(":visible")) {
        if (asNav && withSync) {
          var master = $(slider.vars.asNavFor).data('flexslider');
          slider.atEnd = target === 0 || target === slider.count - 1;
          master.flexAnimate(target, true, false, true, fromNav);
          slider.direction = slider.currentItem < target ? "next" : "prev";
          master.direction = slider.direction;

          if (Math.ceil((target + 1) / slider.visible) - 1 !== slider.currentSlide && target !== 0) {
            slider.currentItem = target;
            slider.slides.removeClass(namespace + "active-slide").eq(target).addClass(namespace + "active-slide");
            target = Math.floor(target / slider.visible);
          } else {
            slider.currentItem = target;
            slider.slides.removeClass(namespace + "active-slide").eq(target).addClass(namespace + "active-slide");
            return false;
          }
        }

        slider.animating = true;
        slider.animatingTo = target; // SLIDESHOW:

        if (pause) {
          slider.pause();
        } // API: before() animation Callback


        slider.vars.before(slider); // SYNC:

        if (slider.syncExists && !fromNav) {
          methods.sync("animate");
        } // CONTROLNAV


        if (slider.vars.controlNav) {
          methods.controlNav.active();
        } // !CAROUSEL:
        // CANDIDATE: slide active class (for add/remove slide)


        if (!carousel) {
          slider.slides.removeClass(namespace + 'active-slide').eq(target).addClass(namespace + 'active-slide');
        } // INFINITE LOOP:
        // CANDIDATE: atEnd


        slider.atEnd = target === 0 || target === slider.last; // DIRECTIONNAV:

        if (slider.vars.directionNav) {
          methods.directionNav.update();
        }

        if (target === slider.last) {
          // API: end() of cycle Callback
          slider.vars.end(slider); // SLIDESHOW && !INFINITE LOOP:

          if (!slider.vars.animationLoop) {
            slider.pause();
          }
        } // SLIDE:


        if (!fade) {
          var dimension = vertical ? slider.slides.filter(':first').height() : slider.computedW,
              margin,
              slideString,
              calcNext; // INFINITE LOOP / REVERSE:

          if (carousel) {
            margin = slider.vars.itemMargin;
            calcNext = (slider.itemW + margin) * slider.move * slider.animatingTo;
            slideString = calcNext > slider.limit && slider.visible !== 1 ? slider.limit : calcNext;
          } else if (slider.currentSlide === 0 && target === slider.count - 1 && slider.vars.animationLoop && slider.direction !== "next") {
            slideString = reverse ? (slider.count + slider.cloneOffset) * dimension : 0;
          } else if (slider.currentSlide === slider.last && target === 0 && slider.vars.animationLoop && slider.direction !== "prev") {
            slideString = reverse ? 0 : (slider.count + 1) * dimension;
          } else {
            slideString = reverse ? (slider.count - 1 - target + slider.cloneOffset) * dimension : (target + slider.cloneOffset) * dimension;
          }

          slider.setProps(slideString, "", slider.vars.animationSpeed);

          if (slider.transitions) {
            if (!slider.vars.animationLoop || !slider.atEnd) {
              slider.animating = false;
              slider.currentSlide = slider.animatingTo;
            } // Unbind previous transitionEnd events and re-bind new transitionEnd event


            slider.container.unbind("webkitTransitionEnd transitionend");
            slider.container.bind("webkitTransitionEnd transitionend", function () {
              clearTimeout(slider.ensureAnimationEnd);
              slider.wrapup(dimension);
            }); // Insurance for the ever-so-fickle transitionEnd event

            clearTimeout(slider.ensureAnimationEnd);
            slider.ensureAnimationEnd = setTimeout(function () {
              slider.wrapup(dimension);
            }, slider.vars.animationSpeed + 100);
          } else {
            slider.container.animate(slider.args, slider.vars.animationSpeed, slider.vars.easing, function () {
              slider.wrapup(dimension);
            });
          }
        } else {
          // FADE:
          if (!touch) {
            slider.slides.eq(slider.currentSlide).css({
              "zIndex": 1
            }).animate({
              "opacity": 0
            }, slider.vars.animationSpeed, slider.vars.easing);
            slider.slides.eq(target).css({
              "zIndex": 2
            }).animate({
              "opacity": 1
            }, slider.vars.animationSpeed, slider.vars.easing, slider.wrapup);
          } else {
            slider.slides.eq(slider.currentSlide).css({
              "opacity": 0,
              "zIndex": 1
            });
            slider.slides.eq(target).css({
              "opacity": 1,
              "zIndex": 2
            });
            slider.wrapup(dimension);
          }
        } // SMOOTH HEIGHT:


        if (slider.vars.smoothHeight) {
          methods.smoothHeight(slider.vars.animationSpeed);
        }
      }
    };

    slider.wrapup = function (dimension) {
      // SLIDE:
      if (!fade && !carousel) {
        if (slider.currentSlide === 0 && slider.animatingTo === slider.last && slider.vars.animationLoop) {
          slider.setProps(dimension, "jumpEnd");
        } else if (slider.currentSlide === slider.last && slider.animatingTo === 0 && slider.vars.animationLoop) {
          slider.setProps(dimension, "jumpStart");
        }
      }

      slider.animating = false;
      slider.currentSlide = slider.animatingTo; // API: after() animation Callback

      slider.vars.after(slider);
    }; // SLIDESHOW:


    slider.animateSlides = function () {
      if (!slider.animating && focused) {
        slider.flexAnimate(slider.getTarget("next"));
      }
    }; // SLIDESHOW:


    slider.pause = function () {
      clearInterval(slider.animatedSlides);
      slider.animatedSlides = null;
      slider.playing = false; // PAUSEPLAY:

      if (slider.vars.pausePlay) {
        methods.pausePlay.update("play");
      } // SYNC:


      if (slider.syncExists) {
        methods.sync("pause");
      }
    }; // SLIDESHOW:


    slider.play = function () {
      if (slider.playing) {
        clearInterval(slider.animatedSlides);
      }

      slider.animatedSlides = slider.animatedSlides || setInterval(slider.animateSlides, slider.vars.slideshowSpeed);
      slider.started = slider.playing = true; // PAUSEPLAY:

      if (slider.vars.pausePlay) {
        methods.pausePlay.update("pause");
      } // SYNC:


      if (slider.syncExists) {
        methods.sync("play");
      }
    }; // STOP:


    slider.stop = function () {
      slider.pause();
      slider.stopped = true;
    };

    slider.canAdvance = function (target, fromNav) {
      // ASNAV:
      var last = asNav ? slider.pagingCount - 1 : slider.last;
      return fromNav ? true : asNav && slider.currentItem === slider.count - 1 && target === 0 && slider.direction === "prev" ? true : asNav && slider.currentItem === 0 && target === slider.pagingCount - 1 && slider.direction !== "next" ? false : target === slider.currentSlide && !asNav ? false : slider.vars.animationLoop ? true : slider.atEnd && slider.currentSlide === 0 && target === last && slider.direction !== "next" ? false : slider.atEnd && slider.currentSlide === last && target === 0 && slider.direction === "next" ? false : true;
    };

    slider.getTarget = function (dir) {
      slider.direction = dir;

      if (dir === "next") {
        return slider.currentSlide === slider.last ? 0 : slider.currentSlide + 1;
      } else {
        return slider.currentSlide === 0 ? slider.last : slider.currentSlide - 1;
      }
    }; // SLIDE:


    slider.setProps = function (pos, special, dur) {
      var target = function () {
        var posCheck = pos ? pos : (slider.itemW + slider.vars.itemMargin) * slider.move * slider.animatingTo,
            posCalc = function () {
          if (carousel) {
            return special === "setTouch" ? pos : reverse && slider.animatingTo === slider.last ? 0 : reverse ? slider.limit - (slider.itemW + slider.vars.itemMargin) * slider.move * slider.animatingTo : slider.animatingTo === slider.last ? slider.limit : posCheck;
          } else {
            switch (special) {
              case "setTotal":
                return reverse ? (slider.count - 1 - slider.currentSlide + slider.cloneOffset) * pos : (slider.currentSlide + slider.cloneOffset) * pos;

              case "setTouch":
                return reverse ? pos : pos;

              case "jumpEnd":
                return reverse ? pos : slider.count * pos;

              case "jumpStart":
                return reverse ? slider.count * pos : pos;

              default:
                return pos;
            }
          }
        }();

        return posCalc * (slider.vars.rtl ? 1 : -1) + "px";
      }();

      if (slider.transitions) {
        target = vertical ? "translate3d(0," + target + ",0)" : "translate3d(" + ((slider.vars.rtl ? -1 : 1) * parseInt(target) + 'px') + ",0,0)";
        dur = dur !== undefined ? dur / 1000 + "s" : "0s";
        slider.container.css("-" + slider.pfx + "-transition-duration", dur);
        slider.container.css("transition-duration", dur);
      }

      slider.args[slider.prop] = target;

      if (slider.transitions || dur === undefined) {
        slider.container.css(slider.args);
      }

      slider.container.css('transform', target);
    };

    slider.setup = function (type) {
      // SLIDE:
      if (!fade) {
        var sliderOffset, arr;

        if (type === "init") {
          slider.viewport = $('<div class="' + namespace + 'viewport"></div>').css({
            "overflow": "hidden",
            "position": "relative"
          }).appendTo(slider).append(slider.container); // INFINITE LOOP:

          slider.cloneCount = 0;
          slider.cloneOffset = 0; // REVERSE:

          if (reverse) {
            arr = $.makeArray(slider.slides).reverse();
            slider.slides = $(arr);
            slider.container.empty().append(slider.slides);
          }
        } // INFINITE LOOP && !CAROUSEL:


        if (slider.vars.animationLoop && !carousel) {
          slider.cloneCount = 2;
          slider.cloneOffset = 1; // clear out old clones

          if (type !== "init") {
            slider.container.find('.clone').remove();
          }

          slider.container.append(methods.uniqueID(slider.slides.first().clone().addClass('clone')).attr('aria-hidden', 'true')).prepend(methods.uniqueID(slider.slides.last().clone().addClass('clone')).attr('aria-hidden', 'true'));
        }

        slider.newSlides = $(slider.vars.selector, slider);
        sliderOffset = reverse ? slider.count - 1 - slider.currentSlide + slider.cloneOffset : slider.currentSlide + slider.cloneOffset; // VERTICAL:

        if (vertical && !carousel) {
          slider.container.height((slider.count + slider.cloneCount) * 200 + "%").css("position", "absolute").width("100%");
          setTimeout(function () {
            slider.newSlides.css({
              "display": "block"
            });
            slider.doMath();
            slider.viewport.height(slider.h);
            slider.setProps(sliderOffset * slider.h, "init");
          }, type === "init" ? 100 : 0);
        } else {
          slider.container.width((slider.count + slider.cloneCount) * 200 + "%");
          slider.setProps(sliderOffset * slider.computedW, "init");
          setTimeout(function () {
            slider.doMath();

            if (slider.vars.rtl) {
              slider.newSlides.css({
                "width": slider.computedW,
                "marginRight": slider.computedM,
                "float": "left",
                "display": "block"
              });
            } else {
              slider.newSlides.css({
                "width": slider.computedW,
                "marginRight": slider.computedM,
                "float": "left",
                "display": "block"
              });
            } // SMOOTH HEIGHT:


            if (slider.vars.smoothHeight) {
              methods.smoothHeight();
            }
          }, type === "init" ? 100 : 0);
        }
      } else {
        // FADE:
        if (slider.vars.rtl) {
          slider.slides.css({
            "width": "100%",
            "float": 'right',
            "marginLeft": "-100%",
            "position": "relative"
          });
        } else {
          slider.slides.css({
            "width": "100%",
            "float": 'left',
            "marginRight": "-100%",
            "position": "relative"
          });
        }

        if (type === "init") {
          if (!touch) {
            //slider.slides.eq(slider.currentSlide).fadeIn(slider.vars.animationSpeed, slider.vars.easing);
            if (slider.vars.fadeFirstSlide == false) {
              slider.slides.css({
                "opacity": 0,
                "display": "block",
                "zIndex": 1
              }).eq(slider.currentSlide).css({
                "zIndex": 2
              }).css({
                "opacity": 1
              });
            } else {
              slider.slides.css({
                "opacity": 0,
                "display": "block",
                "zIndex": 1
              }).eq(slider.currentSlide).css({
                "zIndex": 2
              }).animate({
                "opacity": 1
              }, slider.vars.animationSpeed, slider.vars.easing);
            }
          } else {
            slider.slides.css({
              "opacity": 0,
              "display": "block",
              "webkitTransition": "opacity " + slider.vars.animationSpeed / 1000 + "s ease",
              "zIndex": 1
            }).eq(slider.currentSlide).css({
              "opacity": 1,
              "zIndex": 2
            });
          }
        } // SMOOTH HEIGHT:


        if (slider.vars.smoothHeight) {
          methods.smoothHeight();
        }
      } // !CAROUSEL:
      // CANDIDATE: active slide


      if (!carousel) {
        slider.slides.removeClass(namespace + "active-slide").eq(slider.currentSlide).addClass(namespace + "active-slide");
      } //FlexSlider: init() Callback


      slider.vars.init(slider);
    };

    slider.doMath = function () {
      var slide = slider.slides.first(),
          slideMargin = slider.vars.itemMargin,
          minItems = slider.vars.minItems,
          maxItems = slider.vars.maxItems;
      slider.w = slider.viewport === undefined ? slider.width() : slider.viewport.width();
      slider.h = slide.height();
      slider.boxPadding = slide.outerWidth() - slide.width(); // CAROUSEL:

      if (carousel) {
        slider.itemT = slider.vars.itemWidth + slideMargin;
        slider.itemM = slideMargin;
        slider.minW = minItems ? minItems * slider.itemT : slider.w;
        slider.maxW = maxItems ? maxItems * slider.itemT - slideMargin : slider.w;
        slider.itemW = slider.minW > slider.w ? (slider.w - slideMargin * (minItems - 1)) / minItems : slider.maxW < slider.w ? (slider.w - slideMargin * (maxItems - 1)) / maxItems : slider.vars.itemWidth > slider.w ? slider.w : slider.vars.itemWidth;
        slider.visible = Math.floor(slider.w / slider.itemW);
        slider.move = slider.vars.move > 0 && slider.vars.move < slider.visible ? slider.vars.move : slider.visible;
        slider.pagingCount = Math.ceil((slider.count - slider.visible) / slider.move + 1);
        slider.last = slider.pagingCount - 1;
        slider.limit = slider.pagingCount === 1 ? 0 : slider.vars.itemWidth > slider.w ? slider.itemW * (slider.count - 1) + slideMargin * (slider.count - 1) : (slider.itemW + slideMargin) * slider.count - slider.w - slideMargin;
      } else {
        slider.itemW = slider.w;
        slider.itemM = slideMargin;
        slider.pagingCount = slider.count;
        slider.last = slider.count - 1;
      }

      slider.computedW = slider.itemW - slider.boxPadding;
      slider.computedM = slider.itemM;
    };

    slider.update = function (pos, action) {
      slider.doMath(); // update currentSlide and slider.animatingTo if necessary

      if (!carousel) {
        if (pos < slider.currentSlide) {
          slider.currentSlide += 1;
        } else if (pos <= slider.currentSlide && pos !== 0) {
          slider.currentSlide -= 1;
        }

        slider.animatingTo = slider.currentSlide;
      } // update controlNav


      if (slider.vars.controlNav && !slider.manualControls) {
        if (action === "add" && !carousel || slider.pagingCount > slider.controlNav.length) {
          methods.controlNav.update("add");
        } else if (action === "remove" && !carousel || slider.pagingCount < slider.controlNav.length) {
          if (carousel && slider.currentSlide > slider.last) {
            slider.currentSlide -= 1;
            slider.animatingTo -= 1;
          }

          methods.controlNav.update("remove", slider.last);
        }
      } // update directionNav


      if (slider.vars.directionNav) {
        methods.directionNav.update();
      }
    };

    slider.addSlide = function (obj, pos) {
      var $obj = $(obj);
      slider.count += 1;
      slider.last = slider.count - 1; // append new slide

      if (vertical && reverse) {
        pos !== undefined ? slider.slides.eq(slider.count - pos).after($obj) : slider.container.prepend($obj);
      } else {
        pos !== undefined ? slider.slides.eq(pos).before($obj) : slider.container.append($obj);
      } // update currentSlide, animatingTo, controlNav, and directionNav


      slider.update(pos, "add"); // update slider.slides

      slider.slides = $(slider.vars.selector + ':not(.clone)', slider); // re-setup the slider to accomdate new slide

      slider.setup(); //FlexSlider: added() Callback

      slider.vars.added(slider);
    };

    slider.removeSlide = function (obj) {
      var pos = isNaN(obj) ? slider.slides.index($(obj)) : obj; // update count

      slider.count -= 1;
      slider.last = slider.count - 1; // remove slide

      if (isNaN(obj)) {
        $(obj, slider.slides).remove();
      } else {
        vertical && reverse ? slider.slides.eq(slider.last).remove() : slider.slides.eq(obj).remove();
      } // update currentSlide, animatingTo, controlNav, and directionNav


      slider.doMath();
      slider.update(pos, "remove"); // update slider.slides

      slider.slides = $(slider.vars.selector + ':not(.clone)', slider); // re-setup the slider to accomdate new slide

      slider.setup(); // FlexSlider: removed() Callback

      slider.vars.removed(slider);
    }; //FlexSlider: Initialize


    methods.init();
  }; // Ensure the slider isn't focussed if the window loses focus.


  $(window).blur(function (e) {
    focused = false;
  }).focus(function (e) {
    focused = true;
  }); //FlexSlider: Default Settings

  $.flexslider.defaults = {
    namespace: "flex-",
    //{NEW} String: Prefix string attached to the class of every element generated by the plugin
    selector: ".slides > li",
    //{NEW} Selector: Must match a simple pattern. '{container} > {slide}' -- Ignore pattern at your own peril
    animation: "fade",
    //String: Select your animation type, "fade" or "slide"
    easing: "swing",
    //{NEW} String: Determines the easing method used in jQuery transitions. jQuery easing plugin is supported!
    direction: "horizontal",
    //String: Select the sliding direction, "horizontal" or "vertical"
    reverse: false,
    //{NEW} Boolean: Reverse the animation direction
    animationLoop: true,
    //Boolean: Should the animation loop? If false, directionNav will received "disable" classes at either end
    smoothHeight: false,
    //{NEW} Boolean: Allow height of the slider to animate smoothly in horizontal mode
    startAt: 0,
    //Integer: The slide that the slider should start on. Array notation (0 = first slide)
    slideshow: true,
    //Boolean: Animate slider automatically
    slideshowSpeed: 7000,
    //Integer: Set the speed of the slideshow cycling, in milliseconds
    animationSpeed: 600,
    //Integer: Set the speed of animations, in milliseconds
    initDelay: 0,
    //{NEW} Integer: Set an initialization delay, in milliseconds
    randomize: false,
    //Boolean: Randomize slide order
    fadeFirstSlide: true,
    //Boolean: Fade in the first slide when animation type is "fade"
    thumbCaptions: false,
    //Boolean: Whether or not to put captions on thumbnails when using the "thumbnails" controlNav.
    // Usability features
    pauseOnAction: true,
    //Boolean: Pause the slideshow when interacting with control elements, highly recommended.
    pauseOnHover: false,
    //Boolean: Pause the slideshow when hovering over slider, then resume when no longer hovering
    pauseInvisible: true,
    //{NEW} Boolean: Pause the slideshow when tab is invisible, resume when visible. Provides better UX, lower CPU usage.
    useCSS: true,
    //{NEW} Boolean: Slider will use CSS3 transitions if available
    touch: true,
    //{NEW} Boolean: Allow touch swipe navigation of the slider on touch-enabled devices
    video: false,
    //{NEW} Boolean: If using video in the slider, will prevent CSS3 3D Transforms to avoid graphical glitches
    // Primary Controls
    controlNav: true,
    //Boolean: Create navigation for paging control of each slide? Note: Leave true for manualControls usage
    directionNav: true,
    //Boolean: Create navigation for previous/next navigation? (true/false)
    prevText: "Previous",
    //String: Set the text for the "previous" directionNav item
    nextText: "Next",
    //String: Set the text for the "next" directionNav item
    // Secondary Navigation
    keyboard: true,
    //Boolean: Allow slider navigating via keyboard left/right keys
    multipleKeyboard: false,
    //{NEW} Boolean: Allow keyboard navigation to affect multiple sliders. Default behavior cuts out keyboard navigation with more than one slider present.
    mousewheel: false,
    //{UPDATED} Boolean: Requires jquery.mousewheel.js (https://github.com/brandonaaron/jquery-mousewheel) - Allows slider navigating via mousewheel
    pausePlay: false,
    //Boolean: Create pause/play dynamic element
    pauseText: "Pause",
    //String: Set the text for the "pause" pausePlay item
    playText: "Play",
    //String: Set the text for the "play" pausePlay item
    // Special properties
    controlsContainer: "",
    //{UPDATED} jQuery Object/Selector: Declare which container the navigation elements should be appended too. Default container is the FlexSlider element. Example use would be $(".flexslider-container"). Property is ignored if given element is not found.
    manualControls: "",
    //{UPDATED} jQuery Object/Selector: Declare custom control navigation. Examples would be $(".flex-control-nav li") or "#tabs-nav li img", etc. The number of elements in your controlNav should match the number of slides/tabs.
    customDirectionNav: "",
    //{NEW} jQuery Object/Selector: Custom prev / next button. Must be two jQuery elements. In order to make the events work they have to have the classes "prev" and "next" (plus namespace)
    sync: "",
    //{NEW} Selector: Mirror the actions performed on this slider with another slider. Use with care.
    asNavFor: "",
    //{NEW} Selector: Internal property exposed for turning the slider into a thumbnail navigation for another slider
    // Carousel Options
    itemWidth: 0,
    //{NEW} Integer: Box-model width of individual carousel items, including horizontal borders and padding.
    itemMargin: 0,
    //{NEW} Integer: Margin between carousel items.
    minItems: 1,
    //{NEW} Integer: Minimum number of carousel items that should be visible. Items will resize fluidly when below this.
    maxItems: 0,
    //{NEW} Integer: Maxmimum number of carousel items that should be visible. Items will resize fluidly when above this limit.
    move: 0,
    //{NEW} Integer: Number of carousel items that should move on animation. If 0, slider will move all visible items.
    allowOneSlide: true,
    //{NEW} Boolean: Whether or not to allow a slider comprised of a single slide
    // Callback API
    start: function start() {},
    //Callback: function(slider) - Fires when the slider loads the first slide
    before: function before() {},
    //Callback: function(slider) - Fires asynchronously with each slider animation
    after: function after() {},
    //Callback: function(slider) - Fires after each slider animation completes
    end: function end() {},
    //Callback: function(slider) - Fires when the slider reaches the last slide (asynchronous)
    added: function added() {},
    //{NEW} Callback: function(slider) - Fires after a slide is added
    removed: function removed() {},
    //{NEW} Callback: function(slider) - Fires after a slide is removed
    init: function init() {},
    //{NEW} Callback: function(slider) - Fires after the slider is initially setup
    rtl: false //{NEW} Boolean: Whether or not to enable RTL mode

  }; //FlexSlider: Plugin Function

  $.fn.flexslider = function (options) {
    if (options === undefined) {
      options = {};
    }

    if ((0,esm_typeof/* default */.Z)(options) === "object") {
      return this.each(function () {
        var $this = $(this),
            selector = options.selector ? options.selector : ".slides > li",
            $slides = $this.find(selector);

        if ($slides.length === 1 && options.allowOneSlide === false || $slides.length === 0) {
          $slides.fadeIn(400);

          if (options.start) {
            options.start($this);
          }
        } else if ($this.data('flexslider') === undefined) {
          new $.flexslider(this, options);
        }
      });
    } else {
      // Helper strings to quickly perform functions on the slider
      var $slider = $(this).data('flexslider');

      switch (options) {
        case "play":
          $slider.play();
          break;

        case "pause":
          $slider.pause();
          break;

        case "stop":
          $slider.stop();
          break;

        case "next":
          $slider.flexAnimate($slider.getTarget("next"), true);
          break;

        case "prev":
        case "previous":
          $slider.flexAnimate($slider.getTarget("prev"), true);
          break;

        default:
          if (typeof options === "number") {
            $slider.flexAnimate(options, true);
          }

      }
    }
  };
})(jQuery);
;// CONCATENATED MODULE: ./src/components/flexslider/js/index.js




/* 
 *************************************
 * <!-- Flexslider (Third-party plugin) -->
 *************************************
 */



var FLEXSLIDER = function (module, $, window, document) {
  if (window.FLEXSLIDER === null) return false;
  module.FLEXSLIDER = module.FLEXSLIDER || {};
  module.FLEXSLIDER.version = '0.2.1';

  module.FLEXSLIDER.documentReady = function ($) {
    var windowWidth = window.innerWidth,
        windowHeight = window.innerHeight;
    var flexslider = {
      vars: {}
    };
    var pluginNamespace = 'uix-flexslider__';
    /*
     * Tiny helper function to add breakpoints.
     *
     * @param  {Number} number           - Number of carousel items that should be visible.
     * @return {Void}
     */

    function getGridSize(number) {
      return window.innerWidth <= 768 ? 1 : number;
    }
    /*
     * Return an event from callback function to each slider.
     *
     * @param  {Element} thisSlider             - The current slider.
     * @param  {Element} sliderWrapper          - The current slider wrapper.
     * @param  {String} fireState              - State of fire asynchronously.
     * @return {Number}                        - Index of current slider .
     */


    function initslides(sliderWrapper, thisSlider, fireState) {
      if (thisSlider.find('.' + pluginNamespace + 'item').length == 0) return false;
      var curIndex = thisSlider.currentSlide,
          count = thisSlider.count,
          activeClass = pluginNamespace + 'item--active',
          prevClass = activeClass + '-prev',
          nextClass = activeClass + '-next',
          $items = thisSlider.find('.' + pluginNamespace + 'item'),
          $current = thisSlider.slides.eq(curIndex),
          $prev = thisSlider.slides.eq(curIndex - 1),
          $next = thisSlider.slides.eq(thisSlider.animatingTo),
          $first = thisSlider.slides.eq(0),
          curHeight = $current.height(),
          dataNhumbs = thisSlider.data('my-nav-thumbs'),
          dataPNThumbs = thisSlider.data('my-prev-next-thumbs'),
          dataTimeline = thisSlider.data('my-nav-timeline'),
          dataCountTotal = thisSlider.data('my-count-total'),
          dataCountCur = thisSlider.data('my-count-now'),
          dataShowItems = thisSlider.data('my-multiple-items'),
          dataShowItemsMove = thisSlider.data('my-multiple-items-move'),
          dataParallax = thisSlider.data('my-parallax'),
          dataCustomConID = thisSlider.data('my-controls');
      if ((0,esm_typeof/* default */.Z)(dataPNThumbs) === ( true ? "undefined" : 0)) dataPNThumbs = false;
      if ((0,esm_typeof/* default */.Z)(dataTimeline) === ( true ? "undefined" : 0)) dataTimeline = false;
      if ((0,esm_typeof/* default */.Z)(dataCountTotal) === ( true ? "undefined" : 0)) dataCountTotal = false;
      if ((0,esm_typeof/* default */.Z)(dataCountCur) === ( true ? "undefined" : 0)) dataCountCur = false;
      if ((0,esm_typeof/* default */.Z)(dataParallax) === ( true ? "undefined" : 0)) dataParallax = false;
      if ((0,esm_typeof/* default */.Z)(dataShowItemsMove) === ( true ? "undefined" : 0)) dataShowItemsMove = 1; //Add disabled class to custom navigation 

      if ((0,esm_typeof/* default */.Z)(dataCustomConID) != ( true ? "undefined" : 0) && dataCustomConID != '' && dataCustomConID != false) {
        var myCustomDirectionNav = $('.uix-flexslider__mycontrols' + dataCustomConID + ' a');
        var disabledClass = pluginNamespace + 'disabled';

        if (thisSlider.pagingCount === 1) {
          myCustomDirectionNav.addClass(disabledClass).attr('tabindex', '-1');
        } else if (!thisSlider.vars.animationLoop) {
          if (thisSlider.animatingTo === 0) {
            myCustomDirectionNav.removeClass(disabledClass);
            myCustomDirectionNav.first().addClass(disabledClass).attr('tabindex', '-1');
          } else if (thisSlider.animatingTo === thisSlider.last) {
            myCustomDirectionNav.removeClass(disabledClass);
            myCustomDirectionNav.last().addClass(disabledClass).attr('tabindex', '-1');
          } else {
            myCustomDirectionNav.removeClass(disabledClass).removeAttr('tabindex');
          }
        } else {
          myCustomDirectionNav.removeClass(disabledClass).removeAttr('tabindex');
        }
      } //Total counter selector
      //Current counter selector.


      var countTotalSelector = dataCountTotal ? $(dataCountTotal) : $('.uix-flexslider__mycontrols__count em.count'),
          countCurSelector = dataCountCur ? $(dataCountCur) : $('.uix-flexslider__mycontrols__count em.current'); // Fires when the slider loads the first slide.
      // Fires after each slider animation completes.

      if (fireState == 'start' || fireState == 'after') {
        //Remove the slider loading
        //-------------------------------------
        thisSlider.removeClass(pluginNamespace + '-flexslider-loading'); //With Timeline
        //-------------------------------------	

        if (dataTimeline && dataTimeline != '') {
          var curPerMinWidth = curIndex / count * 100 + '%',
              curPerMaxWidth = (curIndex + 1) / count * 100 + '%',
              curTotalWidth = $(dataTimeline).width(); //Fires animation effect of an element width.

          $(dataTimeline).find('> span').css({
            'width': curTotalWidth,
            'transition': 'all ' + parseFloat(thisSlider.vars.slideshowSpeed - thisSlider.vars.animationSpeed) + 'ms linear'
          });
        } //Display Next/Prev image thumbnail in navigation
        //-------------------------------------		


        if (dataPNThumbs && dataPNThumbs != '') {
          var prevIndex = curIndex - 1,
              nextIndex = thisSlider.animatingTo + 1,
              pimg = '',
              nimg = '',
              $plink = $(dataPNThumbs + '> a'),
              $plinkPrev = $plink.filter('.uix-flexslider__mycontrols--thumb__prev'),
              $plinkNext = $plink.filter('.uix-flexslider__mycontrols--thumb__next');
          $plinkPrev.removeClass('is-disabled');
          $plinkNext.removeClass('is-disabled');

          if (!thisSlider.vars.animationLoop) {
            if (prevIndex === -1) $plinkPrev.addClass('is-disabled');
            if (nextIndex === thisSlider.last + 1) $plinkNext.addClass('is-disabled');
          } else {
            if (prevIndex === -1) prevIndex = thisSlider.last;
            if (nextIndex === thisSlider.last + 1) nextIndex = 0;
          } //Get images URL


          pimg = thisSlider.slides.eq(prevIndex).find('img').attr('src');
          nimg = thisSlider.slides.eq(nextIndex).find('img').attr('src');

          if ($(dataPNThumbs).length > 0) {
            $plink.attr('href', 'javascript:void(0);');
            if ((0,esm_typeof/* default */.Z)(pimg) != ( true ? "undefined" : 0)) $plinkPrev.attr('data-goto', prevIndex).find('> span').html('<img src="' + pimg + '" alt="">');
            if ((0,esm_typeof/* default */.Z)(nimg) != ( true ? "undefined" : 0)) $plinkNext.attr('data-goto', nextIndex).find('> span').html('<img src="' + nimg + '" alt="">');
            $plink.off('click').on('click', function (e) {
              e.preventDefault();
              thisSlider.flexslider(parseInt($(this).attr('data-goto')));
            });
          }
        } // Fires local videos asynchronously with slider switch.
        //-------------------------------------


        videoEmbedInit($items, false);
        videoEmbedInit($current, true); //Auto-restart player if paused after action
        //-------------------------------------

        if (thisSlider.vars.slideshow) {
          if (!thisSlider.playing) {
            thisSlider.play();
          }
        } //Prevent to <a> of page transitions
        //-------------------------------------


        $('a').each(function () {
          var attr = $(this).attr('href');

          if ((0,esm_typeof/* default */.Z)(attr) === ( true ? "undefined" : 0)) {
            $(this).attr('href', '#');
          }
        }); //Thumbnail ControlNav Pattern
        //-------------------------------------

        if (dataNhumbs && dataNhumbs != '') {
          $('.uix-flexslider__thumbs' + dataNhumbs + ' > ul > li').removeClass('is-active');
          $('.uix-flexslider__thumbs' + dataNhumbs + ' > ul > li').eq(curIndex).addClass('is-active');
        } //Initialize items background of the slider
        //-------------------------------------


        thisSlider.find('[data-slider-bg]').each(function () {
          $(this).css('background-image', 'url(' + $(this).data('slider-bg') + ')');
        }); //Enable "prettyPhoto" plugin
        //-------------------------------------

        if ($.isFunction($.fn.lightbox)) {
          thisSlider.slides.find("a[rel^='theme-slider-prettyPhoto']").lightbox();
        } //Return an event from callback function to each slider 
        //with dynamic min/max ranges.
        //-------------------------------------


        if ((0,esm_typeof/* default */.Z)(dataShowItems) != ( true ? "undefined" : 0) && dataShowItems != '' && dataShowItems != 0) {
          if (dataShowItemsMove == 1) {
            $items.removeClass(activeClass);
            $items.removeClass(prevClass);
            $items.removeClass(nextClass);

            if (windowWidth <= 768) {
              //Focus slider
              $items.eq(parseFloat(curIndex)).addClass(activeClass);
            } else {
              //Focus slider
              $items.eq(parseFloat(curIndex + 1)).addClass(activeClass); //Previous slider

              $items.eq(parseFloat(curIndex)).addClass(prevClass); //Next slider

              $items.eq(parseFloat(curIndex + 2)).addClass(nextClass);
            }
          } else {
            $items.addClass(activeClass);
          }
        } //Display counter
        //-------------------------------------


        if (sliderWrapper.find('.uix-flexslider__mycontrols__count').length == 0) {
          if (sliderWrapper.closest('section').find('.uix-flexslider__mycontrols__count').length > 0) {
            var showCountTotal = count,
                showCountCur = curIndex + 1;
            if (showCountTotal < 10) showCountTotal = '0' + showCountTotal;
            if (showCountCur < 10) showCountCur = '0' + showCountCur;
            countTotalSelector.text(showCountTotal);
            countCurSelector.text(showCountCur);
          }
        }
      } // Fires asynchronously with each slider animation.


      if (fireState == 'before') {
        //Common images style
        //-------------------------------------	
        $next.find('img').addClass('is-active');
        $current.find('img').removeClass('is-active');
        $prev.find('img').removeClass('is-active');
        $first.find('img').removeClass('is-active'); //With Timeline
        //-------------------------------------	

        if (dataTimeline && dataTimeline != '') {
          //Fires animation effect of an element width.
          $(dataTimeline).find('> span').css({
            'width': 0,
            'transition': 'all 100ms linear'
          });
        }
      } // Fires when the slider reaches the last slide (asynchronous).


      if (fireState == 'end') {
        //Common images style
        //-------------------------------------	
        $first.find('img').addClass('is-active');
      } // Fires asynchronously with each slider animation.
      // Fires when the slider loads the first slide.


      if (fireState == 'before' || fireState == 'start') {
        //Return an event from callback function to each slider to make parallax effect.
        //-------------------------------------
        if (dataParallax) {
          var dir = 'uix-flexslider__item--left';
          $.each(thisSlider.slides, function (i, item) {
            var el = $(item);
            el.removeClass('uix-flexslider__item--right uix-flexslider__item--left');

            if (i >= thisSlider.animatingTo && dir !== 'uix-flexslider__item--right') {
              dir = 'uix-flexslider__item--right';
            } else {
              el.addClass(dir);
            }
          });
        }
      }

      return curIndex;
    }
    /*
     * Initialize embedded local video.
     *
     * @param  {Element} wrapper          - The outermost video container, which can contain multiple videos
     * @param  {Boolean} play            - Forced to trigger pause or play events.
     * @return {Void}
     */


    function videoEmbedInit(wrapper, play) {
      wrapper.find('.uix-video__slider').each(function () {
        var $this = $(this);
        var videoWrapperW = $this.closest('[data-embed-video-wrapper]').width(),
            curVideoID = $this.find('video').attr('id') + '-slider-videopush',
            coverPlayBtnID = 'videocover-' + curVideoID,
            $replayBtn = $('#' + curVideoID + '-replay-btn');
        var dataControls = $this.data('embed-video-controls'),
            dataAuto = $this.data('embed-video-autoplay'),
            dataLoop = $this.data('embed-video-loop'),
            dataW = $this.data('embed-video-width'),
            dataH = $this.data('embed-video-height'); //Push a new ID to video
        //Solve the problem that ajax asynchronous loading does not play

        $this.find('.video-js').attr('id', curVideoID);

        if ((0,esm_typeof/* default */.Z)(dataAuto) === ( true ? "undefined" : 0)) {
          dataAuto = true;
        }

        if ((0,esm_typeof/* default */.Z)(dataLoop) === ( true ? "undefined" : 0)) {
          dataLoop = true;
        }

        if ((0,esm_typeof/* default */.Z)(dataControls) === ( true ? "undefined" : 0)) {
          dataControls = false;
        }

        if ((0,esm_typeof/* default */.Z)(dataW) === ( true ? "undefined" : 0) || dataW == 'auto') {
          dataW = videoWrapperW;
        }

        if ((0,esm_typeof/* default */.Z)(dataH) === ( true ? "undefined" : 0) || dataH == 'auto') {
          dataH = videoWrapperW / 1.77777777777778;
        } //Display cover and play buttons when some mobile device browsers cannot automatically play video


        if ($('#' + coverPlayBtnID).length == 0) {
          $('<div id="' + coverPlayBtnID + '" class="uix-video__cover"><span class="uix-video__cover__placeholder" style="background-image:url(' + $this.find('video').attr('poster') + ')"></span><span class="uix-video__cover__playbtn"></span></div>').insertBefore($this);
          var btnEv = Modernizr.touchevents ? 'touchstart' : 'click';
          $('#' + coverPlayBtnID + ' .uix-video__cover__playbtn').on(btnEv, function (e) {
            e.preventDefault();
            myPlayer.play();
            $('#' + coverPlayBtnID).hide();
          });
        } //Add replay button to video 


        if ($replayBtn.length == 0) {
          $this.after('<span class="uix-video__btn-play" id="' + curVideoID + '-replay-btn"></span>');
        } //HTML5 video autoplay on mobile revisited


        if (dataAuto && windowWidth <= 768) {
          $this.find('.video-js').attr({
            'autoplay': 'true',
            'muted': 'true',
            'playsinline': 'true'
          });
        }

        var myPlayer = videojs(curVideoID, {
          width: dataW,
          height: dataH,
          loop: dataLoop,
          autoplay: dataAuto
        }, function onPlayerReady() {
          var initVideo = function initVideo(obj) {
            //Get Video Dimensions
            var curW = obj.videoWidth(),
                curH = obj.videoHeight(),
                newW = curW,
                newH = curH;
            newW = videoWrapperW; //Scaled/Proportional Content 

            newH = curH * (newW / curW);

            if (!isNaN(newW) && !isNaN(newH)) {
              obj.height(newH);
              obj.width(newW);
              $this.css('height', newH);
            } //Show this video wrapper


            $this.css('visibility', 'visible'); //Hide loading effect

            $this.find('.vjs-loading-spinner, .vjs-big-play-button').hide();
          };
          /* ---------  Video initialize */


          this.on('loadedmetadata', function () {
            initVideo(this);
          });
          /* ---------  Display the play button  */

          if (!dataAuto) $this.find('.vjs-big-play-button').show();
          $this.find('.vjs-big-play-button').off('click').on('click', function () {
            $(this).hide();
          });
          /* ---------  Set, tell the player it's in fullscreen  */

          if (dataAuto) {
            //Fix an error of Video auto play is not working in browser
            //this.muted( true ); 
            //Prevent autoplay error: Uncaught (in promise) DOMException
            var promise = this.play();

            if (promise !== undefined) {
              promise.then(function () {// Autoplay started!
              })["catch"](function (error) {
                // Autoplay was prevented.
                $('#' + coverPlayBtnID).show();
                $('#' + coverPlayBtnID + ' .uix-video__cover__playbtn').show();
                console.log('Autoplay was prevented.');
              });
            }
          }
          /* ---------  Disable control bar play button click */


          if (!dataControls) {
            this.controls(false);
          }
          /* ---------  Determine if the video is auto played from mobile devices  */


          var autoPlayOK = false;
          this.on('timeupdate', function () {
            var duration = this.duration();

            if (duration > 0) {
              autoPlayOK = true;

              if (this.currentTime() > 0) {
                autoPlayOK = true;
                this.off('timeupdate'); //Hide cover and play buttons when the video automatically played

                $('#' + coverPlayBtnID).hide();
              }
            }
          });
          /* ---------  Pause the video when it is not current slider  */

          if (!play) {
            this.pause();
            this.currentTime(0);
          } else {
            if (dataAuto) {
              this.currentTime(0); //Prevent autoplay error: Uncaught (in promise) DOMException

              var _promise = this.play();

              if (_promise !== undefined) {
                _promise.then(function () {// Autoplay started!
                })["catch"](function (error) {
                  // Autoplay was prevented.
                  $('#' + coverPlayBtnID).show();
                  $('#' + coverPlayBtnID + ' .uix-video__cover__playbtn').show();
                  console.log('Autoplay was prevented.');
                });
              } //Hidden replay button


              $replayBtn.hide(); //Should the video go to the beginning when it ends

              this.on('ended', function () {
                if (dataLoop) {
                  this.currentTime(0);
                  this.play();
                } else {
                  //Replay this video
                  this.currentTime(0);
                  $replayBtn.show().off('click').on('click', function (e) {
                    e.preventDefault();
                    this.play();
                    $replayBtn.hide();
                  });
                }
              });
            }
          }
        });
      });
    }
    /*
     * Make slider image draggable 
     *
     * @param  {Element} $obj             - The current FlexSlider setup using custom selector.
     * @return {Void}
     */


    function slidesExDraggable($obj, animDelay) {
      function prevMove() {
        $obj.flexslider('prev');
      }

      function nextMove() {
        $obj.flexslider('next');
      } //Added touch method to mobile device and desktop
      //-------------------------------------	


      var $dragTrigger = $obj.find('.uix-flexslider__inner');
      var mouseX, mouseY;
      var isMoving = false; //Avoid images causing mouseup to fail

      $dragTrigger.find('img').css({
        'pointer-events': 'none',
        'user-select': 'none'
      }); //Make the cursor a move icon when a user hovers over an item

      $dragTrigger.css('cursor', 'move');
      $dragTrigger[0].removeEventListener('mousedown', dragStart);
      document.removeEventListener('mouseup', dragEnd); //

      $dragTrigger[0].addEventListener('mousedown', dragStart);

      function dragStart(e) {
        if ($obj.data('flexslider').animating) {
          return;
        } //Do not use "e.preventDefault()" to avoid prevention page scroll on drag in IOS and Android


        mouseX = e.clientX;
        mouseY = e.clientY;
        document.addEventListener('mouseup', dragEnd);
        document.addEventListener('mousemove', dragProcess);
      }

      function dragProcess(e) {
        var offsetX, offsetY;
        offsetX = mouseX - e.clientX, offsetY = mouseY - e.clientY;

        if ('horizontal' === $obj.data('flexslider').vars.direction) {
          //--- left
          if (offsetX >= 50) {
            if (!isMoving) {
              isMoving = true;
              nextMove();
            }
          } //--- right


          if (offsetX <= -50) {
            if (!isMoving) {
              isMoving = true;
              prevMove();
            }
          }
        } else {
          //--- up
          if (offsetY >= 50) {
            if (!isMoving) {
              isMoving = true;
              nextMove();
            }
          } //--- down


          if (offsetY <= -50) {
            if (!isMoving) {
              isMoving = true;
              prevMove();
            }
          }
        }
      }

      function dragEnd(e) {
        document.removeEventListener('mousemove', dragProcess); //restore move action status

        setTimeout(function () {
          isMoving = false;
        }, animDelay);
      }
    }
    /*
     *  Scroll The Slider With Mousewheel
     *
     * @param  {Element} $obj            - The current FlexSlider setup using custom selector.
     * @return {Void}
     */


    function slidesExMousewheel($obj) {
      var timer = null,
          wheeling = false;
      $obj[0].addEventListener('wheel', function (e) {
        //Gets a value that indicates the amount that the mouse wheel has changed.
        var delta = Math.max(-1, Math.min(1, -e.deltaY));

        if (timer) {
          clearTimeout(timer);
        }

        if (!wheeling) {
          if (delta < 0) {
            //scroll down
            $obj.flexslider('next');
          } else {
            //scroll up
            $obj.flexslider('prev');
          }
        }

        wheeling = true;
        timer = setTimeout(function () {
          wheeling = false;
        }, 60);
      }, UixBrowser.supportsPassive ? {
        passive: true
      } : false);
    }
    /*
     * Slider With Thumbnail ControlNav Pattern
     *
     * @param  {Element} slider           - The current slider.
     * @param  {String} navThumbClass    - Class name of thumbnail controlNav.
     * @return {Void}
     */


    function initslidesWithNavThumb(slider, navThumbClass) {
      $('.uix-flexslider__thumbs' + navThumbClass + ' > ul > li').off('click').on('click', function () {
        $('.uix-flexslider__thumbs' + navThumbClass + ' > ul > li').removeClass('is-active');
        $(this).addClass('is-active');
        slider.flexslider($(this).index());
      });
    }
    /*
    * Method that updates children slides
    * fortunately, since all the children are not animating,
    * they will only update if the main flexslider updates. 
     *
     * @param  {Number} slideNumber          - The current slider index.
     * @param  {Element} childrenSlidesObj    - Target slider.
     * @param  {Boolean} loop                - Gives the slider a seamless infinite loop.
     * @param  {Number} speed                - Set the speed of animations, in milliseconds.
     * @param  {Number} timing               - Set the speed of the slideshow cycling, in milliseconds.
     * @return {Void}
     */


    function updateChildrenSlides(slideNumber, childrenSlidesObj, loop, speed, timing) {
      /** 
      * Create the children flexsliders. Must be array of jquery objects with the
      * flexslider data. Easiest way is to place selector group in a var.
      */
      var childrenSlides = $(childrenSlidesObj).flexslider({
        slideshow: false,
        // Remove the animations
        controlNav: false,
        // Remove the controls
        animationLoop: loop,
        animationSpeed: speed,
        slideshowSpeed: timing
      }); // Iterate through the children slides but not past the max

      for (var i = 0; i < childrenSlides.length; i++) {
        // Run the animate method on the child slide
        $(childrenSlides[i]).data('flexslider').flexAnimate(slideNumber);
      }
    }
    /*! 
     ---------------------------
           Initialize slideshow
     ---------------------------
     */


    var $sliderDefault = $('.uix-flexslider');
    $sliderDefault.each(function () {
      var $this = $(this);
      var dataSpeed = $this.data('speed'),
          dataDrag = $this.data('draggable'),
          dataWheel = $this.data('wheel'),
          dataTiming = $this.data('timing'),
          dataLoop = $this.data('loop'),
          dataPrev = $this.data('prev'),
          dataNext = $this.data('next'),
          dataAnim = $this.data('animation'),
          dataPaging = $this.data('paging'),
          dataArrows = $this.data('arrows'),
          dataAuto = $this.data('auto'),
          dataNhumbs = $this.data('my-nav-thumbs'),
          dataPNThumbs = $this.data('my-prev-next-thumbs'),
          dataTimeline = $this.data('my-nav-timeline'),
          dataCountTotal = $this.data('my-count-total'),
          dataCountCur = $this.data('my-count-now'),
          customConID = $this.data('my-controls'),
          dataShowItems = $this.data('my-multiple-items'),
          dataShowItemsMove = $this.data('my-multiple-items-move'),
          dataParallax = $this.data('my-parallax'),
          dataSync = $this.data('my-sync'); //Fires local videos asynchronously with slider switch.

      videoEmbedInit($this.find('.uix-flexslider__item'), false); // Custom Controls

      var myControlsContainer, myCustomDirectionNav;

      if ((0,esm_typeof/* default */.Z)(customConID) === ( true ? "undefined" : 0) || customConID == '' || customConID == false) {
        myControlsContainer = '';
        myCustomDirectionNav = '';
      } else {
        myControlsContainer = $('.uix-flexslider__mycontrols' + customConID + ' .uix-flexslider__mycontrols__control-paging');
        myCustomDirectionNav = $('.uix-flexslider__mycontrols' + customConID + ' a'); //Change the class naming of the page up and down buttons to support trigger events

        myCustomDirectionNav.first().addClass(pluginNamespace + 'prev');
        myCustomDirectionNav.last().addClass(pluginNamespace + 'next');
      } // If there is no data-xxx, save current source to it


      if ((0,esm_typeof/* default */.Z)(dataSpeed) === ( true ? "undefined" : 0)) dataSpeed = 600;
      if ((0,esm_typeof/* default */.Z)(dataTiming) === ( true ? "undefined" : 0)) dataTiming = 10000;
      if ((0,esm_typeof/* default */.Z)(dataLoop) === ( true ? "undefined" : 0)) dataLoop = true;
      if ((0,esm_typeof/* default */.Z)(dataPrev) === ( true ? "undefined" : 0)) dataPrev = "<i class='fa fa-chevron-left'></i>";
      if ((0,esm_typeof/* default */.Z)(dataNext) === ( true ? "undefined" : 0)) dataNext = "<i class='fa fa-chevron-right'></i>";
      if ((0,esm_typeof/* default */.Z)(dataAnim) === ( true ? "undefined" : 0)) dataAnim = 'slide';
      if ((0,esm_typeof/* default */.Z)(dataPaging) === ( true ? "undefined" : 0)) dataPaging = true;
      if ((0,esm_typeof/* default */.Z)(dataArrows) === ( true ? "undefined" : 0)) dataArrows = true;
      if ((0,esm_typeof/* default */.Z)(dataAuto) === ( true ? "undefined" : 0)) dataAuto = true;
      if ((0,esm_typeof/* default */.Z)(dataDrag) === ( true ? "undefined" : 0)) dataDrag = false;
      if ((0,esm_typeof/* default */.Z)(dataWheel) === ( true ? "undefined" : 0)) dataWheel = false;
      if ((0,esm_typeof/* default */.Z)(dataNhumbs) === ( true ? "undefined" : 0)) dataNhumbs = false;
      if ((0,esm_typeof/* default */.Z)(dataPNThumbs) === ( true ? "undefined" : 0)) dataPNThumbs = false;
      if ((0,esm_typeof/* default */.Z)(dataTimeline) === ( true ? "undefined" : 0)) dataTimeline = false;
      if ((0,esm_typeof/* default */.Z)(dataCountTotal) === ( true ? "undefined" : 0)) dataCountTotal = false;
      if ((0,esm_typeof/* default */.Z)(dataCountCur) === ( true ? "undefined" : 0)) dataCountCur = false;
      if ((0,esm_typeof/* default */.Z)(dataParallax) === ( true ? "undefined" : 0)) dataParallax = false;
      if ((0,esm_typeof/* default */.Z)(dataShowItemsMove) === ( true ? "undefined" : 0)) dataShowItemsMove = 1; //Make slider image draggable 

      if (dataDrag) slidesExDraggable($this, dataSpeed); //Scroll The Slider With Mousewheel

      if (dataWheel) slidesExMousewheel($this); //With Thumbnail ControlNav Pattern

      if (dataNhumbs) {
        initslidesWithNavThumb($this, dataNhumbs); //Prevent index error

        dataLoop = false;
      } //Show number of items


      var my_itemWidth = 0,
          my_move = dataShowItemsMove,
          my_minItems = 0,
          my_maxItems = 0;

      if ((0,esm_typeof/* default */.Z)(dataShowItems) != ( true ? "undefined" : 0) && dataShowItems != '' && dataShowItems != 0) {
        my_itemWidth = 1;
        my_minItems = getGridSize(dataShowItems);
        my_maxItems = getGridSize(dataShowItems);
      } // Determine if this slider is added with a synchronization event


      $('[data-my-sync]').each(function () {
        var curSync = $(this).data('my-sync');
        var thisSliderID = $this.attr('id');

        if ((0,esm_typeof/* default */.Z)(curSync) != ( true ? "undefined" : 0)) {
          curSync = curSync.toString().replace('#', '').replace('.', '');
        }

        if ((0,esm_typeof/* default */.Z)(thisSliderID) != ( true ? "undefined" : 0) && thisSliderID == curSync) {
          dataAuto = false; //Set it not to scroll automatically

          dataPaging = false; // break out of jQuery each Loop

          return false;
        }
      });
      $this.flexslider({
        namespace: pluginNamespace,
        animation: dataAnim,
        selector: '.uix-flexslider__inner > div.uix-flexslider__item',
        controlNav: dataPaging,
        smoothHeight: true,
        prevText: dataPrev,
        nextText: dataNext,
        animationSpeed: dataSpeed,
        slideshowSpeed: dataTiming,
        slideshow: dataAuto,
        animationLoop: dataLoop,
        directionNav: dataArrows,
        itemWidth: my_itemWidth,
        move: my_move,
        // Number of carousel items that should move on animation.
        minItems: my_minItems,
        // use function to pull in initial value
        maxItems: my_maxItems,
        // use function to pull in initial value
        controlsContainer: myControlsContainer,
        customDirectionNav: myCustomDirectionNav,
        //Fires when the slider loads the first slide.
        start: function start(slider) {
          //set slider instance to flexslider variable
          if ((0,esm_typeof/* default */.Z)(dataShowItems) != ( true ? "undefined" : 0) && dataShowItems != '' && dataShowItems != 0) {
            flexslider = slider;
          }

          initslides($this, slider, 'start');
        },
        //Fires asynchronously with each slider animation.
        before: function before(slider) {
          initslides($this, slider, 'before'); // Call the updateChildrenSlides which itterates through all children slides 

          if ((0,esm_typeof/* default */.Z)(dataSync) != ( true ? "undefined" : 0) && dataSync != '' && dataSync != 0) {
            updateChildrenSlides(slider.animatingTo, dataSync, dataLoop, dataSpeed, dataTiming);
          }
        },
        //Fires after each slider animation completes.
        after: function after(slider) {
          initslides($this, slider, 'after');
        },
        //Fires when the slider reaches the last slide (asynchronous).
        end: function end(slider) {
          initslides($this, slider, 'end');
        }
      });
    });
    /*! 
     ---------------------------
           Check grid size on resize event
     ---------------------------
     */

    function windowUpdate() {
      // Check window width has actually changed and it's not just iOS triggering a resize event on scroll
      if (window.innerWidth != windowWidth) {
        // Update the window width for next time
        windowWidth = window.innerWidth; // Do stuff here

        $sliderDefault.each(function () {
          if ($(this).length > 0) {
            // check grid size on resize event
            var dataShowItems = $(this).data('my-multiple-items');

            if ((0,esm_typeof/* default */.Z)(dataShowItems) != ( true ? "undefined" : 0) && dataShowItems != '' && dataShowItems != 0) {
              var gridSize = getGridSize(dataShowItems);
              flexslider.vars.minItems = gridSize;
              flexslider.vars.maxItems = gridSize;
            }

            $(this).data('flexslider').setup();
          }
        });
      }
    } // Add function to the window that should be resized


    var debounceFuncWindow = UixDebounce(windowUpdate, 50);
    window.removeEventListener('resize', debounceFuncWindow);
    window.addEventListener('resize', debounceFuncWindow);
  };

  module.components.documentReady.push(module.FLEXSLIDER.documentReady);
  return /*#__PURE__*/_createClass(function FLEXSLIDER() {
    _classCallCheck(this, FLEXSLIDER);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/floating-side-element/js/index.js



/* 
 *************************************
 * <!-- Floating Side Element -->
 *************************************
 */


var FLOATING_SIDE_EL = function (module, $, window, document) {
  if (window.FLOATING_SIDE_EL === null) return false;
  module.FLOATING_SIDE_EL = module.FLOATING_SIDE_EL || {};
  module.FLOATING_SIDE_EL.version = '0.0.7';

  module.FLOATING_SIDE_EL.documentReady = function ($) {
    var documentHeight = 0,
        $floatingSideEl = $('.uix-floating-side-el'),
        floatingOffset = $floatingSideEl.offset(); //Prevent this module from loading in other pages

    if ($floatingSideEl.length == 0) return false;
    documentHeight = $(document).height(); //Init position

    TweenMax.to($floatingSideEl, 0.3, {
      css: {
        marginTop: -floatingOffset.top + ($(window).height() - $floatingSideEl.height()) / 2
      }
    });

    function scrollUpdate() {
      var sideBarHeight = $floatingSideEl.height(),
          scrolled = $(window).scrollTop();
      documentHeight = $(document).height();

      if (scrolled > floatingOffset.top) {
        var newPosition = scrolled - floatingOffset.top,
            maxPosition = documentHeight - sideBarHeight;

        if (newPosition > maxPosition) {
          newPosition = maxPosition;
        }

        TweenMax.to($floatingSideEl, 0.3, {
          css: {
            marginTop: newPosition + (window.innerHeight - sideBarHeight) / 2
          }
        });
      } else {
        TweenMax.to($floatingSideEl, 0.3, {
          css: {
            marginTop: 0
          }
        });
      }
    } // Add function to the element that should be used as the scrollable area.


    var throttleFunc = UixThrottle(scrollUpdate, 5);
    window.removeEventListener('scroll', throttleFunc);
    window.removeEventListener('touchmove', throttleFunc);
    window.addEventListener('scroll', throttleFunc);
    window.addEventListener('touchmove', throttleFunc);
    throttleFunc();
  };

  module.components.documentReady.push(module.FLOATING_SIDE_EL.documentReady);
  return /*#__PURE__*/_createClass(function FLOATING_SIDE_EL() {
    _classCallCheck(this, FLOATING_SIDE_EL);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/form-progress/js/fn/form-progress-to-next.js


/*
 * Shows the next form.
 *
 * @param  {Element} selector        - Each target forms selector.
 * @param  {Element} formTarget      - Wrapper of target forms selector.
 * @param  {String} indicator       - Indicator of timeline.
 * @param  {Number} index           - Default index for initialization.
 * 									  0 => step one, 
 * 									  1 => step two
 * 									  2 => step three
 * 									  3 => step four
 * 									  4 => step five
 * 									  ...
 * @return {Void}
 */
(function ($) {
  'use strict';

  $.fn.UixFormProgressToNext = function (options) {
    // This is the easiest way to have default options.
    var settings = $.extend({
      selector: $('.uix-form-progress__target .uix-form-progress__target__step'),
      formTarget: $('.uix-form-progress__target'),
      indicator: '.uix-form-progress .uix-form-progress__indicator',
      index: 0
    }, options);
    this.each(function () {
      var $this = $(this);
      var transitionEnd = 'webkitTransitionEnd transitionend',
          $sections = settings.selector,
          $formTarget = settings.formTarget,
          $indicator = $(settings.indicator),
          allStep = $indicator.length,
          stepPerValue = 100 / (allStep - 1);
      var value = 0,
          tarIndex,
          curIndex;
      if ($indicator.length == 0) return false; //Returns current index

      if (settings.index > allStep - 1) {
        curIndex = allStep - 1;
      } else {
        curIndex = settings.index;
      }

      tarIndex = curIndex - 1; // Returns current index

      if (tarIndex > allStep - 2) {
        value = stepPerValue * (allStep - 2);
        curIndex = allStep - 2;
      } else {
        curIndex = tarIndex;
      } // Increment value (based on 4 steps 0 - 100)


      value = stepPerValue * curIndex; //Get form transition speed

      var dur = $formTarget.data('anime-speed');

      if ((0,esm_typeof/* default */.Z)(dur) === ( true ? "undefined" : 0)) {
        dur = '0.5s';
      }

      var durString = dur.toString().toLowerCase(),
          isMS = durString.indexOf('ms') >= 0,
          numberNum = durString.replace('ms', '').replace('s', ''),
          animeSpeed = isMS ? numberNum : numberNum * 1000;
      var currentFormStep = parseInt($sections.eq(tarIndex).attr('data-step')) || false,
          $nextForm = $formTarget.find('.uix-form-progress__target__step[data-step="' + (currentFormStep + 1) + '"]');
      var currentFormIndex = $nextForm.attr('data-step') - 1;
      if (isNaN(currentFormIndex)) currentFormIndex = 0; // Activate other unused modules

      if (currentFormIndex > 0) {
        for (var i = 0; i < curIndex; i++) {
          $sections.eq(i).addClass('leaving');
          $indicator.eq(i).addClass('is-active');
        }

        $indicator.eq(curIndex).addClass('is-active');
      } // Hide current form fields


      $sections.eq(tarIndex).addClass('leaving');
      setTimeout(function () {
        $indicator.eq(currentFormIndex).addClass('is-active');
      }, animeSpeed); // Show next form fields

      $nextForm.addClass('coming').one(transitionEnd, function () {
        $nextForm.removeClass('coming waiting');
      }); // Active next form fields

      $sections.removeClass('is-active');
      $sections.eq(currentFormIndex).addClass('is-active'); // Increment value (based on 4 steps 0 - 100)

      value += stepPerValue; //console.log( currentFormIndex );
      //Initialize pointer and form location data

      if (currentFormIndex == 0) {
        //Avoid initialization to always cover other same events
        $('body').addClass('form-progress-initok'); //so something

        $indicator.removeClass('is-active');
        $indicator.each(function (index) {
          $(this).css('left', index * stepPerValue + '%');
          $formTarget.find('.uix-form-progress__target__step:eq(' + index + ')').attr('data-step', index + 1);
        });
        setTimeout(function () {
          $formTarget.addClass('js-uix-show');
        }, animeSpeed);
        $formTarget.find('.uix-form-progress__target__step').removeClass('left leaving').css({
          'position': 'absolute'
        }).not(':eq(0)').addClass('waiting');
      } //Set wrapper height


      var currentContentH = $formTarget.find('.uix-form-progress__target__step:eq(' + currentFormIndex + ') > .uix-form-progress__content').height() + 100;
      $formTarget.css('height', currentContentH + 'px');
      var curText = $('.uix-form-progress .uix-form-progress__indicator:eq(' + currentFormIndex + ') > span').html();
      $('#app-form-progress-text').text(curText); //The current indicator class

      $indicator.removeClass('current');
      $indicator.eq(currentFormIndex).addClass('current'); // Reset if we've reached the end

      if (value >= 100) {
        $formTarget.find('.uix-form-progress__target__step').addClass('leaving').last().removeClass('coming waiting leaving');
      } else {
        $('.uix-form-progress').find('.uix-form-progress__indicator.is-active').next('.uix-form-progress__indicator').addClass('is-active');
      } // Set progress bar value


      $('.uix-form-progress .uix-form-progress__line span').css('width', value + '%');
      return false;
    });
  };
})(jQuery);
;// CONCATENATED MODULE: ./src/components/form-progress/js/index.js




/* 
 *************************************
 * <!-- Form Progress -->
 *************************************
 */

/*
    Note:
	
	If you want to initialize the indicator to a location when the page is first run,
	you need to call the following function:
	
	$( 'body' ).waitForImages().done(function() {
		$( document ).UixFormProgressToNext({ 
			'selector'         : $( '.uix-form-progress__target .uix-form-progress__target__step' ),
			'formTarget'       : $( '.uix-form-progress__target' ),
			'indicator'        : '.uix-form-progress .uix-form-progress__indicator',
			'index'            : 0
		});
	});


*/




var FORM_PROGRESS = function (module, $, window, document) {
  if (window.FORM_PROGRESS === null) return false;
  module.FORM_PROGRESS = module.FORM_PROGRESS || {};
  module.FORM_PROGRESS.version = '0.0.5';

  module.FORM_PROGRESS.pageLoaded = function () {
    var $progressBar = $('.uix-form-progress progress'),
        $formTarget = $('.uix-form-progress__target'),
        $indicator = $('.uix-form-progress .uix-form-progress__indicator'),
        formAreaH = $formTarget.height(),
        allStep = $indicator.length,
        stepPerValue = 100 / (allStep - 1),
        value = 0,
        transitionEnd = 'webkitTransitionEnd transitionend'; //Get form transition speed

    var dur = $formTarget.data('anime-speed');

    if ((0,esm_typeof/* default */.Z)(dur) === ( true ? "undefined" : 0)) {
      dur = '0.5s';
    }

    var durString = dur.toString().toLowerCase(),
        isMS = durString.indexOf('ms') >= 0,
        numberNum = durString.replace('ms', '').replace('s', ''),
        animeSpeed = isMS ? numberNum : numberNum * 1000; //Gets the party started.

    formReset(); //Display the target

    setTimeout(function () {
      $formTarget.addClass('is-active');
    }, parseFloat(dur) * 1000); // Show next form on continue click

    $(document).off('click.FORM_PROGRESS').on('click.FORM_PROGRESS', '.uix-form-progress__target .go-step:not(.disable)', function (e) {
      e.preventDefault();
      var $sections = $(this).parents('.uix-form-progress__target__step');
      $(document).UixFormProgressToNext({
        'selector': $('.uix-form-progress__target .uix-form-progress__target__step'),
        'formTarget': $formTarget,
        'indicator': '.uix-form-progress .uix-form-progress__indicator',
        'index': $sections.index() + 1
      }); //Scroll Top

      TweenMax.to(window, 0.5, {
        scrollTo: {
          y: 0,
          autoKill: false
        },
        ease: Power2.easeOut
      });
    }); // Reset form on reset button click

    $(document).off('click.FORM_PROGRESS_RESET').on('click.FORM_PROGRESS_RESET', '.uix-form-progress__target .go-reset', function (e) {
      e.preventDefault();
      formReset();
    });
    /*
     * Resets the form back to the default state.
     *
     * @return {Void}
     */

    function formReset() {
      $(document).UixFormProgressToNext({
        'selector': $('.uix-form-progress__target .uix-form-progress__target__step'),
        'formTarget': $('.uix-form-progress__target'),
        'indicator': '.uix-form-progress .uix-form-progress__indicator',
        'index': 0
      });
    }
  };

  module.components.pageLoaded.push(module.FORM_PROGRESS.pageLoaded);
  return /*#__PURE__*/_createClass(function FORM_PROGRESS() {
    _classCallCheck(this, FORM_PROGRESS);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/form/js/fn/normal-radio.js


/*
 * Render Normal Radio
 *
 * @param  {String} controls                 - Wrapper of controls.
 * @return {Void}
 */
(function ($) {
  'use strict';

  $.fn.UixRenderNormalRadio = function (options) {
    // This is the easiest way to have default options.
    var settings = $.extend({
      controls: '.uix-controls__radio'
    }, options);
    this.each(function () {
      $(settings.controls).each(function () {
        var $this = $(this); // Initialize status
        //------------------------------------------

        $this.find('> label').each(function () {
          var targetID = '#' + $(this).parent().attr("data-targetid");
          var switchIDs = ''; //add switch IDs

          $(this).parent().find('> label').each(function () {
            if ((0,esm_typeof/* default */.Z)($(this).data("switchid")) != ( true ? "undefined" : 0)) {
              switchIDs += $(this).data("switchid") + ',';
            }
          });
          $(this).parent().attr("data-switchids", switchIDs.replace(/,\s*$/, '')); //Set actived style from their values

          if ((0,esm_typeof/* default */.Z)($(this).data('value')) != ( true ? "undefined" : 0)) {
            if ($(targetID).val() == $(this).data('value')) {
              $(this).addClass('is-active').find('[type="radio"]').prop('checked', true);
            } else {
              $(this).removeClass('is-active').find('[type="radio"]').prop('checked', false);
            }
          }
        }); // Mouse events
        //------------------------------------------

        var normalRadioItem = settings.controls + ' > label';
        /*
        * Initialize single switch
        *
        * @param  {Element} obj                 - Radio controls. 
        * @return {Void}
        */

        var hideAllNormalRadioItems = function hideAllNormalRadioItems(obj) {
          obj.each(function (index) {
            var $sel = $(this),
                defaultValue = $('#' + $sel.attr("data-targetid")).val(),
                deffaultSwitchIndex = 0; //get default selected switch index

            $sel.find('> label').each(function (index) {
              if (defaultValue == $(this).data('value')) {
                deffaultSwitchIndex = index;
              }
            });

            if ((0,esm_typeof/* default */.Z)($sel.data('switchids')) != ( true ? "undefined" : 0) && $sel.data('switchids') != '') {
              var _switchIDsArr = $sel.data('switchids').split(',');

              _switchIDsArr.forEach(function (element, index) {
                if (deffaultSwitchIndex != index) {
                  $('#' + element).hide();
                } else {
                  $('#' + element).show();
                }
              });
            }
          });
        };

        hideAllNormalRadioItems($(settings.controls));
        $(document).off('click.FORM_NORMAL_RADIO').on('click.FORM_NORMAL_RADIO', normalRadioItem, function (e) {
          var $selector = $(this).parent(),
              $option = $(this),
              targetID = '#' + $selector.data("targetid"),
              switchID = '#' + $option.data("switchid"),
              curVal = $option.data('value'); //Radio Selector

          $selector.find('> label').removeClass('is-active').find('[type="radio"]').prop('checked', false);
          $(targetID).val(curVal);
          $option.addClass('is-active').find('[type="radio"]').prop('checked', true); //Switch some options

          if ((0,esm_typeof/* default */.Z)($option.data("switchid")) != ( true ? "undefined" : 0)) {
            hideAllNormalRadioItems($selector);
            $(switchID).show();
          } //Dynamic listening for the latest value


          $(targetID).focus().blur();
        });
      });
    });
  };
})(jQuery);
// EXTERNAL MODULE: ./src/components/form/js/third-party/jquery.mousewheel.esm.js
var jquery_mousewheel_esm = __webpack_require__(126);
;// CONCATENATED MODULE: ./src/components/form/js/third-party/jquery.datetimepicker.esm.js


/*!
 * @copyright Copyright &copy; Kartik Visweswaran, Krajee.com, 2014 - 2016
 * @version 1.3.4
 *
 * Date formatter utility library that allows formatting date/time variables or Date objects using PHP DateTime format.
 * @see http://php.net/manual/en/function.date.php
 *
 * For more JQuery plugins visit http://plugins.krajee.com
 * For more Yii related demos visit http://demos.krajee.com
 */

var DateFormatter;
!function () {
  "use strict";

  var t, _e, _r, n, a, u, i;

  u = 864e5, i = 3600, t = function t(_t, e) {
    return "string" == typeof _t && "string" == typeof e && _t.toLowerCase() === e.toLowerCase();
  }, _e = function e(t, r, n) {
    var a = n || "0",
        u = t.toString();
    return u.length < r ? _e(a + u, r) : u;
  }, _r = function r(t) {
    var e, n;

    for (t = t || {}, e = 1; e < arguments.length; e++) {
      if (n = arguments[e]) for (var a in n) {
        n.hasOwnProperty(a) && ("object" == (0,esm_typeof/* default */.Z)(n[a]) ? _r(t[a], n[a]) : t[a] = n[a]);
      }
    }

    return t;
  }, n = function n(t, e) {
    for (var r = 0; r < e.length; r++) {
      if (e[r].toLowerCase() === t.toLowerCase()) return r;
    }

    return -1;
  }, a = {
    dateSettings: {
      days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
      daysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
      months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
      monthsShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
      meridiem: ["AM", "PM"],
      ordinal: function ordinal(t) {
        var e = t % 10,
            r = {
          1: "st",
          2: "nd",
          3: "rd"
        };
        return 1 !== Math.floor(t % 100 / 10) && r[e] ? r[e] : "th";
      }
    },
    separators: /[ \-+\/\.T:@]/g,
    validParts: /[dDjlNSwzWFmMntLoYyaABgGhHisueTIOPZcrU]/g,
    intParts: /[djwNzmnyYhHgGis]/g,
    tzParts: /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g,
    tzClip: /[^-+\dA-Z]/g
  }, DateFormatter = function DateFormatter(t) {
    var e = this,
        n = _r(a, t);

    e.dateSettings = n.dateSettings, e.separators = n.separators, e.validParts = n.validParts, e.intParts = n.intParts, e.tzParts = n.tzParts, e.tzClip = n.tzClip;
  }, DateFormatter.prototype = {
    constructor: DateFormatter,
    getMonth: function getMonth(t) {
      var e,
          r = this;
      return e = n(t, r.dateSettings.monthsShort) + 1, 0 === e && (e = n(t, r.dateSettings.months) + 1), e;
    },
    parseDate: function parseDate(e, r) {
      var n,
          a,
          u,
          i,
          s,
          o,
          c,
          f,
          l,
          h,
          d = this,
          g = !1,
          m = !1,
          p = d.dateSettings,
          y = {
        date: null,
        year: null,
        month: null,
        day: null,
        hour: 0,
        min: 0,
        sec: 0
      };
      if (!e) return null;
      if (e instanceof Date) return e;
      if ("U" === r) return u = parseInt(e), u ? new Date(1e3 * u) : e;

      switch ((0,esm_typeof/* default */.Z)(e)) {
        case "number":
          return new Date(e);

        case "string":
          break;

        default:
          return null;
      }

      if (n = r.match(d.validParts), !n || 0 === n.length) throw new Error("Invalid date format definition.");

      for (a = e.replace(d.separators, "\x00").split("\x00"), u = 0; u < a.length; u++) {
        switch (i = a[u], s = parseInt(i), n[u]) {
          case "y":
          case "Y":
            if (!s) return null;
            l = i.length, y.year = 2 === l ? parseInt((70 > s ? "20" : "19") + i) : s, g = !0;
            break;

          case "m":
          case "n":
          case "M":
          case "F":
            if (isNaN(s)) {
              if (o = d.getMonth(i), !(o > 0)) return null;
              y.month = o;
            } else {
              if (!(s >= 1 && 12 >= s)) return null;
              y.month = s;
            }

            g = !0;
            break;

          case "d":
          case "j":
            if (!(s >= 1 && 31 >= s)) return null;
            y.day = s, g = !0;
            break;

          case "g":
          case "h":
            if (c = n.indexOf("a") > -1 ? n.indexOf("a") : n.indexOf("A") > -1 ? n.indexOf("A") : -1, h = a[c], c > -1) f = t(h, p.meridiem[0]) ? 0 : t(h, p.meridiem[1]) ? 12 : -1, s >= 1 && 12 >= s && f > -1 ? y.hour = s + f - 1 : s >= 0 && 23 >= s && (y.hour = s);else {
              if (!(s >= 0 && 23 >= s)) return null;
              y.hour = s;
            }
            m = !0;
            break;

          case "G":
          case "H":
            if (!(s >= 0 && 23 >= s)) return null;
            y.hour = s, m = !0;
            break;

          case "i":
            if (!(s >= 0 && 59 >= s)) return null;
            y.min = s, m = !0;
            break;

          case "s":
            if (!(s >= 0 && 59 >= s)) return null;
            y.sec = s, m = !0;
        }
      }

      if (g === !0 && y.year && y.month && y.day) y.date = new Date(y.year, y.month - 1, y.day, y.hour, y.min, y.sec, 0);else {
        if (m !== !0) return null;
        y.date = new Date(0, 0, 0, y.hour, y.min, y.sec, 0);
      }
      return y.date;
    },
    guessDate: function guessDate(t, e) {
      if ("string" != typeof t) return t;
      var r,
          n,
          a,
          u,
          i,
          s,
          o = this,
          c = t.replace(o.separators, "\x00").split("\x00"),
          f = /^[djmn]/g,
          l = e.match(o.validParts),
          h = new Date(),
          d = 0;
      if (!f.test(l[0])) return t;

      for (a = 0; a < c.length; a++) {
        if (d = 2, i = c[a], s = parseInt(i.substr(0, 2)), isNaN(s)) return null;

        switch (a) {
          case 0:
            "m" === l[0] || "n" === l[0] ? h.setMonth(s - 1) : h.setDate(s);
            break;

          case 1:
            "m" === l[0] || "n" === l[0] ? h.setDate(s) : h.setMonth(s - 1);
            break;

          case 2:
            if (n = h.getFullYear(), r = i.length, d = 4 > r ? r : 4, n = parseInt(4 > r ? n.toString().substr(0, 4 - r) + i : i.substr(0, 4)), !n) return null;
            h.setFullYear(n);
            break;

          case 3:
            h.setHours(s);
            break;

          case 4:
            h.setMinutes(s);
            break;

          case 5:
            h.setSeconds(s);
        }

        u = i.substr(d), u.length > 0 && c.splice(a + 1, 0, u);
      }

      return h;
    },
    parseFormat: function parseFormat(t, r) {
      var n,
          a = this,
          s = a.dateSettings,
          o = /\\?(.?)/gi,
          _c = function c(t, e) {
        return n[t] ? n[t]() : e;
      };

      return n = {
        d: function d() {
          return _e(n.j(), 2);
        },
        D: function D() {
          return s.daysShort[n.w()];
        },
        j: function j() {
          return r.getDate();
        },
        l: function l() {
          return s.days[n.w()];
        },
        N: function N() {
          return n.w() || 7;
        },
        w: function w() {
          return r.getDay();
        },
        z: function z() {
          var t = new Date(n.Y(), n.n() - 1, n.j()),
              e = new Date(n.Y(), 0, 1);
          return Math.round((t - e) / u);
        },
        W: function W() {
          var t = new Date(n.Y(), n.n() - 1, n.j() - n.N() + 3),
              r = new Date(t.getFullYear(), 0, 4);
          return _e(1 + Math.round((t - r) / u / 7), 2);
        },
        F: function F() {
          return s.months[r.getMonth()];
        },
        m: function m() {
          return _e(n.n(), 2);
        },
        M: function M() {
          return s.monthsShort[r.getMonth()];
        },
        n: function n() {
          return r.getMonth() + 1;
        },
        t: function t() {
          return new Date(n.Y(), n.n(), 0).getDate();
        },
        L: function L() {
          var t = n.Y();
          return t % 4 === 0 && t % 100 !== 0 || t % 400 === 0 ? 1 : 0;
        },
        o: function o() {
          var t = n.n(),
              e = n.W(),
              r = n.Y();
          return r + (12 === t && 9 > e ? 1 : 1 === t && e > 9 ? -1 : 0);
        },
        Y: function Y() {
          return r.getFullYear();
        },
        y: function y() {
          return n.Y().toString().slice(-2);
        },
        a: function a() {
          return n.A().toLowerCase();
        },
        A: function A() {
          var t = n.G() < 12 ? 0 : 1;
          return s.meridiem[t];
        },
        B: function B() {
          var t = r.getUTCHours() * i,
              n = 60 * r.getUTCMinutes(),
              a = r.getUTCSeconds();
          return _e(Math.floor((t + n + a + i) / 86.4) % 1e3, 3);
        },
        g: function g() {
          return n.G() % 12 || 12;
        },
        G: function G() {
          return r.getHours();
        },
        h: function h() {
          return _e(n.g(), 2);
        },
        H: function H() {
          return _e(n.G(), 2);
        },
        i: function i() {
          return _e(r.getMinutes(), 2);
        },
        s: function s() {
          return _e(r.getSeconds(), 2);
        },
        u: function u() {
          return _e(1e3 * r.getMilliseconds(), 6);
        },
        e: function e() {
          var t = /\((.*)\)/.exec(String(r))[1];
          return t || "Coordinated Universal Time";
        },
        I: function I() {
          var t = new Date(n.Y(), 0),
              e = Date.UTC(n.Y(), 0),
              r = new Date(n.Y(), 6),
              a = Date.UTC(n.Y(), 6);
          return t - e !== r - a ? 1 : 0;
        },
        O: function O() {
          var t = r.getTimezoneOffset(),
              n = Math.abs(t);
          return (t > 0 ? "-" : "+") + _e(100 * Math.floor(n / 60) + n % 60, 4);
        },
        P: function P() {
          var t = n.O();
          return t.substr(0, 3) + ":" + t.substr(3, 2);
        },
        T: function T() {
          var t = (String(r).match(a.tzParts) || [""]).pop().replace(a.tzClip, "");
          return t || "UTC";
        },
        Z: function Z() {
          return 60 * -r.getTimezoneOffset();
        },
        c: function c() {
          return "Y-m-d\\TH:i:sP".replace(o, _c);
        },
        r: function r() {
          return "D, d M Y H:i:s O".replace(o, _c);
        },
        U: function U() {
          return r.getTime() / 1e3 || 0;
        }
      }, _c(t, t);
    },
    formatDate: function formatDate(t, e) {
      var r,
          n,
          a,
          u,
          i,
          s = this,
          o = "",
          c = "\\";
      if ("string" == typeof t && (t = s.parseDate(t, e), !t)) return null;

      if (t instanceof Date) {
        for (a = e.length, r = 0; a > r; r++) {
          i = e.charAt(r), "S" !== i && i !== c && (r > 0 && e.charAt(r - 1) === c ? o += i : (u = s.parseFormat(i, t), r !== a - 1 && s.intParts.test(i) && "S" === e.charAt(r + 1) && (n = parseInt(u) || 0, u += s.dateSettings.ordinal(n)), o += u));
        }

        return o;
      }

      return "";
    }
  };
}();
/**
* @preserve jQuery DateTimePicker
* @homepage http://xdsoft.net/jqplugins/datetimepicker/
* @author Chupurnov Valeriy (<chupurnov@gmail.com>)
*/

(function ($) {
  'use strict';

  var default_options = {
    i18n: {
      ar: {
        // Arabic
        months: ["كانون الثاني", "شباط", "آذار", "نيسان", "مايو", "حزيران", "تموز", "آب", "أيلول", "تشرين الأول", "تشرين الثاني", "كانون الأول"],
        dayOfWeekShort: ["ن", "ث", "ع", "خ", "ج", "س", "ح"],
        dayOfWeek: ["الأحد", "الاثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت", "الأحد"]
      },
      ro: {
        // Romanian
        months: ["Ianuarie", "Februarie", "Martie", "Aprilie", "Mai", "Iunie", "Iulie", "August", "Septembrie", "Octombrie", "Noiembrie", "Decembrie"],
        dayOfWeekShort: ["Du", "Lu", "Ma", "Mi", "Jo", "Vi", "Sâ"],
        dayOfWeek: ["Duminică", "Luni", "Marţi", "Miercuri", "Joi", "Vineri", "Sâmbătă"]
      },
      id: {
        // Indonesian
        months: ["Januari", "Februari", "Maret", "April", "Mei", "Juni", "Juli", "Agustus", "September", "Oktober", "November", "Desember"],
        dayOfWeekShort: ["Min", "Sen", "Sel", "Rab", "Kam", "Jum", "Sab"],
        dayOfWeek: ["Minggu", "Senin", "Selasa", "Rabu", "Kamis", "Jumat", "Sabtu"]
      },
      is: {
        // Icelandic
        months: ["Janúar", "Febrúar", "Mars", "Apríl", "Maí", "Júní", "Júlí", "Ágúst", "September", "Október", "Nóvember", "Desember"],
        dayOfWeekShort: ["Sun", "Mán", "Þrið", "Mið", "Fim", "Fös", "Lau"],
        dayOfWeek: ["Sunnudagur", "Mánudagur", "Þriðjudagur", "Miðvikudagur", "Fimmtudagur", "Föstudagur", "Laugardagur"]
      },
      bg: {
        // Bulgarian
        months: ["Януари", "Февруари", "Март", "Април", "Май", "Юни", "Юли", "Август", "Септември", "Октомври", "Ноември", "Декември"],
        dayOfWeekShort: ["Нд", "Пн", "Вт", "Ср", "Чт", "Пт", "Сб"],
        dayOfWeek: ["Неделя", "Понеделник", "Вторник", "Сряда", "Четвъртък", "Петък", "Събота"]
      },
      fa: {
        // Persian/Farsi
        months: ['فروردین', 'اردیبهشت', 'خرداد', 'تیر', 'مرداد', 'شهریور', 'مهر', 'آبان', 'آذر', 'دی', 'بهمن', 'اسفند'],
        dayOfWeekShort: ['یکشنبه', 'دوشنبه', 'سه شنبه', 'چهارشنبه', 'پنجشنبه', 'جمعه', 'شنبه'],
        dayOfWeek: ["یک‌شنبه", "دوشنبه", "سه‌شنبه", "چهارشنبه", "پنج‌شنبه", "جمعه", "شنبه", "یک‌شنبه"]
      },
      ru: {
        // Russian
        months: ['Январь', 'Февраль', 'Март', 'Апрель', 'Май', 'Июнь', 'Июль', 'Август', 'Сентябрь', 'Октябрь', 'Ноябрь', 'Декабрь'],
        dayOfWeekShort: ["Вс", "Пн", "Вт", "Ср", "Чт", "Пт", "Сб"],
        dayOfWeek: ["Воскресенье", "Понедельник", "Вторник", "Среда", "Четверг", "Пятница", "Суббота"]
      },
      uk: {
        // Ukrainian
        months: ['Січень', 'Лютий', 'Березень', 'Квітень', 'Травень', 'Червень', 'Липень', 'Серпень', 'Вересень', 'Жовтень', 'Листопад', 'Грудень'],
        dayOfWeekShort: ["Ндл", "Пнд", "Втр", "Срд", "Чтв", "Птн", "Сбт"],
        dayOfWeek: ["Неділя", "Понеділок", "Вівторок", "Середа", "Четвер", "П'ятниця", "Субота"]
      },
      en: {
        // English
        months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
        dayOfWeekShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
        dayOfWeek: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
      },
      el: {
        // Ελληνικά
        months: ["Ιανουάριος", "Φεβρουάριος", "Μάρτιος", "Απρίλιος", "Μάιος", "Ιούνιος", "Ιούλιος", "Αύγουστος", "Σεπτέμβριος", "Οκτώβριος", "Νοέμβριος", "Δεκέμβριος"],
        dayOfWeekShort: ["Κυρ", "Δευ", "Τρι", "Τετ", "Πεμ", "Παρ", "Σαβ"],
        dayOfWeek: ["Κυριακή", "Δευτέρα", "Τρίτη", "Τετάρτη", "Πέμπτη", "Παρασκευή", "Σάββατο"]
      },
      de: {
        // German
        months: ['Januar', 'Februar', 'März', 'April', 'Mai', 'Juni', 'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember'],
        dayOfWeekShort: ["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"],
        dayOfWeek: ["Sonntag", "Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag"]
      },
      nl: {
        // Dutch
        months: ["januari", "februari", "maart", "april", "mei", "juni", "juli", "augustus", "september", "oktober", "november", "december"],
        dayOfWeekShort: ["zo", "ma", "di", "wo", "do", "vr", "za"],
        dayOfWeek: ["zondag", "maandag", "dinsdag", "woensdag", "donderdag", "vrijdag", "zaterdag"]
      },
      tr: {
        // Turkish
        months: ["Ocak", "Şubat", "Mart", "Nisan", "Mayıs", "Haziran", "Temmuz", "Ağustos", "Eylül", "Ekim", "Kasım", "Aralık"],
        dayOfWeekShort: ["Paz", "Pts", "Sal", "Çar", "Per", "Cum", "Cts"],
        dayOfWeek: ["Pazar", "Pazartesi", "Salı", "Çarşamba", "Perşembe", "Cuma", "Cumartesi"]
      },
      fr: {
        //French
        months: ["Janvier", "Février", "Mars", "Avril", "Mai", "Juin", "Juillet", "Août", "Septembre", "Octobre", "Novembre", "Décembre"],
        dayOfWeekShort: ["Dim", "Lun", "Mar", "Mer", "Jeu", "Ven", "Sam"],
        dayOfWeek: ["dimanche", "lundi", "mardi", "mercredi", "jeudi", "vendredi", "samedi"]
      },
      es: {
        // Spanish
        months: ["Enero", "Febrero", "Marzo", "Abril", "Mayo", "Junio", "Julio", "Agosto", "Septiembre", "Octubre", "Noviembre", "Diciembre"],
        dayOfWeekShort: ["Dom", "Lun", "Mar", "Mié", "Jue", "Vie", "Sáb"],
        dayOfWeek: ["Domingo", "Lunes", "Martes", "Miércoles", "Jueves", "Viernes", "Sábado"]
      },
      th: {
        // Thai
        months: ['มกราคม', 'กุมภาพันธ์', 'มีนาคม', 'เมษายน', 'พฤษภาคม', 'มิถุนายน', 'กรกฎาคม', 'สิงหาคม', 'กันยายน', 'ตุลาคม', 'พฤศจิกายน', 'ธันวาคม'],
        dayOfWeekShort: ['อา.', 'จ.', 'อ.', 'พ.', 'พฤ.', 'ศ.', 'ส.'],
        dayOfWeek: ["อาทิตย์", "จันทร์", "อังคาร", "พุธ", "พฤหัส", "ศุกร์", "เสาร์", "อาทิตย์"]
      },
      pl: {
        // Polish
        months: ["styczeń", "luty", "marzec", "kwiecień", "maj", "czerwiec", "lipiec", "sierpień", "wrzesień", "październik", "listopad", "grudzień"],
        dayOfWeekShort: ["nd", "pn", "wt", "śr", "cz", "pt", "sb"],
        dayOfWeek: ["niedziela", "poniedziałek", "wtorek", "środa", "czwartek", "piątek", "sobota"]
      },
      pt: {
        // Portuguese
        months: ["Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"],
        dayOfWeekShort: ["Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "Sab"],
        dayOfWeek: ["Domingo", "Segunda", "Terça", "Quarta", "Quinta", "Sexta", "Sábado"]
      },
      ch: {
        // Simplified Chinese
        months: ["一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月"],
        dayOfWeekShort: ["日", "一", "二", "三", "四", "五", "六"]
      },
      se: {
        // Swedish
        months: ["Januari", "Februari", "Mars", "April", "Maj", "Juni", "Juli", "Augusti", "September", "Oktober", "November", "December"],
        dayOfWeekShort: ["Sön", "Mån", "Tis", "Ons", "Tor", "Fre", "Lör"]
      },
      km: {
        // Khmer (ភាសាខ្មែរ)
        months: ["មករា​", "កុម្ភៈ", "មិនា​", "មេសា​", "ឧសភា​", "មិថុនា​", "កក្កដា​", "សីហា​", "កញ្ញា​", "តុលា​", "វិច្ឆិកា", "ធ្នូ​"],
        dayOfWeekShort: ["អាទិ​", "ច័ន្ទ​", "អង្គារ​", "ពុធ​", "ព្រហ​​", "សុក្រ​", "សៅរ៍"],
        dayOfWeek: ["អាទិត្យ​", "ច័ន្ទ​", "អង្គារ​", "ពុធ​", "ព្រហស្បតិ៍​", "សុក្រ​", "សៅរ៍"]
      },
      kr: {
        // Korean
        months: ["1월", "2월", "3월", "4월", "5월", "6월", "7월", "8월", "9월", "10월", "11월", "12월"],
        dayOfWeekShort: ["일", "월", "화", "수", "목", "금", "토"],
        dayOfWeek: ["일요일", "월요일", "화요일", "수요일", "목요일", "금요일", "토요일"]
      },
      it: {
        // Italian
        months: ["Gennaio", "Febbraio", "Marzo", "Aprile", "Maggio", "Giugno", "Luglio", "Agosto", "Settembre", "Ottobre", "Novembre", "Dicembre"],
        dayOfWeekShort: ["Dom", "Lun", "Mar", "Mer", "Gio", "Ven", "Sab"],
        dayOfWeek: ["Domenica", "Lunedì", "Martedì", "Mercoledì", "Giovedì", "Venerdì", "Sabato"]
      },
      da: {
        // Dansk
        months: ["Januar", "Februar", "Marts", "April", "Maj", "Juni", "Juli", "August", "September", "Oktober", "November", "December"],
        dayOfWeekShort: ["Søn", "Man", "Tir", "Ons", "Tor", "Fre", "Lør"],
        dayOfWeek: ["søndag", "mandag", "tirsdag", "onsdag", "torsdag", "fredag", "lørdag"]
      },
      no: {
        // Norwegian
        months: ["Januar", "Februar", "Mars", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Desember"],
        dayOfWeekShort: ["Søn", "Man", "Tir", "Ons", "Tor", "Fre", "Lør"],
        dayOfWeek: ['Søndag', 'Mandag', 'Tirsdag', 'Onsdag', 'Torsdag', 'Fredag', 'Lørdag']
      },
      ja: {
        // Japanese
        months: ["1月", "2月", "3月", "4月", "5月", "6月", "7月", "8月", "9月", "10月", "11月", "12月"],
        dayOfWeekShort: ["日", "月", "火", "水", "木", "金", "土"],
        dayOfWeek: ["日曜", "月曜", "火曜", "水曜", "木曜", "金曜", "土曜"]
      },
      vi: {
        // Vietnamese
        months: ["Tháng 1", "Tháng 2", "Tháng 3", "Tháng 4", "Tháng 5", "Tháng 6", "Tháng 7", "Tháng 8", "Tháng 9", "Tháng 10", "Tháng 11", "Tháng 12"],
        dayOfWeekShort: ["CN", "T2", "T3", "T4", "T5", "T6", "T7"],
        dayOfWeek: ["Chủ nhật", "Thứ hai", "Thứ ba", "Thứ tư", "Thứ năm", "Thứ sáu", "Thứ bảy"]
      },
      sl: {
        // Slovenščina
        months: ["Januar", "Februar", "Marec", "April", "Maj", "Junij", "Julij", "Avgust", "September", "Oktober", "November", "December"],
        dayOfWeekShort: ["Ned", "Pon", "Tor", "Sre", "Čet", "Pet", "Sob"],
        dayOfWeek: ["Nedelja", "Ponedeljek", "Torek", "Sreda", "Četrtek", "Petek", "Sobota"]
      },
      cs: {
        // Čeština
        months: ["Leden", "Únor", "Březen", "Duben", "Květen", "Červen", "Červenec", "Srpen", "Září", "Říjen", "Listopad", "Prosinec"],
        dayOfWeekShort: ["Ne", "Po", "Út", "St", "Čt", "Pá", "So"]
      },
      hu: {
        // Hungarian
        months: ["Január", "Február", "Március", "Április", "Május", "Június", "Július", "Augusztus", "Szeptember", "Október", "November", "December"],
        dayOfWeekShort: ["Va", "Hé", "Ke", "Sze", "Cs", "Pé", "Szo"],
        dayOfWeek: ["vasárnap", "hétfő", "kedd", "szerda", "csütörtök", "péntek", "szombat"]
      },
      az: {
        //Azerbaijanian (Azeri)
        months: ["Yanvar", "Fevral", "Mart", "Aprel", "May", "Iyun", "Iyul", "Avqust", "Sentyabr", "Oktyabr", "Noyabr", "Dekabr"],
        dayOfWeekShort: ["B", "Be", "Ça", "Ç", "Ca", "C", "Ş"],
        dayOfWeek: ["Bazar", "Bazar ertəsi", "Çərşənbə axşamı", "Çərşənbə", "Cümə axşamı", "Cümə", "Şənbə"]
      },
      bs: {
        //Bosanski
        months: ["Januar", "Februar", "Mart", "April", "Maj", "Jun", "Jul", "Avgust", "Septembar", "Oktobar", "Novembar", "Decembar"],
        dayOfWeekShort: ["Ned", "Pon", "Uto", "Sri", "Čet", "Pet", "Sub"],
        dayOfWeek: ["Nedjelja", "Ponedjeljak", "Utorak", "Srijeda", "Četvrtak", "Petak", "Subota"]
      },
      ca: {
        //Català
        months: ["Gener", "Febrer", "Març", "Abril", "Maig", "Juny", "Juliol", "Agost", "Setembre", "Octubre", "Novembre", "Desembre"],
        dayOfWeekShort: ["Dg", "Dl", "Dt", "Dc", "Dj", "Dv", "Ds"],
        dayOfWeek: ["Diumenge", "Dilluns", "Dimarts", "Dimecres", "Dijous", "Divendres", "Dissabte"]
      },
      'en-GB': {
        //English (British)
        months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
        dayOfWeekShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
        dayOfWeek: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
      },
      et: {
        //"Eesti"
        months: ["Jaanuar", "Veebruar", "Märts", "Aprill", "Mai", "Juuni", "Juuli", "August", "September", "Oktoober", "November", "Detsember"],
        dayOfWeekShort: ["P", "E", "T", "K", "N", "R", "L"],
        dayOfWeek: ["Pühapäev", "Esmaspäev", "Teisipäev", "Kolmapäev", "Neljapäev", "Reede", "Laupäev"]
      },
      eu: {
        //Euskara
        months: ["Urtarrila", "Otsaila", "Martxoa", "Apirila", "Maiatza", "Ekaina", "Uztaila", "Abuztua", "Iraila", "Urria", "Azaroa", "Abendua"],
        dayOfWeekShort: ["Ig.", "Al.", "Ar.", "Az.", "Og.", "Or.", "La."],
        dayOfWeek: ['Igandea', 'Astelehena', 'Asteartea', 'Asteazkena', 'Osteguna', 'Ostirala', 'Larunbata']
      },
      fi: {
        //Finnish (Suomi)
        months: ["Tammikuu", "Helmikuu", "Maaliskuu", "Huhtikuu", "Toukokuu", "Kesäkuu", "Heinäkuu", "Elokuu", "Syyskuu", "Lokakuu", "Marraskuu", "Joulukuu"],
        dayOfWeekShort: ["Su", "Ma", "Ti", "Ke", "To", "Pe", "La"],
        dayOfWeek: ["sunnuntai", "maanantai", "tiistai", "keskiviikko", "torstai", "perjantai", "lauantai"]
      },
      gl: {
        //Galego
        months: ["Xan", "Feb", "Maz", "Abr", "Mai", "Xun", "Xul", "Ago", "Set", "Out", "Nov", "Dec"],
        dayOfWeekShort: ["Dom", "Lun", "Mar", "Mer", "Xov", "Ven", "Sab"],
        dayOfWeek: ["Domingo", "Luns", "Martes", "Mércores", "Xoves", "Venres", "Sábado"]
      },
      hr: {
        //Hrvatski
        months: ["Siječanj", "Veljača", "Ožujak", "Travanj", "Svibanj", "Lipanj", "Srpanj", "Kolovoz", "Rujan", "Listopad", "Studeni", "Prosinac"],
        dayOfWeekShort: ["Ned", "Pon", "Uto", "Sri", "Čet", "Pet", "Sub"],
        dayOfWeek: ["Nedjelja", "Ponedjeljak", "Utorak", "Srijeda", "Četvrtak", "Petak", "Subota"]
      },
      ko: {
        //Korean (한국어)
        months: ["1월", "2월", "3월", "4월", "5월", "6월", "7월", "8월", "9월", "10월", "11월", "12월"],
        dayOfWeekShort: ["일", "월", "화", "수", "목", "금", "토"],
        dayOfWeek: ["일요일", "월요일", "화요일", "수요일", "목요일", "금요일", "토요일"]
      },
      lt: {
        //Lithuanian (lietuvių)
        months: ["Sausio", "Vasario", "Kovo", "Balandžio", "Gegužės", "Birželio", "Liepos", "Rugpjūčio", "Rugsėjo", "Spalio", "Lapkričio", "Gruodžio"],
        dayOfWeekShort: ["Sek", "Pir", "Ant", "Tre", "Ket", "Pen", "Šeš"],
        dayOfWeek: ["Sekmadienis", "Pirmadienis", "Antradienis", "Trečiadienis", "Ketvirtadienis", "Penktadienis", "Šeštadienis"]
      },
      lv: {
        //Latvian (Latviešu)
        months: ["Janvāris", "Februāris", "Marts", "Aprīlis ", "Maijs", "Jūnijs", "Jūlijs", "Augusts", "Septembris", "Oktobris", "Novembris", "Decembris"],
        dayOfWeekShort: ["Sv", "Pr", "Ot", "Tr", "Ct", "Pk", "St"],
        dayOfWeek: ["Svētdiena", "Pirmdiena", "Otrdiena", "Trešdiena", "Ceturtdiena", "Piektdiena", "Sestdiena"]
      },
      mk: {
        //Macedonian (Македонски)
        months: ["јануари", "февруари", "март", "април", "мај", "јуни", "јули", "август", "септември", "октомври", "ноември", "декември"],
        dayOfWeekShort: ["нед", "пон", "вто", "сре", "чет", "пет", "саб"],
        dayOfWeek: ["Недела", "Понеделник", "Вторник", "Среда", "Четврток", "Петок", "Сабота"]
      },
      mn: {
        //Mongolian (Монгол)
        months: ["1-р сар", "2-р сар", "3-р сар", "4-р сар", "5-р сар", "6-р сар", "7-р сар", "8-р сар", "9-р сар", "10-р сар", "11-р сар", "12-р сар"],
        dayOfWeekShort: ["Дав", "Мяг", "Лха", "Пүр", "Бсн", "Бям", "Ням"],
        dayOfWeek: ["Даваа", "Мягмар", "Лхагва", "Пүрэв", "Баасан", "Бямба", "Ням"]
      },
      'pt-BR': {
        //Português(Brasil)
        months: ["Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"],
        dayOfWeekShort: ["Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "Sáb"],
        dayOfWeek: ["Domingo", "Segunda", "Terça", "Quarta", "Quinta", "Sexta", "Sábado"]
      },
      sk: {
        //Slovenčina
        months: ["Január", "Február", "Marec", "Apríl", "Máj", "Jún", "Júl", "August", "September", "Október", "November", "December"],
        dayOfWeekShort: ["Ne", "Po", "Ut", "St", "Št", "Pi", "So"],
        dayOfWeek: ["Nedeľa", "Pondelok", "Utorok", "Streda", "Štvrtok", "Piatok", "Sobota"]
      },
      sq: {
        //Albanian (Shqip)
        months: ["Janar", "Shkurt", "Mars", "Prill", "Maj", "Qershor", "Korrik", "Gusht", "Shtator", "Tetor", "Nëntor", "Dhjetor"],
        dayOfWeekShort: ["Die", "Hën", "Mar", "Mër", "Enj", "Pre", "Shtu"],
        dayOfWeek: ["E Diel", "E Hënë", "E Martē", "E Mërkurë", "E Enjte", "E Premte", "E Shtunë"]
      },
      'sr-YU': {
        //Serbian (Srpski)
        months: ["Januar", "Februar", "Mart", "April", "Maj", "Jun", "Jul", "Avgust", "Septembar", "Oktobar", "Novembar", "Decembar"],
        dayOfWeekShort: ["Ned", "Pon", "Uto", "Sre", "čet", "Pet", "Sub"],
        dayOfWeek: ["Nedelja", "Ponedeljak", "Utorak", "Sreda", "Četvrtak", "Petak", "Subota"]
      },
      sr: {
        //Serbian Cyrillic (Српски)
        months: ["јануар", "фебруар", "март", "април", "мај", "јун", "јул", "август", "септембар", "октобар", "новембар", "децембар"],
        dayOfWeekShort: ["нед", "пон", "уто", "сре", "чет", "пет", "суб"],
        dayOfWeek: ["Недеља", "Понедељак", "Уторак", "Среда", "Четвртак", "Петак", "Субота"]
      },
      sv: {
        //Svenska
        months: ["Januari", "Februari", "Mars", "April", "Maj", "Juni", "Juli", "Augusti", "September", "Oktober", "November", "December"],
        dayOfWeekShort: ["Sön", "Mån", "Tis", "Ons", "Tor", "Fre", "Lör"],
        dayOfWeek: ["Söndag", "Måndag", "Tisdag", "Onsdag", "Torsdag", "Fredag", "Lördag"]
      },
      'zh-TW': {
        //Traditional Chinese (繁體中文)
        months: ["一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月"],
        dayOfWeekShort: ["日", "一", "二", "三", "四", "五", "六"],
        dayOfWeek: ["星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六"]
      },
      zh: {
        //Simplified Chinese (简体中文)
        months: ["一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月"],
        dayOfWeekShort: ["日", "一", "二", "三", "四", "五", "六"],
        dayOfWeek: ["星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六"]
      },
      ug: {
        // Uyghur(ئۇيغۇرچە)
        months: ["1-ئاي", "2-ئاي", "3-ئاي", "4-ئاي", "5-ئاي", "6-ئاي", "7-ئاي", "8-ئاي", "9-ئاي", "10-ئاي", "11-ئاي", "12-ئاي"],
        dayOfWeek: ["يەكشەنبە", "دۈشەنبە", "سەيشەنبە", "چارشەنبە", "پەيشەنبە", "جۈمە", "شەنبە"]
      },
      he: {
        //Hebrew (עברית)
        months: ['ינואר', 'פברואר', 'מרץ', 'אפריל', 'מאי', 'יוני', 'יולי', 'אוגוסט', 'ספטמבר', 'אוקטובר', 'נובמבר', 'דצמבר'],
        dayOfWeekShort: ['א\'', 'ב\'', 'ג\'', 'ד\'', 'ה\'', 'ו\'', 'שבת'],
        dayOfWeek: ["ראשון", "שני", "שלישי", "רביעי", "חמישי", "שישי", "שבת", "ראשון"]
      },
      hy: {
        // Armenian
        months: ["Հունվար", "Փետրվար", "Մարտ", "Ապրիլ", "Մայիս", "Հունիս", "Հուլիս", "Օգոստոս", "Սեպտեմբեր", "Հոկտեմբեր", "Նոյեմբեր", "Դեկտեմբեր"],
        dayOfWeekShort: ["Կի", "Երկ", "Երք", "Չոր", "Հնգ", "Ուրբ", "Շբթ"],
        dayOfWeek: ["Կիրակի", "Երկուշաբթի", "Երեքշաբթի", "Չորեքշաբթի", "Հինգշաբթի", "Ուրբաթ", "Շաբաթ"]
      },
      kg: {
        // Kyrgyz
        months: ['Үчтүн айы', 'Бирдин айы', 'Жалган Куран', 'Чын Куран', 'Бугу', 'Кулжа', 'Теке', 'Баш Оона', 'Аяк Оона', 'Тогуздун айы', 'Жетинин айы', 'Бештин айы'],
        dayOfWeekShort: ["Жек", "Дүй", "Шей", "Шар", "Бей", "Жум", "Ише"],
        dayOfWeek: ["Жекшемб", "Дүйшөмб", "Шейшемб", "Шаршемб", "Бейшемби", "Жума", "Ишенб"]
      },
      rm: {
        // Romansh
        months: ["Schaner", "Favrer", "Mars", "Avrigl", "Matg", "Zercladur", "Fanadur", "Avust", "Settember", "October", "November", "December"],
        dayOfWeekShort: ["Du", "Gli", "Ma", "Me", "Gie", "Ve", "So"],
        dayOfWeek: ["Dumengia", "Glindesdi", "Mardi", "Mesemna", "Gievgia", "Venderdi", "Sonda"]
      },
      ka: {
        // Georgian
        months: ['იანვარი', 'თებერვალი', 'მარტი', 'აპრილი', 'მაისი', 'ივნისი', 'ივლისი', 'აგვისტო', 'სექტემბერი', 'ოქტომბერი', 'ნოემბერი', 'დეკემბერი'],
        dayOfWeekShort: ["კვ", "ორშ", "სამშ", "ოთხ", "ხუთ", "პარ", "შაბ"],
        dayOfWeek: ["კვირა", "ორშაბათი", "სამშაბათი", "ოთხშაბათი", "ხუთშაბათი", "პარასკევი", "შაბათი"]
      }
    },
    ownerDocument: document,
    contentWindow: window,
    value: '',
    rtl: false,
    format: 'Y/m/d H:i',
    formatTime: 'H:i',
    formatDate: 'Y/m/d',
    startDate: false,
    // new Date(), '1986/12/08', '-1970/01/05','-1970/01/05',
    step: 60,
    monthChangeSpinner: true,
    closeOnDateSelect: false,
    closeOnTimeSelect: true,
    closeOnWithoutClick: true,
    closeOnInputClick: true,
    openOnFocus: true,
    timepicker: true,
    datepicker: true,
    weeks: false,
    defaultTime: false,
    // use formatTime format (ex. '10:00' for formatTime:	'H:i')
    defaultDate: false,
    // use formatDate format (ex new Date() or '1986/12/08' or '-1970/01/05' or '-1970/01/05')
    minDate: false,
    maxDate: false,
    minTime: false,
    maxTime: false,
    minDateTime: false,
    maxDateTime: false,
    allowTimes: [],
    opened: false,
    initTime: true,
    inline: false,
    theme: '',
    touchMovedThreshold: 5,
    onSelectDate: function onSelectDate() {},
    onSelectTime: function onSelectTime() {},
    onChangeMonth: function onChangeMonth() {},
    onGetWeekOfYear: function onGetWeekOfYear() {},
    onChangeYear: function onChangeYear() {},
    onChangeDateTime: function onChangeDateTime() {},
    onShow: function onShow() {},
    onClose: function onClose() {},
    onGenerate: function onGenerate() {},
    withoutCopyright: true,
    inverseButton: false,
    hours12: false,
    next: 'xdsoft_next',
    prev: 'xdsoft_prev',
    dayOfWeekStart: 0,
    parentID: 'body',
    timeHeightInTimePicker: 25,
    timepickerScrollbar: true,
    todayButton: true,
    prevButton: true,
    nextButton: true,
    defaultSelect: true,
    scrollMonth: true,
    scrollTime: true,
    scrollInput: true,
    lazyInit: false,
    mask: false,
    validateOnBlur: true,
    allowBlank: true,
    yearStart: 1950,
    yearEnd: 2050,
    monthStart: 0,
    monthEnd: 11,
    style: '',
    id: '',
    fixed: false,
    roundTime: 'round',
    // ceil, floor
    className: '',
    weekends: [],
    highlightedDates: [],
    highlightedPeriods: [],
    allowDates: [],
    allowDateRe: null,
    disabledDates: [],
    disabledWeekDays: [],
    yearOffset: 0,
    beforeShowDay: null,
    enterLikeTab: true,
    showApplyButton: false,
    insideParent: false
  };
  var dateHelper = null,
      defaultDateHelper = null,
      globalLocaleDefault = 'en',
      globalLocale = 'en';
  var dateFormatterOptionsDefault = {
    meridiem: ['AM', 'PM']
  };

  var initDateFormatter = function initDateFormatter() {
    var locale = default_options.i18n[globalLocale],
        opts = {
      days: locale.dayOfWeek,
      daysShort: locale.dayOfWeekShort,
      months: locale.months,
      monthsShort: $.map(locale.months, function (n) {
        return n.substring(0, 3);
      })
    };

    if (typeof DateFormatter === 'function') {
      dateHelper = defaultDateHelper = new DateFormatter({
        dateSettings: $.extend({}, dateFormatterOptionsDefault, opts)
      });
    }
  };

  var dateFormatters = {
    moment: {
      default_options: {
        format: 'YYYY/MM/DD HH:mm',
        formatDate: 'YYYY/MM/DD',
        formatTime: 'HH:mm'
      },
      formatter: {
        parseDate: function parseDate(date, format) {
          if (isFormatStandard(format)) {
            return defaultDateHelper.parseDate(date, format);
          }

          var d = moment(date, format);
          return d.isValid() ? d.toDate() : false;
        },
        formatDate: function formatDate(date, format) {
          if (isFormatStandard(format)) {
            return defaultDateHelper.formatDate(date, format);
          }

          return moment(date).format(format);
        },
        formatMask: function formatMask(format) {
          return format.replace(/Y{4}/g, '9999').replace(/Y{2}/g, '99').replace(/M{2}/g, '19').replace(/D{2}/g, '39').replace(/H{2}/g, '29').replace(/m{2}/g, '59').replace(/s{2}/g, '59');
        }
      }
    }
  }; // for locale settings

  $.datetimepicker = {
    setLocale: function setLocale(locale) {
      var newLocale = default_options.i18n[locale] ? locale : globalLocaleDefault;

      if (globalLocale !== newLocale) {
        globalLocale = newLocale; // reinit date formatter

        initDateFormatter();
      }
    },
    setDateFormatter: function setDateFormatter(dateFormatter) {
      if (typeof dateFormatter === 'string' && dateFormatters.hasOwnProperty(dateFormatter)) {
        var df = dateFormatters[dateFormatter];
        $.extend(default_options, df.default_options);
        dateHelper = df.formatter;
      } else {
        dateHelper = dateFormatter;
      }
    }
  };
  var standardFormats = {
    RFC_2822: 'D, d M Y H:i:s O',
    ATOM: 'Y-m-d\TH:i:sP',
    ISO_8601: 'Y-m-d\TH:i:sO',
    RFC_822: 'D, d M y H:i:s O',
    RFC_850: 'l, d-M-y H:i:s T',
    RFC_1036: 'D, d M y H:i:s O',
    RFC_1123: 'D, d M Y H:i:s O',
    RSS: 'D, d M Y H:i:s O',
    W3C: 'Y-m-d\TH:i:sP'
  };

  var isFormatStandard = function isFormatStandard(format) {
    return Object.values(standardFormats).indexOf(format) === -1 ? false : true;
  };

  $.extend($.datetimepicker, standardFormats); // first init date formatter

  initDateFormatter(); // fix for ie8

  if (!window.getComputedStyle) {
    window.getComputedStyle = function (el) {
      this.el = el;

      this.getPropertyValue = function (prop) {
        var re = /(-([a-z]))/g;

        if (prop === 'float') {
          prop = 'styleFloat';
        }

        if (re.test(prop)) {
          prop = prop.replace(re, function (a, b, c) {
            return c.toUpperCase();
          });
        }

        return el.currentStyle[prop] || null;
      };

      return this;
    };
  }

  if (!Array.prototype.indexOf) {
    Array.prototype.indexOf = function (obj, start) {
      var i, j;

      for (i = start || 0, j = this.length; i < j; i += 1) {
        if (this[i] === obj) {
          return i;
        }
      }

      return -1;
    };
  }

  Date.prototype.countDaysInMonth = function () {
    return new Date(this.getFullYear(), this.getMonth() + 1, 0).getDate();
  };

  $.fn.xdsoftScroller = function (options, percent) {
    return this.each(function () {
      var timeboxparent = $(this),
          pointerEventToXY = function pointerEventToXY(e) {
        var out = {
          x: 0,
          y: 0
        },
            touch;

        if (e.type === 'touchstart' || e.type === 'touchmove' || e.type === 'touchend' || e.type === 'touchcancel') {
          touch = e.originalEvent.touches[0] || e.originalEvent.changedTouches[0];
          out.x = touch.clientX;
          out.y = touch.clientY;
        } else if (e.type === 'mousedown' || e.type === 'mouseup' || e.type === 'mousemove' || e.type === 'mouseover' || e.type === 'mouseout' || e.type === 'mouseenter' || e.type === 'mouseleave') {
          out.x = e.clientX;
          out.y = e.clientY;
        }

        return out;
      },
          timebox,
          parentHeight,
          height,
          scrollbar,
          scroller,
          maximumOffset = 100,
          start = false,
          startY = 0,
          startTop = 0,
          h1 = 0,
          touchStart = false,
          startTopScroll = 0,
          calcOffset = function calcOffset() {};

      if (percent === 'hide') {
        timeboxparent.find('.xdsoft_scrollbar').hide();
        return;
      }

      if (!$(this).hasClass('xdsoft_scroller_box')) {
        timebox = timeboxparent.children().eq(0);
        parentHeight = timeboxparent[0].clientHeight;
        height = timebox[0].offsetHeight;
        scrollbar = $('<div class="xdsoft_scrollbar"></div>');
        scroller = $('<div class="xdsoft_scroller"></div>');
        scrollbar.append(scroller);
        timeboxparent.addClass('xdsoft_scroller_box').append(scrollbar);

        calcOffset = function calcOffset(event) {
          var offset = pointerEventToXY(event).y - startY + startTopScroll;

          if (offset < 0) {
            offset = 0;
          }

          if (offset + scroller[0].offsetHeight > h1) {
            offset = h1 - scroller[0].offsetHeight;
          }

          timeboxparent.trigger('scroll_element.xdsoft_scroller', [maximumOffset ? offset / maximumOffset : 0]);
        };

        scroller.on('touchstart.xdsoft_scroller mousedown.xdsoft_scroller', function (event) {
          if (!parentHeight) {
            timeboxparent.trigger('resize_scroll.xdsoft_scroller', [percent]);
          }

          startY = pointerEventToXY(event).y;
          startTopScroll = parseInt(scroller.css('margin-top'), 10);
          h1 = scrollbar[0].offsetHeight;

          if (event.type === 'mousedown' || event.type === 'touchstart') {
            if (options.ownerDocument) {
              $(options.ownerDocument.body).addClass('xdsoft_noselect');
            }

            $([options.ownerDocument.body, options.contentWindow]).on('touchend mouseup.xdsoft_scroller', function arguments_callee() {
              $([options.ownerDocument.body, options.contentWindow]).off('touchend mouseup.xdsoft_scroller', arguments_callee).off('mousemove.xdsoft_scroller', calcOffset).removeClass('xdsoft_noselect');
            });
            $(options.ownerDocument.body).on('mousemove.xdsoft_scroller', calcOffset);
          } else {
            touchStart = true;
            event.stopPropagation();
            event.preventDefault();
          }
        }).on('touchmove', function (event) {
          if (touchStart) {
            event.preventDefault();
            calcOffset(event);
          }
        }).on('touchend touchcancel', function () {
          touchStart = false;
          startTopScroll = 0;
        });
        timeboxparent.on('scroll_element.xdsoft_scroller', function (event, percentage) {
          if (!parentHeight) {
            timeboxparent.trigger('resize_scroll.xdsoft_scroller', [percentage, true]);
          }

          percentage = percentage > 1 ? 1 : percentage < 0 || isNaN(percentage) ? 0 : percentage;
          scroller.css('margin-top', maximumOffset * percentage);
          setTimeout(function () {
            timebox.css('marginTop', -parseInt((timebox[0].offsetHeight - parentHeight) * percentage, 10));
          }, 10);
        }).on('resize_scroll.xdsoft_scroller', function (event, percentage, noTriggerScroll) {
          var percent, sh;
          parentHeight = timeboxparent[0].clientHeight;
          height = timebox[0].offsetHeight;
          percent = parentHeight / height;
          sh = percent * scrollbar[0].offsetHeight;

          if (percent > 1) {
            scroller.hide();
          } else {
            scroller.show();
            scroller.css('height', parseInt(sh > 10 ? sh : 10, 10));
            maximumOffset = scrollbar[0].offsetHeight - scroller[0].offsetHeight;

            if (noTriggerScroll !== true) {
              timeboxparent.trigger('scroll_element.xdsoft_scroller', [percentage || Math.abs(parseInt(timebox.css('marginTop'), 10)) / (height - parentHeight)]);
            }
          }
        });
        timeboxparent.on('mousewheel', function (event) {
          var top = Math.abs(parseInt(timebox.css('marginTop'), 10));
          top = top - event.deltaY * 20;

          if (top < 0) {
            top = 0;
          }

          timeboxparent.trigger('scroll_element.xdsoft_scroller', [top / (height - parentHeight)]);
          event.stopPropagation();
          return false;
        });
        timeboxparent.on('touchstart', function (event) {
          start = pointerEventToXY(event);
          startTop = Math.abs(parseInt(timebox.css('marginTop'), 10));
        });
        timeboxparent.on('touchmove', function (event) {
          if (start) {
            event.preventDefault();
            var coord = pointerEventToXY(event);
            timeboxparent.trigger('scroll_element.xdsoft_scroller', [(startTop - (coord.y - start.y)) / (height - parentHeight)]);
          }
        });
        timeboxparent.on('touchend touchcancel', function () {
          start = false;
          startTop = 0;
        });
      }

      timeboxparent.trigger('resize_scroll.xdsoft_scroller', [percent]);
    });
  };

  $.fn.datetimepicker = function (opt, opt2) {
    var result = this,
        KEY0 = 48,
        KEY9 = 57,
        _KEY0 = 96,
        _KEY9 = 105,
        CTRLKEY = 17,
        CMDKEY = 91,
        DEL = 46,
        ENTER = 13,
        ESC = 27,
        BACKSPACE = 8,
        ARROWLEFT = 37,
        ARROWUP = 38,
        ARROWRIGHT = 39,
        ARROWDOWN = 40,
        TAB = 9,
        F5 = 116,
        AKEY = 65,
        CKEY = 67,
        VKEY = 86,
        ZKEY = 90,
        YKEY = 89,
        ctrlDown = false,
        cmdDown = false,
        options = $.isPlainObject(opt) || !opt ? $.extend(true, {}, default_options, opt) : $.extend(true, {}, default_options),
        lazyInitTimer = 0,
        createDateTimePicker,
        destroyDateTimePicker,
        lazyInit = function lazyInit(input) {
      input.on('open.xdsoft focusin.xdsoft mousedown.xdsoft touchstart', function initOnActionCallback() {
        if (input.is(':disabled') || input.data('xdsoft_datetimepicker')) {
          return;
        }

        clearTimeout(lazyInitTimer);
        lazyInitTimer = setTimeout(function () {
          if (!input.data('xdsoft_datetimepicker')) {
            createDateTimePicker(input);
          }

          input.off('open.xdsoft focusin.xdsoft mousedown.xdsoft touchstart', initOnActionCallback).trigger('open.xdsoft');
        }, 100);
      });
    };

    createDateTimePicker = function createDateTimePicker(input) {
      var datetimepicker = $('<div class="xdsoft_datetimepicker xdsoft_noselect"></div>'),
          xdsoft_copyright = $('<div class="xdsoft_copyright"><a target="_blank" href="http://xdsoft.net/jqplugins/datetimepicker/">xdsoft.net</a></div>'),
          datepicker = $('<div class="xdsoft_datepicker active"></div>'),
          month_picker = $('<div class="xdsoft_monthpicker"><button type="button" class="xdsoft_prev"></button><button type="button" class="xdsoft_today_button"></button>' + '<div class="xdsoft_label xdsoft_month"><span></span><i></i></div>' + '<div class="xdsoft_label xdsoft_year"><span></span><i></i></div>' + '<button type="button" class="xdsoft_next"></button></div>'),
          calendar = $('<div class="xdsoft_calendar"></div>'),
          timepicker = $('<div class="xdsoft_timepicker active"><button type="button" class="xdsoft_prev"></button><div class="xdsoft_time_box"></div><button type="button" class="xdsoft_next"></button></div>'),
          timeboxparent = timepicker.find('.xdsoft_time_box').eq(0),
          timebox = $('<div class="xdsoft_time_variant"></div>'),
          applyButton = $('<button type="button" class="xdsoft_save_selected blue-gradient-button">Save Selected</button>'),
          monthselect = $('<div class="xdsoft_select xdsoft_monthselect"><div></div></div>'),
          yearselect = $('<div class="xdsoft_select xdsoft_yearselect"><div></div></div>'),
          triggerAfterOpen = false,
          XDSoft_datetime,
          xchangeTimer,
          timerclick,
          current_time_index,
          setPos,
          timer = 0,
          _xdsoft_datetime,
          forEachAncestorOf;

      if (options.id) {
        datetimepicker.attr('id', options.id);
      }

      if (options.style) {
        datetimepicker.attr('style', options.style);
      }

      if (options.weeks) {
        datetimepicker.addClass('xdsoft_showweeks');
      }

      if (options.rtl) {
        datetimepicker.addClass('xdsoft_rtl');
      }

      datetimepicker.addClass('xdsoft_' + options.theme);
      datetimepicker.addClass(options.className);
      month_picker.find('.xdsoft_month span').after(monthselect);
      month_picker.find('.xdsoft_year span').after(yearselect);
      month_picker.find('.xdsoft_month,.xdsoft_year').on('touchstart mousedown.xdsoft', function (event) {
        var select = $(this).find('.xdsoft_select').eq(0),
            val = 0,
            top = 0,
            visible = select.is(':visible'),
            items,
            i;
        month_picker.find('.xdsoft_select').hide();

        if (_xdsoft_datetime.currentTime) {
          val = _xdsoft_datetime.currentTime[$(this).hasClass('xdsoft_month') ? 'getMonth' : 'getFullYear']();
        }

        select[visible ? 'hide' : 'show']();

        for (items = select.find('div.xdsoft_option'), i = 0; i < items.length; i += 1) {
          if (items.eq(i).data('value') === val) {
            break;
          } else {
            top += items[0].offsetHeight;
          }
        }

        select.xdsoftScroller(options, top / (select.children()[0].offsetHeight - select[0].clientHeight));
        event.stopPropagation();
        return false;
      });

      var handleTouchMoved = function handleTouchMoved(event) {
        var evt = event.originalEvent;
        var touchPosition = evt.touches ? evt.touches[0] : evt;
        this.touchStartPosition = this.touchStartPosition || touchPosition;
        var xMovement = Math.abs(this.touchStartPosition.clientX - touchPosition.clientX);
        var yMovement = Math.abs(this.touchStartPosition.clientY - touchPosition.clientY);
        var distance = Math.sqrt(xMovement * xMovement + yMovement * yMovement);

        if (distance > options.touchMovedThreshold) {
          this.touchMoved = true;
        }
      };

      month_picker.find('.xdsoft_select').xdsoftScroller(options).on('touchstart mousedown.xdsoft', function (event) {
        var evt = event.originalEvent;
        this.touchMoved = false;
        this.touchStartPosition = evt.touches ? evt.touches[0] : evt;
        event.stopPropagation();
        event.preventDefault();
      }).on('touchmove', '.xdsoft_option', handleTouchMoved).on('touchend mousedown.xdsoft', '.xdsoft_option', function () {
        if (!this.touchMoved) {
          if (_xdsoft_datetime.currentTime === undefined || _xdsoft_datetime.currentTime === null) {
            _xdsoft_datetime.currentTime = _xdsoft_datetime.now();
          }

          var year = _xdsoft_datetime.currentTime.getFullYear();

          if (_xdsoft_datetime && _xdsoft_datetime.currentTime) {
            _xdsoft_datetime.currentTime[$(this).parent().parent().hasClass('xdsoft_monthselect') ? 'setMonth' : 'setFullYear']($(this).data('value'));
          }

          $(this).parent().parent().hide();
          datetimepicker.trigger('xchange.xdsoft');

          if (options.onChangeMonth && $.isFunction(options.onChangeMonth)) {
            options.onChangeMonth.call(datetimepicker, _xdsoft_datetime.currentTime, datetimepicker.data('input'));
          }

          if (year !== _xdsoft_datetime.currentTime.getFullYear() && $.isFunction(options.onChangeYear)) {
            options.onChangeYear.call(datetimepicker, _xdsoft_datetime.currentTime, datetimepicker.data('input'));
          }
        }
      });

      datetimepicker.getValue = function () {
        return _xdsoft_datetime.getCurrentTime();
      };

      datetimepicker.setOptions = function (_options) {
        var highlightedDates = {};
        options = $.extend(true, {}, options, _options);

        if (_options.allowTimes && $.isArray(_options.allowTimes) && _options.allowTimes.length) {
          options.allowTimes = $.extend(true, [], _options.allowTimes);
        }

        if (_options.weekends && $.isArray(_options.weekends) && _options.weekends.length) {
          options.weekends = $.extend(true, [], _options.weekends);
        }

        if (_options.allowDates && $.isArray(_options.allowDates) && _options.allowDates.length) {
          options.allowDates = $.extend(true, [], _options.allowDates);
        }

        if (_options.allowDateRe && Object.prototype.toString.call(_options.allowDateRe) === "[object String]") {
          options.allowDateRe = new RegExp(_options.allowDateRe);
        }

        if (_options.highlightedDates && $.isArray(_options.highlightedDates) && _options.highlightedDates.length) {
          $.each(_options.highlightedDates, function (index, value) {
            var splitData = $.map(value.split(','), $.trim),
                exDesc,
                hDate = new HighlightedDate(dateHelper.parseDate(splitData[0], options.formatDate), splitData[1], splitData[2]),
                // date, desc, style
            keyDate = dateHelper.formatDate(hDate.date, options.formatDate);

            if (highlightedDates[keyDate] !== undefined) {
              exDesc = highlightedDates[keyDate].desc;

              if (exDesc && exDesc.length && hDate.desc && hDate.desc.length) {
                highlightedDates[keyDate].desc = exDesc + "\n" + hDate.desc;
              }
            } else {
              highlightedDates[keyDate] = hDate;
            }
          });
          options.highlightedDates = $.extend(true, [], highlightedDates);
        }

        if (_options.highlightedPeriods && $.isArray(_options.highlightedPeriods) && _options.highlightedPeriods.length) {
          highlightedDates = $.extend(true, [], options.highlightedDates);
          $.each(_options.highlightedPeriods, function (index, value) {
            var dateTest, // start date
            dateEnd, desc, hDate, keyDate, exDesc, style;

            if ($.isArray(value)) {
              dateTest = value[0];
              dateEnd = value[1];
              desc = value[2];
              style = value[3];
            } else {
              var splitData = $.map(value.split(','), $.trim);
              dateTest = dateHelper.parseDate(splitData[0], options.formatDate);
              dateEnd = dateHelper.parseDate(splitData[1], options.formatDate);
              desc = splitData[2];
              style = splitData[3];
            }

            while (dateTest <= dateEnd) {
              hDate = new HighlightedDate(dateTest, desc, style);
              keyDate = dateHelper.formatDate(dateTest, options.formatDate);
              dateTest.setDate(dateTest.getDate() + 1);

              if (highlightedDates[keyDate] !== undefined) {
                exDesc = highlightedDates[keyDate].desc;

                if (exDesc && exDesc.length && hDate.desc && hDate.desc.length) {
                  highlightedDates[keyDate].desc = exDesc + "\n" + hDate.desc;
                }
              } else {
                highlightedDates[keyDate] = hDate;
              }
            }
          });
          options.highlightedDates = $.extend(true, [], highlightedDates);
        }

        if (_options.disabledDates && $.isArray(_options.disabledDates) && _options.disabledDates.length) {
          options.disabledDates = $.extend(true, [], _options.disabledDates);
        }

        if (_options.disabledWeekDays && $.isArray(_options.disabledWeekDays) && _options.disabledWeekDays.length) {
          options.disabledWeekDays = $.extend(true, [], _options.disabledWeekDays);
        }

        if ((options.open || options.opened) && !options.inline) {
          input.trigger('open.xdsoft');
        }

        if (options.inline) {
          triggerAfterOpen = true;
          datetimepicker.addClass('xdsoft_inline');
          input.after(datetimepicker).hide();
        }

        if (options.inverseButton) {
          options.next = 'xdsoft_prev';
          options.prev = 'xdsoft_next';
        }

        if (options.datepicker) {
          datepicker.addClass('active');
        } else {
          datepicker.removeClass('active');
        }

        if (options.timepicker) {
          timepicker.addClass('active');
        } else {
          timepicker.removeClass('active');
        }

        if (options.value) {
          _xdsoft_datetime.setCurrentTime(options.value);

          if (input && input.val) {
            input.val(_xdsoft_datetime.str);
          }
        }

        if (isNaN(options.dayOfWeekStart)) {
          options.dayOfWeekStart = 0;
        } else {
          options.dayOfWeekStart = parseInt(options.dayOfWeekStart, 10) % 7;
        }

        if (!options.timepickerScrollbar) {
          timeboxparent.xdsoftScroller(options, 'hide');
        }

        if (options.minDate && /^[\+\-](.*)$/.test(options.minDate)) {
          options.minDate = dateHelper.formatDate(_xdsoft_datetime.strToDateTime(options.minDate), options.formatDate);
        }

        if (options.maxDate && /^[\+\-](.*)$/.test(options.maxDate)) {
          options.maxDate = dateHelper.formatDate(_xdsoft_datetime.strToDateTime(options.maxDate), options.formatDate);
        }

        if (options.minDateTime && /^\+(.*)$/.test(options.minDateTime)) {
          options.minDateTime = _xdsoft_datetime.strToDateTime(options.minDateTime).dateFormat(options.formatDate);
        }

        if (options.maxDateTime && /^\+(.*)$/.test(options.maxDateTime)) {
          options.maxDateTime = _xdsoft_datetime.strToDateTime(options.maxDateTime).dateFormat(options.formatDate);
        }

        applyButton.toggle(options.showApplyButton);
        month_picker.find('.xdsoft_today_button').css('visibility', !options.todayButton ? 'hidden' : 'visible');
        month_picker.find('.' + options.prev).css('visibility', !options.prevButton ? 'hidden' : 'visible');
        month_picker.find('.' + options.next).css('visibility', !options.nextButton ? 'hidden' : 'visible');
        setMask(options);

        if (options.validateOnBlur) {
          input.off('blur.xdsoft').on('blur.xdsoft', function () {
            if (options.allowBlank && (!$.trim($(this).val()).length || typeof options.mask === "string" && $.trim($(this).val()) === options.mask.replace(/[0-9]/g, '_'))) {
              $(this).val(null);
              datetimepicker.data('xdsoft_datetime').empty();
            } else {
              var d = dateHelper.parseDate($(this).val(), options.format);

              if (d) {
                // parseDate() may skip some invalid parts like date or time, so make it clear for user: show parsed date/time
                $(this).val(dateHelper.formatDate(d, options.format));
              } else {
                var splittedHours = +[$(this).val()[0], $(this).val()[1]].join(''),
                    splittedMinutes = +[$(this).val()[2], $(this).val()[3]].join(''); // parse the numbers as 0312 => 03:12

                if (!options.datepicker && options.timepicker && splittedHours >= 0 && splittedHours < 24 && splittedMinutes >= 0 && splittedMinutes < 60) {
                  $(this).val([splittedHours, splittedMinutes].map(function (item) {
                    return item > 9 ? item : '0' + item;
                  }).join(':'));
                } else {
                  $(this).val(dateHelper.formatDate(_xdsoft_datetime.now(), options.format));
                }
              }

              datetimepicker.data('xdsoft_datetime').setCurrentTime($(this).val());
            }

            datetimepicker.trigger('changedatetime.xdsoft');
            datetimepicker.trigger('close.xdsoft');
          });
        }

        options.dayOfWeekStartPrev = options.dayOfWeekStart === 0 ? 6 : options.dayOfWeekStart - 1;
        datetimepicker.trigger('xchange.xdsoft').trigger('afterOpen.xdsoft');
      };

      datetimepicker.data('options', options).on('touchstart mousedown.xdsoft', function (event) {
        event.stopPropagation();
        event.preventDefault();
        yearselect.hide();
        monthselect.hide();
        return false;
      }); //scroll_element = timepicker.find('.xdsoft_time_box');

      timeboxparent.append(timebox);
      timeboxparent.xdsoftScroller(options);
      datetimepicker.on('afterOpen.xdsoft', function () {
        timeboxparent.xdsoftScroller(options);
      });
      datetimepicker.append(datepicker).append(timepicker);

      if (options.withoutCopyright !== true) {
        datetimepicker.append(xdsoft_copyright);
      }

      datepicker.append(month_picker).append(calendar).append(applyButton);

      if (options.insideParent) {
        $(input).parent().append(datetimepicker);
      } else {
        $(options.parentID).append(datetimepicker);
      }

      XDSoft_datetime = function XDSoft_datetime() {
        var _this = this;

        _this.now = function (norecursion) {
          var d = new Date(),
              date,
              time;

          if (!norecursion && options.defaultDate) {
            date = _this.strToDateTime(options.defaultDate);
            d.setFullYear(date.getFullYear());
            d.setMonth(date.getMonth());
            d.setDate(date.getDate());
          }

          d.setFullYear(d.getFullYear());

          if (!norecursion && options.defaultTime) {
            time = _this.strtotime(options.defaultTime);
            d.setHours(time.getHours());
            d.setMinutes(time.getMinutes());
            d.setSeconds(time.getSeconds());
            d.setMilliseconds(time.getMilliseconds());
          }

          return d;
        };

        _this.isValidDate = function (d) {
          if (Object.prototype.toString.call(d) !== "[object Date]") {
            return false;
          }

          return !isNaN(d.getTime());
        };

        _this.setCurrentTime = function (dTime, requireValidDate) {
          if (typeof dTime === 'string') {
            _this.currentTime = _this.strToDateTime(dTime);
          } else if (_this.isValidDate(dTime)) {
            _this.currentTime = dTime;
          } else if (!dTime && !requireValidDate && options.allowBlank && !options.inline) {
            _this.currentTime = null;
          } else {
            _this.currentTime = _this.now();
          }

          datetimepicker.trigger('xchange.xdsoft');
        };

        _this.empty = function () {
          _this.currentTime = null;
        };

        _this.getCurrentTime = function () {
          return _this.currentTime;
        };

        _this.nextMonth = function () {
          if (_this.currentTime === undefined || _this.currentTime === null) {
            _this.currentTime = _this.now();
          }

          var month = _this.currentTime.getMonth() + 1,
              year;

          if (month === 12) {
            _this.currentTime.setFullYear(_this.currentTime.getFullYear() + 1);

            month = 0;
          }

          year = _this.currentTime.getFullYear();

          _this.currentTime.setDate(Math.min(new Date(_this.currentTime.getFullYear(), month + 1, 0).getDate(), _this.currentTime.getDate()));

          _this.currentTime.setMonth(month);

          if (options.onChangeMonth && $.isFunction(options.onChangeMonth)) {
            options.onChangeMonth.call(datetimepicker, _xdsoft_datetime.currentTime, datetimepicker.data('input'));
          }

          if (year !== _this.currentTime.getFullYear() && $.isFunction(options.onChangeYear)) {
            options.onChangeYear.call(datetimepicker, _xdsoft_datetime.currentTime, datetimepicker.data('input'));
          }

          datetimepicker.trigger('xchange.xdsoft');
          return month;
        };

        _this.prevMonth = function () {
          if (_this.currentTime === undefined || _this.currentTime === null) {
            _this.currentTime = _this.now();
          }

          var month = _this.currentTime.getMonth() - 1;

          if (month === -1) {
            _this.currentTime.setFullYear(_this.currentTime.getFullYear() - 1);

            month = 11;
          }

          _this.currentTime.setDate(Math.min(new Date(_this.currentTime.getFullYear(), month + 1, 0).getDate(), _this.currentTime.getDate()));

          _this.currentTime.setMonth(month);

          if (options.onChangeMonth && $.isFunction(options.onChangeMonth)) {
            options.onChangeMonth.call(datetimepicker, _xdsoft_datetime.currentTime, datetimepicker.data('input'));
          }

          datetimepicker.trigger('xchange.xdsoft');
          return month;
        };

        _this.getWeekOfYear = function (datetime) {
          if (options.onGetWeekOfYear && $.isFunction(options.onGetWeekOfYear)) {
            var week = options.onGetWeekOfYear.call(datetimepicker, datetime);

            if (typeof week !== 'undefined') {
              return week;
            }
          }

          var onejan = new Date(datetime.getFullYear(), 0, 1); //First week of the year is th one with the first Thursday according to ISO8601

          if (onejan.getDay() !== 4) {
            onejan.setMonth(0, 1 + (4 - onejan.getDay() + 7) % 7);
          }

          return Math.ceil(((datetime - onejan) / 86400000 + onejan.getDay() + 1) / 7);
        };

        _this.strToDateTime = function (sDateTime) {
          var tmpDate = [],
              timeOffset,
              currentTime;

          if (sDateTime && sDateTime instanceof Date && _this.isValidDate(sDateTime)) {
            return sDateTime;
          }

          tmpDate = /^([+-]{1})(.*)$/.exec(sDateTime);

          if (tmpDate) {
            tmpDate[2] = dateHelper.parseDate(tmpDate[2], options.formatDate);
          }

          if (tmpDate && tmpDate[2]) {
            timeOffset = tmpDate[2].getTime() - tmpDate[2].getTimezoneOffset() * 60000;
            currentTime = new Date(_this.now(true).getTime() + parseInt(tmpDate[1] + '1', 10) * timeOffset);
          } else {
            currentTime = sDateTime ? dateHelper.parseDate(sDateTime, options.format) : _this.now();
          }

          if (!_this.isValidDate(currentTime)) {
            currentTime = _this.now();
          }

          return currentTime;
        };

        _this.strToDate = function (sDate) {
          if (sDate && sDate instanceof Date && _this.isValidDate(sDate)) {
            return sDate;
          }

          var currentTime = sDate ? dateHelper.parseDate(sDate, options.formatDate) : _this.now(true);

          if (!_this.isValidDate(currentTime)) {
            currentTime = _this.now(true);
          }

          return currentTime;
        };

        _this.strtotime = function (sTime) {
          if (sTime && sTime instanceof Date && _this.isValidDate(sTime)) {
            return sTime;
          }

          var currentTime = sTime ? dateHelper.parseDate(sTime, options.formatTime) : _this.now(true);

          if (!_this.isValidDate(currentTime)) {
            currentTime = _this.now(true);
          }

          return currentTime;
        };

        _this.str = function () {
          var format = options.format;

          if (options.yearOffset) {
            format = format.replace('Y', _this.currentTime.getFullYear() + options.yearOffset);
            format = format.replace('y', String(_this.currentTime.getFullYear() + options.yearOffset).substring(2, 4));
          }

          return dateHelper.formatDate(_this.currentTime, format);
        };

        _this.currentTime = this.now();
      };

      _xdsoft_datetime = new XDSoft_datetime();
      applyButton.on('touchend click', function (e) {
        //pathbrite
        e.preventDefault();
        datetimepicker.data('changed', true);

        _xdsoft_datetime.setCurrentTime(getCurrentValue());

        input.val(_xdsoft_datetime.str());
        datetimepicker.trigger('close.xdsoft');
      });
      month_picker.find('.xdsoft_today_button').on('touchend mousedown.xdsoft', function () {
        datetimepicker.data('changed', true);

        _xdsoft_datetime.setCurrentTime(0, true);

        datetimepicker.trigger('afterOpen.xdsoft');
      }).on('dblclick.xdsoft', function () {
        var currentDate = _xdsoft_datetime.getCurrentTime(),
            minDate,
            maxDate;

        currentDate = new Date(currentDate.getFullYear(), currentDate.getMonth(), currentDate.getDate());
        minDate = _xdsoft_datetime.strToDate(options.minDate);
        minDate = new Date(minDate.getFullYear(), minDate.getMonth(), minDate.getDate());

        if (currentDate < minDate) {
          return;
        }

        maxDate = _xdsoft_datetime.strToDate(options.maxDate);
        maxDate = new Date(maxDate.getFullYear(), maxDate.getMonth(), maxDate.getDate());

        if (currentDate > maxDate) {
          return;
        }

        input.val(_xdsoft_datetime.str());
        input.trigger('change');
        datetimepicker.trigger('close.xdsoft');
      });
      month_picker.find('.xdsoft_prev,.xdsoft_next').on('touchend mousedown.xdsoft', function () {
        var $this = $(this),
            timer = 0,
            stop = false;

        (function arguments_callee1(v) {
          if ($this.hasClass(options.next)) {
            _xdsoft_datetime.nextMonth();
          } else if ($this.hasClass(options.prev)) {
            _xdsoft_datetime.prevMonth();
          }

          if (options.monthChangeSpinner) {
            if (!stop) {
              timer = setTimeout(arguments_callee1, v || 100);
            }
          }
        })(500);

        $([options.ownerDocument.body, options.contentWindow]).on('touchend mouseup.xdsoft', function arguments_callee2() {
          clearTimeout(timer);
          stop = true;
          $([options.ownerDocument.body, options.contentWindow]).off('touchend mouseup.xdsoft', arguments_callee2);
        });
      });
      timepicker.find('.xdsoft_prev,.xdsoft_next').on('touchend mousedown.xdsoft', function () {
        var $this = $(this),
            timer = 0,
            stop = false,
            period = 110;

        (function arguments_callee4(v) {
          var pheight = timeboxparent[0].clientHeight,
              height = timebox[0].offsetHeight,
              top = Math.abs(parseInt(timebox.css('marginTop'), 10));

          if ($this.hasClass(options.next) && height - pheight - options.timeHeightInTimePicker >= top) {
            timebox.css('marginTop', '-' + (top + options.timeHeightInTimePicker) + 'px');
          } else if ($this.hasClass(options.prev) && top - options.timeHeightInTimePicker >= 0) {
            timebox.css('marginTop', '-' + (top - options.timeHeightInTimePicker) + 'px');
          }
          /**
           * Fixed bug:
           * When using css3 transition, it will cause a bug that you cannot scroll the timepicker list.
           * The reason is that the transition-duration time, if you set it to 0, all things fine, otherwise, this
           * would cause a bug when you use jquery.css method.
           * Let's say: * { transition: all .5s ease; }
           * jquery timebox.css('marginTop') will return the original value which is before you clicking the next/prev button,
           * meanwhile the timebox[0].style.marginTop will return the right value which is after you clicking the
           * next/prev button.
           *
           * What we should do:
           * Replace timebox.css('marginTop') with timebox[0].style.marginTop.
           */


          timeboxparent.trigger('scroll_element.xdsoft_scroller', [Math.abs(parseInt(timebox[0].style.marginTop, 10) / (height - pheight))]);
          period = period > 10 ? 10 : period - 10;

          if (!stop) {
            timer = setTimeout(arguments_callee4, v || period);
          }
        })(500);

        $([options.ownerDocument.body, options.contentWindow]).on('touchend mouseup.xdsoft', function arguments_callee5() {
          clearTimeout(timer);
          stop = true;
          $([options.ownerDocument.body, options.contentWindow]).off('touchend mouseup.xdsoft', arguments_callee5);
        });
      });
      xchangeTimer = 0; // base handler - generating a calendar and timepicker

      datetimepicker.on('xchange.xdsoft', function (event) {
        clearTimeout(xchangeTimer);
        xchangeTimer = setTimeout(function () {
          if (_xdsoft_datetime.currentTime === undefined || _xdsoft_datetime.currentTime === null) {
            _xdsoft_datetime.currentTime = _xdsoft_datetime.now();
          }

          var table = '',
              start = new Date(_xdsoft_datetime.currentTime.getFullYear(), _xdsoft_datetime.currentTime.getMonth(), 1, 12, 0, 0),
              i = 0,
              j,
              today = _xdsoft_datetime.now(),
              maxDate = false,
              minDate = false,
              minDateTime = false,
              maxDateTime = false,
              hDate,
              day,
              d,
              y,
              m,
              w,
              classes = [],
              customDateSettings,
              newRow = true,
              time = '',
              h,
              line_time,
              description;

          while (start.getDay() !== options.dayOfWeekStart) {
            start.setDate(start.getDate() - 1);
          }

          table += '<table><thead><tr>';

          if (options.weeks) {
            table += '<th></th>';
          }

          for (j = 0; j < 7; j += 1) {
            table += '<th>' + options.i18n[globalLocale].dayOfWeekShort[(j + options.dayOfWeekStart) % 7] + '</th>';
          }

          table += '</tr></thead>';
          table += '<tbody>';

          if (options.maxDate !== false) {
            maxDate = _xdsoft_datetime.strToDate(options.maxDate);
            maxDate = new Date(maxDate.getFullYear(), maxDate.getMonth(), maxDate.getDate(), 23, 59, 59, 999);
          }

          if (options.minDate !== false) {
            minDate = _xdsoft_datetime.strToDate(options.minDate);
            minDate = new Date(minDate.getFullYear(), minDate.getMonth(), minDate.getDate());
          }

          if (options.minDateTime !== false) {
            minDateTime = _xdsoft_datetime.strToDate(options.minDateTime);
            minDateTime = new Date(minDateTime.getFullYear(), minDateTime.getMonth(), minDateTime.getDate(), minDateTime.getHours(), minDateTime.getMinutes(), minDateTime.getSeconds());
          }

          if (options.maxDateTime !== false) {
            maxDateTime = _xdsoft_datetime.strToDate(options.maxDateTime);
            maxDateTime = new Date(maxDateTime.getFullYear(), maxDateTime.getMonth(), maxDateTime.getDate(), maxDateTime.getHours(), maxDateTime.getMinutes(), maxDateTime.getSeconds());
          }

          var maxDateTimeDay;

          if (maxDateTime !== false) {
            maxDateTimeDay = (maxDateTime.getFullYear() * 12 + maxDateTime.getMonth()) * 31 + maxDateTime.getDate();
          }

          while (i < _xdsoft_datetime.currentTime.countDaysInMonth() || start.getDay() !== options.dayOfWeekStart || _xdsoft_datetime.currentTime.getMonth() === start.getMonth()) {
            classes = [];
            i += 1;
            day = start.getDay();
            d = start.getDate();
            y = start.getFullYear();
            m = start.getMonth();
            w = _xdsoft_datetime.getWeekOfYear(start);
            description = '';
            classes.push('xdsoft_date');

            if (options.beforeShowDay && $.isFunction(options.beforeShowDay.call)) {
              customDateSettings = options.beforeShowDay.call(datetimepicker, start);
            } else {
              customDateSettings = null;
            }

            if (options.allowDateRe && Object.prototype.toString.call(options.allowDateRe) === "[object RegExp]") {
              if (!options.allowDateRe.test(dateHelper.formatDate(start, options.formatDate))) {
                classes.push('xdsoft_disabled');
              }
            }

            if (options.allowDates && options.allowDates.length > 0) {
              if (options.allowDates.indexOf(dateHelper.formatDate(start, options.formatDate)) === -1) {
                classes.push('xdsoft_disabled');
              }
            }

            var currentDay = (start.getFullYear() * 12 + start.getMonth()) * 31 + start.getDate();

            if (maxDate !== false && start > maxDate || minDateTime !== false && start < minDateTime || minDate !== false && start < minDate || maxDateTime !== false && currentDay > maxDateTimeDay || customDateSettings && customDateSettings[0] === false) {
              classes.push('xdsoft_disabled');
            }

            if (options.disabledDates.indexOf(dateHelper.formatDate(start, options.formatDate)) !== -1) {
              classes.push('xdsoft_disabled');
            }

            if (options.disabledWeekDays.indexOf(day) !== -1) {
              classes.push('xdsoft_disabled');
            }

            if (input.is('[disabled]')) {
              classes.push('xdsoft_disabled');
            }

            if (customDateSettings && customDateSettings[1] !== "") {
              classes.push(customDateSettings[1]);
            }

            if (_xdsoft_datetime.currentTime.getMonth() !== m) {
              classes.push('xdsoft_other_month');
            }

            if ((options.defaultSelect || datetimepicker.data('changed')) && dateHelper.formatDate(_xdsoft_datetime.currentTime, options.formatDate) === dateHelper.formatDate(start, options.formatDate)) {
              classes.push('xdsoft_current');
            }

            if (dateHelper.formatDate(today, options.formatDate) === dateHelper.formatDate(start, options.formatDate)) {
              classes.push('xdsoft_today');
            }

            if (start.getDay() === 0 || start.getDay() === 6 || options.weekends.indexOf(dateHelper.formatDate(start, options.formatDate)) !== -1) {
              classes.push('xdsoft_weekend');
            }

            if (options.highlightedDates[dateHelper.formatDate(start, options.formatDate)] !== undefined) {
              hDate = options.highlightedDates[dateHelper.formatDate(start, options.formatDate)];
              classes.push(hDate.style === undefined ? 'xdsoft_highlighted_default' : hDate.style);
              description = hDate.desc === undefined ? '' : hDate.desc;
            }

            if (options.beforeShowDay && $.isFunction(options.beforeShowDay)) {
              classes.push(options.beforeShowDay(start));
            }

            if (newRow) {
              table += '<tr>';
              newRow = false;

              if (options.weeks) {
                table += '<th>' + w + '</th>';
              }
            }

            table += '<td data-date="' + d + '" data-month="' + m + '" data-year="' + y + '"' + ' class="xdsoft_date xdsoft_day_of_week' + start.getDay() + ' ' + classes.join(' ') + '" title="' + description + '">' + '<div>' + d + '</div>' + '</td>';

            if (start.getDay() === options.dayOfWeekStartPrev) {
              table += '</tr>';
              newRow = true;
            }

            start.setDate(d + 1);
          }

          table += '</tbody></table>';
          calendar.html(table);
          month_picker.find('.xdsoft_label span').eq(0).text(options.i18n[globalLocale].months[_xdsoft_datetime.currentTime.getMonth()]);
          month_picker.find('.xdsoft_label span').eq(1).text(_xdsoft_datetime.currentTime.getFullYear() + options.yearOffset); // generate timebox

          time = '';
          h = '';
          m = '';
          var minTimeMinutesOfDay = 0;

          if (options.minTime !== false) {
            var t = _xdsoft_datetime.strtotime(options.minTime);

            minTimeMinutesOfDay = 60 * t.getHours() + t.getMinutes();
          }

          var maxTimeMinutesOfDay = 24 * 60;

          if (options.maxTime !== false) {
            var t = _xdsoft_datetime.strtotime(options.maxTime);

            maxTimeMinutesOfDay = 60 * t.getHours() + t.getMinutes();
          }

          if (options.minDateTime !== false) {
            var t = _xdsoft_datetime.strToDateTime(options.minDateTime);

            var currentDayIsMinDateTimeDay = dateHelper.formatDate(_xdsoft_datetime.currentTime, options.formatDate) === dateHelper.formatDate(t, options.formatDate);

            if (currentDayIsMinDateTimeDay) {
              var m = 60 * t.getHours() + t.getMinutes();
              if (m > minTimeMinutesOfDay) minTimeMinutesOfDay = m;
            }
          }

          if (options.maxDateTime !== false) {
            var t = _xdsoft_datetime.strToDateTime(options.maxDateTime);

            var currentDayIsMaxDateTimeDay = dateHelper.formatDate(_xdsoft_datetime.currentTime, options.formatDate) === dateHelper.formatDate(t, options.formatDate);

            if (currentDayIsMaxDateTimeDay) {
              var m = 60 * t.getHours() + t.getMinutes();
              if (m < maxTimeMinutesOfDay) maxTimeMinutesOfDay = m;
            }
          }

          line_time = function line_time(h, m) {
            var now = _xdsoft_datetime.now(),
                current_time,
                isALlowTimesInit = options.allowTimes && $.isArray(options.allowTimes) && options.allowTimes.length;

            now.setHours(h);
            h = parseInt(now.getHours(), 10);
            now.setMinutes(m);
            m = parseInt(now.getMinutes(), 10);
            classes = [];
            var currentMinutesOfDay = 60 * h + m;

            if (input.is('[disabled]') || currentMinutesOfDay >= maxTimeMinutesOfDay || currentMinutesOfDay < minTimeMinutesOfDay) {
              classes.push('xdsoft_disabled');
            }

            current_time = new Date(_xdsoft_datetime.currentTime);
            current_time.setHours(parseInt(_xdsoft_datetime.currentTime.getHours(), 10));

            if (!isALlowTimesInit) {
              current_time.setMinutes(Math[options.roundTime](_xdsoft_datetime.currentTime.getMinutes() / options.step) * options.step);
            }

            if ((options.initTime || options.defaultSelect || datetimepicker.data('changed')) && current_time.getHours() === parseInt(h, 10) && (!isALlowTimesInit && options.step > 59 || current_time.getMinutes() === parseInt(m, 10))) {
              if (options.defaultSelect || datetimepicker.data('changed')) {
                classes.push('xdsoft_current');
              } else if (options.initTime) {
                classes.push('xdsoft_init_time');
              }
            }

            if (parseInt(today.getHours(), 10) === parseInt(h, 10) && parseInt(today.getMinutes(), 10) === parseInt(m, 10)) {
              classes.push('xdsoft_today');
            }

            time += '<div class="xdsoft_time ' + classes.join(' ') + '" data-hour="' + h + '" data-minute="' + m + '">' + dateHelper.formatDate(now, options.formatTime) + '</div>';
          };

          if (!options.allowTimes || !$.isArray(options.allowTimes) || !options.allowTimes.length) {
            for (i = 0, j = 0; i < (options.hours12 ? 12 : 24); i += 1) {
              for (j = 0; j < 60; j += options.step) {
                var currentMinutesOfDay = i * 60 + j;
                if (currentMinutesOfDay < minTimeMinutesOfDay) continue;
                if (currentMinutesOfDay >= maxTimeMinutesOfDay) continue;
                h = (i < 10 ? '0' : '') + i;
                m = (j < 10 ? '0' : '') + j;
                line_time(h, m);
              }
            }
          } else {
            for (i = 0; i < options.allowTimes.length; i += 1) {
              h = _xdsoft_datetime.strtotime(options.allowTimes[i]).getHours();
              m = _xdsoft_datetime.strtotime(options.allowTimes[i]).getMinutes();
              line_time(h, m);
            }
          }

          timebox.html(time);
          opt = '';

          for (i = parseInt(options.yearStart, 10); i <= parseInt(options.yearEnd, 10); i += 1) {
            opt += '<div class="xdsoft_option ' + (_xdsoft_datetime.currentTime.getFullYear() === i ? 'xdsoft_current' : '') + '" data-value="' + i + '">' + (i + options.yearOffset) + '</div>';
          }

          yearselect.children().eq(0).html(opt);

          for (i = parseInt(options.monthStart, 10), opt = ''; i <= parseInt(options.monthEnd, 10); i += 1) {
            opt += '<div class="xdsoft_option ' + (_xdsoft_datetime.currentTime.getMonth() === i ? 'xdsoft_current' : '') + '" data-value="' + i + '">' + options.i18n[globalLocale].months[i] + '</div>';
          }

          monthselect.children().eq(0).html(opt);
          $(datetimepicker).trigger('generate.xdsoft');
        }, 10);
        event.stopPropagation();
      }).on('afterOpen.xdsoft', function () {
        if (options.timepicker) {
          var classType, pheight, height, top;

          if (timebox.find('.xdsoft_current').length) {
            classType = '.xdsoft_current';
          } else if (timebox.find('.xdsoft_init_time').length) {
            classType = '.xdsoft_init_time';
          }

          if (classType) {
            pheight = timeboxparent[0].clientHeight;
            height = timebox[0].offsetHeight;
            top = timebox.find(classType).index() * options.timeHeightInTimePicker + 1;

            if (height - pheight < top) {
              top = height - pheight;
            }

            timeboxparent.trigger('scroll_element.xdsoft_scroller', [parseInt(top, 10) / (height - pheight)]);
          } else {
            timeboxparent.trigger('scroll_element.xdsoft_scroller', [0]);
          }
        }
      });
      timerclick = 0;
      calendar.on('touchend click.xdsoft', 'td', function (xdevent) {
        xdevent.stopPropagation(); // Prevents closing of Pop-ups, Modals and Flyouts in Bootstrap

        timerclick += 1;
        var $this = $(this),
            currentTime = _xdsoft_datetime.currentTime;

        if (currentTime === undefined || currentTime === null) {
          _xdsoft_datetime.currentTime = _xdsoft_datetime.now();
          currentTime = _xdsoft_datetime.currentTime;
        }

        if ($this.hasClass('xdsoft_disabled')) {
          return false;
        }

        currentTime.setDate(1);
        currentTime.setFullYear($this.data('year'));
        currentTime.setMonth($this.data('month'));
        currentTime.setDate($this.data('date'));
        datetimepicker.trigger('select.xdsoft', [currentTime]);
        input.val(_xdsoft_datetime.str());

        if (options.onSelectDate && $.isFunction(options.onSelectDate)) {
          options.onSelectDate.call(datetimepicker, _xdsoft_datetime.currentTime, datetimepicker.data('input'), xdevent);
        }

        datetimepicker.data('changed', true);
        datetimepicker.trigger('xchange.xdsoft');
        datetimepicker.trigger('changedatetime.xdsoft');

        if ((timerclick > 1 || options.closeOnDateSelect === true || options.closeOnDateSelect === false && !options.timepicker) && !options.inline) {
          datetimepicker.trigger('close.xdsoft');
        }

        setTimeout(function () {
          timerclick = 0;
        }, 200);
      });
      timebox.on('touchstart', 'div', function (xdevent) {
        this.touchMoved = false;
      }).on('touchmove', 'div', handleTouchMoved).on('touchend click.xdsoft', 'div', function (xdevent) {
        if (!this.touchMoved) {
          xdevent.stopPropagation();
          var $this = $(this),
              currentTime = _xdsoft_datetime.currentTime;

          if (currentTime === undefined || currentTime === null) {
            _xdsoft_datetime.currentTime = _xdsoft_datetime.now();
            currentTime = _xdsoft_datetime.currentTime;
          }

          if ($this.hasClass('xdsoft_disabled')) {
            return false;
          }

          currentTime.setHours($this.data('hour'));
          currentTime.setMinutes($this.data('minute'));
          datetimepicker.trigger('select.xdsoft', [currentTime]);
          datetimepicker.data('input').val(_xdsoft_datetime.str());

          if (options.onSelectTime && $.isFunction(options.onSelectTime)) {
            options.onSelectTime.call(datetimepicker, _xdsoft_datetime.currentTime, datetimepicker.data('input'), xdevent);
          }

          datetimepicker.data('changed', true);
          datetimepicker.trigger('xchange.xdsoft');
          datetimepicker.trigger('changedatetime.xdsoft');

          if (options.inline !== true && options.closeOnTimeSelect === true) {
            datetimepicker.trigger('close.xdsoft');
          }
        }
      });
      datepicker.on('mousewheel.xdsoft', function (event) {
        if (!options.scrollMonth) {
          return true;
        }

        if (event.deltaY < 0) {
          _xdsoft_datetime.nextMonth();
        } else {
          _xdsoft_datetime.prevMonth();
        }

        return false;
      });
      input.on('mousewheel.xdsoft', function (event) {
        if (!options.scrollInput) {
          return true;
        }

        if (!options.datepicker && options.timepicker) {
          current_time_index = timebox.find('.xdsoft_current').length ? timebox.find('.xdsoft_current').eq(0).index() : 0;

          if (current_time_index + event.deltaY >= 0 && current_time_index + event.deltaY < timebox.children().length) {
            current_time_index += event.deltaY;
          }

          if (timebox.children().eq(current_time_index).length) {
            timebox.children().eq(current_time_index).trigger('mousedown');
          }

          return false;
        }

        if (options.datepicker && !options.timepicker) {
          datepicker.trigger(event, [event.deltaY, event.deltaX, event.deltaY]);

          if (input.val) {
            input.val(_xdsoft_datetime.str());
          }

          datetimepicker.trigger('changedatetime.xdsoft');
          return false;
        }
      });
      datetimepicker.on('changedatetime.xdsoft', function (event) {
        if (options.onChangeDateTime && $.isFunction(options.onChangeDateTime)) {
          var $input = datetimepicker.data('input');
          options.onChangeDateTime.call(datetimepicker, _xdsoft_datetime.currentTime, $input, event);
          delete options.value;
          $input.trigger('change');
        }
      }).on('generate.xdsoft', function () {
        if (options.onGenerate && $.isFunction(options.onGenerate)) {
          options.onGenerate.call(datetimepicker, _xdsoft_datetime.currentTime, datetimepicker.data('input'));
        }

        if (triggerAfterOpen) {
          datetimepicker.trigger('afterOpen.xdsoft');
          triggerAfterOpen = false;
        }
      }).on('click.xdsoft', function (xdevent) {
        xdevent.stopPropagation();
      });
      current_time_index = 0;
      /**
       * Runs the callback for each of the specified node's ancestors.
       *
       * Return FALSE from the callback to stop ascending.
       *
       * @param {DOMNode} node
       * @param {Function} callback
       * @returns {undefined}
       */

      forEachAncestorOf = function forEachAncestorOf(node, callback) {
        do {
          node = node.parentNode;

          if (!node || callback(node) === false) {
            break;
          }
        } while (node.nodeName !== 'HTML');
      };
      /**
       * Sets the position of the picker.
       *
       * @returns {undefined}
       */


      setPos = function setPos() {
        var dateInputOffset, dateInputElem, verticalPosition, left, position, datetimepickerElem, dateInputHasFixedAncestor, $dateInput, windowWidth, verticalAnchorEdge, datetimepickerCss, windowHeight, windowScrollTop;
        $dateInput = datetimepicker.data('input');
        dateInputOffset = $dateInput.offset();
        dateInputElem = $dateInput[0];
        verticalAnchorEdge = 'top';
        verticalPosition = dateInputOffset.top + dateInputElem.offsetHeight - 1;
        left = dateInputOffset.left;
        position = "absolute";
        windowWidth = $(options.contentWindow).width();
        windowHeight = $(options.contentWindow).height();
        windowScrollTop = $(options.contentWindow).scrollTop();

        if (options.ownerDocument.documentElement.clientWidth - dateInputOffset.left < datepicker.parent().outerWidth(true)) {
          var diff = datepicker.parent().outerWidth(true) - dateInputElem.offsetWidth;
          left = left - diff;
        }

        if ($dateInput.parent().css('direction') === 'rtl') {
          left -= datetimepicker.outerWidth() - $dateInput.outerWidth();
        }

        if (options.fixed) {
          verticalPosition -= windowScrollTop;
          left -= $(options.contentWindow).scrollLeft();
          position = "fixed";
        } else {
          dateInputHasFixedAncestor = false;
          forEachAncestorOf(dateInputElem, function (ancestorNode) {
            if (ancestorNode === null) {
              return false;
            }

            if (options.contentWindow.getComputedStyle(ancestorNode).getPropertyValue('position') === 'fixed') {
              dateInputHasFixedAncestor = true;
              return false;
            }
          });

          if (dateInputHasFixedAncestor && !options.insideParent) {
            position = 'fixed'; //If the picker won't fit entirely within the viewport then display it above the date input.

            if (verticalPosition + datetimepicker.outerHeight() > windowHeight + windowScrollTop) {
              verticalAnchorEdge = 'bottom';
              verticalPosition = windowHeight + windowScrollTop - dateInputOffset.top;
            } else {
              verticalPosition -= windowScrollTop;
            }
          } else {
            if (verticalPosition + datetimepicker[0].offsetHeight > windowHeight + windowScrollTop) {
              verticalPosition = dateInputOffset.top - datetimepicker[0].offsetHeight + 1;
            }
          }

          if (verticalPosition < 0) {
            verticalPosition = 0;
          }

          if (left + dateInputElem.offsetWidth > windowWidth) {
            left = windowWidth - dateInputElem.offsetWidth;
          }
        }

        datetimepickerElem = datetimepicker[0];
        forEachAncestorOf(datetimepickerElem, function (ancestorNode) {
          var ancestorNodePosition;
          ancestorNodePosition = options.contentWindow.getComputedStyle(ancestorNode).getPropertyValue('position');

          if (ancestorNodePosition === 'relative' && windowWidth >= ancestorNode.offsetWidth) {
            left = left - (windowWidth - ancestorNode.offsetWidth) / 2;
            return false;
          }
        });
        datetimepickerCss = {
          position: position,
          left: options.insideParent ? dateInputElem.offsetLeft : left,
          top: '',
          //Initialize to prevent previous values interfering with new ones.
          bottom: '' //Initialize to prevent previous values interfering with new ones.

        };

        if (options.insideParent) {
          datetimepickerCss[verticalAnchorEdge] = dateInputElem.offsetTop + dateInputElem.offsetHeight;
        } else {
          datetimepickerCss[verticalAnchorEdge] = verticalPosition;
        }

        datetimepicker.css(datetimepickerCss);
      };

      datetimepicker.on('open.xdsoft', function (event) {
        var onShow = true;

        if (options.onShow && $.isFunction(options.onShow)) {
          onShow = options.onShow.call(datetimepicker, _xdsoft_datetime.currentTime, datetimepicker.data('input'), event);
        }

        if (onShow !== false) {
          datetimepicker.show();
          setPos();
          $(options.contentWindow).off('resize.xdsoft', setPos).on('resize.xdsoft', setPos);

          if (options.closeOnWithoutClick) {
            $([options.ownerDocument.body, options.contentWindow]).on('touchstart mousedown.xdsoft', function arguments_callee6() {
              datetimepicker.trigger('close.xdsoft');
              $([options.ownerDocument.body, options.contentWindow]).off('touchstart mousedown.xdsoft', arguments_callee6);
            });
          }
        }
      }).on('close.xdsoft', function (event) {
        var onClose = true;
        month_picker.find('.xdsoft_month,.xdsoft_year').find('.xdsoft_select').hide();

        if (options.onClose && $.isFunction(options.onClose)) {
          onClose = options.onClose.call(datetimepicker, _xdsoft_datetime.currentTime, datetimepicker.data('input'), event);
        }

        if (onClose !== false && !options.opened && !options.inline) {
          datetimepicker.hide();
        }

        event.stopPropagation();
      }).on('toggle.xdsoft', function () {
        if (datetimepicker.is(':visible')) {
          datetimepicker.trigger('close.xdsoft');
        } else {
          datetimepicker.trigger('open.xdsoft');
        }
      }).data('input', input);
      timer = 0;
      datetimepicker.data('xdsoft_datetime', _xdsoft_datetime);
      datetimepicker.setOptions(options);

      function getCurrentValue() {
        var ct = false,
            time;

        if (options.startDate) {
          ct = _xdsoft_datetime.strToDate(options.startDate);
        } else {
          ct = options.value || (input && input.val && input.val() ? input.val() : '');

          if (ct) {
            ct = _xdsoft_datetime.strToDateTime(ct);

            if (options.yearOffset) {
              ct = new Date(ct.getFullYear() - options.yearOffset, ct.getMonth(), ct.getDate(), ct.getHours(), ct.getMinutes(), ct.getSeconds(), ct.getMilliseconds());
            }
          } else if (options.defaultDate) {
            ct = _xdsoft_datetime.strToDateTime(options.defaultDate);

            if (options.defaultTime) {
              time = _xdsoft_datetime.strtotime(options.defaultTime);
              ct.setHours(time.getHours());
              ct.setMinutes(time.getMinutes());
            }
          }
        }

        if (ct && _xdsoft_datetime.isValidDate(ct)) {
          datetimepicker.data('changed', true);
        } else {
          ct = '';
        }

        return ct || 0;
      }

      function setMask(options) {
        var isValidValue = function isValidValue(mask, value) {
          var reg = mask.replace(/([\[\]\/\{\}\(\)\-\.\+]{1})/g, '\\$1').replace(/_/g, '{digit+}').replace(/([0-9]{1})/g, '{digit$1}').replace(/\{digit([0-9]{1})\}/g, '[0-$1_]{1}').replace(/\{digit[\+]\}/g, '[0-9_]{1}');
          return new RegExp(reg).test(value);
        },
            getCaretPos = function getCaretPos(input) {
          try {
            if (options.ownerDocument.selection && options.ownerDocument.selection.createRange) {
              var range = options.ownerDocument.selection.createRange();
              return range.getBookmark().charCodeAt(2) - 2;
            }

            if (input.setSelectionRange) {
              return input.selectionStart;
            }
          } catch (e) {
            return 0;
          }
        },
            setCaretPos = function setCaretPos(node, pos) {
          node = typeof node === "string" || node instanceof String ? options.ownerDocument.getElementById(node) : node;

          if (!node) {
            return false;
          }

          if (node.createTextRange) {
            var textRange = node.createTextRange();
            textRange.collapse(true);
            textRange.moveEnd('character', pos);
            textRange.moveStart('character', pos);
            textRange.select();
            return true;
          }

          if (node.setSelectionRange) {
            node.setSelectionRange(pos, pos);
            return true;
          }

          return false;
        };

        if (options.mask) {
          input.off('keydown.xdsoft');
        }

        if (options.mask === true) {
          if (dateHelper.formatMask) {
            options.mask = dateHelper.formatMask(options.format);
          } else {
            options.mask = options.format.replace(/Y/g, '9999').replace(/F/g, '9999').replace(/m/g, '19').replace(/d/g, '39').replace(/H/g, '29').replace(/i/g, '59').replace(/s/g, '59');
          }
        }

        if ($.type(options.mask) === 'string') {
          if (!isValidValue(options.mask, input.val())) {
            input.val(options.mask.replace(/[0-9]/g, '_'));
            setCaretPos(input[0], 0);
          }

          input.on('paste.xdsoft', function (event) {
            // couple options here
            // 1. return false - tell them they can't paste
            // 2. insert over current characters - minimal validation
            // 3. full fledged parsing and validation
            // let's go option 2 for now
            // fires multiple times for some reason
            // https://stackoverflow.com/a/30496488/1366033
            var clipboardData = event.clipboardData || event.originalEvent.clipboardData || window.clipboardData,
                pastedData = clipboardData.getData('text'),
                val = this.value,
                pos = this.selectionStart;
            var valueBeforeCursor = val.substr(0, pos);
            var valueAfterPaste = val.substr(pos + pastedData.length);
            val = valueBeforeCursor + pastedData + valueAfterPaste;
            pos += pastedData.length;

            if (isValidValue(options.mask, val)) {
              this.value = val;
              setCaretPos(this, pos);
            } else if ($.trim(val) === '') {
              this.value = options.mask.replace(/[0-9]/g, '_');
            } else {
              input.trigger('error_input.xdsoft');
            }

            event.preventDefault();
            return false;
          });
          input.on('keydown.xdsoft', function (event) {
            var val = this.value,
                key = event.which,
                pos = this.selectionStart,
                selEnd = this.selectionEnd,
                hasSel = pos !== selEnd,
                digit; // only alow these characters

            if (key >= KEY0 && key <= KEY9 || key >= _KEY0 && key <= _KEY9 || key === BACKSPACE || key === DEL) {
              // get char to insert which is new character or placeholder ('_')
              digit = key === BACKSPACE || key === DEL ? '_' : String.fromCharCode(_KEY0 <= key && key <= _KEY9 ? key - KEY0 : key); // we're deleting something, we're not at the start, and have normal cursor, move back one
              // if we have a selection length, cursor actually sits behind deletable char, not in front

              if (key === BACKSPACE && pos && !hasSel) {
                pos -= 1;
              } // don't stop on a separator, continue whatever direction you were going
              //   value char - keep incrementing position while on separator char and we still have room
              //   del char   - keep decrementing position while on separator char and we still have room


              while (true) {
                var maskValueAtCurPos = options.mask.substr(pos, 1);
                var posShorterThanMaskLength = pos < options.mask.length;
                var posGreaterThanZero = pos > 0;
                var notNumberOrPlaceholder = /[^0-9_]/;
                var curPosOnSep = notNumberOrPlaceholder.test(maskValueAtCurPos);
                var continueMovingPosition = curPosOnSep && posShorterThanMaskLength && posGreaterThanZero; // if we hit a real char, stay where we are

                if (!continueMovingPosition) break; // hitting backspace in a selection, you can possibly go back any further - go forward

                pos += key === BACKSPACE && !hasSel ? -1 : 1;
              }

              if (event.metaKey) {
                // cmd has been pressed
                pos = 0;
                hasSel = true;
              }

              if (hasSel) {
                // pos might have moved so re-calc length
                var selLength = selEnd - pos; // if we have a selection length we will wipe out entire selection and replace with default template for that range

                var defaultBlank = options.mask.replace(/[0-9]/g, '_');
                var defaultBlankSelectionReplacement = defaultBlank.substr(pos, selLength);
                var selReplacementRemainder = defaultBlankSelectionReplacement.substr(1); // might be empty

                var valueBeforeSel = val.substr(0, pos);
                var insertChars = digit + selReplacementRemainder;
                var charsAfterSelection = val.substr(pos + selLength);
                val = valueBeforeSel + insertChars + charsAfterSelection;
              } else {
                var valueBeforeCursor = val.substr(0, pos);
                var insertChar = digit;
                var valueAfterNextChar = val.substr(pos + 1);
                val = valueBeforeCursor + insertChar + valueAfterNextChar;
              }

              if ($.trim(val) === '') {
                // if empty, set to default
                val = defaultBlank;
              } else {
                // if at the last character don't need to do anything
                if (pos === options.mask.length) {
                  event.preventDefault();
                  return false;
                }
              } // resume cursor location


              pos += key === BACKSPACE ? 0 : 1; // don't stop on a separator, continue whatever direction you were going

              while (/[^0-9_]/.test(options.mask.substr(pos, 1)) && pos < options.mask.length && pos > 0) {
                pos += key === BACKSPACE ? 0 : 1;
              }

              if (isValidValue(options.mask, val)) {
                this.value = val;
                setCaretPos(this, pos);
              } else if ($.trim(val) === '') {
                this.value = options.mask.replace(/[0-9]/g, '_');
              } else {
                input.trigger('error_input.xdsoft');
              }
            } else {
              if ([AKEY, CKEY, VKEY, ZKEY, YKEY].indexOf(key) !== -1 && ctrlDown || [ESC, ARROWUP, ARROWDOWN, ARROWLEFT, ARROWRIGHT, F5, CTRLKEY, TAB, ENTER].indexOf(key) !== -1) {
                return true;
              }
            }

            event.preventDefault();
            return false;
          });
        }
      }

      _xdsoft_datetime.setCurrentTime(getCurrentValue());

      input.data('xdsoft_datetimepicker', datetimepicker).on('open.xdsoft focusin.xdsoft mousedown.xdsoft touchstart', function () {
        if (input.is(':disabled') || input.data('xdsoft_datetimepicker').is(':visible') && options.closeOnInputClick) {
          return;
        }

        if (!options.openOnFocus) {
          return;
        }

        clearTimeout(timer);
        timer = setTimeout(function () {
          if (input.is(':disabled')) {
            return;
          }

          triggerAfterOpen = true;

          _xdsoft_datetime.setCurrentTime(getCurrentValue(), true);

          if (options.mask) {
            setMask(options);
          }

          datetimepicker.trigger('open.xdsoft');
        }, 100);
      }).on('keydown.xdsoft', function (event) {
        var elementSelector,
            key = event.which;

        if ([ENTER].indexOf(key) !== -1 && options.enterLikeTab) {
          elementSelector = $("input:visible,textarea:visible,button:visible,a:visible");
          datetimepicker.trigger('close.xdsoft');
          elementSelector.eq(elementSelector.index(this) + 1).focus();
          return false;
        }

        if ([TAB].indexOf(key) !== -1) {
          datetimepicker.trigger('close.xdsoft');
          return true;
        }
      }).on('blur.xdsoft', function () {
        datetimepicker.trigger('close.xdsoft');
      });
    };

    destroyDateTimePicker = function destroyDateTimePicker(input) {
      var datetimepicker = input.data('xdsoft_datetimepicker');

      if (datetimepicker) {
        datetimepicker.data('xdsoft_datetime', null);
        datetimepicker.remove();
        input.data('xdsoft_datetimepicker', null).off('.xdsoft');
        $(options.contentWindow).off('resize.xdsoft');
        $([options.contentWindow, options.ownerDocument.body]).off('mousedown.xdsoft touchstart');

        if (input.unmousewheel) {
          input.unmousewheel();
        }
      }
    };

    $(options.ownerDocument).off('keydown.xdsoftctrl keyup.xdsoftctrl').off('keydown.xdsoftcmd keyup.xdsoftcmd').on('keydown.xdsoftctrl', function (e) {
      if (e.keyCode === CTRLKEY) {
        ctrlDown = true;
      }
    }).on('keyup.xdsoftctrl', function (e) {
      if (e.keyCode === CTRLKEY) {
        ctrlDown = false;
      }
    }).on('keydown.xdsoftcmd', function (e) {
      if (e.keyCode === CMDKEY) {
        cmdDown = true;
      }
    }).on('keyup.xdsoftcmd', function (e) {
      if (e.keyCode === CMDKEY) {
        cmdDown = false;
      }
    });
    this.each(function () {
      var datetimepicker = $(this).data('xdsoft_datetimepicker'),
          $input;

      if (datetimepicker) {
        if ($.type(opt) === 'string') {
          switch (opt) {
            case 'show':
              $(this).select().focus();
              datetimepicker.trigger('open.xdsoft');
              break;

            case 'hide':
              datetimepicker.trigger('close.xdsoft');
              break;

            case 'toggle':
              datetimepicker.trigger('toggle.xdsoft');
              break;

            case 'destroy':
              destroyDateTimePicker($(this));
              break;

            case 'reset':
              this.value = this.defaultValue;

              if (!this.value || !datetimepicker.data('xdsoft_datetime').isValidDate(dateHelper.parseDate(this.value, options.format))) {
                datetimepicker.data('changed', false);
              }

              datetimepicker.data('xdsoft_datetime').setCurrentTime(this.value);
              break;

            case 'validate':
              $input = datetimepicker.data('input');
              $input.trigger('blur.xdsoft');
              break;

            default:
              if (datetimepicker[opt] && $.isFunction(datetimepicker[opt])) {
                result = datetimepicker[opt](opt2);
              }

          }
        } else {
          datetimepicker.setOptions(opt);
        }

        return 0;
      }

      if ($.type(opt) !== 'string') {
        if (!options.lazyInit || options.open || options.inline) {
          createDateTimePicker($(this));
        } else {
          lazyInit($(this));
        }
      }
    });
    return result;
  };

  $.fn.datetimepicker.defaults = default_options;

  function HighlightedDate(date, desc, style) {
    "use strict";

    this.date = date;
    this.desc = desc;
    this.style = style;
  }
})(jQuery);
;// CONCATENATED MODULE: ./src/components/form/js/fn/datepicker.js


/*
 * Render Date Picker
 *
 * @param  {String} controls                 - Wrapper of controls.
 * @return {Void}
 */


(function ($) {
  'use strict';

  $.fn.UixRenderDatePicker = function (options) {
    // This is the easiest way to have default options.
    var settings = $.extend({
      controls: '[data-picker]'
    }, options);
    this.each(function () {
      if ($.isFunction($.fn.datetimepicker)) {
        $(settings.controls).each(function () {
          var $this = $(this);
          var dateFormat = $this.data('picker-format'),
              timeEnabled = $this.data('picker-timepicker'),
              lang = $this.data('picker-lang'),
              myminDate = $this.data('picker-min-date'),
              mymaxDate = $this.data('picker-max-date'),
              rtlEnabled = false; // If there is no data-xxx, save current source to it

          if ((0,esm_typeof/* default */.Z)(dateFormat) === ( true ? "undefined" : 0)) dateFormat = 'M d, Y'; //Y-m-d H:i:s

          if ((0,esm_typeof/* default */.Z)(timeEnabled) === ( true ? "undefined" : 0)) timeEnabled = false;
          if ((0,esm_typeof/* default */.Z)(lang) === ( true ? "undefined" : 0)) lang = 'en';
          if ((0,esm_typeof/* default */.Z)(myminDate) === ( true ? "undefined" : 0)) myminDate = false; //yesterday is minimum date(for today use 0 or -1970/01/01)

          if ((0,esm_typeof/* default */.Z)(mymaxDate) === ( true ? "undefined" : 0)) mymaxDate = false; //tomorrow is maximum date calendar, such as '+2050/01/01'

          if ((0,esm_typeof/* default */.Z)(rtlEnabled) === ( true ? "undefined" : 0)) rtlEnabled = false;
          $.datetimepicker.setLocale(lang); //RTL 

          if ($('body').hasClass('rtl')) {
            rtlEnabled = true;
          } //hide or display time selector


          if (timeEnabled) {
            $(document).on('mouseenter', 'td.xdsoft_date[data-date]', function () {
              if ($(this).hasClass('xdsoft_disabled')) {
                $(this).closest('.xdsoft_datepicker').next('.xdsoft_timepicker.active').hide();
              } else {
                $(this).closest('.xdsoft_datepicker').next('.xdsoft_timepicker.active').show();
              }
            });
          }

          $this.datetimepicker({
            rtl: rtlEnabled,
            timepicker: timeEnabled,
            format: dateFormat,
            formatTime: 'H:i',
            formatDate: 'Y/m/d',
            minDate: myminDate,
            maxDate: mymaxDate
          });
        }); //Dynamic listening for the latest value

        $(document).on('mouseleave', '[data-handler]', function () {
          $('[data-picker]').each(function () {
            $(this).closest('div').find('label, .uix-controls__bar').addClass('is-active');
          });
        });
      } // function datetimepicker is exist

    });
  };
})(jQuery);
// EXTERNAL MODULE: ./src/components/form/js/fn/controls-hover.js
var controls_hover = __webpack_require__(366);
;// CONCATENATED MODULE: ./src/components/form/js/fn/single-seletor.js


/*
 * Render Single Selector
 *
 * @param  {String} controls                 - Wrapper of controls.
 * @return {Void}
 */
(function ($) {
  'use strict';

  $.fn.UixRenderCustomSingleSel = function (options) {
    // This is the easiest way to have default options.
    var settings = $.extend({
      controls: '.uix-controls__single-sel'
    }, options);
    this.each(function () {
      $(settings.controls).each(function () {
        var $this = $(this);
        var actived = $this.data('activated');

        if ((0,esm_typeof/* default */.Z)(actived) === ( true ? "undefined" : 0)) {
          // Initialize status
          //------------------------------------------
          $(this).find('> span').each(function () {
            var targetID = '#' + $(this).parent().attr('data-targetid');
            var switchIDs = ''; //add switch IDs

            $(this).parent().find('> span').each(function () {
              if ((0,esm_typeof/* default */.Z)($(this).data("switchid")) != ( true ? "undefined" : 0)) {
                switchIDs += $(this).data("switchid") + ',';
              }
            });
            $(this).parent().attr("data-switchids", switchIDs.replace(/,\s*$/, '')); //Set actived style from their values

            if ($(targetID).val() == $(this).data('value')) {
              $(this).addClass('is-active').attr('aria-checked', true);
            } else {
              $(this).removeClass('is-active').attr('aria-checked', false);
            }
          }); // Mouse events
          //------------------------------------------

          var singleSelItem = settings.controls + ' > span';
          /*
          * Initialize single switch
          *
          * @param  {Element} obj                 - Radio controls. 
          * @return {Void}
          */

          var hideAllSingleSelItems = function hideAllSingleSelItems(obj) {
            obj.each(function (index) {
              var $sel = $(this),
                  defaultValue = $('#' + $sel.attr('data-targetid')).val(),
                  deffaultSwitchIndex = 0; //get default selected switch index

              $sel.find('> span').each(function (index) {
                if (defaultValue == $(this).data('value')) {
                  deffaultSwitchIndex = index;
                }
              });

              if ((0,esm_typeof/* default */.Z)($sel.data('switchids')) != ( true ? "undefined" : 0) && $sel.data('switchids') != '') {
                var _switchIDsArr = $sel.data('switchids').split(',');

                _switchIDsArr.forEach(function (element, index) {
                  if (deffaultSwitchIndex != index) {
                    $('#' + element).hide();
                  } else {
                    $('#' + element).show();
                  }
                });
              }
            });
          };

          hideAllSingleSelItems($this);
          $(document).off('click.FORM_SINGLE_SEL').on('click.FORM_SINGLE_SEL', singleSelItem, function (e) {
            e.preventDefault();
            var $selector = $(this).parent(),
                $option = $(this),
                targetID = '#' + $selector.data("targetid"),
                switchID = '#' + $option.data("switchid"),
                curVal = $option.data('value'); //Radio Selector

            $selector.find('> span').removeClass('is-active').attr('aria-checked', false);
            $(targetID).val(curVal);
            $option.addClass('is-active').attr('aria-checked', true); //Switch some options

            if ((0,esm_typeof/* default */.Z)($option.data("switchid")) != ( true ? "undefined" : 0)) {
              hideAllSingleSelItems($selector);
              $(switchID).show();
            } //Dynamic listening for the latest value


            $(targetID).focus().blur();
          }); //------------------------------------------
          //Prevents front-end javascripts that are activated in the background to repeat loading.

          $this.data('activated', 1);
        } //endif actived			

      });
      $(settings.controls).each(function () {});
    });
  };
})(jQuery);
;// CONCATENATED MODULE: ./src/components/form/js/fn/multi-seletor.js


/*
 * Render Multiple Selector
 *
 * @param  {String} controls                 - Wrapper of controls.
 * @return {Void}
 */
(function ($) {
  'use strict';

  $.fn.UixRenderCustomMultiSel = function (options) {
    // This is the easiest way to have default options.
    var settings = $.extend({
      controls: '.uix-controls__multi-sel'
    }, options);
    this.each(function () {
      $(settings.controls).each(function () {
        var $this = $(this);
        var actived = $this.data('activated');

        if ((0,esm_typeof/* default */.Z)(actived) === ( true ? "undefined" : 0)) {
          // Initialize status
          //------------------------------------------
          $(this).find('> span').each(function () {
            var targetID = '#' + $(this).parent().attr('data-targetid');

            if ($(targetID).val().indexOf($(this).data('value')) >= 0) {
              $(this).addClass('is-active').attr('aria-checked', true);
            } else {
              $(this).removeClass('is-active').attr('aria-checked', false);
            }
          }); // Click Event of Multiple Selector
          //------------------------------------------

          var multiSel = '.uix-controls__multi-sel',
              multiSelItem = multiSel + ' > span';
          $(document).off('click.FORM_MULTI_SEL').on('click.FORM_MULTI_SEL', multiSelItem, function (e) {
            e.preventDefault();
            var $selector = $(this).parent(),
                $option = $(this),
                targetID = '#' + $selector.data("targetid"),
                curVal = $option.data('value'),
                tarVal = $(targetID).val() + ',',
                resVal = '';
            $option.toggleClass('is-active').attr('aria-checked', function (index, attr) {
              return attr == 'true' ? false : true;
            });

            if (tarVal.indexOf(curVal + ',') < 0) {
              resVal = tarVal + curVal + ',';
            } else {
              resVal = tarVal.replace(curVal + ',', '');
            }

            resVal = resVal.replace(/,\s*$/, '').replace(/^,/, '');
            $(targetID).val(resVal); //Dynamic listening for the latest value

            $(targetID).focus().blur();
          }); //------------------------------------------
          //Prevents front-end javascripts that are activated in the background to repeat loading.

          $this.data('activated', 1);
        } //endif actived			

      });
    });
  };
})(jQuery);
// EXTERNAL MODULE: ./src/components/form/js/fn/file-dropzone.js
var file_dropzone = __webpack_require__(283);
// EXTERNAL MODULE: ./src/components/form/js/fn/upload.js
var upload = __webpack_require__(433);
// EXTERNAL MODULE: ./src/components/form/js/fn/controls-disable.js
var controls_disable = __webpack_require__(260);
;// CONCATENATED MODULE: ./src/components/form/js/fn/controls-line.js


/*
 * Create Line Effect on Click
 *
 * @param  {String} controls                 - Wrapper of controls.
 * @return {Void}
 */
(function ($) {
  'use strict';

  $.fn.UixRenderControlsLineEff = function (options) {
    // This is the easiest way to have default options.
    var settings = $.extend({
      controls: '.uix-controls.uix-controls--line'
    }, options);
    this.each(function () {
      var $this = $(this);
      var customControls = settings.controls;
      $(customControls).each(function () {
        var dataExist = $(this).data('exist');

        if ((0,esm_typeof/* default */.Z)(dataExist) === ( true ? "undefined" : 0) && dataExist != 1) {
          $('<ins class="uix-controls__bar"></ins><ins class="uix-controls__basic-bar"></ins>').insertAfter($(this).find('label')); //Multiple Selector or Single Selector

          if ($(this).hasClass('uix-controls__multi-sel') || $(this).hasClass('uix-controls__single-sel')) {
            $(this).find('> span').each(function () {
              $(this).prepend('<ins class="uix-controls__bar"></ins><ins class="uix-controls__basic-bar"></ins>');
            });
          } //Custom Input Number


          if ($(this).hasClass('uix-controls__number')) {
            $(this).prepend('<ins class="uix-controls__bar"></ins><ins class="uix-controls__basic-bar"></ins>');
          } //Prevent the form from being initialized again


          $(this).data('exist', 1);
        }
      });
    });
  };
})(jQuery);
;// CONCATENATED MODULE: ./src/components/form/js/fn/radio-and-checkbox.js


/*
 * Render Custom Radio, Checkbox and Toggle 
 *
 * @param  {String} radioWrapper             - Wrapper of the radio.
 * @param  {String} toggle                   - Toggle of the checkbox.
 * @param  {String} checkboxWrapper          - Wrapper of the checkbox.
 * @return {Void}
 */
(function ($) {
  'use strict';

  $.fn.UixRenderCustomRadioCheckbox = function (options) {
    // This is the easiest way to have default options.
    var settings = $.extend({
      radioWrapper: '.uix-controls__radio',
      toggle: '.uix-controls__toggle',
      checkboxWrapper: '.uix-controls__checkbox'
    }, options);
    this.each(function () {
      $(settings.checkboxWrapper).each(function () {
        var $this = $(this);
        var actived = $this.data('activated');

        if ((0,esm_typeof/* default */.Z)(actived) === ( true ? "undefined" : 0)) {
          // Initialize status
          //------------------------------------------  
          $(settings.checkboxWrapper).find('input[type="checkbox"]').each(function () {
            var dataExist = $(this).data('exist'),
                $obj = $(this).closest('.uix-controls');

            if ((0,esm_typeof/* default */.Z)(dataExist) === ( true ? "undefined" : 0) && dataExist != 1) {
              $('<span class="uix-controls__checkbox-trigger"></span>').insertAfter($(this)); //hide or display a associated div

              var targetID = '#' + $obj.attr('data-targetid');

              if ($(this).is(':checked')) {
                $obj.addClass('is-active').attr('aria-checked', true);
                $(targetID).show();
              } else {
                $obj.removeClass('is-active').attr('aria-checked', false);
                $(targetID).hide();
              } //Prevent the form from being initialized again


              $(this).data('exist', 1);
            }
          }); // Mouse events
          //------------------------------------------

          $(document).on('change', settings.toggle + ' [type="checkbox"]', function (e) {
            //hide or display a associated div
            var $obj = $(this).closest('.uix-controls'),
                targetID = '#' + $obj.attr('data-targetid');

            if (this.checked) {
              $obj.addClass('is-active').attr('aria-checked', true);
              $(targetID).show();
            } else {
              $obj.removeClass('is-active').attr('aria-checked', false);
              $(targetID).hide();
            }
          }); //------------------------------------------
          //Prevents front-end javascripts that are activated in the background to repeat loading.

          $this.data('activated', 1);
        } //endif actived			

      });
      $(settings.toggle).each(function () {
        var $this = $(this);
        var actived = $this.data('activated');

        if ((0,esm_typeof/* default */.Z)(actived) === ( true ? "undefined" : 0)) {
          // Initialize status
          //------------------------------------------  
          $(settings.toggle).find('input[type="checkbox"]').each(function () {
            var dataExist = $(this).data('exist'),
                $obj = $(this).closest('.uix-controls'),
                offText = $obj.data('off-text'),
                onText = $obj.data('on-text');

            if ((0,esm_typeof/* default */.Z)(dataExist) === ( true ? "undefined" : 0) && dataExist != 1) {
              $('<span class="uix-controls__toggle-trigger" data-off-text="' + offText + '" data-on-text="' + onText + '"></span>').insertAfter($(this)); //hide or display a associated div

              var targetID = '#' + $obj.attr('data-targetid');

              if ($(this).is(':checked')) {
                $obj.addClass('is-active').attr('aria-checked', true);
                $(targetID).show();
              } else {
                $obj.removeClass('is-active').attr('aria-checked', false);
                $(targetID).hide();
              } //Prevent the form from being initialized again


              $(this).data('exist', 1);
            }
          }); // Mouse events
          //------------------------------------------

          $(document).on('change', settings.checkboxWrapper + ' [type="checkbox"]', function (e) {
            //hide or display a associated div
            var $obj = $(this).closest('.uix-controls'),
                targetID = '#' + $obj.attr('data-targetid');

            if (this.checked) {
              $obj.addClass('is-active').attr('aria-checked', true);
              $(targetID).show();
            } else {
              $obj.removeClass('is-active').attr('aria-checked', false);
              $(targetID).hide();
            }
          }); //------------------------------------------
          //Prevents front-end javascripts that are activated in the background to repeat loading.

          $this.data('activated', 1);
        } //endif actived			

      });
      $(settings.radioWrapper).each(function () {
        var $this = $(this);
        var actived = $this.data('activated');

        if ((0,esm_typeof/* default */.Z)(actived) === ( true ? "undefined" : 0)) {
          // Initialize status
          //------------------------------------------  
          $(settings.radioWrapper).find('input[type="radio"]').each(function () {
            var dataExist = $(this).data('exist');

            if ((0,esm_typeof/* default */.Z)(dataExist) === ( true ? "undefined" : 0) && dataExist != 1) {
              $('<span class="uix-controls__radio-trigger"></span>').insertAfter($(this)); //Prevent the form from being initialized again

              $(this).data('exist', 1);
            }
          }); //------------------------------------------
          //Prevents front-end javascripts that are activated in the background to repeat loading.

          $this.data('activated', 1);
        } //endif actived			

      });
    });
  };
})(jQuery);
;// CONCATENATED MODULE: ./src/components/form/js/fn/select.js


/*
 * Render Custom Select
 *
 * @param  {String} selector             - The current selector.
 * @param  {String} targetWrapper        - Wrapper of the selector.
 * @param  {String} trigger              - Trigger of the selector.
 * @param  {String} itemsWrapper         - Selector's options container.
 * @param  {Element} item                 - Each option of the selector.
 * @return {Void}
 */
(function ($) {
  'use strict';

  $.fn.UixRenderCustomSelect = function (options) {
    // This is the easiest way to have default options.
    var settings = $.extend({
      selector: '.uix-controls__select',
      targetWrapper: '.uix-controls__select-wrapper',
      trigger: '.uix-controls__select-trigger',
      itemsWrapper: '.uix-controls__select__option-container',
      item: '.uix-controls__select__option'
    }, options);
    this.each(function () {
      $(settings.selector).not('.js-uix-new').each(function () {
        var $this = $(this);
        var classes = $this.attr('class'),
            id = $this.attr('id'),
            name = $this.attr('name'),
            labelText = $this.find('> span').html(),
            dataExist = $this.data('exist');
        var template = '';

        if ((0,esm_typeof/* default */.Z)(dataExist) === ( true ? "undefined" : 0) && dataExist != 1) {
          template = '<div class="' + classes + ' js-uix-new">';
          template += '<span class="uix-controls__select-trigger">' + $this.find('select').attr('placeholder') + '</span><ins class="uix-controls__bar"></ins><ins class="uix-controls__basic-bar"></ins>';
          template += '<div role="presentation" class="uix-controls__select__option-container">';
          $this.find('select option').each(function (index) {
            var selected = '';

            if ($(this).is(':selected')) {
              selected = 'is-active';
            }

            template += '<span role="option" class="uix-controls__select__option ' + selected + '" data-value="' + $(this).attr('value') + '">' + $(this).html() + '</span>';
          });
          template += '</div></div>';

          if ((0,esm_typeof/* default */.Z)(labelText) != ( true ? "undefined" : 0) && labelText != '') {
            template += '<span class="uix-controls__select-label">' + labelText + '</span>';
          }

          $this.wrap('<div class="' + settings.targetWrapper.replace('.', '') + ' ' + ($this.hasClass('uix-controls--line') ? 'uix-controls--line' : '') + ' ' + ($this.hasClass('is-fullwidth') ? 'is-fullwidth' : '') + ' ' + ($this.hasClass('is-disabled') ? 'is-disabled' : '') + '"></div>');
          $this.hide();
          $this.after(template); //Prevent the form from being initialized again

          $(this).data('exist', 1);
        }
      }); //Show/Hide Selector

      $(document).off('click.FORM_CUSTOM_SELECT').on('click.FORM_CUSTOM_SELECT', settings.trigger, function (e) {
        e.preventDefault();
        var $selectWrapper = $(this).closest(settings.targetWrapper),
            $selectCurWrapper = $selectWrapper.find(settings.selector + '.js-uix-new');
        $selectCurWrapper.addClass('is-opened');
      }); //Do not add off() to this

      $(document.body).on('click', function (e) {
        if (e.target.className != '' && (0,esm_typeof/* default */.Z)(e.target.className) != ( true ? "undefined" : 0) && Object.prototype.toString.call(e.target.className) != '[object SVGAnimatedString]') {
          if (e.target.className.indexOf('uix-controls__select__option') < 0) {
            $(settings.selector + '.js-uix-new').removeClass('is-opened');
          }
        }
      }); //Set the default selector text

      $(settings.selector + '.js-uix-new').each(function (index) {
        $(this).find(settings.trigger).text($(this).find(settings.item + '.is-active').html());
      }); //Change Event Here
      //Prevents the triggering of multiple change events

      $(document).off('click.FORM_CUSTOM_SELECT_ITEM').on('click.FORM_CUSTOM_SELECT_ITEM', settings.item, function (e) {
        e.preventDefault();
        var $selectWrapper = $(this).closest(settings.targetWrapper),
            $selectCurWrapper = $selectWrapper.find(settings.selector + '.js-uix-new'),
            curVal = $(this).data('value'); //Close the selector

        $selectCurWrapper.removeClass('is-opened'); //Set the selector text

        $selectCurWrapper.find(settings.trigger).text($(this).html()).addClass('is-active'); //Activate this option

        $selectCurWrapper.find(settings.item).removeClass('is-active');
        $(this).addClass('is-active'); //Set select option 'selected', by value

        $selectWrapper.find('select').val(curVal);
        $selectWrapper.find('select option').removeAttr('selected');
        $selectWrapper.find('select option[value="' + curVal + '"]').attr('selected', 'selected').change();
      }); //Synchronize to the original select change event

      $(settings.selector).not('.js-uix-new').each(function () {
        var $this = $(this).find('select'),
            $cusSelect = $this.closest(settings.targetWrapper).find(settings.selector + '.js-uix-new');
        var newOptions = '';
        $this.closest(settings.targetWrapper).find('select option').each(function (index) {
          var selected = '';

          if ($(this).is(':selected')) {
            selected = 'is-active';
          }

          newOptions += '<span role="option" class="uix-controls__select__option ' + selected + '" data-value="' + $(this).attr('value') + '">' + $(this).html() + '</span>';
        });
        $cusSelect.find(settings.itemsWrapper).html('<div>' + newOptions + '</div>'); //Set the default selector text

        $cusSelect.each(function (index) {
          $(this).find(settings.trigger).text($(this).find(settings.item + '.is-active').html());
        });
      });
    });
  };
})(jQuery);
;// CONCATENATED MODULE: ./src/components/form/js/fn/tag-input.js


/*
 * Render Tag Input
 *
 * @param  {String} controls                 - Wrapper of controls.
 * @return {Void}
 */
(function ($) {
  'use strict';

  $.fn.UixRenderTagInput = function (options) {
    // This is the easiest way to have default options.
    var settings = $.extend({
      controls: '.uix-controls__tags-wrapper'
    }, options);
    this.each(function () {
      $(settings.controls).each(function () {
        var $this = $(this);
        var actived = $this.data('activated');

        if ((0,esm_typeof/* default */.Z)(actived) === ( true ? "undefined" : 0)) {
          // Initialize status
          //------------------------------------------
          var taginputTip = $this.data('placeholder');
          var $tagInputUserArea = $("<div><ul class=\"uix-controls__tags__list\"></ul><div class=\"uix-controls__tags\"><input type=\"text\" autoComplete=\"off\" placeholder=\"".concat(taginputTip, "\" value=\"\"></div></div>")); //init tag input

          $this.append($tagInputUserArea); //

          var lastId = -1;
          var defaultTagsVal = [];
          var maxTags = (0,esm_typeof/* default */.Z)($this.data('max-tags')) != ( true ? "undefined" : 0) ? $this.data('max-tags') : 10;
          var dVal = $this.find('> input').attr('type', 'hidden').val(); //get default value

          if (dVal) {
            dVal.trim().replace(/^\,|\,$/g, '').split(',').forEach(function (item, index) {
              defaultTagsVal.push({
                content: item,
                id: index
              });
            });
          } //
          // What the user has entered


          var defaultItems = dVal !== '' && dVal !== null ? defaultTagsVal : []; //init data

          $this.data({
            'data': defaultItems,
            'user-input': '',
            'already-in-items': false,
            'max': maxTags
          });

          var updateTagResult = function updateTagResult(el, data) {
            var tagList = '';
            var resArr = [];
            data.forEach(function (listitem, index) {
              resArr.push(listitem.content);
              tagList += "<li data-item=\"".concat(listitem.id, "\">").concat(listitem.content, "</li>");
            }); //update value

            el.find('> input').val(resArr.join(',')); //create list

            el.find('.uix-controls__tags__list').html(tagList);
          };

          updateTagResult($this, defaultItems); // Mouse events
          //------------------------------------------

          $(document).off('click.FORM_TAG_INPUT_DELETE').on('click.FORM_TAG_INPUT_DELETE', settings.controls + ' .uix-controls__tags__list > li', function (e) {
            var $obj = $(this).closest(settings.controls);
            var currentItems = $obj.data('data');
            var idToRemove = Number(e.target.dataset["item"]);
            var newArray = currentItems.filter(function (listitem) {
              return listitem.id !== idToRemove;
            });
            currentItems = newArray; //update data

            $obj.data({
              'data': currentItems
            }); //

            updateTagResult($obj, currentItems);
          });
          $(document).on('change input', settings.controls + ' .uix-controls__tags input', function (e) {
            var $obj = $(this).closest(settings.controls);
            var currentItems = $obj.data('data');
            var _userInput = e.currentTarget.value;
            var _alreadyInItems = false;

            if (currentItems && currentItems.length > 0) {
              var alreadyIn = currentItems.some(function (obj) {
                return obj.content.toLowerCase() == _userInput.toLowerCase();
              });

              if (alreadyIn) {
                _alreadyInItems = true;
              } else {
                _alreadyInItems = false;
              }
            } //update data


            $obj.data({
              'user-input': e.currentTarget.value,
              'already-in-items': _alreadyInItems
            });
          });
          $(document).on('keypress', settings.controls + ' .uix-controls__tags input', function (e) {
            var $obj = $(this).closest(settings.controls);
            var currentItems = $obj.data('data');
            var userInput = $obj.data('user-input');
            var alreadyInItems = $obj.data('already-in-items');

            if (e.which == 13) {
              e.preventDefault();
              if (alreadyInItems) return false; //

              var newArray = currentItems;
              var currentcontent = userInput.trim();

              if (!currentcontent) {
                return;
              } //Limit the total number of tags added


              if ($obj.data('max') - 1 < newArray.length) {
                return;
              }

              newArray.push({
                content: currentcontent,
                id: ++lastId
              });
              currentItems = newArray; //update data

              $obj.data({
                'data': currentItems,
                'user-input': ''
              }); //

              $(this).val('');
              updateTagResult($obj, currentItems);
            }
          });
          $(document).on('focus', settings.controls + ' .uix-controls__tags input', function (e) {
            var $obj = $(this).closest(settings.controls);
            $obj.addClass('is-active');
          });
          $(document).on('blur', settings.controls + ' .uix-controls__tags input', function (e) {
            var $obj = $(this).closest(settings.controls);
            $obj.removeClass('is-active');
          }); //------------------------------------------
          //Prevents front-end javascripts that are activated in the background to repeat loading.

          $this.data('activated', 1);
        } //endif actived			

      });
    });
  };
})(jQuery);
;// CONCATENATED MODULE: ./src/components/form/js/fn/number-input.js


/*
 * Render Number Input
 *
 * @param  {String} controls                 - Wrapper of controls.
 * @return {Void}
 */
(function ($) {
  'use strict';

  $.fn.UixRenderNumberInput = function (options) {
    // This is the easiest way to have default options.
    var settings = $.extend({
      controls: '.uix-controls__number'
    }, options);
    this.each(function () {
      $(settings.controls).each(function () {
        var $this = $(this);
        var actived = $this.data('activated');

        if ((0,esm_typeof/* default */.Z)(actived) === ( true ? "undefined" : 0)) {
          // Mouse events
          //------------------------------------------
          $(document).off('click.FORM_NUMBER_BTN_ADD').on('click.FORM_NUMBER_BTN_ADD', settings.controls + ' .uix-controls__number__btn--add', function (e) {
            var step = parseFloat($(this).data('step')),
                decimals = $(this).data('decimals'),
                $numberInput = $(this).closest('.uix-controls__number').find('input[type="number"]'),
                numberInputVal = parseFloat($numberInput.val()),
                max = $numberInput.attr('max');
            if ((0,esm_typeof/* default */.Z)(step) === ( true ? "undefined" : 0) || isNaN(step)) step = 1;
            if ((0,esm_typeof/* default */.Z)(decimals) === ( true ? "undefined" : 0)) decimals = 0;

            if ((0,esm_typeof/* default */.Z)(max) != ( true ? "undefined" : 0) && parseFloat(numberInputVal + step) > max) {
              step = 0;
            }

            numberInputVal = parseFloat(numberInputVal + step);
            $numberInput.val(numberInputVal.toFixed(decimals));
          });
          $(document).off('click.FORM_NUMBER_BTN_REMOVE').on('click.FORM_NUMBER_BTN_REMOVE', settings.controls + ' .uix-controls__number__btn--remove', function (e) {
            var step = $(this).data('step'),
                decimals = $(this).data('decimals'),
                $numberInput = $(this).closest('.uix-controls__number').find('input[type="number"]'),
                numberInputVal = parseFloat($numberInput.val()),
                min = $numberInput.attr('min');
            if ((0,esm_typeof/* default */.Z)(step) === ( true ? "undefined" : 0) || isNaN(step)) step = 1;
            if ((0,esm_typeof/* default */.Z)(decimals) === ( true ? "undefined" : 0)) decimals = 0;

            if ((0,esm_typeof/* default */.Z)(min) != ( true ? "undefined" : 0) && parseFloat(numberInputVal - step) < min) {
              step = 0;
            }

            numberInputVal -= step;
            $numberInput.val(numberInputVal.toFixed(decimals));
          }); //------------------------------------------
          //Prevents front-end javascripts that are activated in the background to repeat loading.

          $this.data('activated', 1);
        } //endif actived			

      });
    });
  };
})(jQuery);
;// CONCATENATED MODULE: ./src/components/form/js/fn/dynamic-fields.js















/*
 * Render Dynamic Fields
 *
 * @param  {String} controls                 - Wrapper of controls.
 * @return {Void}
 */

(function ($) {
  'use strict';

  $.fn.UixRenderDynamicFields = function (options) {
    // This is the easiest way to have default options.
    var settings = $.extend({
      controls: '.uix-controls__dynamic-fields-container'
    }, options);
    this.each(function () {
      $(settings.controls).each(function () {
        var $this = $(this);
        var actived = $this.data('activated');

        if ((0,esm_typeof/* default */.Z)(actived) === ( true ? "undefined" : 0)) {
          // Mouse events
          //------------------------------------------
          var $addButton = $this.find('.uix-controls__dynamic-fields__addbtn'),
              //The add button
          $appendWrapper = $this.find('.uix-controls__dynamic-fields__append'),
              //The field wrapper ID or class 
          loopCls = '.uix-controls__dynamic-fields__tmpl__wrapper',
              defaultItems = $appendWrapper.find(loopCls).length;
          var x = defaultItems == 0 ? 1 : defaultItems + 1,
              maxField = $this.data('max-fields'),
              fieldHTML = ''; //Maximum number of forms added

          if ((0,esm_typeof/* default */.Z)(maxField) === ( true ? "undefined" : 0)) {
            maxField = 5;
          } //Add a field


          var addOne = function addOne(fieldCode) {
            //replace the index of field name
            fieldCode = fieldCode.replace(/___GUID___/gi, UixGUID.create()); //hide add button

            if (x == maxField) $addButton.hide();

            if (x <= maxField) {
              $appendWrapper.append(fieldCode); //Initialize Form

              $(document).UixRenderCustomSelect(); //Render Custom Select

              $(document).UixRenderCustomRadioCheckbox(); //Render Custom Radio, Toggle And Checkbox

              $(document).UixRenderControlsLineEff(); //Create Line Effect on Click

              $(document).UixRenderControlsDisable(); //Disabled Controls

              $(document).UixRenderCustomFile(); //Render Custom File Type

              $(document).UixRenderCustomFileDropzone(); //Render Custom File Dropzone

              $(document).UixRenderControlsHover(); //Hover Effect

              $(document).UixRenderCustomMultiSel(); //Render Multiple Selector

              $(document).UixRenderCustomSingleSel(); //Render Single Selector

              $(document).UixRenderNormalRadio(); //Render Normal Radio

              $(document).UixRenderDatePicker(); //Render Date Picker	

              $(document).UixRenderTagInput(); //Render Tag Input

              $(document).UixRenderNumberInput(); //Render Number Input

              x++;
            }
          }; // default item


          if (defaultItems == 0) {
            addOne($this.find('.uix-controls__dynamic-fields__tmpl').html());
          } //Prevent duplicate function assigned


          $addButton.off('click').off('click').on('click', function (e) {
            e.preventDefault(); //template init

            addOne($this.find('.uix-controls__dynamic-fields__tmpl').html()); //Remove per item
            //Prevent duplicate function assigned

            $this.find('.uix-controls__dynamic-fields__removebtn').off('click').on('click', function (e) {
              e.preventDefault(); //display add button

              $addButton.show(); //remove current item

              $(this).closest(loopCls).remove();
              x--;
            });
            return false;
          }); //------------------------------------------
          //Prevents front-end javascripts that are activated in the background to repeat loading.

          $this.data('activated', 1);
        } //endif actived			

      });
    });
  };
})(jQuery);
;// CONCATENATED MODULE: ./src/components/form/js/index.js



/* 
 *************************************
 * <!-- Form -->
 *************************************
 */

/*
    Note:
	
	If you use the "change" event to asynchronously change a custom control of select, radio or checkbox, 
	you need add a callback function that initializes the style:
	
	$( document ).UixRenderXXXXXXXXX();

	
*/



















var FORM = function (module, $, window, document) {
  if (window.FORM === null) return false;
  module.FORM = module.FORM || {};
  module.FORM.version = '0.1.8';

  module.FORM.documentReady = function ($) {
    /*
     * Callbacks for special forms (supports asynchronous)
     * Add this code to initialize the style when calling 
     * the form externally with other scripts
     *
     * @return {Void}
     */
    $(document).UixRenderCustomSelect(); //Render Custom Select

    $(document).UixRenderCustomRadioCheckbox(); //Render Custom Radio, Toggle And Checkbox

    $(document).UixRenderControlsLineEff(); //Create Line Effect on Click

    $(document).UixRenderControlsDisable(); //Disabled Controls

    $(document).UixRenderCustomFile(); //Render Custom File Type

    $(document).UixRenderCustomFileDropzone(); //Render Custom File Dropzone

    $(document).UixRenderControlsHover(); //Hover Effect

    $(document).UixRenderCustomMultiSel(); //Render Multiple Selector

    $(document).UixRenderCustomSingleSel(); //Render Single Selector

    $(document).UixRenderNormalRadio(); //Render Normal Radio

    $(document).UixRenderDatePicker(); //Render Date Picker	

    $(document).UixRenderTagInput(); //Render Tag Input

    $(document).UixRenderDynamicFields(); //Render Dynamic Fields

    $(document).UixRenderNumberInput(); //Render Number Input

    /* 
     ---------------------------
     Click Event of Submit Button
     ---------------------------
     */
    //Search Submit Event in WordPress

    $('.uix-search-box__submit').off('click').on('click', function () {
      $(this).closest('form').submit();
    });
  };

  module.components.documentReady.push(module.FORM.documentReady);
  return /*#__PURE__*/_createClass(function FORM() {
    _classCallCheck(this, FORM);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
// EXTERNAL MODULE: ./src/components/gallery/js/third-party/muuri.js
var muuri = __webpack_require__(996);
;// CONCATENATED MODULE: ./src/components/gallery/js/index.js



/* 
 *************************************
 * <!-- Gallery -->
 *************************************
 */



var GALLERY = function (module, $, window, document) {
  if (window.GALLERY === null) return false;
  module.GALLERY = module.GALLERY || {};
  module.GALLERY.version = '0.0.5';

  module.GALLERY.documentReady = function ($) {
    $('.uix-gallery').each(function () {
      var galleryType = $(this).data('show-type');
      /* 
       ---------------------------
       Add a tagname to each list item
       ---------------------------
       */
      // Masonry

      if (galleryType.indexOf('masonry') >= 0) {
        $(this).addClass('masonry-container');
        $(this).find('.uix-gallery__item').addClass('masonry-item');
      } // Filterable


      if (galleryType.indexOf('filter') >= 0) {
        $(this).addClass('filter-container');
        $(this).find('.uix-gallery__item').addClass('filter-item');
      }

      if (galleryType.indexOf('filter') >= 0 || galleryType.indexOf('masonry') >= 0) {
        var filterCat = $(this).data('filter-id'),
            $grid = $(this).find('.uix-gallery__tiles'),
            $allItems = $(this).find('.uix-gallery__item'),
            $filterOptions = $(filterCat);
        var MuuriGrid = new Muuri($grid.get(0), {
          items: $grid.get(0).querySelectorAll('.uix-gallery__item'),
          // Default show animation
          showDuration: 300,
          showEasing: 'ease',
          // Default hide animation
          hideDuration: 300,
          hideEasing: 'ease',
          // Item's visible/hidden state styles
          visibleStyles: {
            opacity: '1',
            transform: 'scale(1)'
          },
          hiddenStyles: {
            opacity: '0',
            transform: 'scale(0.5)'
          },
          // Layout
          layout: {
            fillGaps: false,
            horizontal: false,
            alignRight: false,
            alignBottom: false,
            rounding: true
          },
          layoutOnResize: 100,
          layoutOnInit: true,
          layoutDuration: 300,
          layoutEasing: 'ease',
          //// Drag & Drop
          dragEnabled: false
        }); // When all items have loaded refresh their
        // dimensions and layout the grid.

        $grid.waitForImages().done(function () {
          MuuriGrid.refreshItems().layout(); // For a little finishing touch, let's fade in
          // the images after all them have loaded and
          // they are corrertly positioned.

          $('body').addClass('images-loaded');
        });
        /* 
         ---------------------------
         Function of Filterable and Masonry
         ---------------------------
         */

        if (galleryType.indexOf('filter') >= 0) {
          $filterOptions.find('li > a').off('click').on('click', function () {
            var $this = $(this);
            var activeClass = 'current-cat',
                isActive = $this.parent().hasClass(activeClass),
                group = isActive ? 'all' : $this.data('group'); // Hide current label, show current label in title

            if (!isActive) {
              $filterOptions.find('.' + activeClass).removeClass(activeClass);
            }

            $this.parent().toggleClass(activeClass); // Filter elements

            var filterFieldValue = group;
            MuuriGrid.filter(function (item) {
              var element = item.getElement(),
                  curCats = element.getAttribute('data-groups').toString().replace(/^\,|\,$/g, '').replace(/^\[|\]$/g, '') + ',all',
                  isFilterMatch = !filterFieldValue ? true : (curCats || '').indexOf(filterFieldValue) > -1;
              return isFilterMatch;
            });
            return false;
          });
        } else {
          //remove filter button of all
          $filterOptions.find('[data-group="all"]').parent('li').remove();
        }
      }
    });
  };

  module.components.documentReady.push(module.GALLERY.documentReady);
  return /*#__PURE__*/_createClass(function GALLERY() {
    _classCallCheck(this, GALLERY);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/hybrid-content-slider/js/index.js




/* 
 *************************************
 * <!-- Hybrid Content Slider -->
 *************************************
 */


var HYBRID_CONTENT_SLIDER = function (module, $, window, document) {
  if (window.HYBRID_CONTENT_SLIDER === null) return false;
  module.HYBRID_CONTENT_SLIDER = module.HYBRID_CONTENT_SLIDER || {};
  module.HYBRID_CONTENT_SLIDER.version = '0.1.1';

  module.HYBRID_CONTENT_SLIDER.pageLoaded = function () {
    $('.uix-hybrid-content-slider').each(function () {
      var $sliderWrapper = $(this),
          $slider = $sliderWrapper.find('.uix-hybrid-content-slider__items'),
          $sliderItem = $sliderWrapper.find('.uix-hybrid-content-slider__items > div'),
          itemsTotal = $sliderItem.length,
          amountVisible = 1,
          sliderDir = $sliderWrapper.data('dir'),
          sliderSpeed = $sliderWrapper.data('speed'),
          sliderNext = $sliderWrapper.data('next'),
          sliderPrev = $sliderWrapper.data('prev'),
          sliderPagination = $sliderWrapper.data('pagination'),
          carouseDraggable = $sliderWrapper.data('draggable'),
          carouseDraggableCursor = $sliderWrapper.data('draggable-cursor');
      if ((0,esm_typeof/* default */.Z)(sliderDir) === ( true ? "undefined" : 0)) sliderDir = 'horizontal';
      if ((0,esm_typeof/* default */.Z)(sliderSpeed) === ( true ? "undefined" : 0)) sliderSpeed = 250;
      if ((0,esm_typeof/* default */.Z)(sliderNext) === ( true ? "undefined" : 0)) sliderNext = '#uix-hybrid-content-slider__controls-123 .uix-hybrid-content-slider__controls--next';
      if ((0,esm_typeof/* default */.Z)(sliderPrev) === ( true ? "undefined" : 0)) sliderPrev = '#uix-hybrid-content-slider__controls-123 .uix-hybrid-content-slider__controls--prev';
      if ((0,esm_typeof/* default */.Z)(sliderPagination) === ( true ? "undefined" : 0)) sliderPagination = '#uix-hybrid-content-slider__pagination-123';
      if ((0,esm_typeof/* default */.Z)(carouseDraggable) === ( true ? "undefined" : 0)) carouseDraggable = false;
      if ((0,esm_typeof/* default */.Z)(carouseDraggableCursor) === ( true ? "undefined" : 0)) carouseDraggableCursor = 'move'; //Autoplay parameters

      var dataAuto = $sliderWrapper.data('auto'),
          dataTiming = $sliderWrapper.data('timing'),
          dataLoop = $sliderWrapper.data('loop');
      if ((0,esm_typeof/* default */.Z)(dataAuto) === ( true ? "undefined" : 0)) dataAuto = false;
      if ((0,esm_typeof/* default */.Z)(dataTiming) === ( true ? "undefined" : 0)) dataTiming = 10000;
      if ((0,esm_typeof/* default */.Z)(dataLoop) === ( true ? "undefined" : 0)) dataLoop = false; //Autoplay times

      var playTimes; //A function called "timer" once every second (like a digital watch).

      $sliderWrapper[0].animatedSlides; //Store the latest position (X,Y) in a temporary variable

      var tempItemsPos = []; //each item width and height

      var eachItemNewWidth,
          eachItemNewHeight = []; // Returns the value of a number rounded to the nearest integer.

      var midIndex = 0; // Get the width and height of each item

      $sliderItem.each(function (index) {
        var _height = $(this).height();

        eachItemNewHeight.push(_height);
        $(this).attr({
          'data-height': _height,
          'data-index': index
        });
      }); //Returns the total height of items

      var totalItemsHeight = 0;

      for (var i = 0; i < eachItemNewHeight.length; i++) {
        totalItemsHeight += eachItemNewHeight[i];
        if (i + 1 == itemsTotal - amountVisible) break;
      } //Set target index of the slider buttons


      setButtonTargetIndex($(sliderNext), $(sliderPrev), 'init', null); //set actived item & initialize the height of container

      setContainerSize(0);
      $sliderItem.addClass('js-is-ready'); // Activate the current item from carouse

      setItemState(0);
      /* 
       ---------------------------
       Initialize slider
       ---------------------------
       */

      var eachItemOldWidth = $slider.width() / amountVisible;
      eachItemNewWidth = $sliderWrapper.width() / amountVisible;

      if (sliderDir === 'horizontal') {
        $slider.css('width', itemsTotal * eachItemOldWidth);
      } // Re-order all items


      sliderReOrder(); //default button status

      $(sliderPrev).addClass('is-disabled').data('disabled', 1);
      /* 
       ---------------------------
       Re-order all items
       ---------------------------
       */

      function sliderReOrder() {
        //Initialize the width and height of each item
        if (sliderDir === 'horizontal') {
          var boxWidth = eachItemNewWidth;
          TweenMax.set($sliderItem, {
            width: boxWidth,
            height: function height(i, target) {
              return eachItemNewHeight[i];
            },
            x: function x(i, target) {
              return i * boxWidth;
            }
          });
        } else {
          TweenMax.set($sliderItem, {
            height: function height(i, target) {
              return eachItemNewHeight[i];
            },
            y: function y(i, target) {
              var yIncrement = 0;

              for (var k = 0; k < eachItemNewHeight.length; k++) {
                var tempY = (0,esm_typeof/* default */.Z)(eachItemNewHeight[k - 1]) === ( true ? "undefined" : 0) ? 0 : eachItemNewHeight[k - 1];
                yIncrement += tempY;
                if (k == i) break;
              }

              return yIncrement;
            }
          });
        }
      }
      /* 
       ---------------------------
       Next/Prev buttons
       ---------------------------
       */


      var _prev = $(sliderPrev),
          _next = $(sliderNext);

      _next.off('click').on('click', $sliderWrapper, function (e) {
        e.preventDefault();
        btnNextMove();
      });

      _prev.off('click').on('click', $sliderWrapper, function (e) {
        e.preventDefault();
        btnPrevMove();
      }); // (right/down)


      function btnPrevMove() {
        //Prevent buttons' events from firing multiple times
        if (_prev.attr('aria-disabled') == 'true') return false;

        _prev.attr('aria-disabled', 'true');

        _prev.delay(sliderSpeed).queue(function (next) {
          _prev.attr('aria-disabled', 'false');

          next();
        }); //


        movePositionWithButton(false, _prev, 'prev'); //Pause the auto play event

        clearInterval($sliderWrapper[0].animatedSlides);
      } // (left/up)


      function btnNextMove() {
        //Prevent buttons' events from firing multiple times
        if (_next.attr('aria-disabled') == 'true') return false;

        _next.attr('aria-disabled', 'true');

        _next.delay(sliderSpeed).queue(function (next) {
          _next.attr('aria-disabled', 'false');

          next();
        }); //


        movePositionWithButton(false, _next, 'next'); //Pause the auto play event

        clearInterval($sliderWrapper[0].animatedSlides);
      }
      /* 
       ---------------------------
       Pagination
       ---------------------------
       */


      if ($(sliderPagination).length > 0 && $(sliderPagination).html().length == 0) {
        //Button to add pagination automatically
        var _dot = '';
        _dot += '<ul class="uix-hybrid-content-slider__pagination--default">';

        for (var _i = 0; _i < itemsTotal; _i++) {
          _dot += '<li><a data-target-index="' + _i + '" href="javascript:void(0);"></a></li>';
        }

        _dot += '</ul>';
        $(sliderPagination).html(_dot).promise().done(function () {
          // Activate the currently selected Pagination
          setPaginationState(0);
        });
      } else {
        // Activate the currently selected Pagination
        setPaginationState(0);
      }

      $(sliderPagination).find('li a').off('click').on('click', $sliderWrapper, function (e) {
        e.preventDefault(); //Prevent buttons' events from firing multiple times

        if ($(this).attr('aria-disabled') == 'true') return false;
        $(sliderPagination).find('li a').attr('aria-disabled', 'true');
        $(sliderPagination).find('li a').delay(sliderSpeed).queue(function (next) {
          $(sliderPagination).find('li a').attr('aria-disabled', 'false');
          next();
        }); //

        if (!$(this).parent().hasClass('is-active')) {
          movePositionWithButton(true, $(this), 'next'); //Pause the auto play event

          clearInterval($sliderWrapper[0].animatedSlides);
        }
      }); //Drag and Drop
      //-------------------------------------	

      var $dragDropTrigger = $sliderWrapper;
      var hammerProps = {}; //Make the cursor a move icon when a user hovers over an item

      if (carouseDraggable && carouseDraggableCursor != '' && carouseDraggableCursor != false) $dragDropTrigger.css('cursor', carouseDraggableCursor);

      if (!carouseDraggable) {
        hammerProps = {
          inputClass: Hammer.TouchInput
        };
      } //Mouse event
      //Hammer.js pan event only for touch devices and not for desktop computer Click+Drag


      var direction;
      var dragDropElement = $dragDropTrigger[0],
          dragDropMC = new Hammer(dragDropElement, hammerProps);
      var elAnim = true;
      var targetIndex = 0; //Temporarily store arrays as strings
      //!!!important ///////////////////////////////////////
      //!!! Prevent dragging events from nesting multiple 
      //!!! times to reduce subscripts.
      //!!!important ///////////////////////////////////////

      var allHeightStr = eachItemNewHeight.toString(); // let the pan gesture support all directions.
      // this will block the vertical scrolling on a touch-device while on the element

      dragDropMC.get('pan').set({
        direction: Hammer.DIRECTION_ALL
      });
      dragDropMC.on('press panright panleft panup pandown', function (ev) {
        //Set the direction in here
        direction = ev.type; //Get the current item index

        targetIndex = $(ev.target).data('index');
        if ((0,esm_typeof/* default */.Z)(targetIndex) === ( true ? "undefined" : 0)) targetIndex = $(ev.target).closest('.uix-hybrid-content-slider__item').data('index');
        if ((0,esm_typeof/* default */.Z)(targetIndex) === ( true ? "undefined" : 0)) targetIndex = $(ev.target).find('.uix-hybrid-content-slider__item').data('index');

        switch (direction) {
          case 'panleft':
          case 'panup':
            targetIndex = targetIndex + 1;
            break;

          case 'panright':
          case 'pandown':
            targetIndex = targetIndex;
            break;
        } //Determine whether it is the first or the last    


        var currentIsFirstOrLast = false;
        var firstItemOffset = sliderDir === 'horizontal' ? $slider.find('[data-index="0"]')[0]._gsTransform.x : $slider.find('[data-index="0"]')[0]._gsTransform.y;
        var maxMoveOffset = sliderDir === 'horizontal' ? -eachItemNewWidth * (itemsTotal - amountVisible) : -totalItemsHeight; //

        if ((direction == 'panright' || direction == 'pandown') && firstItemOffset >= 0) {
          //first item
          currentIsFirstOrLast = true;
        }

        if ((direction == 'panleft' || direction == 'panup') && firstItemOffset <= maxMoveOffset) {
          //last item
          currentIsFirstOrLast = true;
        } //Rebound effect of drag offset 
        //
        //!important -> Please do not use multiple case conditions, 
        //otherwise it may cause vertical data problems


        if (sliderDir === 'horizontal') {
          switch (direction) {
            case 'panleft':
              if (ev.deltaX > -eachItemNewWidth / 4 && ev.deltaX < 0) {
                elAnim = false;
                var simulationButtonNext = $(sliderNext);
                itemUpdates($sliderWrapper, simulationButtonNext, ev.deltaX, 0.1, true, targetIndex, allHeightStr);
              } else {
                elAnim = currentIsFirstOrLast ? false : true;
              }

              break;

            case 'panright':
              if (ev.deltaX < eachItemNewWidth / 4 && ev.deltaX > 0) {
                elAnim = false;
                var simulationButtonPrev = $(sliderPrev);
                itemUpdates($sliderWrapper, simulationButtonPrev, ev.deltaX, 0.1, true, targetIndex, allHeightStr);
              } else {
                elAnim = currentIsFirstOrLast ? false : true;
              }

              break;
          }
        } else {
          var draggingItemHeight = (0,esm_typeof/* default */.Z)(allHeightStr.split(',')[targetIndex - 1]) === ( true ? "undefined" : 0) ? allHeightStr.split(',')[targetIndex] : allHeightStr.split(',')[targetIndex - 1];

          switch (direction) {
            case 'panup':
              if (ev.deltaY > -draggingItemHeight / 4 && ev.deltaY < 0) {
                elAnim = false;

                var _simulationButtonNext = $(sliderNext);

                itemUpdates($sliderWrapper, _simulationButtonNext, ev.deltaY, 0.1, true, targetIndex, allHeightStr);
              } else {
                elAnim = currentIsFirstOrLast ? false : true;
              }

              break;

            case 'pandown':
              if (ev.deltaY < draggingItemHeight / 4 && ev.deltaY > 0) {
                elAnim = false;

                var _simulationButtonPrev = $(sliderPrev);

                itemUpdates($sliderWrapper, _simulationButtonPrev, ev.deltaY, 0.1, true, targetIndex, allHeightStr);
              } else {
                elAnim = currentIsFirstOrLast ? false : true;
              }

              break;
          }
        }
      });
      dragDropMC.on('panend', function (ev) {
        if (elAnim) {
          //Use the direction in here
          //You know the pan has ended
          //and you know which action they were taking
          //
          //!important -> Please do not use multiple case conditions, 
          //otherwise it may cause vertical data problems
          if (sliderDir === 'horizontal') {
            switch (direction) {
              case 'panleft':
                btnNextMove();
                break;

              case 'panright':
                btnPrevMove();
                break;
            }
          } else {
            switch (direction) {
              case 'panup':
                btnNextMove();
                break;

              case 'pandown':
                btnPrevMove();
                break;
            }
          }
        } else {
          //Rebound effect of drag offset 
          itemUpdates($sliderWrapper, false, tempItemsPos, null, false, targetIndex, allHeightStr);
        } //Pause the auto play event


        clearInterval($sliderWrapper[0].animatedSlides);
      }); //Autoplay Slider
      //-------------------------------------		

      if (dataAuto && !isNaN(parseFloat(dataTiming)) && isFinite(dataTiming)) {
        sliderAutoPlay(playTimes, dataTiming, dataLoop);

        var autoplayEnter = function autoplayEnter() {
          clearInterval($sliderWrapper[0].animatedSlides);
        };

        var autoplayLeave = function autoplayLeave() {
          sliderAutoPlay(playTimes, dataTiming, dataLoop);
        }; // Do not use the `off()` method, otherwise it will cause the second mouseenter to be invalid


        $sliderWrapper.on('mouseenter', autoplayEnter);
        $sliderWrapper.on('mouseleave', autoplayLeave); // To determine if it is a touch screen.

        if (Modernizr.touchevents) {
          $sliderWrapper.on('pointerenter', autoplayEnter);
          $sliderWrapper.on('pointerleave', autoplayLeave);
        }
      }
      /*
       * Trigger slider autoplay
       *
       * @param  {Function} playTimes      - Number of times.
       * @param  {Number} timing           - Autoplay interval.
       * @param  {Boolean} loop            - Gives the slider a seamless infinite loop.
       * @return {Void}             
       */


      function sliderAutoPlay(playTimes, timing, loop) {
        $sliderWrapper[0].animatedSlides = setInterval(function () {
          var autoMove = function autoMove(indexGo) {
            // Retrieve the position (X,Y) of an element 
            var moveX = eachItemNewWidth * indexGo;
            var moveYIncrement = 0;

            for (var k = 0; k < eachItemNewHeight.length; k++) {
              var tempY = (0,esm_typeof/* default */.Z)(eachItemNewHeight[k - 1]) === ( true ? "undefined" : 0) ? 0 : eachItemNewHeight[k - 1];
              moveYIncrement += tempY;
              if (k == indexGo) break;
            }

            var moveY = moveYIncrement; //

            var delta = sliderDir === 'horizontal' ? -moveX : -moveY; //

            itemUpdates($sliderWrapper, 'auto', delta, null, false, indexGo, eachItemNewHeight);
          };

          playTimes = parseFloat($sliderItem.filter('.is-active').index());
          playTimes++;

          if (!loop) {
            if (playTimes < itemsTotal && playTimes >= 0) {
              autoMove(playTimes);
            }
          } else {
            if (playTimes == itemsTotal) playTimes = 0;
            if (playTimes < 0) playTimes = itemsTotal - 1;
            autoMove(playTimes);
          }
        }, timing);
      }
      /*
       * Transition Between Items
       *
       * @param  {Element} wrapper                  - Wrapper of slider.
       * @param  {?Element|String|Boolean} curBtn   - The button that currently triggers the move.
                * @param  {Number|Array} delta               - The value returned will need to be adjusted according 
                *                                              to the offset  * rate.
                * @param  {?Number} speed                     - Sliding speed. Please set to 0 when rebounding.
                * @param  {Boolean} dragging                  - Determine if the object is being dragged.
                * @param  {!Number} indexGo                   - The target item index.
                * @param  {String|Array} itemsHeight          - Return all items height (the string type is 
                *                                               used when a drag event is triggered).
       * @return {Void}
       */


      function itemUpdates(wrapper, curBtn, delta, speed, dragging, indexGo, itemsHeight) {
        if (speed == null) speed = sliderSpeed / 1000;
        var $curWrapper = wrapper.children('.uix-hybrid-content-slider__items'),
            //Default: $slider
        $curItems = $curWrapper.find('> div'); //Default: $sliderItem
        //Get height constant

        var itemsHeightArr = [];

        var _itemsHeight = itemsHeight.toString().split(',');

        _itemsHeight.forEach(function (element) {
          itemsHeightArr.push(parseFloat(element));
        }); //Check next or previous event


        var btnType = 'init';

        if (curBtn !== false && curBtn !== 'auto') {
          if ((0,esm_typeof/* default */.Z)(curBtn.attr('class')) !== ( true ? "undefined" : 0)) {
            btnType = curBtn.attr('class').indexOf('--next') >= 0 ? 'next' : 'prev';
          } else {
            btnType = 'next';
          }
        } //Check next or previous event ( Autoplay )


        if (curBtn === 'auto') btnType = 'next';
        ; //Clone the first element to the last position

        if (sliderDir === 'horizontal') {
          var boxWidth = eachItemNewWidth;
          TweenMax.to($curItems, speed, {
            x: function x(i, target) {
              var xIncrement = 0;

              for (var k = 0; k < itemsTotal; k++) {
                var tempX = k == 0 ? 0 : boxWidth;
                xIncrement += tempX;
                if (k == i) break;
              }

              if (Array.isArray(delta)) {
                //Rebound effect of drag offset 
                return delta.length == 0 ? xIncrement : delta[i];
              } else {
                if (!dragging) {
                  //console.log( 'btnType: ' + btnType + ' indexGo: ' + indexGo );
                  var curWidthIncrement = 0;

                  for (var m = 0; m < itemsTotal; m++) {
                    var tempW = m == 0 ? 0 : boxWidth;
                    curWidthIncrement += tempW;
                    if (m == (btnType == 'next' ? indexGo : indexGo - 1)) break;
                  }

                  return xIncrement + -curWidthIncrement;
                } else {
                  //console.log( 'dragging...' );
                  var x = Math.round(target._gsTransform.x / boxWidth) * boxWidth;
                  return x + delta;
                }
              }
            },
            onComplete: function onComplete() {
              if (!dragging && !Array.isArray(delta)) {
                //Get index of current element
                var currentIndex = 0; //The state of the control button

                setButtonState(Math.round($curItems.first()[0]._gsTransform.x), Math.round(($curItems.length - amountVisible) * boxWidth)); //Initialize the height of container

                currentIndex = Math.round($curItems.first()[0]._gsTransform.x / boxWidth);
                setContainerSize(currentIndex); //Set target index of the slider buttons

                setButtonTargetIndex($(sliderNext), $(sliderPrev), btnType, btnType == 'next' ? Math.abs(currentIndex) : Math.abs(currentIndex) + 1); // Activate the currently selected Pagination

                setPaginationState(Math.abs(currentIndex)); // Activate the current item from carouse

                setItemState(Math.abs(currentIndex)); //Store the latest position (X,Y) in a temporary variable

                tempItemsPos = createStoreLatestPosition();
              }
            }
          });
        } else {
          TweenMax.to($curItems, speed, {
            y: function y(i, target) {
              var yIncrement = 0;

              for (var k = 0; k < itemsHeightArr.length; k++) {
                var tempY = (0,esm_typeof/* default */.Z)(itemsHeightArr[k - 1]) === ( true ? "undefined" : 0) ? 0 : itemsHeightArr[k - 1];
                yIncrement += tempY;
                if (k == i) break;
              }

              if (Array.isArray(delta)) {
                //Rebound effect of drag offset 
                return delta.length == 0 ? yIncrement : delta[i];
              } else {
                if (!dragging) {
                  //console.log( 'btnType: ' + btnType + ' indexGo: ' + indexGo );
                  var curHeightIncrement = 0;

                  for (var m = 0; m < itemsHeightArr.length; m++) {
                    var tempH = (0,esm_typeof/* default */.Z)(itemsHeightArr[m - 1]) === ( true ? "undefined" : 0) ? 0 : itemsHeightArr[m - 1];
                    curHeightIncrement += tempH;
                    if (m == (btnType == 'next' ? indexGo : indexGo - 1)) break;
                  }

                  return yIncrement + -curHeightIncrement;
                } else {
                  //console.log( 'dragging...' );
                  var draggingItemHeight = (0,esm_typeof/* default */.Z)(itemsHeightArr[indexGo - 1]) === ( true ? "undefined" : 0) ? itemsHeightArr[indexGo] : itemsHeightArr[indexGo - 1];
                  var y = Math.round(target._gsTransform.y / draggingItemHeight) * draggingItemHeight;
                  return y + delta;
                }
              }
            },
            onComplete: function onComplete() {
              if (!dragging && !Array.isArray(delta)) {
                //The state of the control button
                setButtonState($curItems.first()[0]._gsTransform.y, totalItemsHeight); //Set target index of the slider buttons

                setButtonTargetIndex($(sliderNext), $(sliderPrev), btnType, indexGo); //set actived item & initialize the height of container

                setContainerSize(btnType == 'next' ? indexGo : indexGo - 1); // Activate the currently selected Pagination

                setPaginationState(btnType == 'next' ? indexGo : indexGo - 1); // Activate the current item from carouse

                setItemState(btnType == 'next' ? indexGo : indexGo - 1); //Store the latest position (X,Y) in a temporary variable

                tempItemsPos = createStoreLatestPosition();
              }
            }
          });
        }
      }
      /*
       * Use the button to trigger the transition between the two sliders
       *
       * @param  {Boolean} paginationEnabled   - Determine whether it is triggered by pagination
       * @param  {Element} $btn               - The button that currently triggers the move.
                * @param  {String} type                - Move next or previous.
       * @return {Void}
       */


      function movePositionWithButton(paginationEnabled, $btn, type) {
        var //Protection button is not triggered multiple times.
        btnDisabled = $btn.data('disabled'),
            //Get current button index
        tIndex = parseFloat($btn.attr('data-target-index')); // Retrieve the position (X,Y) of an element 

        var moveX = eachItemNewWidth,
            moveY = (0,esm_typeof/* default */.Z)(eachItemNewHeight[tIndex - 1]) === ( true ? "undefined" : 0) ? 0 : eachItemNewHeight[tIndex - 1];

        if (paginationEnabled) {
          //--
          moveX = eachItemNewWidth * tIndex; //--

          var moveYIncrement = 0;

          for (var k = 0; k < eachItemNewHeight.length; k++) {
            var tempY = (0,esm_typeof/* default */.Z)(eachItemNewHeight[k - 1]) === ( true ? "undefined" : 0) ? 0 : eachItemNewHeight[k - 1];
            moveYIncrement += tempY;
            if (k == tIndex) break;
          }

          moveY = moveYIncrement;
        } //


        var delta;

        if (type == 'next') {
          delta = sliderDir === 'horizontal' ? -moveX : -moveY;
        } else {
          delta = sliderDir === 'horizontal' ? moveX : moveY;
        }

        if ((0,esm_typeof/* default */.Z)(btnDisabled) === ( true ? "undefined" : 0)) {
          itemUpdates($sliderWrapper, $btn, delta, null, false, tIndex, eachItemNewHeight);
        }
      }
      /*
       * Activate the currently selected Pagination
       *
                * @param  {Number} index          - Get index of current element.
       * @return {Void}
       */


      function setPaginationState(index) {
        $(sliderPagination).find('li').removeClass('is-active');
        $(sliderPagination).find('li a[data-target-index="' + index + '"]').parent().addClass('is-active');
      }
      /*
       * Activate the current item from carouse
       *
                * @param  {Number} index          - Get index of current element.
       * @return {Void}
       */


      function setItemState(index) {
        $sliderItem.removeClass('is-active');
        $sliderItem.eq(index).addClass('is-active');
      }
      /*
       * Store the latest position (X,Y) in a temporary variable
       *
       * @return {Array}              - Return to a new position.
       */


      function createStoreLatestPosition() {
        var pos = []; // Retrieve the temporary variable of each item.

        $sliderItem.each(function () {
          pos.push(sliderDir === 'horizontal' ? $(this)[0]._gsTransform.x : $(this)[0]._gsTransform.y);
        });
        return pos;
      }
      /*
       * Initialize the height of container
       *
                * @param  {Number} index          - Get index of current element.
       * @return {Void}
       */


      function setContainerSize(index) {
        var _h = eachItemNewHeight[Math.abs(index)];

        if ((0,esm_typeof/* default */.Z)(_h) !== ( true ? "undefined" : 0)) {
          TweenMax.to($slider, 0.2, {
            height: eachItemNewHeight[Math.abs(index)]
          });
        }
      }
      /*
       * Set target index of the slider buttons
       *
       * @param  {Element} nextBtn      - The next move button.
       * @param  {Element} prevBtn      - The previous move button.
                * @param  {String} type          - The type of button is triggered. Values: next, prev, init
                * @param  {?Number} indexGo      - The target item index.
       * @return {Void}
       */


      function setButtonTargetIndex(nextBtn, prevBtn, type, indexGo) {
        switch (type) {
          case 'init':
            nextBtn.attr({
              'data-target-index': 1
            });
            prevBtn.attr({
              'data-target-index': 0
            });
            break;

          case 'next':
            var nextBtnOldTargetIndex1 = parseFloat(nextBtn.attr('data-target-index'));
            var prevBtnOldTargetIndex1 = parseFloat(prevBtn.attr('data-target-index'));

            if (indexGo != null) {
              nextBtnOldTargetIndex1 = indexGo;
              prevBtnOldTargetIndex1 = indexGo - 1;
            }

            nextBtn.attr({
              'data-target-index': nextBtnOldTargetIndex1 + 1
            });
            prevBtn.attr({
              'data-target-index': prevBtnOldTargetIndex1 + 1
            });
            break;

          case 'prev':
            var nextBtnOldTargetIndex2 = parseFloat(nextBtn.attr('data-target-index')) - 1;
            var prevBtnOldTargetIndex2 = parseFloat(prevBtn.attr('data-target-index')) - 1;

            if (indexGo != null) {
              nextBtnOldTargetIndex2 = indexGo;
              prevBtnOldTargetIndex2 = indexGo - 1;
            }

            nextBtn.attr({
              'data-target-index': nextBtnOldTargetIndex2
            });
            prevBtn.attr({
              'data-target-index': prevBtnOldTargetIndex2
            });
            break;
        }
      }
      /*
       * The state of the control button
       *
                * @param  {Number} firstOffset          - Get the computed Translate X or Y values of a given first DOM element.
                * @param  {Number} lastOffset           - Get the computed Translate X or Y values of a given last DOM element.
       * @return {Void}
       */


      function setButtonState(firstOffset, lastOffset) {
        if (Math.abs(firstOffset) == lastOffset) {
          $(sliderNext).addClass('is-disabled').data('disabled', 1);
          $(sliderPrev).removeClass('is-disabled').removeData('disabled');
        } else if (Math.round(firstOffset) == 0) {
          $(sliderNext).removeClass('is-disabled').removeData('disabled');
          $(sliderPrev).addClass('is-disabled').data('disabled', 1);
        } else {
          $(sliderNext).removeClass('is-disabled').removeData('disabled');
          $(sliderPrev).removeClass('is-disabled').removeData('disabled');
        }
      }
    });
  };

  module.components.pageLoaded.push(module.HYBRID_CONTENT_SLIDER.pageLoaded);
  return /*#__PURE__*/_createClass(function HYBRID_CONTENT_SLIDER() {
    _classCallCheck(this, HYBRID_CONTENT_SLIDER);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/hover-delay-interaction/js/index.js



/* 
 *************************************
 * <!-- Hover Delay Interaction -->
 *************************************
 */

var HOVER_DELAY_INTERACTION = function (module, $, window, document) {
  if (window.HOVER_DELAY_INTERACTION === null) return false;
  module.HOVER_DELAY_INTERACTION = module.HOVER_DELAY_INTERACTION || {};
  module.HOVER_DELAY_INTERACTION.version = '0.0.1';

  module.HOVER_DELAY_INTERACTION.documentReady = function ($) {
    var delayTime = 250;
    $('.uix-hover-delay-el').on('mouseover', function () {
      var $this = $(this);

      if ($this.prop('hoverTimeout')) {
        $this.prop('hoverTimeout', clearTimeout($this.prop('hoverTimeout')));
      }

      $this.prop('hoverIntent', setTimeout(function () {
        $this.find('> div').html('Okay!');
      }, delayTime));
    }).on('mouseleave', function () {
      var $this = $(this);

      if ($this.prop('hoverIntent')) {
        $this.prop('hoverIntent', clearTimeout($this.prop('hoverIntent')));
      }

      $this.prop('hoverTimeout', setTimeout(function () {
        $this.find('> div').html('Touch Me');
      }, delayTime));
    });
  };

  module.components.documentReady.push(module.HOVER_DELAY_INTERACTION.documentReady);
  return /*#__PURE__*/_createClass(function HOVER_DELAY_INTERACTION() {
    _classCallCheck(this, HOVER_DELAY_INTERACTION);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/image-shapes/js/index.js



/* 
 *************************************
 * <!-- Image Shapes -->
 *************************************
 */


var IMAGE_SHAPES = function (module, $, window, document) {
  if (window.IMAGE_SHAPES === null) return false;
  module.IMAGE_SHAPES = module.IMAGE_SHAPES || {};
  module.IMAGE_SHAPES.version = '0.0.2';

  module.IMAGE_SHAPES.documentReady = function ($) {
    var windowWidth = window.innerWidth,
        windowHeight = window.innerHeight; //  Initialize

    shapesInit(windowWidth);

    function windowUpdate() {
      // Check window width has actually changed and it's not just iOS triggering a resize event on scroll
      if (window.innerWidth != windowWidth) {
        // Update the window width for next time
        windowWidth = window.innerWidth; // Do stuff here

        shapesInit(windowWidth);
      }
    } // Add function to the window that should be resized


    var debounceFuncWindow = UixDebounce(windowUpdate, 50);
    window.removeEventListener('resize', debounceFuncWindow);
    window.addEventListener('resize', debounceFuncWindow);
    /*
     * Initialize Shapes
     *
     * @param  {Number} w         - Returns width of browser viewport
     * @param  {Number} h         - Returns height of browser viewport
     * @return {Void}
     */

    function shapesInit(w) {
      $('.uix-shape-img').each(function () {
        var $this = $(this);
        var ranID = 'uix-shape-img-' + UixGUID.create(),
            svgPath = $this.data('path'),
            svgW = parseFloat($this.data('svg-const-width')),
            svgH = parseFloat($this.data('svg-const-height')),
            svgRatio = svgW / svgH,
            curImgURL = $this.find('img').attr('src');
        var imgW = parseFloat($this.data('img-width'));
        var imgRatio = null,
            bothWidthRatio = null,
            newSvgHeight = null,
            newImgHeight = null,
            svgOut = '',
            curImgW = imgW,
            curImgH = null;

        if (imgW > w) {
          imgW = w;
        } //Check if the picture is loaded on the page


        var img = new Image();

        img.onload = function () {
          curImgH = $this.find('img').height();
          curImgW = $this.find('img').width();
          imgRatio = curImgW / curImgH; //Add a custom shape SVG to the page

          bothWidthRatio = imgW / svgW;
          newSvgHeight = imgW / svgRatio;
          newImgHeight = svgW / imgRatio;
          svgOut += '<svg fill-rule="evenodd" clip-rule="evenodd" width="' + imgW + 'px" height="' + newSvgHeight + 'px" viewBox="0 0 ' + imgW + ' ' + newSvgHeight + '" >';
          svgOut += '	<pattern id="' + ranID + '" patternUnits="userSpaceOnUse" width="' + svgW + '" height="' + svgH + '">';
          svgOut += '		  <image xlink:href="' + curImgURL + '" width="' + svgW + 'px" height="' + newImgHeight + 'px" x="0" y="0" />';
          svgOut += '	</pattern> ';
          svgOut += '	<path fill="url(#' + ranID + ')" transform="scale(' + bothWidthRatio + ')" d="' + svgPath + '"/>';
          svgOut += '</svg>';
          $this.addClass('is-active').html(svgOut);
        };

        img.src = curImgURL;
      });
    }
  };

  module.components.documentReady.push(module.IMAGE_SHAPES.documentReady);
  return /*#__PURE__*/_createClass(function IMAGE_SHAPES() {
    _classCallCheck(this, IMAGE_SHAPES);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/infinite-scrolling-element/js/index.js




/* 
 *************************************
 * <!-- Infinite Scrolling Element -->
 *************************************
 */


var INFINITE_SCROLLING_EL = function (module, $, window, document) {
  if (window.INFINITE_SCROLLING_EL === null) return false;
  module.INFINITE_SCROLLING_EL = module.INFINITE_SCROLLING_EL || {};
  module.INFINITE_SCROLLING_EL.version = '0.0.3';

  module.INFINITE_SCROLLING_EL.documentReady = function ($) {
    $('.uix-infinite-scrolling').each(function () {
      var $this = $(this);
      var speed = $this.data('speed'),
          gap = $this.data('gap');
      if ((0,esm_typeof/* default */.Z)(speed) === ( true ? "undefined" : 0)) speed = 3000;
      if ((0,esm_typeof/* default */.Z)(gap) === ( true ? "undefined" : 0)) gap = 20;
      var root = $this[0];
      var wrapperWidth = root.clientWidth;
      var $list = root.firstElementChild; // whitespace nodes might interfere with using `firstChild`

      var $itemsOriginal = $list.children;
      var itemsTotal = $itemsOriginal.length; //original width (including: padding)
      //------------------------------------------

      var itemsWidthOriginal = [];
      Array.prototype.forEach.call($list.children, function (node, index) {
        itemsWidthOriginal.push(node.clientWidth + gap);
      });
      var allWidthOriginal = itemsWidthOriginal.reduce(function (previousValue, currentValue, currentIndex, array) {
        var newVal = previousValue + currentValue;
        return newVal;
      }); //clone elements in order to complement content area
      //------------------------------------------

      var loopTimes = Math.ceil(wrapperWidth / allWidthOriginal);

      for (var i = 0; i < loopTimes; i++) {
        var $clonedItems = $list.cloneNode(true).querySelectorAll('li'); //do not use `children`

        Array.prototype.some.call($clonedItems, function (node, index) {
          $list.appendChild(node);
          if (index === itemsTotal - 1) return true;
        });
      } //calculate the total width
      //------------------------------------------


      var $items = root.getElementsByTagName('li');
      var itemsWidth = [];
      var itemPos = [];
      Array.prototype.forEach.call($items, function (node, index) {
        itemsWidth.push(node.clientWidth + gap);
      });
      itemPos.push(0, itemsWidth[0]);
      var allWidth = itemsWidth.reduce(function (previousValue, currentValue, currentIndex, array) {
        var newVal = previousValue + currentValue;
        itemPos.push(newVal);
        return newVal;
      });
      itemPos.pop(); // console.log('itemsWidth: ', itemsWidth);
      // console.log('itemPos: ', itemPos);
      // console.log('allWidth: ', allWidth);
      //initially colorize each box and position in a row
      //------------------------------------------

      TweenMax.set($items, {
        x: function x(i) {
          return itemPos[i];
        }
      }); //TimelineMax

      var tl = new TimelineMax({
        repeat: -1,
        paused: true
      });
      tl.to($items, speed / 1000, {
        ease: Linear.easeNone,
        x: "-=" + allWidthOriginal,
        //move each box "allWidthOriginal" to left
        modifiers: {
          x: function x(_x, target) {
            return _x % allWidth; //force x value to be between 0 and "allWidth" using modulus
          }
        }
      }).progress(1).progress(0).play(); //Pause/Play		

      $this.on('mouseenter', function () {
        tl.pause();
      }).on('mouseleave', function () {
        tl.play();
      });
    });
  };

  module.components.documentReady.push(module.INFINITE_SCROLLING_EL.documentReady);
  return /*#__PURE__*/_createClass(function INFINITE_SCROLLING_EL() {
    _classCallCheck(this, INFINITE_SCROLLING_EL);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/lava-lamp-style-menu/js/index.js



/* 
 *************************************
 * <!-- Lava-Lamp Style Menu -->
 *************************************
 */


var LAVA_LAMP_STYLE_MENU = function (module, $, window, document) {
  if (window.LAVA_LAMP_STYLE_MENU === null) return false;
  module.LAVA_LAMP_STYLE_MENU = module.LAVA_LAMP_STYLE_MENU || {};
  module.LAVA_LAMP_STYLE_MENU.version = '0.0.3';

  module.LAVA_LAMP_STYLE_MENU.documentReady = function ($) {
    var $menuContainer = $('.uix-lavalamp-menu__container'),
        menu = 'ul.uix-lavalamp-menu',
        followEl = menu + ' .uix-lavalamp-menu__slide-line'; //Prevent this module from loading in other pages

    if ($menuContainer.length == 0) return false; // adds sliding underline HTML

    $(menu).append('<span class="uix-lavalamp-menu__slide-line"></span>'); // set initial position of element

    TweenMax.set(followEl, {
      css: {
        width: 0,
        x: 0,
        y: 0
      }
    });

    function mouseFollowEv(index) {
      var $this = $(menu + ' > li').eq(index).find('a'),
          offset = $this.offset(),
          offsetBody = $('.uix-lavalamp-menu__container').offset(); //find the offset of the wrapping div  
      //Activate navigation style

      $(menu + ' > li').removeClass('is-active');
      $this.parent().addClass('is-active'); // GSAP animate to clicked menu item

      TweenMax.to(followEl, 1, {
        css: {
          width: parseFloat($this.outerWidth() + 0) + 'px',
          x: offset.left - offsetBody.left + 'px'
        },
        ease: Elastic.easeOut.config(1, 0.5)
      });
    } //!import: Please do not try `$( document ).on( MOUSE_EVENT )` to improve performance


    $(menu + ' > li a').on('mouseover', function () {
      mouseFollowEv($(this).parent().index());
    });
    mouseFollowEv(0);
  };

  module.components.documentReady.push(module.LAVA_LAMP_STYLE_MENU.documentReady);
  return /*#__PURE__*/_createClass(function LAVA_LAMP_STYLE_MENU() {
    _classCallCheck(this, LAVA_LAMP_STYLE_MENU);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
// EXTERNAL MODULE: ./src/components/_third-party-plugins/Miscellaneous/scrollLock.js
var scrollLock = __webpack_require__(111);
;// CONCATENATED MODULE: ./src/components/lightbox/js/index.js




/* 
 *************************************
 * <!-- Custom Lightbox -->
 *************************************
 */




var LIGHTBOX = function (module, $, window, document) {
  if (window.LIGHTBOX === null) return false;
  module.LIGHTBOX = module.LIGHTBOX || {};
  module.LIGHTBOX.version = '0.2.3';

  module.LIGHTBOX.pageLoaded = function () {
    if ($('.uix-lightbox__container').length == 0) {
      $('body').prepend('<div class="uix-lightbox__loading is-loaded uix-t-c"><i class="fa fa-spinner fa-spin"></i> Loading...</div><a class="uix-lightbox__original__close" href="javascript:void(0);"></a><div class="uix-lightbox__container"><div class="uix-lightbox__inner"><div class="uix-lightbox__html"></div><p class="title"></p></div></div><div class="uix-lightbox__container-mask"></div><div class="uix-lightbox__close"><button type="button"></button></div>');
    } // To display the template tag content.


    $('template').each(function () {
      var _content = $(this).html(function (index, html) {
        return html.replace(/[\r\n]/g, '');
      }).html(),
          _id = $(this).attr('id'); //If it is dialog, clone the contents of the <template> into the body


      if ((0,esm_typeof/* default */.Z)(_id) !== ( true ? "undefined" : 0) && !$('body').hasClass(_id) && $('<div>' + _content + '</div>').find('[role="dialog"]').length > 0) {
        //reset id
        $(this).removeAttr('id');
        $('body').addClass(_id); //append content to body

        $(_content.replace(/role=[\'\"]dialog[\'\"]/, 'role="dialog" id="' + _id + '"')).appendTo('body');
      }
    });
    var innerEl = '.uix-lightbox__inner',
        wrapperEl = '.uix-lightbox__container',
        loaderEl = '.uix-lightbox__loading',
        maskEl = '.uix-lightbox__container-mask',
        closeEl = '.uix-lightbox__close',
        largeImgCloseEl = '.uix-lightbox__original__close',
        triggerEl = '.uix-lightbox__trigger',
        docURL = window.location.href,
        $content = $(innerEl).find('.uix-lightbox__html'),
        customWidth = 1000; //Match the width in the css file;
    //Detect URL change & Fire click event

    window.addEventListener('popstate', function (e) {
      var eleTarget = null;
      $('[data-lb-ajax]').each(function () {
        var prevURL = decodeURIComponent(document.cookie.replace(new RegExp("(?:(?:^|.*;)\\s*" + encodeURIComponent('uix-lightbox-ajaxURL').replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=\\s*([^;]*).*$)|^.*$"), "$1")) || null;

        if ($(this).attr('href') === prevURL) {
          eleTarget = this;
        }
      });
      var backURL = $(eleTarget).data('lb-ajax-doc-url');

      if ((0,esm_typeof/* default */.Z)(backURL) != ( true ? "undefined" : 0)) {
        lightboxClose(backURL);
      }
    });
    $(document).off('click.LIGHTBOX_TRIGGER').on('click.LIGHTBOX_TRIGGER', triggerEl, function () {
      var $this = $(this);
      var dataPhoto = $this.data('lb-src'),
          dataHtmlID = $this.data('lb-html'),
          dataFixed = $this.data('lb-fixed'),
          dataMaskClose = $this.data('lb-mask-close'),
          dataAjax = $this.data('lb-ajax'),
          htmlContent = '',
          imgSrcStr = '',
          imgSrcStrToW = '';

      if ((0,esm_typeof/* default */.Z)(dataFixed) === ( true ? "undefined" : 0)) {
        dataFixed = true;
      }

      if ((0,esm_typeof/* default */.Z)(dataMaskClose) === ( true ? "undefined" : 0)) {
        dataMaskClose = false;
      }

      if ((0,esm_typeof/* default */.Z)(dataAjax) === ( true ? "undefined" : 0)) {
        dataAjax = false;
      }

      if (dataAjax) {
        $(wrapperEl).addClass('js-uix-ajax'); //Record current page URL for history

        if ((0,esm_typeof/* default */.Z)($this.data('lb-ajax-doc-url')) === ( true ? "undefined" : 0)) $this.data('lb-ajax-doc-url', docURL);
      } //Display loading


      $(loaderEl).removeClass('is-loaded'); //Reset the wrapper position

      $(wrapperEl).css('margin-top', 0);

      if (!dataFixed) {
        $(wrapperEl).addClass('js-uix-no-fixed');
        $(closeEl).addClass('is-active'); //Initialize the wrapper position

        $(wrapperEl).css('margin-top', $(window).scrollTop() + 'px');
      } //Reset current container type


      $(innerEl).removeClass('js-uix-custom js-uix-pure-image'); // Locks the page

      if (!$(wrapperEl).hasClass('js-uix-no-fixed')) {
        $.scrollLock(true); //Add class for body
        //When scrollLock is used, scrollTop value will change

        $('body').addClass('scrollLock');
      } // Show the lightbox


      var showLightbox = function showLightbox() {
        $(closeEl).addClass('is-active');
        $(wrapperEl).show();
        $(maskEl).show();
        $(innerEl).show();
      }; // hide the content container


      var hideLightboxContent = function hideLightboxContent() {
        TweenMax.set($content, {
          css: {
            'display': 'none'
          }
        });
      }; // show the content container


      var showLightboxContent = function showLightboxContent() {
        TweenMax.set($content, {
          css: {
            'display': 'block'
          },
          onComplete: function onComplete() {
            TweenMax.to(this.target, 0.5, {
              alpha: 1
            });
          }
        });
      };

      hideLightboxContent(); ////////////////////////
      //////// PHOTOS ///////
      ////////////////////////  

      if ((0,esm_typeof/* default */.Z)(dataPhoto) != ( true ? "undefined" : 0) && dataPhoto != '') {
        //show the lightbox
        showLightbox();

        if (dataPhoto.indexOf('[') >= 0 && dataPhoto.indexOf(']') >= 0) {
          imgSrcStr = JSON.parse(dataPhoto.replace(/([a-zA-Z0-9]+?):/g, '"$1":').replace(/'/g, '"'));
        } else {
          imgSrcStr = dataPhoto;
        } //Judging whether multiple image sets


        if (Object.prototype.toString.call(imgSrcStr) == '[object Array]') {
          var largePhotos = '',
              thumbs = '';
          imgSrcStrToW = imgSrcStr[0].large; //push the large photos

          largePhotos += '<div class="uix-lightbox__photo-container uix-lightbox__photo-sets-container"><a href="javascript:" class="uix-lightbox__photo-sets__prev"></a><a href="javascript:" class="uix-lightbox__photo-sets__next"></a><ul>';

          for (var i = 0; i < imgSrcStr.length; i++) {
            var tempID = 'lightbox-' + UixGUID.create();
            largePhotos += '<li>';
            largePhotos += '	<a class="uix-lightbox__original__link" data-target-id="' + tempID + '-sets-' + i + '" href="javascript:void(0);">';
            largePhotos += '	   <img src="' + imgSrcStr[i].large + '" alt="">';
            largePhotos += '	</a>';
            largePhotos += '	<div class="uix-lightbox__original__target" id="' + tempID + '-sets-' + i + '">';
            largePhotos += '	   <img src="' + imgSrcStr[i].large + '" alt="">';
            largePhotos += '	</div>';
            largePhotos += '</li>';
          }

          largePhotos += '</ul></div>'; //push the thumbs

          thumbs += '<div class="uix-lightbox__thumb-container"><ul>';

          for (var k = 0; k < imgSrcStr.length; k++) {
            var active = k == 0 ? 'class="is-active"' : '';
            thumbs += '<li ' + active + '><img src="' + imgSrcStr[k].thumb + '" alt=""></li>';
          }

          thumbs += '</ul></div>';
          htmlContent = largePhotos + thumbs;
        } else {
          var _tempID = 'lightbox-' + UixGUID.create(); //Only one image


          imgSrcStrToW = imgSrcStr;
          htmlContent += '<div class="uix-lightbox__photo-container">';
          htmlContent += '	<a class="uix-lightbox__original__link" data-target-id="' + _tempID + '" href="javascript:void(0);">';
          htmlContent += '	   <img src="' + imgSrcStr + '" alt="">';
          htmlContent += '	</a>';
          htmlContent += '	<div class="uix-lightbox__original__target" id="' + _tempID + '">';
          htmlContent += '	   <img src="' + imgSrcStr + '" alt="">';
          htmlContent += '	</div>';
          htmlContent += '</div>';
        }

        $content.html(htmlContent).promise().done(function () {
          //Set current container type
          $(innerEl).addClass('js-uix-pure-image'); //Set container width

          var img = new Image();
          img.src = imgSrcStrToW;

          img.onload = function () {
            //remove loading
            $(loaderEl).addClass('is-loaded'); // show the content container

            showLightboxContent();
            var sw = window.innerWidth - 30,
                ow = this.width,
                oh = this.height,
                ratioH = oh / ow,
                ratioW = ow / oh,
                w = ow > customWidth ? customWidth : ow,
                h;
            if (w > sw) w = sw;
            h = w * ratioH; //Prevent height overflow

            if (h > window.innerHeight) h = window.innerHeight * 0.95;
            $(innerEl).css({
              'width': w + 'px'
            }); //Don't write variables outside

            var $lbSetsContainer = $('.uix-lightbox__photo-container.uix-lightbox__photo-sets-container');
            $lbSetsContainer.css({
              'height': h + 'px'
            }); //Set a new height & width of inside images

            $content.find('.uix-lightbox__photo-sets-container ul > li img').css({
              'height': h + 'px'
            });

            if (!$('body').hasClass('rtl')) {
              $content.find('.uix-lightbox__photo-sets-container').css({
                'width': 'calc(' + h * ratioW + 'px + 6rem)',
                'margin-left': '-3rem'
              });
            } else {
              $content.find('.uix-lightbox__photo-sets-container').css({
                'width': 'calc(' + h * ratioW + 'px + 6rem)',
                'margin-right': '-3rem'
              });
            } //If the image is larger than the current window, it will display at the top.
            //Don't write variables outside


            var $lbTarImg = $('.uix-lightbox__photo-container > .uix-lightbox__original__target');

            if (oh > window.innerHeight) {
              $lbTarImg.addClass('uix-lightbox__original__target--imgfull');
            } else {
              $lbTarImg.removeClass('uix-lightbox__original__target--imgfull');
            }
          };

          $(innerEl).find('> .uix-lightbox__html').removeClass('js-uix-no-img');
        });
      } ////////////////////////
      //////// HTML /////////
      ////////////////////////  


      if ((0,esm_typeof/* default */.Z)(dataHtmlID) != ( true ? "undefined" : 0) && dataHtmlID != '') {
        dataHtmlID = dataHtmlID.replace('#', '');
        var $htmlAjaxContainer = $('#' + dataHtmlID).find('.uix-lightbox__content > div'); //show the lightbox

        showLightbox(); // Content pushing completed

        var htmlContentLoaded = function htmlContentLoaded() {
          //remove loading
          $(loaderEl).addClass('is-loaded'); //Set current container type

          $(innerEl).addClass('js-uix-custom'); //Set container width

          if ($(innerEl).find('> .uix-lightbox__html .uix-lightbox__content').length > 0) {
            if (window.innerWidth <= 768) {
              $(innerEl).css('width', window.innerWidth - 10 + 'px');
            } else {
              $(innerEl).css('width', $(innerEl).find('> .uix-lightbox__html .uix-lightbox__content').width() + 'px');
            }

            $(innerEl).find('> .uix-lightbox__html').addClass('js-uix-no-img');
          }
        };

        if ($(wrapperEl).hasClass('js-uix-ajax')) {
          //Add content to the dynamic AJAX container
          var ajaxURL = $this.attr('href'),
              ajaxConfig = dataAjax; // Modify the URL without reloading the page

          if (history.pushState) {
            history.pushState(null, null, ajaxURL);
          } else {
            location.hash = ajaxURL;
          }

          document.cookie = 'uix-lightbox-ajaxURL=' + ajaxURL; // Add a request or response interceptor

          var axiosInterceptor = axios.interceptors.request.use(function (config) {
            // Do something before request is sent
            //
            return config;
          }, function (error) {
            return Promise.reject(error);
          }); // To send data in the application/x-www-form-urlencoded format instead

          var formData = new FormData();
          var defaultPostData = {
            action: 'load_singlepages_ajax_content'
          };

          for (var _k in defaultPostData) {
            formData.append(_k, defaultPostData[_k]);
          } // Create a request event


          axios({
            timeout: 15000,
            method: ajaxConfig.method,
            url: ajaxURL,
            data: formData,
            responseType: 'text'
          }).then(function (response) {
            var htmlCode = response.data;
            $htmlAjaxContainer.html($(htmlCode).find(dataAjax.target).html()).promise().done(function () {
              $content.html($('#' + dataHtmlID).html()).promise().done(function () {
                // Apply some asynchronism scripts
                $(document).UixApplyAsyncScripts({
                  lightBox: false,
                  ajaxPostList: false
                }); // show the content container

                showLightboxContent(); // Content pushing completed

                htmlContentLoaded();
              });
            });
          })["catch"](function (error) {
            if (error.response) {
              // The request was made and the server responded with a status code
              // that falls out of the range of 2xx
              var status = error.response.status;
              console.log(status);
              if (status == 404 || status == 405) window.location.href = ajaxURL;
            } else if (error.request) {
              // The request was made but no response was received
              // `error.request` is an instance of XMLHttpRequest in the browser and an instance of
              // http.ClientRequest in node.js
              console.log(error.request); //

              window.location.href = ajaxURL;
            } else {
              // If there was a problem, we need to
              // dispatch the error condition
              console.log(error.message);
            }
          }); // Remove an interceptor later

          axios.interceptors.request.eject(axiosInterceptor);
        } else {
          // show the content container
          showLightboxContent();
          $content.html($('#' + dataHtmlID).html()).promise().done(function () {
            // Content pushing completed
            htmlContentLoaded();
          });
        } //endif $( wrapperEl ).hasClass( 'js-uix-ajax' )

      }

      return false;
    });
    /* end click event for triggerEl */
    ////////////////////////
    // Close the lightbox //
    ////////////////////////   	

    $(document).off('click.LIGHTBOX_CLOSE').on('click.LIGHTBOX_CLOSE', closeEl + ',' + maskEl, function () {
      lightboxClose(docURL);
    });
    $(document).off('click.LIGHTBOX_THUMB').on('click.LIGHTBOX_THUMB', '.uix-lightbox__thumb-container li', function () {
      lightboxThumbSwitch($(this).index(), $(this));
    });
    $(document).off('click.LIGHTBOX_PHOTO_SETS').on('click.LIGHTBOX_PHOTO_SETS', '.uix-lightbox__photo-sets-container > a', function () {
      var $largePhoto = $(this).closest('.uix-lightbox__html').find('.uix-lightbox__photo-container.uix-lightbox__photo-sets-container'),
          $thumb = $(this).closest('.uix-lightbox__html').find('.uix-lightbox__thumb-container li'),
          total = $thumb.length,
          curIndex = $thumb.filter('.is-active').index();
      var prevIndex = curIndex - 1,
          nextIndex = curIndex + 1;
      if (prevIndex < 0) prevIndex = total - 1;
      if (nextIndex > total - 1) nextIndex = 0;

      if ($(this).hasClass('uix-lightbox__photo-sets__prev')) {
        lightboxThumbSwitch(prevIndex, $thumb.eq(prevIndex));
      }

      if ($(this).hasClass('uix-lightbox__photo-sets__next')) {
        lightboxThumbSwitch(nextIndex, $thumb.eq(nextIndex));
      }
    }); ////////////////////////////////
    // Close/Open enlarge image //
    ///////////////////////////////	

    if (window.innerWidth > 768) {
      $(document).off('click.LIGHTBOX_ORGINAL_LINK').on('click.LIGHTBOX_ORGINAL_LINK', '.uix-lightbox__original__link', function (e) {
        $('.uix-lightbox__original__target#' + $(this).data('target-id')).addClass('is-active');

        if ($(this).closest('.uix-lightbox__container.js-uix-no-fixed').length > 0) {
          $('.uix-lightbox__container.js-uix-no-fixed, .uix-lightbox__original__target--imgfull').addClass('no-fixed-imgEnlarged');
        } //---


        $('html').css('overflow-y', 'hidden');
        $(largeImgCloseEl).addClass('is-active');
      });
      $(document).off('click.LIGHTBOX_LARGE_IMG_CLOSE').on('click.LIGHTBOX_LARGE_IMG_CLOSE', largeImgCloseEl, function (e) {
        $('.uix-lightbox__original__target').removeClass('is-active');
        $('.uix-lightbox__container.js-uix-no-fixed, .uix-lightbox__original__target--imgfull').removeClass('no-fixed-imgEnlarged'); //---

        $(this).removeClass('is-active');
        $('html').css('overflow-y', 'auto');
      });
    }
    /*
     * Click thumbnail to show large photo
     *
     * @param  {Number} index           - The target index of large photo.
     * @param  {Element} obj             - Target large image <li>.
     * @return {Void}
     */


    function lightboxThumbSwitch(index, obj) {
      var $largePhoto = obj.closest('.uix-lightbox__html').find('.uix-lightbox__photo-container.uix-lightbox__photo-sets-container'),
          $thumb = obj.closest('.uix-lightbox__html').find('.uix-lightbox__thumb-container li'); // show the content container

      var showLightboxContent = function showLightboxContent() {
        TweenMax.set(obj.closest('.uix-lightbox__html'), {
          css: {
            'display': 'block'
          },
          onComplete: function onComplete() {
            TweenMax.to(this.target, 0.5, {
              alpha: 1
            });
          }
        });
      };

      $thumb.removeClass('is-active');
      obj.addClass('is-active'); //all items

      TweenMax.set($largePhoto.find('li'), {
        css: {
          'display': 'none',
          'opacity': 0
        },
        onComplete: function onComplete() {
          $(this.target).removeClass('is-active');
        }
      }); //current item

      TweenMax.set($largePhoto.find('li').eq(index), {
        css: {
          'display': 'block',
          'opacity': 0
        },
        onComplete: function onComplete() {
          var _cur = this.target;
          $(_cur).addClass('is-active'); //
          //Reset the container height

          var imgClick = new Image();
          imgClick.src = $largePhoto.find('li').eq(index).find('img').attr('src');

          imgClick.onload = function () {
            //remove loading
            $(loaderEl).addClass('is-loaded'); // show the content container

            showLightboxContent();
            var sw = window.innerWidth - 30,
                ow = this.width,
                oh = this.height,
                ratioH = oh / ow,
                w = ow > customWidth ? customWidth : ow,
                h;
            if (w > sw) w = sw;
            h = w * ratioH; //Prevent height overflow

            if (h > window.innerHeight) h = window.innerHeight * 0.95;
            $largePhoto.css({
              'height': h + 'px'
            }).find('img').css({
              'height': h + 'px'
            }); //If the image is larger than the current window, it will display at the top.
            //Don't write variables outside

            var $lbTarImg = $largePhoto.find('li').eq(index).find('.uix-lightbox__original__target');

            if (oh > window.innerHeight) {
              $lbTarImg.addClass('uix-lightbox__original__target--imgfull');
            } else {
              $lbTarImg.removeClass('uix-lightbox__original__target--imgfull');
            }

            TweenMax.to(_cur, 0.5, {
              alpha: 1
            });
          }; //imgClick.onload       

        }
      });
    }
    /*
     * Close the lightbox
     *
     * @param  {String} url             - The current page URL for history.
     * @return {Void}
     */


    function lightboxClose(url) {
      //Detect URL change when AJAX calls are done
      if ($(wrapperEl).hasClass('js-uix-ajax')) {
        history.pushState(null, null, url);
      } //Remove all dynamic classes


      $(wrapperEl).removeClass('js-uix-no-fixed js-uix-ajax');
      $(closeEl).removeClass('is-active'); //Add a scroll bar.

      $('html').css('overflow-y', 'auto'); //Reset current container type

      $(innerEl).removeClass('js-uix-custom js-uix-pure-image'); //close windows

      $(wrapperEl).hide();
      $(maskEl).hide(); // Unlocks the page

      $.scrollLock(false); //Remove class for body
      //When scrollLock is used, scrollTop value will change

      $('body').removeClass('scrollLock');
    }
  };

  module.components.pageLoaded.push(module.LIGHTBOX.pageLoaded);
  return /*#__PURE__*/_createClass(function LIGHTBOX() {
    _classCallCheck(this, LIGHTBOX);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/list-bulleted/js/index.js



/* 
 *************************************
 * <!-- Bulleted List -->
 *************************************
 */


var BULLETED_LIST = function (module, $, window, document) {
  if (window.BULLETED_LIST === null) return false;
  module.BULLETED_LIST = module.BULLETED_LIST || {};
  module.BULLETED_LIST.version = '0.0.1';

  module.BULLETED_LIST.documentReady = function ($) {
    // Icon bulleted lists
    $('[data-list-bullet]').each(function () {
      var bullet = $(this).attr('data-list-bullet');
      $(this).find('li').prepend('<i class="' + bullet + '" aria-hidden="true"></i>');
    });
  };

  module.components.documentReady.push(module.BULLETED_LIST.documentReady);
  return /*#__PURE__*/_createClass(function BULLETED_LIST() {
    _classCallCheck(this, BULLETED_LIST);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
// EXTERNAL MODULE: ./src/components/list-posts/js/third-party/template7.js
var template7 = __webpack_require__(642);
;// CONCATENATED MODULE: ./src/components/list-posts/js/index.js




/* 
 *************************************
 * <!-- Posts List With Ajax -->
 *************************************
 */






var POST_LIST_AJAX = function (module, $, window, document) {
  if (window.POST_LIST_AJAX === null) return false;
  module.POST_LIST_AJAX = module.POST_LIST_AJAX || {};
  module.POST_LIST_AJAX.version = '0.1.9';

  module.POST_LIST_AJAX.documentReady = function ($) {
    $('[data-ajax-list-json]').each(function () {
      var $this = $(this);
      var wrapperID = 'refresh-all-waypoint-' + UixGUID.create();
      var curPage = $this.data('ajax-list-page-now'),
          initCurPage = curPage,
          perShow = $this.data('ajax-list-page-per'),
          totalPage = $this.data('ajax-list-page-total'),
          method = $this.data('ajax-list-method'),
          trigger = $this.data('ajax-list-trigger'),
          infinitescroll = $this.data('ajax-list-infinitescroll'),
          jsonFile = $this.data('ajax-list-json'),
          render = $this.data('ajax-list-render'),
          template7ID = $this.data('ajax-list-temp-id'),
          pushContainer = $this.data('ajax-list-push-container-class'),
          triggerActive = $this.data('ajax-list-trigger-active-class'),
          pageParmStr = $this.data('ajax-list-page-parm-str'),
          noneInfo = $this.data('ajax-list-none-info');
      $this.attr('id', wrapperID);

      if ((0,esm_typeof/* default */.Z)(pageParmStr) === ( true ? "undefined" : 0)) {
        pageParmStr = {
          'totalPage': 'total',
          'currentPage': 'page',
          'displayPerPage': 'per'
        };
      }

      if ((0,esm_typeof/* default */.Z)(curPage) === ( true ? "undefined" : 0)) {
        curPage = 1;
      }

      if ((0,esm_typeof/* default */.Z)(perShow) === ( true ? "undefined" : 0)) {
        perShow = 8;
      }

      if ((0,esm_typeof/* default */.Z)(totalPage) === ( true ? "undefined" : 0)) {
        totalPage = 3;
      }

      if ((0,esm_typeof/* default */.Z)(totalPage) != ( true ? "undefined" : 0) && totalPage == '-1') {
        totalPage = 9999;
      }

      if ((0,esm_typeof/* default */.Z)(trigger) === ( true ? "undefined" : 0)) {
        trigger = '.uix-load-more';
      }

      if ((0,esm_typeof/* default */.Z)(infinitescroll) === ( true ? "undefined" : 0)) {
        infinitescroll = false;
      }

      if ((0,esm_typeof/* default */.Z)(render) === ( true ? "undefined" : 0)) {
        render = 'before';
      }

      if ((0,esm_typeof/* default */.Z)(jsonFile) === ( true ? "undefined" : 0)) {
        jsonFile = '';
      }

      if ((0,esm_typeof/* default */.Z)(template7ID) === ( true ? "undefined" : 0)) {
        template7ID = '';
      }

      if ((0,esm_typeof/* default */.Z)(triggerActive) === ( true ? "undefined" : 0)) {
        triggerActive = 'is-waiting';
      }

      if ((0,esm_typeof/* default */.Z)(method) === ( true ? "undefined" : 0)) {
        method = 'POST';
      }

      if ((0,esm_typeof/* default */.Z)(noneInfo) === ( true ? "undefined" : 0)) {
        noneInfo = '{"none":"","error":""}';
      }

      triggerActive = triggerActive.replace('.', '');

      if ((0,esm_typeof/* default */.Z)(pushContainer) === ( true ? "undefined" : 0)) {
        pushContainer = '.uix-ajax-items__container';

        if ($this.find(pushContainer).length == 0) {
          $('#' + template7ID).after('<div class="uix-ajax-items__container"></div>');
        }
      } //Get all attributes of an element and push the new attributes like "data-*"


      var curAttrs = $this.attr(),
          defaultPostData = '',
          customPostData = '';
      $.each(curAttrs, function (i, val) {
        if (i.indexOf('data-ajax-list-field-') >= 0) {
          customPostData += '"' + i.replace('data-ajax-list-field-', '') + '": ' + '"' + val + '", ';
        }
      });
      customPostData = customPostData.replace(/,\s*$/, ''); //Parse the JSON data

      if (jsonFile != '' && template7ID != '') {
        //Default output of the first page
        if (curPage == 2) {
          //Perform dynamic loading
          if (customPostData != '') {
            defaultPostData = JSON.parse('{ "' + pageParmStr.totalPage + '": ' + totalPage + ', "' + pageParmStr.displayPerPage + '": ' + perShow + ', "' + pageParmStr.currentPage + '": 1, ' + customPostData + ' }');
          } else {
            defaultPostData = JSON.parse('{ "' + pageParmStr.totalPage + '": ' + totalPage + ', "' + pageParmStr.displayPerPage + '": ' + perShow + ', "' + pageParmStr.currentPage + '": 1 }');
          }

          ajaxLoadInit($this, defaultPostData, $(trigger), curPage, totalPage, perShow, template7ID, jsonFile, triggerActive, pushContainer, method, render, noneInfo);
        }

        if (infinitescroll) {
          var scrollUpdate = function scrollUpdate() {
            var spyTop = parseFloat($button[0].getBoundingClientRect().top + $button.outerHeight(true));

            if (spyTop < window.innerHeight && !$button.hasClass(triggerActive)) {
              // Active this button
              $button.addClass(triggerActive);

              var _curPage = $button.attr('data-cur-page'); //Add next page number to the button


              _curPage = parseFloat(_curPage) + 1;
              $button.attr('data-cur-page', _curPage); //Avoid touching the same button multiple times

              if (_curPage == totalPage + 1) return false; //Perform dynamic loading

              if (customPostData != '') {
                defaultPostData = JSON.parse('{ "' + pageParmStr.totalPage + '": ' + totalPage + ', "' + pageParmStr.displayPerPage + '": ' + perShow + ', "' + pageParmStr.currentPage + '": ' + _curPage + ', ' + customPostData + ' }');
              } else {
                defaultPostData = JSON.parse('{ "' + pageParmStr.totalPage + '": ' + totalPage + ', "' + pageParmStr.displayPerPage + '": ' + perShow + ', "' + pageParmStr.currentPage + '": ' + _curPage + ' }');
              }

              ajaxLoadInit($this, defaultPostData, $button, _curPage, totalPage, perShow, template7ID, jsonFile, triggerActive, pushContainer, method, render, noneInfo);
            }
          }; // Add function to the element that should be used as the scrollable area.


          /* 
           ---------------------------
           Infinite scroll
           ---------------------------
           */
          var $button = $(trigger),
              btnTop = $button.offset().top; //Add default page number to the button

          $button.attr('data-cur-page', initCurPage); //Hide the next button 

          if (totalPage == 1) {
            $button.addClass('is-hide');
          }

          var throttleFunc = UixThrottle(scrollUpdate, 5);
          window.removeEventListener('scroll', throttleFunc);
          window.removeEventListener('touchmove', throttleFunc);
          window.addEventListener('scroll', throttleFunc);
          window.addEventListener('touchmove', throttleFunc);
          throttleFunc();
        } else {
          /* 
           ---------------------------
           Ajax with JSON data
           ---------------------------
           */
          var triggerStr = '';

          if (trigger.indexOf('[') >= 0 && trigger.indexOf(']') >= 0) {
            triggerStr = JSON.parse(trigger.replace(/([a-zA-Z0-9]+?):/g, '"$1":').replace(/'/g, '"'));
          } else {
            triggerStr = trigger;
          } //Whether there are two flip buttons "Previous" and "Next"


          if (Object.prototype.toString.call(triggerStr) == '[object Array]') {
            var prevTrigger = triggerStr[0].prev,
                nextTrigger = triggerStr[1].next; //Add default page number to the button

            $(nextTrigger).parent().attr('data-cur-page', initCurPage); //--------------- Next Button ------------------
            //Hide the next button 

            if (totalPage == 1) {
              $(nextTrigger).addClass('is-hide');
            } //Avoid using $( document ) to cause an asynchronous load without counting from 1


            $(nextTrigger).off('click').on('click', function (e) {
              e.preventDefault();
              var $button = $(this);
              var curPage = $button.parent().attr('data-cur-page'); //Add next page number to the button

              curPage = parseFloat(curPage) + 1;
              $button.parent().attr('data-cur-page', curPage); //Init button status

              $(prevTrigger).removeClass(triggerActive);
              $(nextTrigger).removeClass(triggerActive);
              $(prevTrigger).removeClass('is-hide'); // Active this button

              $button.addClass(triggerActive); //Perform dynamic loading

              if (customPostData != '') {
                defaultPostData = JSON.parse('{ "' + pageParmStr.totalPage + '": ' + totalPage + ', "' + pageParmStr.displayPerPage + '": ' + perShow + ', "' + pageParmStr.currentPage + '": ' + curPage + ', ' + customPostData + ' }');
              } else {
                defaultPostData = JSON.parse('{ "' + pageParmStr.totalPage + '": ' + totalPage + ', "' + pageParmStr.displayPerPage + '": ' + perShow + ', "' + pageParmStr.currentPage + '": ' + curPage + ' }');
              }

              ajaxLoadInit($this, defaultPostData, $button, curPage, totalPage, perShow, template7ID, jsonFile, triggerActive, pushContainer, method, render, noneInfo);
              return false;
            }); //----------------- Previous Button ----------------
            //Hide the prev button 

            $(prevTrigger).addClass('is-hide'); //Avoid using $( document ) to cause an asynchronous load without counting from 1

            $(prevTrigger).off('click').on('click', function (e) {
              e.preventDefault();
              var $button = $(this);
              var curPage = $button.parent().attr('data-cur-page'); //Add next page number to the button

              curPage = parseFloat(curPage) - 1;
              $button.parent().attr('data-cur-page', curPage); //Init button status

              $(prevTrigger).removeClass(triggerActive);
              $(nextTrigger).removeClass(triggerActive);
              $(nextTrigger).removeClass('is-hide'); // Active this button

              $button.addClass(triggerActive); //Perform dynamic loading

              if (customPostData != '') {
                defaultPostData = JSON.parse('{ "' + pageParmStr.totalPage + '": ' + totalPage + ', "' + pageParmStr.displayPerPage + '": ' + perShow + ', "' + pageParmStr.currentPage + '": ' + curPage + ', ' + customPostData + ' }');
              } else {
                defaultPostData = JSON.parse('{ "' + pageParmStr.totalPage + '": ' + totalPage + ', "' + pageParmStr.displayPerPage + '": ' + perShow + ', "' + pageParmStr.currentPage + '": ' + curPage + ' }');
              }

              ajaxLoadInit($this, defaultPostData, $button, curPage, totalPage, perShow, template7ID, jsonFile, triggerActive, pushContainer, method, render, noneInfo);
              return false;
            });
          } else {
            //----------------- More Button ----------------
            //Add default page number to the button
            $(trigger).attr('data-cur-page', initCurPage); //Hide the next button 

            if (totalPage == 1) {
              $(trigger).addClass('is-hide');
            } //Avoid using $( document ) to cause an asynchronous load without counting from 1


            $(trigger).off('click.POST_LIST_AJAX').on('click.POST_LIST_AJAX', function (e) {
              e.preventDefault();
              var $button = $(this);
              var curPage = $button.attr('data-cur-page'); //Add next page number to the button

              curPage = parseFloat(curPage) + 1;
              $button.attr('data-cur-page', curPage); // Active this button

              $button.addClass(triggerActive); //Perform dynamic loading

              if (customPostData != '') {
                defaultPostData = JSON.parse('{ "' + pageParmStr.totalPage + '": ' + totalPage + ', "' + pageParmStr.displayPerPage + '": ' + perShow + ', "' + pageParmStr.currentPage + '": ' + curPage + ', ' + customPostData + ' }');
              } else {
                defaultPostData = JSON.parse('{ "' + pageParmStr.totalPage + '": ' + totalPage + ', "' + pageParmStr.displayPerPage + '": ' + perShow + ', "' + pageParmStr.currentPage + '": ' + curPage + ' }');
              }

              ajaxLoadInit($this, defaultPostData, $button, curPage, totalPage, perShow, template7ID, jsonFile, triggerActive, pushContainer, method, render, noneInfo);
              return false;
            });
          }
        } //end if

      }
    });
    /*
     * Ajax with JSON data
     *
     * @param  {Element} ajaxWrapper     - The outermost container of list.
     * @param  {Object} defaultPostData - Data to be sent to the server which is custom JSON fields.
     * @param  {String} trigger         - Trigger ajax loaded button object.
     * @param  {Number} curPage         - The current page to load.
     * @param  {Number} perShow         - The amount to load each time.
     * @param  {Number} totalPage       - The total page to load.
     * @param  {String} template7ID     - HTML template ID
     * @param  {String} jsonFile        - JSON file path to docking data
     * @param  {String} triggerActive   - The class name of trigger button actived.
     * @param  {String} pushContainer   - This container is used to display the loaded dynamic data.
     * @param  {String} method          - The type of request to make, which can be either "POST" or "GET".
     * @param  {String} render          - Rendering mode of display information. ==> before | html | append
     * @param  {String} noneInfo        - Returns information of ajax asynchronous callback when the content is empty.
     * @return {Void}
     */

    function ajaxLoadInit(ajaxWrapper, defaultPostData, trigger, curPage, totalPage, perShow, template7ID, jsonFile, triggerActive, pushContainer, method, render, noneInfo) {
      var $divRoot = ajaxWrapper;
      var template = document.getElementById(template7ID).innerHTML; // Register partial
      // Recursive Partials
      // We can even use partials to make recursive templates, like nested comments:
      // The root node of JSON, which can be `items` or `comments` by default

      /*
      compiledTemplate({
      	comments: [
      		{
      			author: 'John Doe',
      			text: 'Lorem ipsum dolor',
      			comments: [
      				{
      					author: 'Mike Doe',
      					text: 'Aliquam erat volutpat'
      				},
      				{
      					author: 'Kate Doe',
      					text: 'Donec eget fringilla turpis'
      				}
      			]
      		},
      		{
      			author: 'Jane Doe',
      			text: 'Donec sodales euismod augue'
      		}
      	]
      });
      */

      if ($divRoot.hasClass('js-ajax-comments')) {
        var recursivePartialsTemplate_Comments = template;
        Template7.registerPartial('comments', recursivePartialsTemplate_Comments); //update new template code

        template = '{{> "comments"}}';
      } //


      var compiledTemplate = Template7.compile(template),
          $button = $(trigger); //hide the button and callback the information

      var returnEmptyInfo = function returnEmptyInfo() {
        $button.addClass('is-hide');
        $divRoot.after(noneInfo.none);
      };

      var returnDataError = function returnDataError() {
        $button.addClass('is-hide');
        $divRoot.after(noneInfo.error);
      }; // Add a request or response interceptor


      var axiosInterceptor = axios.interceptors.request.use(function (config) {
        // Do something before request is sent
        //
        return config;
      }, function (error) {
        return Promise.reject(error);
      }); // To send data in the application/x-www-form-urlencoded format instead

      var formData = new FormData();

      for (var k in defaultPostData) {
        formData.append(k, defaultPostData[k]);
      } // Create a request event


      axios({
        timeout: 15000,
        method: method,
        url: jsonFile,
        data: formData,
        responseType: 'json'
      }).then(function (response) {
        var jsonData = response.data; //If the data is empty
        // The root node of JSON, which can be `items` or `comments` by default

        if (jsonData && (jsonData == null || Object.prototype.toString.call(jsonData.items) == '[object String]') || jsonData && (jsonData == null || Object.prototype.toString.call(jsonData.comments) == '[object String]')) {
          returnEmptyInfo();
        } //Check if a key exists inside a json object
        // The root node of JSON, which can be `items` or `comments` by default


        if (jsonData && jsonData.hasOwnProperty('items') && Object.prototype.toString.call(jsonData.items) == '[object Array]' || jsonData && jsonData.hasOwnProperty('comments') && Object.prototype.toString.call(jsonData.comments) == '[object Array]') {
          //Data overflow may occur when the total number of pages is not posted
          try {
            var html = compiledTemplate(jsonData),
                curHtml = $divRoot.find(pushContainer).html();
            var result = null,
                htmlEl = null; //--------- Do or not append to the original content

            if (render == 'before') {
              result = curHtml + html;
              htmlEl = $(result);
              $divRoot.find(pushContainer).before(htmlEl);
            }

            if (render == 'html') {
              result = html;
              htmlEl = $(result);
              $divRoot.find(pushContainer).html(htmlEl);
            }

            if (render == 'append') {
              $divRoot.find(pushContainer).append(html);
            } //--------- Apply some asynchronism scripts


            $(document).UixApplyAsyncScripts({
              ajaxPostList: false
            }); //--------- Remove this button

            $button.removeClass(triggerActive); //--------- Hidden button when the page total number is set and does not equal -1 or 9999

            if (curPage == totalPage && totalPage != 9999 && totalPage != -1 && totalPage != 1) {
              returnEmptyInfo();
            }
          } catch (err) {
            console.log(err.message);
            returnDataError();
          }
        } else {
          //if not array
          returnEmptyInfo();
        }
      })["catch"](function (error) {
        if (error.response) {
          // The request was made and the server responded with a status code
          // that falls out of the range of 2xx
          var status = error.response.status;
          console.log(status);
        } else if (error.request) {
          // The request was made but no response was received
          // `error.request` is an instance of XMLHttpRequest in the browser and an instance of
          // http.ClientRequest in node.js
          console.log(error.request); //

          returnEmptyInfo();
        } else {
          // If there was a problem, we need to
          // dispatch the error condition
          console.log(error.message);
        }
      }); // Remove an interceptor later

      axios.interceptors.request.eject(axiosInterceptor);
    }
  };

  module.components.documentReady.push(module.POST_LIST_AJAX.documentReady);
  return /*#__PURE__*/_createClass(function POST_LIST_AJAX() {
    _classCallCheck(this, POST_LIST_AJAX);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/fullwidth-column-to-edge/js/index.js




/* 
 *************************************
 * <!-- Full Width Column to Edge -->
 *************************************
 */


var FULL_WIDTH_COLUMN_TO_EDGE = function (module, $, window, document) {
  if (window.FULL_WIDTH_COLUMN_TO_EDGE === null) return false;
  module.FULL_WIDTH_COLUMN_TO_EDGE = module.FULL_WIDTH_COLUMN_TO_EDGE || {};
  module.FULL_WIDTH_COLUMN_TO_EDGE.version = '0.0.2';

  module.FULL_WIDTH_COLUMN_TO_EDGE.pageLoaded = function () {
    $('.js-uix-fullwidth-column-to-edge--extend-right').each(function () {
      var $el = $(this);
      var actived = $el.data('activated');

      if ((0,esm_typeof/* default */.Z)(actived) === ( true ? "undefined" : 0)) {
        fullwidthToDir($(this), 'right', window.innerWidth); //Prevents front-end javascripts that are activated in the background to repeat loading.

        $el.data('activated', 1);
      } //endif actived

    });
    $('.js-uix-fullwidth-column-to-edge--extend-left').each(function () {
      var $el = $(this);
      var actived = $el.data('activated');

      if ((0,esm_typeof/* default */.Z)(actived) === ( true ? "undefined" : 0)) {
        fullwidthToDir($(this), 'left', window.innerWidth); //Prevents front-end javascripts that are activated in the background to repeat loading.

        $el.data('activated', 1);
      } //endif actived

    });

    function fullwidthToDir(obj, dir, w) {
      var dividerPosition = obj.offset();
      var dividerWidth = $(window).width() - dividerPosition.left;
      var bsGridGutter = 15;

      if (w > 768) {
        obj.css('width', dividerWidth + bsGridGutter);

        if (dir == 'left') {
          var _dis = -(dividerPosition.left + bsGridGutter * 2);

          obj.css('margin-left', _dis + 'px');
        }
      } else {
        obj.css('width', 'inherit');

        if (dir == 'left') {
          obj.css('margin-left', -bsGridGutter + 'px');
        }
      }
    }
  };

  module.components.pageLoaded.push(module.FULL_WIDTH_COLUMN_TO_EDGE.pageLoaded);
  return /*#__PURE__*/_createClass(function FULL_WIDTH_COLUMN_TO_EDGE() {
    _classCallCheck(this, FULL_WIDTH_COLUMN_TO_EDGE);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/login-templates/js/index.js



/* 
 *************************************
 * <!-- Login Templates -->
 *************************************
 */


var LOGIN_UI = function (module, $, window, document) {
  if (window.LOGIN_UI === null) return false;
  module.LOGIN_UI = module.LOGIN_UI || {};
  module.LOGIN_UI.version = '0.0.2';

  module.LOGIN_UI.documentReady = function ($) {
    var $loginToggle = $('.uix-special-login__toggle'),
        $loginForms = $('.uix-special-login__form');
    $loginToggle.data('switched', true).off('click').on('click', function (e) {
      e.preventDefault();
      var $form1 = $loginForms.eq(0),
          $form2 = $loginForms.eq(1);

      if ($(this).data('switched')) {
        $(this).data('switched', false);
        TweenMax.set($form2, {
          height: 'auto'
        });
        TweenMax.from($form2, 0.5, {
          height: 0
        });
        TweenMax.to($form1, 0.5, {
          height: 0
        }); // Switches the Icon

        $(this).find('> span i').eq(0).hide();
        $(this).find('> span i').eq(1).show();
      } else {
        $(this).data('switched', true);
        TweenMax.set($form1, {
          height: 'auto'
        });
        TweenMax.from($form1, 0.5, {
          height: 0
        });
        TweenMax.to($form2, 0.5, {
          height: 0
        }); // Switches the Icon

        $(this).find('> span i').eq(1).hide();
        $(this).find('> span i').eq(0).show();
      }
    });
  };

  module.components.documentReady.push(module.LOGIN_UI.documentReady);
  return /*#__PURE__*/_createClass(function LOGIN_UI() {
    _classCallCheck(this, LOGIN_UI);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/modal-dialog/js/fn/fire-modal-dialog.js


/*
 * Fire Modal Dialog
 *
 * @param  {String} id                   - Modal's unique identifier.
 * @param  {Number|Boolean} height       - Custom modal height whick need a unit string. 
										   This attribute "data-modal-height" may not exist. Such as: 200px
 * @param  {Number|Boolean} width        - Custom modal width whick need a unit string. 
										   This attribute "data-modal-height" may not exist. Such as: 200px
 * @param  {Number} speed                - Delay Time when Full Screen Effect is fired.   
 * @param  {?Element|Boolean} btn          - Link or button that fires an event.
 * @param  {Boolean} lightbox            - Whether to enable the lightbox effect.
 * @param  {Number|Boolean} autoClose    - Specify auto-close time. This function is not enabled when this value is false.
 * @param  {Boolean} closeOnlyBtn        - Disable mask to close the window.
 * @return {Void}
 */


(function ($) {
  'use strict';

  $.fn.UixFireModalDialog = function (options) {
    // This is the easiest way to have default options.
    var settings = $.extend({
      id: 'demo',
      height: false,
      width: false,
      speed: 500,
      btn: false,
      lightbox: true,
      autoClose: false,
      closeOnlyBtn: false
    }, options);
    this.each(function () {
      if (settings.id == '') return false; //Prevent automatic close from affecting new fire effects

      clearTimeout(window.setCloseModalDialog); //Add modal mask to stage

      if ($('.uix-modal-mask').length == 0) {
        $('body').prepend('<div class="uix-modal-mask"></div>');
      }

      $.when($('.uix-modal-mask').length > 0).then(function () {
        if (settings.closeOnlyBtn) {
          $('.uix-modal-mask').addClass('js-uix-disabled');
        } else {
          $('.uix-modal-mask').removeClass('js-uix-disabled');
        }

        var dataID = settings.id,
            dataH = settings.height,
            dataW = settings.width,
            linkBtn = settings.btn,
            closeTime = settings.autoClose,
            $obj = $('.uix-modal-box#' + dataID); // Initializate modal

        if (linkBtn) {
          linkBtn.attr('href', 'javascript:void(0)');
          $obj.find('.uix-modal-box__content').addClass('js-uix-no-fullscreen');

          if (linkBtn.data('video-win')) {
            $obj.find('.uix-modal-box__content > .uix-modal-box__body').css('overflow-y', 'hidden');
          }
        }

        if ($obj.length > 0) {
          // Locks the page
          $.scrollLock(true); //Add class for body
          //When scrollLock is used, scrollTop value will change

          $('body').addClass('scrollLock');

          if ((0,esm_typeof/* default */.Z)(dataH) != ( true ? "undefined" : 0) && dataH != '' && dataH) {
            $obj.css({
              'height': dataH
            });
          }

          if ((0,esm_typeof/* default */.Z)(dataW) != ( true ? "undefined" : 0) && dataW != '' && dataW) {
            $obj.css({
              'width': dataW
            });
          } //Enable the lightbox effect.


          if (settings.lightbox) {
            TweenMax.set('.uix-modal-mask', {
              css: {
                opacity: 0,
                display: 'none'
              },
              onComplete: function onComplete() {
                TweenMax.to(this.target, 0.3, {
                  css: {
                    opacity: 1,
                    display: 'block'
                  }
                });
              }
            });
          }

          $obj.addClass('is-active'); //auto close

          if (closeTime && !isNaN(closeTime)) {
            window.setCloseModalDialog = setTimeout(function () {
              $(document).closeModalDialog();
            }, closeTime);
          }
        }

        if ($obj.hasClass('is-fullscreen')) {
          setTimeout(function () {
            if (!$obj.hasClass('is-video')) {
              $obj.find('.uix-modal-box__content > .uix-modal-box__body').css('overflow-y', 'scroll');
            } else {
              $obj.find('.uix-modal-box__content > .uix-modal-box__body').css('overflow-y', 'hidden');
            }
          }, settings.speed);
        }
      });
    });
  };
})(jQuery);
;// CONCATENATED MODULE: ./src/components/modal-dialog/js/fn/close-modal-dialog.js
/*
 * Close Modal Dialog
 *
 * @return {Void}
 */


(function ($) {
  'use strict';

  $.fn.UixCloseModalDialog = function (options) {
    // This is the easiest way to have default options.
    var settings = $.extend({
      target: '.uix-modal-box'
    }, options);
    this.each(function () {
      //Enable mask to close the window.
      $('.uix-modal-mask').removeClass('js-uix-disabled');
      $(settings.target).removeClass('is-active');
      TweenMax.to('.uix-modal-mask', 0.3, {
        css: {
          opacity: 0,
          display: 'none'
        }
      });
      $(settings.target).find('.uix-modal-box__content').removeClass('js-uix-no-fullscreen'); // Unlocks the page

      $.scrollLock(false); //Remove class for body
      //When scrollLock is used, scrollTop value will change

      $('body').removeClass('scrollLock'); //Prevent automatic close from affecting new fire effects

      clearTimeout(window.setCloseModalDialog);
    });
  };
})(jQuery);
;// CONCATENATED MODULE: ./src/components/modal-dialog/js/index.js




/* 
 *************************************
 * <!-- Modal Dialog -->
 *************************************
 */




var MODAL_DIALOG = function (module, $, window, document) {
  if (window.MODAL_DIALOG === null) return false;
  module.MODAL_DIALOG = module.MODAL_DIALOG || {};
  module.MODAL_DIALOG.version = '0.1.9';

  module.MODAL_DIALOG.documentReady = function ($) {
    //Delay Time when Full Screen Effect is fired.
    var modalSpeed = UixCssProperty.getTransitionDuration($('.uix-modal-box:first')[0]); // To display the template tag content.

    $('template').each(function () {
      var _content = $(this).html(function (index, html) {
        return html.replace(/[\r\n]/g, '');
      }).html(),
          _id = $(this).attr('id'); //If it is dialog, clone the contents of the <template> into the body


      if ((0,esm_typeof/* default */.Z)(_id) !== ( true ? "undefined" : 0) && !$('body').hasClass(_id) && $('<div>' + _content + '</div>').find('[role="dialog"]').length > 0) {
        //reset id
        $(this).removeAttr('id');
        $('body').addClass(_id); //append content to body

        $(_content.replace(/role=[\'\"]dialog[\'\"]/, 'role="dialog" id="' + _id + '"')).appendTo('body');
      }
    });
    /*
      * Unbind that one in a safe way that won't accidentally unbind other click handlers.
      * In order to trigger other custom Modal Dialog events.
    	
    	$( '#element' ).off( 'click.MODAL_DIALOG' );
    	$( '#element' ).off( 'click.MODAL_DIALOG_CLOSE' );
    	
    */
    //Add modal mask to stage

    if ($('.uix-modal-mask').length == 0) {
      $('body').prepend('<div class="uix-modal-mask"></div>');
    }

    $(document).off('click.MODAL_DIALOG').on('click.MODAL_DIALOG', '[data-modal-id]', function () {
      var dataH = $(this).data('modal-height'),
          dataW = $(this).data('modal-width'),
          lightbox = $(this).data('modal-lightbox'),
          closeTime = $(this).data('modal-close-time'),
          closeOnlyBtn = $(this).data('modal-close-onlybtn');

      if ((0,esm_typeof/* default */.Z)(dataH) === ( true ? "undefined" : 0)) {
        dataH = false;
      }

      if ((0,esm_typeof/* default */.Z)(dataW) === ( true ? "undefined" : 0)) {
        dataW = false;
      }

      if ((0,esm_typeof/* default */.Z)(lightbox) === ( true ? "undefined" : 0)) {
        lightbox = true;
      }

      if ((0,esm_typeof/* default */.Z)(closeTime) === ( true ? "undefined" : 0)) {
        closeTime = false;
      }

      if ((0,esm_typeof/* default */.Z)(closeOnlyBtn) === ( true ? "undefined" : 0)) {
        closeOnlyBtn = false;
      }

      $(document).UixFireModalDialog({
        id: $(this).data('modal-id'),
        height: dataH,
        width: dataW,
        speed: modalSpeed,
        btn: $(this),
        lightbox: lightbox,
        autoClose: closeTime,
        closeOnlyBtn: closeOnlyBtn
      });
      return false;
    });
    $(document).off('click.MODAL_DIALOG_CLOSE').on('click.MODAL_DIALOG_CLOSE', '.uix-modal-box [data-modal-close-trigger], .uix-modal-mask:not(.js-uix-disabled)', function () {
      //btn
      if ($(this).hasClass('uix-modal-box__close')) {
        $(this).parent().removeClass('is-active');
      }

      $(document).UixCloseModalDialog();
      return false;
    });
  };

  module.components.documentReady.push(module.MODAL_DIALOG.documentReady);
  return /*#__PURE__*/_createClass(function MODAL_DIALOG() {
    _classCallCheck(this, MODAL_DIALOG);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/mousewheel-interaction/js/index.js



/* 
 *************************************
 * <!-- Mousewheel Interaction -->
 *************************************
 */

var MOUSEWHEEL_INTERACTION = function (module, $, window, document) {
  if (window.MOUSEWHEEL_INTERACTION === null) return false;
  module.MOUSEWHEEL_INTERACTION = module.MOUSEWHEEL_INTERACTION || {};
  module.MOUSEWHEEL_INTERACTION.version = '0.0.4';

  module.MOUSEWHEEL_INTERACTION.documentReady = function ($) {
    //Prevent this module from loading in other pages
    if (!$('body').hasClass('mousewheel-interaction')) return false; //Determine the direction of a jQuery scroll event
    //Fix an issue for mousewheel event is too fast.

    var quietPeriod = 500,
        //Do not change it
    animationTime = 1000; //According to page transition animation changes

    var lastAnimation = 0;
    var scrollCount = 0;
    var startY = 0;

    var onTouchStart = function onTouchStart(e) {
      var touches = e.touches;

      if (touches && touches.length) {
        startY = touches[0].pageY;
      }
    };

    var onDeviceWheel = function onDeviceWheel(e) {
      //Gets a value that indicates the amount that the mouse wheel has changed.
      var dir,
          delta,
          mobileDeltaY = null;
      var touches = e.touches;

      if (touches && touches.length) {
        mobileDeltaY = startY - touches[0].pageY;
      } else {
        delta = Math.max(-1, Math.min(1, -e.deltaY));
      }

      if (mobileDeltaY != null) {
        if (mobileDeltaY >= 10) {
          //--- swipe up
          dir = 'up';
        }

        if (mobileDeltaY <= -10) {
          //--- swipe down
          dir = 'down';
        }
      } else {
        if (delta < 0) {
          //scroll down
          dir = 'down';
        } else {
          //scroll up
          dir = 'up';
        }
      }

      scrollMoveInit(e, dir);
    };

    window.addEventListener('wheel', onDeviceWheel, UixBrowser.supportsPassive ? {
      passive: true
    } : false);
    window.addEventListener('touchstart', onTouchStart, UixBrowser.supportsPassive ? {
      passive: true
    } : false);
    window.addEventListener('touchmove', onDeviceWheel, UixBrowser.supportsPassive ? {
      passive: true
    } : false);
    /*
     * Scroll initialize
     *
     * @param  {Event} event        - The wheel event is fired when a wheel button of a pointing device (usually a mouse) is rotated. 
     * @param  {String} dir          - Gets a value that indicates the amount that the mouse wheel has changed.
     * @return {Void}
     */

    function scrollMoveInit(event, dir) {
      var timeNow = new Date().getTime(); // Cancel scroll if currently animating or within quiet period

      if (timeNow - lastAnimation < quietPeriod + animationTime) {
        return;
      }

      if (dir == 'down') {
        //scroll down
        $('#demo-mousewheel-interaction-status').html('Direction: down, Total: ' + scrollCount);
        scrollCount++;
      } else {
        //scroll up
        $('#demo-mousewheel-interaction-status').html('Direction: up, Total: ' + scrollCount);
        scrollCount++;
      }

      lastAnimation = timeNow;
    }
  };

  module.components.documentReady.push(module.MOUSEWHEEL_INTERACTION.documentReady);
  return /*#__PURE__*/_createClass(function MOUSEWHEEL_INTERACTION() {
    _classCallCheck(this, MOUSEWHEEL_INTERACTION);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/_third-party-plugins/GSAP/esm/ModifiersPlugin.js


/*!
 * VERSION: 0.0.4
 * DATE: 2018-05-30
 * UPDATES AND DOCS AT: http://greensock.com
 *
 * @license Copyright (c) 2008-2019, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 * 
 * @author: Jack Doyle, jack@greensock.com
 */

/* eslint-disable */


var _cssRatioSetter = function _cssRatioSetter(pt, cssp, mod) {
  //Takes an individual CSSPropTween and converts it into a type:2 that has a setRatio that does everything the regular CSSPlugin.setRatio() method does but applying the mod() too. We do this to keep the main CSSPlugin.setRatio() as fast as possible (the vast majority of times, no mod() will be necessary)
  var type = pt.type,
      oldSetRatio = pt.setRatio,
      tween = cssp._tween,
      target = cssp._target;
  pt.type = 2;
  pt.m = mod;

  pt.setRatio = function (v) {
    var min = 0.000001,
        val,
        str,
        i;

    if (v === 1 && (tween._time === tween._duration || tween._time === 0)) {
      if (type !== 2) {
        if (pt.r && type !== -1) {
          val = Math.round(pt.s + pt.c);

          if (!type) {
            pt.t[pt.p] = mod.call(tween, val + pt.xs0, target, tween);
          } else if (type === 1) {
            str = pt.xs0 + val + pt.xs1;

            for (i = 1; i < pt.l; i++) {
              str += pt["xn" + i] + pt["xs" + (i + 1)];
            }

            pt.t[pt.p] = mod.call(tween, str, target, tween);
          }
        } else {
          pt.t[pt.p] = mod.call(tween, pt.e, target, tween);
        }
      } else {
        oldSetRatio.call(pt, v);
      }
    } else if (v || !(tween._time === tween._duration || tween._time === 0) || tween._rawPrevTime === -0.000001) {
      val = pt.c * v + pt.s;

      if (pt.r) {
        val = Math.round(val);
      } else if (val < min) if (val > -min) {
        val = 0;
      }

      if (!type) {
        pt.t[pt.p] = mod.call(tween, val + pt.xs0, target, tween);
      } else if (type === 1) {
        str = pt.xs0 + val + pt.xs1;

        for (i = 1; i < pt.l; i++) {
          str += pt["xn" + i] + pt["xs" + (i + 1)];
        }

        pt.t[pt.p] = mod.call(tween, str, target, tween);
      } else if (type === -1) {
        //non-tweening value
        pt.t[pt.p] = mod.call(tween, pt.xs0, target, tween);
      } else if (oldSetRatio) {
        oldSetRatio.call(pt, v);
      }
    } else {
      if (type !== 2) {
        pt.t[pt.p] = mod.call(tween, pt.b, target, tween);
      } else {
        oldSetRatio.call(pt, v);
      }
    }
  };
},
    _modCSS = function _modCSS(lookup, cssp) {
  var pt = cssp._firstPT,
      hasBezier = lookup.rotation && cssp._overwriteProps.join("").indexOf("bezier") !== -1; //when a Bezier tween is applying autoRotation, it's a very special case we need to handle differently.

  if (lookup.scale) {
    lookup.scaleX = lookup.scaleY = lookup.scale;
  } else if (lookup.rotationZ) {
    lookup.rotation = lookup.rotationZ;
  }

  while (pt) {
    if (typeof lookup[pt.p] === "function") {
      _cssRatioSetter(pt, cssp, lookup[pt.p]);
    } else if (hasBezier && pt.n === "bezier" && pt.plugin._overwriteProps.join("").indexOf("rotation") !== -1) {
      pt.data.mod = lookup.rotation;
    }

    pt = pt._next;
  }
},
    ModifiersPlugin = esm_TweenLite/* _gsScope._gsDefine.plugin */.ML._gsDefine.plugin({
  propName: "modifiers",
  version: "0.0.4",
  API: 2,
  //called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.
  init: function init(target, value, tween) {
    this._tween = tween;
    this._vars = value;
    return true;
  },
  initAll: function initAll() {
    var tween = this._tween,
        lookup = this._vars,
        mpt = this,
        pt = tween._firstPT,
        val,
        next; //initAll() gets called for each and every ModifiersPlugin instance in a tween, so if there are multiple targets, there will be multiple instances. Since we're ripping through the whole tween (and all the PropTweens), we only need to run this code ONCE. So we're setting a toggle on the first PropTween that just tells us if we've done it already. We don't set it on the tween instance because if it gets invalidated, we don't want to have to track this property and reset it. PropTweens get blown away when a tween is invalidated.

    if (pt._modInitted) {
      return false;
    } else {
      pt._modInitted = 1;
    }

    while (pt) {
      next = pt._next; //record here, because it may get removed

      val = lookup[pt.n];

      if (pt.pg) {
        if (pt.t._propName === "css") {
          //handle CSSPlugin uniquely (for performance, due to the fact that the values almost always are a concatenation of numbers and strings, like suffixes, and we don't want to slow down the regular CSSPlugin setRatio() performance with conditional checks for if the value needs to be modded, so we pull any modding prop out and change it to a type:2 one that simply calls a setRatio() method where we encapsulate the modding and update all together. That way, it says in the main CSSProp linked list and just has some custom logic applied to it inside its setRatio())
          _modCSS(lookup, pt.t);
        } else if (pt.t !== mpt) {
          //don't run modProps on modProps :)
          val = lookup[pt.t._propName];
          pt.t._tween = tween;

          pt.t._mod((0,esm_typeof/* default */.Z)(val) === "object" ? val : lookup);
        }
      } else if (typeof val === "function") {
        if (pt.f === 2 && pt.t) {
          //a blob (text containing multiple numeric values)
          pt.t._applyPT.m = val;
          pt.t._tween = tween;
        } else {
          this._add(pt.t, pt.p, pt.s, pt.c, val); //remove from linked list


          if (next) {
            next._prev = pt._prev;
          }

          if (pt._prev) {
            pt._prev._next = next;
          } else if (tween._firstPT === pt) {
            tween._firstPT = next;
          }

          pt._next = pt._prev = null;
          tween._propLookup[pt.n] = mpt;
        }
      }

      pt = next;
    }

    return false;
  }
}),
    ModifiersPlugin_p = ModifiersPlugin.prototype;

ModifiersPlugin_p._add = function (target, p, s, c, mod) {
  this._addTween(target, p, s, s + c, p, mod);

  this._overwriteProps.push(p);
};

ModifiersPlugin_p = esm_TweenLite/* _gsScope._gsDefine.globals.TweenLite.version.split */.ML._gsDefine.globals.TweenLite.version.split(".");

if (Number(ModifiersPlugin_p[0]) <= 1 && Number(ModifiersPlugin_p[1]) < 19 && esm_TweenLite/* _gsScope.console */.ML.console) {
  console.log("ModifiersPlugin requires GSAP 1.19.0 or later.");
}


;// CONCATENATED MODULE: ./src/components/multi-items-carousel/js/index.js




/* 
 *************************************
 * <!-- Multiple Items Carousel -->
 *************************************
 */



var MULTI_ITEMS_CAROUSEL = function (module, $, window, document) {
  if (window.MULTI_ITEMS_CAROUSEL === null) return false;
  module.MULTI_ITEMS_CAROUSEL = module.MULTI_ITEMS_CAROUSEL || {};
  module.MULTI_ITEMS_CAROUSEL.version = '0.0.6';

  module.MULTI_ITEMS_CAROUSEL.documentReady = function ($) {
    $('.uix-multi-carousel').each(function () {
      var $sliderWrapper = $(this),
          $slider = $sliderWrapper.find('.uix-multi-carousel__items'),
          $sliderItem = $sliderWrapper.find('.uix-multi-carousel__items > div'),
          itemsTotal = $sliderItem.length,
          amountVisible = $sliderWrapper.data('show'),
          sliderDir = $sliderWrapper.data('dir'),
          sliderLoop = $sliderWrapper.data('loop'),
          sliderSpeed = $sliderWrapper.data('speed'),
          sliderNext = $sliderWrapper.data('next'),
          sliderPrev = $sliderWrapper.data('prev'),
          carouseDraggable = $sliderWrapper.data('draggable'),
          carouseDraggableCursor = $sliderWrapper.data('draggable-cursor');
      if ((0,esm_typeof/* default */.Z)(sliderDir) === ( true ? "undefined" : 0)) sliderDir = 'horizontal';
      if ((0,esm_typeof/* default */.Z)(sliderLoop) === ( true ? "undefined" : 0)) sliderLoop = false;
      if ((0,esm_typeof/* default */.Z)(amountVisible) === ( true ? "undefined" : 0)) amountVisible = 3;
      if ((0,esm_typeof/* default */.Z)(sliderSpeed) === ( true ? "undefined" : 0)) sliderSpeed = 250;
      if ((0,esm_typeof/* default */.Z)(sliderNext) === ( true ? "undefined" : 0)) sliderNext = '.uix-multi-carousel__controls--next';
      if ((0,esm_typeof/* default */.Z)(sliderPrev) === ( true ? "undefined" : 0)) sliderPrev = '.uix-multi-carousel__controls--prev';
      if ((0,esm_typeof/* default */.Z)(carouseDraggable) === ( true ? "undefined" : 0)) carouseDraggable = false;
      if ((0,esm_typeof/* default */.Z)(carouseDraggableCursor) === ( true ? "undefined" : 0)) carouseDraggableCursor = 'move';
      if (window.innerWidth <= 768) amountVisible = 3; // Returns the value of a number rounded to the nearest integer.

      var midIndex = Math.round(amountVisible / 2) - 1;
      /* 
       ---------------------------
       Initialize slider
       ---------------------------
       */

      var eachItemNewWidth, eachItemNewHeight;
      var eachItemOldWidth = $slider.width() / amountVisible;
      var eachItemOldHeight = $slider.height() / amountVisible;

      if (sliderDir === 'horizontal') {
        eachItemNewWidth = $sliderWrapper.width() / amountVisible;
        $slider.css('width', itemsTotal * eachItemOldWidth);
      } else {
        eachItemNewHeight = $sliderWrapper.height() / amountVisible;
        $slider.css('height', itemsTotal * eachItemOldHeight);
      } // Re-order all items


      sliderReOrder(); //default button status

      if (!sliderLoop) {
        $(sliderPrev).addClass('is-disabled').data('disabled', 1);
      }
      /* 
       ---------------------------
       Re-order all items
       ---------------------------
       */


      function sliderReOrder() {
        if (sliderDir === 'horizontal') {
          var boxWidth = eachItemNewWidth;
          TweenMax.set($sliderItem, {
            width: boxWidth,
            x: function x(i, target) {
              //Active the center item
              if (i === midIndex && sliderLoop) {
                TweenMax.set(target, {
                  className: "+=is-active"
                });
              } //Add index to each item


              $sliderItem.eq(i).attr('data-index', i);
              return i * boxWidth;
            }
          });
        } else {
          var boxHeight = eachItemNewHeight;
          TweenMax.set($sliderItem, {
            height: boxHeight,
            y: function y(i, target) {
              //Active the center item
              if (i === midIndex && sliderLoop) {
                TweenMax.set(target, {
                  className: "+=is-active"
                });
              } //Add index to each item


              $sliderItem.eq(i).attr('data-index', i);
              return i * boxHeight;
            }
          });
        }
      }
      /* 
       ---------------------------
       Next/Prev buttons
       ---------------------------
       */


      var _prev = $(sliderPrev),
          _next = $(sliderNext);

      _next.off('click').on('click', $sliderWrapper, function (e) {
        e.preventDefault();
        btnNextMove();
      });

      _prev.off('click').on('click', $sliderWrapper, function (e) {
        e.preventDefault();
        btnPrevMove();
      }); // (right/down)


      function btnPrevMove() {
        //Prevent buttons' events from firing multiple times
        if (_prev.attr('aria-disabled') == 'true') return false;

        _prev.attr('aria-disabled', 'true');

        _prev.delay(sliderSpeed).queue(function (next) {
          _prev.attr('aria-disabled', 'false');

          next();
        }); //


        movePositionWithButton(_prev, 'prev');
      } // (left/up)


      function btnNextMove() {
        //Prevent buttons' events from firing multiple times
        if (_next.attr('aria-disabled') == 'true') return false;

        _next.attr('aria-disabled', 'true');

        _next.delay(sliderSpeed).queue(function (next) {
          _next.attr('aria-disabled', 'false');

          next();
        }); //


        movePositionWithButton(_next, 'next');
      } //Drag and Drop
      //-------------------------------------	


      var $dragDropTrigger = $sliderWrapper;
      var hammerProps = {}; //Make the cursor a move icon when a user hovers over an item

      if (carouseDraggable && carouseDraggableCursor != '' && carouseDraggableCursor != false) $dragDropTrigger.css('cursor', carouseDraggableCursor);

      if (!carouseDraggable) {
        hammerProps = {
          inputClass: Hammer.TouchInput
        };
      } //Mouse event
      //Hammer.js pan event only for touch devices and not for desktop computer Click+Drag


      var direction;
      var dragDropElement = $dragDropTrigger[0],
          dragDropMC = new Hammer(dragDropElement, hammerProps);
      var elAnim = true; // let the pan gesture support all directions.
      // this will block the vertical scrolling on a touch-device while on the element

      dragDropMC.get('pan').set({
        direction: Hammer.DIRECTION_ALL
      });
      dragDropMC.on('press panright panleft panup pandown', function (ev) {
        //Set the direction in here
        direction = ev.type; //Determine whether it is the first or the last    

        var currentIsFirstOrLast = false;

        if (!sliderLoop) {
          var firstItemOffset = sliderDir === 'horizontal' ? $slider.find('[data-index="0"]')[0]._gsTransform.x : $slider.find('[data-index="0"]')[0]._gsTransform.y;
          var maxMoveOffset = sliderDir === 'horizontal' ? -eachItemNewWidth * (itemsTotal - amountVisible) : -eachItemNewHeight * (itemsTotal - amountVisible);

          if ((direction == 'panright' || direction == 'pandown') && firstItemOffset >= 0) {
            //first item
            currentIsFirstOrLast = true;
          }

          if ((direction == 'panleft' || direction == 'panup') && firstItemOffset <= maxMoveOffset) {
            //last item
            currentIsFirstOrLast = true;
          }
        } //Rebound effect of drag offset 


        switch (direction) {
          case 'panleft':
            if (ev.deltaX > -eachItemNewWidth / 4 && ev.deltaX < 0) {
              elAnim = false;
              itemUpdates($sliderWrapper, ev.deltaX, 0.1, true);
            } else {
              elAnim = currentIsFirstOrLast ? false : true;
            }

            break;

          case 'panup':
            if (ev.deltaY > -eachItemNewHeight / 4 && ev.deltaY < 0) {
              elAnim = false;
              itemUpdates($sliderWrapper, ev.deltaY, 0.1, true);
            } else {
              elAnim = currentIsFirstOrLast ? false : true;
            }

            break;

          case 'panright':
            if (ev.deltaX < eachItemNewWidth / 4 && ev.deltaX > 0) {
              elAnim = false;
              itemUpdates($sliderWrapper, ev.deltaX, 0.1, true);
            } else {
              elAnim = currentIsFirstOrLast ? false : true;
            }

            break;

          case 'pandown':
            if (ev.deltaY < eachItemNewHeight / 4 && ev.deltaY > 0) {
              elAnim = false;
              itemUpdates($sliderWrapper, ev.deltaY, 0.1, true);
            } else {
              elAnim = currentIsFirstOrLast ? false : true;
            }

            break;
        }
      });
      dragDropMC.on('panend', function (ev) {
        if (elAnim) {
          //Use the direction in here
          //You know the pan has ended
          //and you know which action they were taking
          switch (direction) {
            case 'panleft':
            case 'panup':
              var delta1 = sliderDir === 'horizontal' ? -eachItemNewWidth : -eachItemNewHeight;
              itemUpdates($sliderWrapper, delta1, null, false);
              break;

            case 'panright':
            case 'pandown':
              var delta2 = sliderDir === 'horizontal' ? eachItemNewWidth : eachItemNewHeight;
              itemUpdates($sliderWrapper, delta2, null, false);
              break;
          }
        } else {
          itemUpdates($sliderWrapper, 0, null, false);
        }
      });
      /*
       * Transition Between Items
       *
       * @param  {Element} wrapper        - Wrapper of slider.
                * @param  {Number} delta           - The value returned will need to be adjusted according to the offset rate.
                * @param  {?Number} speed          - Sliding speed. Please set to 0 when rebounding.
                * @param  {Boolean} dragging       - Determine if the object is being dragged.
       * @return {Void}
       */

      function itemUpdates(wrapper, delta, speed, dragging) {
        if (speed == null) speed = sliderSpeed / 1000;
        var $curWrapper = wrapper.children('.uix-multi-carousel__items'),
            //Default: $slider
        $curItems = $curWrapper.find('> div'); //Default: $sliderItem
        //Clone the first element to the last position

        if (sliderDir === 'horizontal') {
          var boxWidth = eachItemNewWidth;
          var wrapWidth = ($curItems.length - 1) * boxWidth;
          TweenMax.to($curItems, speed, {
            x: function x(i, target) {
              var x = Math.round(target._gsTransform.x / boxWidth) * boxWidth;
              return x + delta;
            },
            modifiers: {
              x: function x(_x, target) {
                if (sliderLoop) {
                  //Active the center item
                  if (_x === midIndex * boxWidth) {
                    TweenMax.set(target, {
                      className: "+=is-active"
                    });
                  } else {
                    TweenMax.set(target, {
                      className: "-=is-active"
                    });
                  }

                  return wrap(_x, -boxWidth, wrapWidth);
                } else {
                  return _x;
                }
              }
            },
            onComplete: function onComplete() {
              if (!dragging && delta != 0) {
                //The state of the control button
                setButtonState(Math.round($curItems.first()[0]._gsTransform.x), Math.round(($curItems.length - amountVisible) * boxWidth));
              }
            }
          });
        } else {
          var boxHeight = eachItemNewHeight;
          var wrapHeight = ($curItems.length - 1) * boxHeight;
          TweenMax.to($curItems, speed, {
            y: function y(i, target) {
              var y = Math.round(target._gsTransform.y / boxHeight) * boxHeight;
              return y + delta;
            },
            modifiers: {
              y: function y(_y, target) {
                if (sliderLoop) {
                  //Active the center item
                  if (_y === midIndex * boxHeight) {
                    TweenMax.set(target, {
                      className: "+=is-active"
                    });
                  } else {
                    TweenMax.set(target, {
                      className: "-=is-active"
                    });
                  }

                  return wrap(_y, -boxHeight, wrapHeight);
                } else {
                  return _y;
                }
              }
            },
            onComplete: function onComplete() {
              if (!dragging && delta != 0) {
                //The state of the control button
                setButtonState(Math.round($curItems.first()[0]._gsTransform.y), Math.round(($curItems.length - amountVisible) * boxHeight));
              }
            }
          });
        }
      }
      /*
       * Move function with buttons
       *
       * @param  {Element} $btn               - The button that currently triggers the move.
                * @param  {String} type                - Move next or previous.
       * @return {Void}
       */


      function movePositionWithButton($btn, type) {
        var //Protection button is not triggered multiple times.
        btnDisabled = $btn.data('disabled');
        var delta;

        if (type == 'next') {
          delta = sliderDir === 'horizontal' ? -eachItemNewWidth : -eachItemNewHeight;
        } else {
          delta = sliderDir === 'horizontal' ? eachItemNewWidth : eachItemNewHeight;
        }

        if ((0,esm_typeof/* default */.Z)(btnDisabled) === ( true ? "undefined" : 0)) {
          itemUpdates($sliderWrapper, delta, null, false);
        }
      }
      /*
       * The state of the control button
       *
                * @param  {Number} firstOffset          - Get the computed Translate X or Y values of a given first DOM element.
                * @param  {Number} lastOffset           - Get the computed Translate X or Y values of a given last DOM element.
       * @return {Void}
       */


      function setButtonState(firstOffset, lastOffset) {
        if (sliderLoop) return false;

        if (Math.abs(firstOffset) == lastOffset) {
          $(sliderNext).addClass('is-disabled').data('disabled', 1);
          $(sliderPrev).removeClass('is-disabled').removeData('disabled');
        } else if (Math.round(firstOffset) == 0) {
          $(sliderNext).removeClass('is-disabled').removeData('disabled');
          $(sliderPrev).addClass('is-disabled').data('disabled', 1);
        } else {
          $(sliderNext).removeClass('is-disabled').removeData('disabled');
          $(sliderPrev).removeClass('is-disabled').removeData('disabled');
        }
      }
      /*
       * Tweens each box to a relative x/y position of "+={number}"
       *
       * @param  {Number} value           - Current position of the element, x or y coordinates.
       * @param  {Number} min             - The minimum value, used to mark the width or height of each element.
       * @param  {Number} max             - The maximum value, used to mark the width or height of the entire container.
       * @return {Number}                 - The about-to-be-applied value from the regular tween.
       */


      function wrap(value, min, max) {
        var v = value - min;
        var r = max - min; // force x/y value to be between {min} and {max} using modulus

        return (r + v % r) % r + min;
      }
    });
  };

  module.components.documentReady.push(module.MULTI_ITEMS_CAROUSEL.documentReady);
  return /*#__PURE__*/_createClass(function MULTI_ITEMS_CAROUSEL() {
    _classCallCheck(this, MULTI_ITEMS_CAROUSEL);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/one-page/js/index.js



/* 
 *************************************
 * <!-- Full Page/One Page Transition -->
 *************************************
 */


var ONEPAGE = function (module, $, window, document) {
  if (window.ONEPAGE === null) return false;
  module.ONEPAGE = module.ONEPAGE || {};
  module.ONEPAGE.version = '0.1.1';

  module.ONEPAGE.documentReady = function ($) {
    var windowWidth = window.innerWidth,
        windowHeight = window.innerHeight; //Determine the direction of a jQuery scroll event
    //Fix an issue for mousewheel event is too fast.

    var quietPeriod = 500,
        //Do not change it
    animationTime = 1000,
        //According to page transition animation changes
    $sectionsContainer = $('.uix-normal-load__onepage-container'),
        $sections = $sectionsContainer.find('[data-highlight-section]'),
        sectionTotal = $sections.length,

    /* topSpacing         = ( window.innerWidth <= 768 ) ? 0 : $( '.uix-header__container' ).outerHeight( true ), //with margin */
    topSpacing = 0,
        $primaryMenu = $('.uix-menu'),
        $sidefixedMenu = $('.uix-menu-sidefixed');
    var lastAnimation = 0; //Prevent this module from loading in other pages

    if ($sectionsContainer.length == 0) return false; // Prepare everything before binding wheel scroll

    $.each($sections, function (i) {
      $(this).attr('data-index', i);

      if (i == 0) {
        $(this).addClass('is-active');
      }
    }); //Init the section location

    sectionStart(); //Detect URL change

    $(window).on('hashchange', function () {
      var hash = window.location.hash,
          locArr,
          loc;

      if (hash) {
        //Add hashchange event
        locArr = hash.split('section-');
        loc = locArr[1];
        moveTo($sectionsContainer, false, loc);
      }
    });
    /*
     * Init the section location
     *
     * @return {Void}
     */

    function sectionStart() {
      setTimeout(function () {
        var hash = window.location.hash,
            locArr,
            loc,
            curTab;

        if (hash) {
          //Add hashchange event
          locArr = hash.split('section-');
          loc = locArr[1];
          moveTo($sectionsContainer, false, loc);
        } else {
          moveTo($sectionsContainer, false, 1);
        }
      }, quietPeriod);
    }
    /*
     * Scroll initialize
     *
     * @param  {Event} event        - The wheel event is fired when a wheel button of a pointing device (usually a mouse) is rotated. 
     * @param  {String} dir          - Gets a value that indicates the amount that the mouse wheel has changed.
     * @return {Void}
     */


    function scrollMoveInit(event, dir) {
      var timeNow = new Date().getTime(); // Cancel scroll if currently animating or within quiet period

      if (timeNow - lastAnimation < quietPeriod + animationTime) {
        return;
      }

      if (dir == 'down') {
        //scroll down
        moveTo($sectionsContainer, 'down', false);
      } else {
        //scroll up
        moveTo($sectionsContainer, 'up', false);
      }

      lastAnimation = timeNow;
    }
    /*
     * Move Animation
     *
     * @param  {Element} el           - The container of each sections.
     * @param  {String} dir          - Rolling direction indicator.
     * @param  {Number} hashID       - ID of custom hashchange event.
     * @return {Void}
     */


    function moveTo(el, dir, hashID) {
      var index = parseFloat($sections.filter('.is-active').attr('data-index')),
          isNumeric = /^[-+]?(\d+|\d+\.\d*|\d*\.\d+)$/;
      var nextIndex = null,
          $next = null;

      if (dir == 'down' || dir === false) {
        nextIndex = index + 1;
      } else {
        nextIndex = index - 1;
      } //ID of custom hashchange event


      if (isNumeric.test(hashID)) nextIndex = parseFloat(hashID - 1);

      if (nextIndex <= parseFloat(sectionTotal - 1) && nextIndex >= 0) {
        if (nextIndex > parseFloat(sectionTotal - 1)) nextIndex = parseFloat(sectionTotal - 1);
        if (nextIndex < 0) nextIndex = 0; //Returns the target section

        $next = $sections.eq(nextIndex); //Smooth scroll to content

        if ($next.length > 0) {
          TweenMax.to(window, animationTime / 1000, {
            scrollTo: {
              y: $next.offset().top - topSpacing,
              autoKill: false
            },
            ease: Power2.easeOut,
            onComplete: function onComplete() {
              $sections.removeClass('leave');
              $sections.eq(index).addClass('leave');
              $sections.removeClass('is-active');
              $next.addClass('is-active').removeClass('leave'); //Changing The Site URL

              var curSectionIndex = $sections.filter('.is-active').index() + 1,
                  href = window.location.href.substr(0, window.location.href.indexOf('#')) + '#' + $sections.filter('.is-active').attr('id'); // Save state on history stack
              // - First argument is any object that will let you restore state
              // - Second argument is a title (not the page title, and not currently used)
              // - Third argument is the URL - this will appear in the browser address bar

              history.pushState({}, document.title, href);
              console.log('Section ' + curSectionIndex + ' loaded!');
            }
          });
        }
      }
    }
    /* 
     ====================================================
     *  Navigation Interaction
     ====================================================
     */


    goPageSection($primaryMenu);
    goPageSection($sidefixedMenu); //Activate the first item

    $primaryMenu.find('li:first').addClass('is-active');
    $sidefixedMenu.find('li:first').addClass('is-active');
    /*
     * Get section or article by href
     *
     * @param  {String|Object} el  - The current selector or selector ID
     * @return {Object}             - A new selector.
     */

    function getRelatedContent(el) {
      return $($(el).attr('href'));
    }
    /*
     * Get link by section or article id
     *
     * @param  {String|Element} el    - The current selector or selector ID
     * @param  {Element} menuObj       - Returns the menu element within the document.
     * @param  {Boolean} echoIndex    - Whether to return the current index.
     * @return {Object}               - A new selector.
     */


    function getRelatedNavigation(el, menuObj, echoIndex) {
      if (echoIndex) {
        return menuObj.find('li > a[href="#' + $(el).attr('id') + '"]').parent('li').index();
      } else {
        return menuObj.find('li > a[href="#' + $(el).attr('id') + '"]').parent('li');
      }
    }
    /*
     * Get all links by section or article
     *
     * @param  {Element} menuObj     - Returns the menu element within the document.
     * @return {Element}             - A new selector.
     */


    function getAllNavigation(menuObj) {
      return menuObj.find('li');
    }
    /*
     * Smooth scroll to content
     *
     * @param  {Element} menuObj     - Returns the menu element within the document.
     * @return {Void}
     */


    function goPageSection(menuObj) {
      menuObj.find('li > a').off('click.ONEPAGE').on('click.ONEPAGE', function (e) {
        e.preventDefault();
        if ($(this).parent().hasClass('is-active')) return false;
        moveTo($sectionsContainer, false, $(this).parent('li').index() + 1);
      });
    }

    var navMinTop = $sidefixedMenu.length > 0 ? $sidefixedMenu.offset().top : 0,
        navMaxTop = parseFloat($(document).height() - $('.uix-footer__container').height()) - windowHeight / 3;

    function scrollUpdate() {
      var scrolled = $(window).scrollTop(),
          spyTop = parseFloat(scrolled + topSpacing),
          minTop = $('[data-highlight-section="true"]').first().offset().top,
          maxTop = $('[data-highlight-section="true"]').last().offset().top + $('[data-highlight-section="true"]').last().height();
      $('[data-highlight-section="true"]').each(function () {
        var $block = $(this),
            eleTop = $block.offset().top; // The 1 pixel in order to solve inaccurate value of outerHeight() 
        // in Safari and Firefox browsers.

        if (eleTop < spyTop + 1) {
          // Highlight element when related content
          getAllNavigation($primaryMenu).removeClass('is-active');
          getAllNavigation($sidefixedMenu).removeClass('is-active');
          getRelatedNavigation($block, $primaryMenu, false).addClass('is-active');
          getRelatedNavigation($block, $sidefixedMenu, false).addClass('is-active');
        }
      }); //Cancel the current highlight element
      // The 1 pixel in order to solve inaccurate value of outerHeight() 
      // in Safari and Firefox browsers.

      if (spyTop > maxTop || spyTop < minTop - 1) {
        getAllNavigation($primaryMenu).removeClass('is-active');
        getAllNavigation($sidefixedMenu).removeClass('is-active');
      } //Detecting when user scrolls to bottom of div


      if (spyTop > navMaxTop || spyTop < navMinTop) {
        $sidefixedMenu.removeClass('is-fixed');
      } else {
        $sidefixedMenu.addClass('is-fixed');
      }
    } // Add function to the element that should be used as the scrollable area.


    var throttleFunc = UixThrottle(scrollUpdate, 5);
    window.removeEventListener('scroll', throttleFunc);
    window.removeEventListener('touchmove', throttleFunc);
    window.addEventListener('scroll', throttleFunc);
    window.addEventListener('touchmove', throttleFunc);
    throttleFunc();
    /* 
     ====================================================
     *  Mouse Wheel & Touch Method
     ====================================================
     */

    var startY = 0;

    var onTouchStart = function onTouchStart(e) {
      var touches = e.touches;

      if (touches && touches.length) {
        startY = touches[0].pageY;
      }
    };

    var onDeviceWheel = function onDeviceWheel(e) {
      //Gets a value that indicates the amount that the mouse wheel has changed.
      var dir,
          delta,
          mobileDeltaY = null;
      var touches = e.touches;

      if (touches && touches.length) {
        mobileDeltaY = startY - touches[0].pageY;
      } else {
        delta = Math.max(-1, Math.min(1, -e.deltaY));
      }

      if (mobileDeltaY != null) {
        if (mobileDeltaY >= 50) {
          //--- swipe up
          dir = 'up';
        }

        if (mobileDeltaY <= -50) {
          //--- swipe down
          dir = 'down';
        }
      } else {
        if (delta < 0) {
          //scroll down
          dir = 'down';
        } else {
          //scroll up
          dir = 'up';
        }
      }

      scrollMoveInit(e, dir);
    };

    window.addEventListener('wheel', onDeviceWheel, {
      passive: true
    });
    window.addEventListener('touchstart', onTouchStart, {
      passive: true
    });
    window.addEventListener('touchmove', onDeviceWheel, {
      passive: true
    });
  };

  module.components.documentReady.push(module.ONEPAGE.documentReady);
  return /*#__PURE__*/_createClass(function ONEPAGE() {
    _classCallCheck(this, ONEPAGE);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/one-page2/js/index.js



/* 
 *************************************
 * <!-- Full Page/One Page Transition 2 -->
 *************************************
 */

var ONEPAGE2 = function (module, $, window, document) {
  if (window.ONEPAGE2 === null) return false;
  module.ONEPAGE2 = module.ONEPAGE2 || {};
  module.ONEPAGE2.version = '0.0.7';

  module.ONEPAGE2.documentReady = function ($) {
    var windowWidth = window.innerWidth,
        windowHeight = window.innerHeight; //Determine the direction of a jQuery scroll event
    //Fix an issue for mousewheel event is too fast.

    var quietPeriod = 500,
        //Do not change it
    animationTime = 1000,
        //According to page transition animation changes
    $sectionsContainer = $('.uix-normal-load__onepage-container2'),
        $sections = $sectionsContainer.find('[data-highlight-section]'),
        sectionTotal = $sections.length,
        $primaryMenu = $('.uix-menu'),
        $sidefixedMenu = $('.uix-menu-sidefixed');
    var lastAnimation = 0; //Prevent this module from loading in other pages

    if ($sectionsContainer.length == 0) return false; //Init the sections style

    $sectionsContainer.css({
      'position': 'relative'
    });
    var secIndex = 10;

    for (var i = 0; i < sectionTotal; i++) {
      $sections.eq(i).css({
        'position': 'absolute',
        'width': '100%',
        'z-index': secIndex,
        'top': 0,
        'left': 0
      });
      secIndex--;
    } // Prepare everything before binding wheel scroll


    $.each($sections, function (i) {
      $(this).attr('data-index', i);

      if (i == 0) {
        $(this).addClass('is-active');
      }
    }); //Init the section location

    sectionStart(); //Detect URL change

    $(window).on('hashchange', function () {
      var hash = window.location.hash,
          locArr,
          loc;

      if (hash) {
        //Add hashchange event
        locArr = hash.split('section-');
        loc = locArr[1];
        moveTo($sectionsContainer, false, loc);
      }
    });
    /*
     * Init the section location
     *
     * @return {Void}
     */

    function sectionStart() {
      setTimeout(function () {
        var hash = window.location.hash,
            locArr,
            loc,
            curTab;

        if (hash) {
          //Add hashchange event
          locArr = hash.split('section-');
          loc = locArr[1];
          moveTo($sectionsContainer, false, loc);
        } else {
          moveTo($sectionsContainer, false, 1);
        }
      }, quietPeriod);
    }
    /*
     * Initialize the depth of all sections
     *
     * @param  {Number} nextIndex        - Index of next section.
     * @param  {Number} currentIndex     - Index of current section.
     * @return {Void}
     */


    function sectionsDepthInit(nextIndex, currentIndex) {
      var secIndex = 10;

      for (var _i = 0; _i < sectionTotal; _i++) {
        if (nextIndex && _i != nextIndex && _i != currentIndex) {
          $sections.eq(_i).css('z-index', secIndex);
        }

        secIndex--;
      }
    }
    /*
     * Scroll initialize
     *
     * @param  {Event} event        - The wheel event is fired when a wheel button of a pointing device (usually a mouse) is rotated. 
     * @param  {String} dir          - Gets a value that indicates the amount that the mouse wheel has changed.
     * @return {Void}
     */


    function scrollMoveInit(event, dir) {
      var timeNow = new Date().getTime(); // Cancel scroll if currently animating or within quiet period

      if (timeNow - lastAnimation < quietPeriod + animationTime) {
        return;
      }

      if (dir == 'down') {
        //scroll down
        moveTo($sectionsContainer, 'down', false);
      } else {
        //scroll up
        moveTo($sectionsContainer, 'up', false);
      }

      lastAnimation = timeNow;
    }
    /*
     * Move Animation
     *
     * @param  {Element} el           - The container of each sections.
     * @param  {String} dir          - Rolling direction indicator.
     * @param  {Number} hashID       - ID of custom hashchange event.
     * @return {Void}
     */


    function moveTo(el, dir, hashID) {
      var index = parseFloat($sections.filter('.is-active').attr('data-index')),
          isNumeric = /^[-+]?(\d+|\d+\.\d*|\d*\.\d+)$/;
      var nextIndex = null,
          $next = null;

      if (dir == 'down' || dir === false) {
        nextIndex = index + 1;
      } else {
        nextIndex = index - 1;
      } //ID of custom hashchange event


      if (isNumeric.test(hashID)) nextIndex = parseFloat(hashID - 1);

      if (nextIndex <= parseFloat(sectionTotal - 1) && nextIndex >= 0) {
        if (nextIndex > parseFloat(sectionTotal - 1)) nextIndex = parseFloat(sectionTotal - 1);
        if (nextIndex < 0) nextIndex = 0; //Returns the target section

        $next = $sections.eq(nextIndex);

        if ($next.length > 0) {
          TweenMax.set($next, {
            css: {
              'z-index': 12,
              'top': dir == 'down' || dir === false ? windowHeight : -windowHeight
            },
            onComplete: function onComplete() {
              //Reset sections z-index
              $sections.eq(index).css('z-index', 11);
              sectionsDepthInit(nextIndex, index);
              TweenMax.to($sections.eq(index), animationTime / 1000, {
                css: {
                  'top': dir == 'down' || dir === false ? -windowHeight / 2 : windowHeight / 2
                },
                ease: Power2.easeOut
              });
              TweenMax.to(this.target, animationTime / 2000, {
                css: {
                  'top': 0
                },
                ease: Power2.easeOut,
                onComplete: function onComplete() {
                  $sections.removeClass('leave');
                  $sections.eq(index).addClass('leave');
                  $sections.removeClass('is-active');
                  $next.addClass('is-active').removeClass('leave'); //Changing The Site URL

                  var curSectionIndex = $sections.filter('.is-active').index() + 1,
                      href = window.location.href.substr(0, window.location.href.indexOf('#')) + '#' + $sections.filter('.is-active').attr('id'); // Save state on history stack
                  // - First argument is any object that will let you restore state
                  // - Second argument is a title (not the page title, and not currently used)
                  // - Third argument is the URL - this will appear in the browser address bar

                  history.pushState({}, document.title, href);
                  console.log('Section ' + curSectionIndex + ' loaded!'); // Highlight element when related content

                  getAllNavigation($primaryMenu).removeClass('is-active');
                  getAllNavigation($sidefixedMenu).removeClass('is-active');
                  $primaryMenu.find('li').eq(nextIndex).addClass('is-active');
                  $sidefixedMenu.find('li').eq(nextIndex).addClass('is-active');
                }
              });
            }
          });
        }
      }
    }
    /* 
     ====================================================
     *  Navigation Interaction
     ====================================================
     */


    goPageSection($primaryMenu);
    goPageSection($sidefixedMenu); //Activate the first item

    $primaryMenu.find('li:first').addClass('is-active');
    $sidefixedMenu.find('li:first').addClass('is-active');
    /*
     * Get section or article by href
     *
     * @param  {String|Object} el  - The current selector or selector ID
     * @return {Object}             - A new selector.
     */

    function getRelatedContent(el) {
      return $($(el).attr('href'));
    }
    /*
     * Get all links by section or article
     *
     * @param  {Element} menuObj     - Returns the menu element within the document.
     * @return {Element}             - A new selector.
     */


    function getAllNavigation(menuObj) {
      return menuObj.find('li');
    }
    /*
     * Smooth scroll to content
     *
     * @param  {Element} menuObj     - Returns the menu element within the document.
     * @return {Void}
     */


    function goPageSection(menuObj) {
      menuObj.find('li > a').off('click.ONEPAGE2').on('click.ONEPAGE2', function (e) {
        e.preventDefault();
        if ($(this).parent().hasClass('is-active')) return false;
        var dir = 'down';

        if ($sections.filter('.is-active').index() > $(this).parent().index()) {
          dir = 'up';
        }

        moveTo($sectionsContainer, dir, $(this).parent('li').index() + 1);
      });
    }
    /* 
     ====================================================
     *  Mouse Wheel & Touch Method
     ====================================================
     */


    var startY = 0;

    var onTouchStart = function onTouchStart(e) {
      var touches = e.touches;

      if (touches && touches.length) {
        startY = touches[0].pageY;
      }
    };

    var onDeviceWheel = function onDeviceWheel(e) {
      //Gets a value that indicates the amount that the mouse wheel has changed.
      var dir,
          delta,
          mobileDeltaY = null;
      var touches = e.touches;

      if (touches && touches.length) {
        mobileDeltaY = startY - touches[0].pageY;
      } else {
        delta = Math.max(-1, Math.min(1, -e.deltaY));
      }

      if (mobileDeltaY != null) {
        if (mobileDeltaY >= 50) {
          //--- swipe up
          dir = 'up';
        }

        if (mobileDeltaY <= -50) {
          //--- swipe down
          dir = 'down';
        }
      } else {
        if (delta < 0) {
          //scroll down
          dir = 'down';
        } else {
          //scroll up
          dir = 'up';
        }
      }

      scrollMoveInit(e, dir);
    };

    window.addEventListener('wheel', onDeviceWheel, UixBrowser.supportsPassive ? {
      passive: true
    } : false);
    window.addEventListener('touchstart', onTouchStart, UixBrowser.supportsPassive ? {
      passive: true
    } : false);
    window.addEventListener('touchmove', onDeviceWheel, UixBrowser.supportsPassive ? {
      passive: true
    } : false);
  };

  module.components.documentReady.push(module.ONEPAGE2.documentReady);
  return /*#__PURE__*/_createClass(function ONEPAGE2() {
    _classCallCheck(this, ONEPAGE2);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/parallax/js/index.js




/* 
 *************************************
 * <!-- Parallax -->
 *************************************
 */



var PARALLAX = function (module, $, window, document) {
  if (window.PARALLAX === null) return false;
  module.PARALLAX = module.PARALLAX || {};
  module.PARALLAX.version = '0.0.8';

  module.PARALLAX.documentReady = function ($) {
    var windowWidth = window.innerWidth,
        windowHeight = window.innerHeight; //  Initialize

    parallaxInit(windowWidth);

    function windowUpdate() {
      // Check window width has actually changed and it's not just iOS triggering a resize event on scroll
      if (window.innerWidth != windowWidth) {
        // Update the window width for next time
        windowWidth = window.innerWidth; // Do stuff here

        parallaxInit(windowWidth);
      }
    } // Add function to the window that should be resized


    var debounceFuncWindow = UixDebounce(windowUpdate, 50);
    window.removeEventListener('resize', debounceFuncWindow);
    window.addEventListener('resize', debounceFuncWindow);
    /*
     * Initialize parallx settings
     *
     * @param  {Number} w         - Returns width of browser viewport
     * @return {Void}
     */

    function parallaxInit(w) {
      /* Pure parallax scrolling effect without other embedded HTML elements */
      $('.uix-parallax--el').each(function () {
        var $this = $(this);
        var dataSpeed = $this.data('speed'),
            dataEasing = $this.data('transition');

        if ((0,esm_typeof/* default */.Z)(dataSpeed) === ( true ? "undefined" : 0)) {
          dataSpeed = 0;
        }

        if ((0,esm_typeof/* default */.Z)(dataEasing) === ( true ? "undefined" : 0)) {
          dataEasing = 'none 0s ease 0s';
        }

        $this.UixParallax({
          'speed': dataSpeed,
          'bg': false,
          transition: dataEasing
        });
      });
      /* Parallax scrolling effect with embedded HTML elements */

      $('.uix-parallax').each(function () {
        var $this = $(this);
        var $curImg = $this.find('.uix-parallax__img'),
            dataImg = $curImg.attr('src');
        var dataSkew = $this.data('skew'),
            dataSpeed = $this.data('speed'),
            dataEasing = $this.data('transition'),
            dataOverlay = $this.data('overlay-bg'),
            dataFullyVisible = $this.data('fully-visible'),
            dataXPos = $this.data('xpos'),
            dataOffsetTop = parseFloat($this.data('offset-top')),
            curImgH = null,
            curImgW = null,
            curSize = 'cover';

        if ((0,esm_typeof/* default */.Z)(dataOverlay) === ( true ? "undefined" : 0) || dataOverlay == 'none' || dataOverlay == 0 || dataOverlay == false) {
          dataOverlay = 'rgba(0, 0, 0, 0)';
        }

        if ((0,esm_typeof/* default */.Z)(dataSpeed) === ( true ? "undefined" : 0)) {
          // If there is no data-xxx, save current source to it
          dataSpeed = 0;
        }

        if ((0,esm_typeof/* default */.Z)(dataEasing) === ( true ? "undefined" : 0)) {
          dataEasing = 'none 0s ease 0s';
        }

        if ((0,esm_typeof/* default */.Z)(dataXPos) === ( true ? "undefined" : 0)) {
          dataXPos = '50%';
        }

        if ((0,esm_typeof/* default */.Z)(dataOffsetTop) === ( true ? "undefined" : 0)) {
          dataOffsetTop = 0;
        }

        if ((0,esm_typeof/* default */.Z)(dataFullyVisible) === ( true ? "undefined" : 0)) {
          dataFullyVisible = false;
        } //Trigger a callback when the selected images are loaded
        //Check if the picture is loaded on the page


        var img = new Image();

        img.onload = function () {
          curImgH = $curImg.height();
          curImgW = $curImg.width(); //Custom height for parallax container

          if ($this.hasClass('uix-height--10') || $this.hasClass('uix-height--20') || $this.hasClass('uix-height--30') || $this.hasClass('uix-height--40') || $this.hasClass('uix-height--50') || $this.hasClass('uix-height--60') || $this.hasClass('uix-height--70') || $this.hasClass('uix-height--80') || $this.hasClass('uix-height--90') || $this.hasClass('uix-height--100')) {
            var newH = $this.height();
            $this.css({
              'height': newH + 'px'
            });
            $curImg.css('max-height', newH + 'px');
          } else {
            $this.css({
              'height': $this.height() + 'px'
            });
          } //If the ".uix-v-align--absolute" has more content


          if (w <= 768) {
            if ($this.find('.uix-v-align--absolute').height() >= curImgH) {
              $this.find('.uix-v-align--absolute').addClass('uix-v-align--relative');
              $curImg.hide();
            }
          } //Resize the background image to cover the entire container and
          //Resize the background image to make sure the image is fully visible


          if (curImgW > w) {
            curSize = 'contain';
          } else {
            curSize = 'cover';
          } //Determine image height and parallax container height
          //If the height is the same, higher or lower than the height of the container height, 
          //be sure to use the cover attribute
          //*** Must be placed before the "dataFullyVisible" condition


          if (curImgH <= $this.height()) {
            curSize = 'cover';
          } //Whether to display all pictures, including the edges


          if (dataFullyVisible) {
            if (curImgW < w) {
              curSize = 'cover';
            } else {
              curSize = 'contain';
            }
          } //console.log( 'Height: ' +curImgH + '===' + $this.height() + ' | Width: ' + curImgW + '===' + w + ' | ' + curSize );
          //Add background image to parallax container


          if ((0,esm_typeof/* default */.Z)(dataImg) != ( true ? "undefined" : 0)) {
            if (Modernizr.cssanimations) {
              // supported
              $this.css({
                'background': 'linear-gradient(' + dataOverlay + ', ' + dataOverlay + '), url(' + dataImg + ') ' + dataXPos + ' ' + dataOffsetTop + 'px/' + curSize + ' no-repeat fixed'
              });
            } else {
              // not-supported
              $this.css({
                'background': 'url(' + dataImg + ') ' + dataXPos + ' ' + dataOffsetTop + 'px/' + curSize + ' no-repeat fixed'
              });
            }
          } //Apply tilt effect


          if ((0,esm_typeof/* default */.Z)(dataSkew) != ( true ? "undefined" : 0) && dataSkew != 0) {
            //Firefox browser will affect parallax effect due to transform
            $this.css({
              'transform': 'skew(0deg, ' + dataSkew + 'deg)'
            });
          } //Use parallax to background


          $this.UixParallax({
            'speed': dataSpeed,
            'transition': dataEasing,
            'offsetTop': dataOffsetTop,
            'bg': {
              enable: true,
              xPos: dataXPos
            }
          });
        };

        img.src = dataImg;
      });
    }
  };

  module.components.documentReady.push(module.PARALLAX.documentReady);
  return /*#__PURE__*/_createClass(function PARALLAX() {
    _classCallCheck(this, PARALLAX);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/periodical-scroll/js/index.js




/* 
 *************************************
 * <!-- Periodical Scroll -->
 *************************************
 */


var PERIODICAL_SCROLL = function (module, $, window, document) {
  if (window.PERIODICAL_SCROLL === null) return false;
  module.PERIODICAL_SCROLL = module.PERIODICAL_SCROLL || {};
  module.PERIODICAL_SCROLL.version = '0.0.5';

  module.PERIODICAL_SCROLL.documentReady = function ($) {
    $('.uix-periodical-scroll').each(function () {
      var $this = $(this);
      var speed = $this.data('speed'),
          timing = $this.data('timing');
      var $list = $this.find('> ul');
      var itemHeight = $list.find('li:first').height();
      $this.css({
        'height': itemHeight + 'px',
        'overflow': 'hidden'
      });

      if ((0,esm_typeof/* default */.Z)(speed) === ( true ? "undefined" : 0)) {
        speed = 600;
      }

      if ((0,esm_typeof/* default */.Z)(timing) === ( true ? "undefined" : 0)) {
        timing = 2000;
      } //If there is only one item, add one to complete the seamless loop effect


      if ($list.find('li').length == 1) {
        $list.prepend($list.find('li:first').clone());
      } //


      var eachItemAnimOKDelay = 150;
      var $item = $list.find('> li');
      var moveY = itemHeight * 2; //Prevent repetition of animation events

      TweenMax.killTweensOf($item); //

      var tl = new TimelineMax({
        repeat: -1,
        repeatDelay: eachItemAnimOKDelay / 1000
      }); //pauses wherever the playhead currently is:

      tl.pause();
      setTimeout(function () {
        tl.play();
      }, speed);
      tl.add(TweenMax.staggerFromTo($item, speed / 1000, {
        opacity: 0,
        y: moveY
      }, {
        opacity: 1,
        y: 0
      }, timing / 1000)).add(TweenMax.staggerTo($item, speed / 1000, {
        delay: timing / 1000,
        opacity: 0,
        y: -moveY,
        onComplete: function onComplete() {
          TweenMax.set(this.target, {
            delay: eachItemAnimOKDelay / 1000,
            opacity: 0,
            y: moveY
          });
        }
      }, timing / 1000), 0);
      $item.on('mouseenter', function () {
        tl.pause();
      }).on('mouseleave', function () {
        tl.play();

        if ($(this).index() > 0) {
          TweenMax.set($item.first(), {
            opacity: 0,
            y: moveY
          });
        }
      });
    });
  };

  module.components.documentReady.push(module.PERIODICAL_SCROLL.documentReady);
  return /*#__PURE__*/_createClass(function PERIODICAL_SCROLL() {
    _classCallCheck(this, PERIODICAL_SCROLL);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/pricing/js/index.js



/* 
 *************************************
 * <!-- Pricing -->
 *************************************
 */


var PRICING = function (module, $, window, document) {
  if (window.PRICING === null) return false;
  module.PRICING = module.PRICING || {};
  module.PRICING.version = '0.0.3';

  module.PRICING.documentReady = function ($) {
    var windowWidth = window.innerWidth,
        windowHeight = window.innerHeight; //-------- Pricing initialize

    pricingInit(windowWidth);

    function windowUpdate() {
      // Check window width has actually changed and it's not just iOS triggering a resize event on scroll
      if (window.innerWidth != windowWidth) {
        // Update the window width for next time
        windowWidth = window.innerWidth; // Do stuff here

        pricingInit(windowWidth);
      }
    } // Add function to the window that should be resized


    var debounceFuncWindow = UixDebounce(windowUpdate, 50);
    window.removeEventListener('resize', debounceFuncWindow);
    window.addEventListener('resize', debounceFuncWindow);

    function pricingInit(w) {
      //Initialize the height
      $('.uix-price').each(function () {
        //returns new id
        var $this = $(this);
        var $initHeight = $this.find('.js-uix-init-height');
        var priceBGH = [],
            priceBGH_excerpt = [];
        $initHeight.each(function (index) {
          //Screen protection of height
          $(this).find('.uix-price__outline, .uix-price__excerpt').css('height', 'auto');
          var tempheight = $(this).height();
          var tempheight_excerpt = $(this).find('.uix-price__excerpt').height();
          priceBGH.push(tempheight);
          priceBGH_excerpt.push(tempheight_excerpt);
        });
        var priceBGH_Max = Math.max.apply(Math, priceBGH);

        if (priceBGH_Max > 0) {
          if (w > 768) {
            // Initialize the height of all columns
            $initHeight.find('.uix-price__outline').css('height', priceBGH_Max + 'px'); // Actived columns

            $initHeight.find('.uix-price__outline.is-active').each(function () {
              var ty = Math.abs(parseInt($(this).css('transform').split(',')[5]));

              if (!isNaN(ty)) {
                $(this).css('height', priceBGH_Max + ty * 2 + 'px');
              }
            });
          } else {
            $initHeight.find('.uix-price__outline').css('height', 'auto');
          } // Actived columns


          $initHeight.find('.uix-price__outline.is-active').each(function () {
            var textColor = $(this).closest('.uix-price__outline--hover').data('tcolor'),
                btnColor = $(this).closest('.uix-price__outline--hover').data('bcolor');
            $(this).css('background-color', btnColor);
            $(this).find('.uix-btn').removeClass('uix-btn__bg--primary').addClass('uix-btn__bg--secondary');
          });
        }
      });
    }
  };

  module.components.documentReady.push(module.PRICING.documentReady);
  return /*#__PURE__*/_createClass(function PRICING() {
    _classCallCheck(this, PRICING);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/progress-bar/js/index.js




/* 
 *************************************
 * <!-- Progress Bar -->
 *************************************
 */


var PROGRESS_BAR = function (module, $, window, document) {
  if (window.PROGRESS_BAR === null) return false;
  module.PROGRESS_BAR = module.PROGRESS_BAR || {};
  module.PROGRESS_BAR.version = '0.0.7';

  module.PROGRESS_BAR.documentReady = function ($) {
    var $scrollElements = $('[data-progressbar-percent]');
    $scrollElements.each(function () {
      var viewport = 1;
      var $el = $(this); //

      var scrollUpdate = function scrollUpdate() {
        var spyTop = $el[0].getBoundingClientRect().top; //Prevent asynchronous loading of repeated calls

        var actived = $el.data('activated');

        if (spyTop < window.innerHeight * viewport) {
          if ((0,esm_typeof/* default */.Z)(actived) === ( true ? "undefined" : 0)) {
            var percent = $el.data('progressbar-percent'),
                unit = $el.data('progressbar-unit');

            if ((0,esm_typeof/* default */.Z)(percent) === ( true ? "undefined" : 0)) {
              percent = 0;
            }

            if ((0,esm_typeof/* default */.Z)(unit) === ( true ? "undefined" : 0)) {
              unit = '%';
            } //Radial Progress Bar


            if ($el.hasClass('uix-progressbar--circle')) {
              $el.find('.uix-progressbar__track').html('<span>' + percent + '<em class="uix-progressbar__unit">' + unit + '</em></span>');
              $el.addClass('uix-progressbar--progress-' + percent);
            } //Rectangle Progress Bar


            if ($el.hasClass('uix-progressbar--rectangle')) {
              $el.find('.uix-progressbar__bar > span').html('' + percent + '<em class="uix-progressbar__unit">' + unit + '</em>');
              $el.addClass('uix-progressbar--progress-' + percent);
            } //Prevents front-end javascripts that are activated in the background to repeat loading.


            $el.data('activated', 1);
          } //endif actived

        }
      }; // Add function to the element that should be used as the scrollable area.


      var throttleFunc = UixThrottle(scrollUpdate, 5);
      window.removeEventListener('scroll', throttleFunc);
      window.removeEventListener('touchmove', throttleFunc);
      window.addEventListener('scroll', throttleFunc);
      window.addEventListener('touchmove', throttleFunc);
      throttleFunc();
    }); //end each        
  };

  module.components.documentReady.push(module.PROGRESS_BAR.documentReady);
  return /*#__PURE__*/_createClass(function PROGRESS_BAR() {
    _classCallCheck(this, PROGRESS_BAR);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/progress-line/js/index.js



/* 
 *************************************
 * <!-- Progress Line -->
 *************************************
 */


var PROGRESS_LINE = function (module, $, window, document) {
  if (window.PROGRESS_LINE === null) return false;
  module.PROGRESS_LINE = module.PROGRESS_LINE || {};
  module.PROGRESS_LINE.version = '0.0.3';

  module.PROGRESS_LINE.documentReady = function ($) {
    var $obj = $('.uix-progress-line'),
        $progressLineCircle = $obj.find('.uix-progress-line__circle'),
        progressLineRestore = function progressLineRestore() {
      var k = 0;
      var progressLineAnimGo = setInterval(function () {
        $progressLineCircle.eq(k).addClass('is-active');
        $progressLineCircle.eq(k).next('.uix-progress-line__bar').addClass('is-active');
        k++;

        if (k == 10) {
          clearInterval(progressLineAnimGo);
        }
      }, 50);
    }; //


    $progressLineCircle.on('mouseenter', function () {
      var curIndex = $(this).index() / 2;
      $progressLineCircle.removeClass('is-active');
      $progressLineCircle.next('.uix-progress-line__bar').removeClass('is-active');

      for (var i = curIndex; i >= 0; i--) {
        $progressLineCircle.eq(i).addClass('is-active');
        $progressLineCircle.eq(i).next('.uix-progress-line__bar').addClass('is-active');
      }
    });
    $progressLineCircle.parent().on('mouseleave', function () {
      progressLineRestore();
    }); //Adapt line width for different resolution
    //		const plLength     = $progressLineCircle.length,
    //			  newPlW       = $obj.find( '.uix-progress-line__circle' ).first().width(),
    //			  plWrapperW   = $obj.width();
    //
    //		$obj.find( '.uix-progress-line__bar' ).css( 'width', parseFloat( plWrapperW - newPlW*plLength )/(plLength-1) + 'px' );
    //		
  };

  module.components.documentReady.push(module.PROGRESS_LINE.documentReady);
  return /*#__PURE__*/_createClass(function PROGRESS_LINE() {
    _classCallCheck(this, PROGRESS_LINE);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/retina/js/index.js



/* 
 *************************************
 * <!-- Retina Graphics for Website -->
 *************************************
 */

var RETINA = function (module, $, window, document) {
  if (window.RETINA === null) return false;
  module.RETINA = module.RETINA || {};
  module.RETINA.version = '0.0.1';

  module.RETINA.documentReady = function ($) {
    //Determine if you have retinal display
    var hasRetina = false,
        rootRetina = typeof exports === 'undefined' ? window : exports,
        mediaQuery = '(-webkit-min-device-pixel-ratio: 1.5), (min--moz-device-pixel-ratio: 1.5), (-o-min-device-pixel-ratio: 3/2), (min-resolution: 1.5dppx)';

    if (rootRetina.devicePixelRatio > 1 || rootRetina.matchMedia && rootRetina.matchMedia(mediaQuery).matches) {
      hasRetina = true;
    }

    if (hasRetina) {
      //do something
      $('[data-retina]').each(function () {
        $(this).attr({
          'src': $(this).data('retina')
        });
      });
    }
  };

  module.components.documentReady.push(module.RETINA.documentReady);
  return /*#__PURE__*/_createClass(function RETINA() {
    _classCallCheck(this, RETINA);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/rotating-elements/js/index.js




/* 
 *************************************
 * <!-- Rotating Elements -->
 *************************************
 */

var ROTATING_EL = function (module, $, window, document) {
  if (window.ROTATING_EL === null) return false;
  module.ROTATING_EL = module.ROTATING_EL || {};
  module.ROTATING_EL.version = '0.0.2';

  module.ROTATING_EL.documentReady = function ($) {
    $('[data-pointer-to-deg]').each(function () {
      var $this = $(this);
      var config = $this.data('pointer-to-deg');

      if ((0,esm_typeof/* default */.Z)(config) === ( true ? "undefined" : 0)) {
        config = false;
      }

      if (config) {
        if ($(config.target).length == 0) return false;
        var pointer = $(config.target)[0],
            pointerBox = pointer.getBoundingClientRect(),
            centerPoint = window.getComputedStyle(pointer).transformOrigin,
            centers = centerPoint.split(' ');
        var mouseX, mouseY;

        if (config.mouseSpy) {
          $(document).on('mousemove touchstart touchmove', function (e) {
            var pointerEvent = e;

            if (e.targetTouches && e.targetTouches[0]) {
              e.preventDefault();
              pointerEvent = e.targetTouches[0];
              mouseX = pointerEvent.pageX;
              mouseY = pointerEvent.pageY;
            } else {
              mouseX = e.clientX;
              mouseY = e.clientY;
            }

            var centerY = pointerBox.top + parseInt(centers[1]) - window.pageYOffset,
                centerX = pointerBox.left + parseInt(centers[0]) - window.pageXOffset,
                radians = Math.atan2(mouseX - centerX, mouseY - centerY),
                degrees = radians * (180 / Math.PI) * -1 + 180;
            pointer.style.transform = 'rotate(' + degrees + 'deg)';
          });
        }

        $this.off('click').on('click', function (e) {
          e.preventDefault();
          pointer.style.transform = 'rotate(' + config.deg + 'deg)';
        });
      }
    });
  };

  module.components.documentReady.push(module.ROTATING_EL.documentReady);
  return /*#__PURE__*/_createClass(function ROTATING_EL() {
    _classCallCheck(this, ROTATING_EL);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/scroll-reveal/js/index.js




/* 
 *************************************
 * <!-- Scroll Reveal -->
 *************************************
 */

var SCROLL_REVEAL = function (module, $, window, document) {
  if (window.SCROLL_REVEAL === null) return false;
  module.SCROLL_REVEAL = module.SCROLL_REVEAL || {};
  module.SCROLL_REVEAL.version = '0.1.6';

  module.SCROLL_REVEAL.documentReady = function ($) {
    //From JSON config in data attribute in HTML
    var $scrollElements = $('[data-uix-anim]');
    $scrollElements.each(function () {
      var viewport;
      var $el = $(this);
      var tl = new TimelineMax({
        paused: true
      }); //

      var config = $el.data('uix-anim');

      if ((0,esm_typeof/* default */.Z)(config) === ( true ? "undefined" : 0) || config == '' || config === false) {
        config = {
          "from": {
            "opacity": 0,
            "x": 70
          },
          "to": {
            "opacity": 1,
            "x": 0
          },
          "ease": "Power2.easeOut",
          "duration": 0.4,
          "delay": 0,
          "infinite": false,
          "viewport": '100%' //A percentage of the viewport's height.

        };
      } //get attributes to tweenMax


      var fromCSS = config.from,
          toCSS = config.to,
          myEase = config.ease,
          myDuration = config.duration,
          myDelay = config.delay,
          infinite = config.infinite; //A percentage of the viewport's height.

      viewport = config.viewport;
      if ((0,esm_typeof/* default */.Z)(viewport) === ( true ? "undefined" : 0)) viewport = '100%';
      if ((0,esm_typeof/* default */.Z)(myEase) === ( true ? "undefined" : 0)) myEase = 'Power2.easeOut';
      if ((0,esm_typeof/* default */.Z)(myDelay) === ( true ? "undefined" : 0)) myDelay = 0;
      if ((0,esm_typeof/* default */.Z)(myDuration) === ( true ? "undefined" : 0)) myDuration = 0.4;
      if ((0,esm_typeof/* default */.Z)(infinite) === ( true ? "undefined" : 0)) infinite = false; //Conversion between percentage and decimal

      viewport = parseFloat(viewport) / 100.0; //Make it go back and forth

      var reverse = infinite ? 1 : 0; //Set the initial state of the element

      TweenMax.set($el, {
        css: fromCSS
      }); //

      var fromIsString = Object.prototype.toString.call(fromCSS) == '[object String]' ? true : false;

      if (fromIsString) {
        toCSS = toCSS.replace(/\./, '');
      } else {
        tl.to($el, myDuration, {
          css: toCSS,
          ease: myEase,
          delay: myDelay
        });
        $el[0].animation = tl;
      } //


      var scrollUpdate = function scrollUpdate() {
        var spyTop = $el[0].getBoundingClientRect().top; //Prevent asynchronous loading of repeated calls

        var actived = $el.data('activated');

        if (spyTop < window.innerHeight * viewport) {
          if ((0,esm_typeof/* default */.Z)(actived) === ( true ? "undefined" : 0)) {
            if (fromIsString) {
              //Add class when element becomes visible
              $el.delay(myDelay * 1000).queue('fx', function () {
                $(this).addClass(toCSS).dequeue();
              });
            } else {
              $el[0].animation.play(); //Other animation
              //------------------------
              //Image transition

              spyImageTrans('show');
            } //Prevents front-end javascripts that are activated in the background to repeat loading.


            $el.data('activated', 1);
          } //endif actived

        } else {
          if ((0,esm_typeof/* default */.Z)(actived) !== ( true ? "undefined" : 0) && reverse === 1) {
            if (fromIsString) {
              //Add class when element becomes visible
              $el.removeClass(toCSS);
            } else {
              $el[0].animation.reverse(); //Other animation
              //------------------------
              //Image transition

              spyImageTrans('hide');
            }

            $el.removeData('activated');
          } //endif actived

        }
      }; // Add function to the element that should be used as the scrollable area.


      var throttleFunc = UixThrottle(scrollUpdate, 5);
      window.removeEventListener('scroll', throttleFunc);
      window.removeEventListener('touchmove', throttleFunc);
      window.addEventListener('scroll', throttleFunc);
      window.addEventListener('touchmove', throttleFunc);
      throttleFunc();
      /*
      * The transition effect of each group of images
      *
      * @return {Void}
      * #Usage: 
      <ul data-uix-anim='{"viewport":"90%","from":{"y":0},"to":{"y":0},"ease":"Power2.easeOut","duration":0.8,"delay":0.2,"infinite":true}' data-img-ids='["[data-imgshow]"]'>
      <li data-imgshow="1"><img src="logo-1.jpg" alt=""></li>
      <li data-imgshow="1"><img src="logo-2.jpg" alt=""></li>
      <li data-imgshow="1"><img src="logo-3.jpg" alt=""></li>
      <li data-imgshow="1"><img src="logo-4.jpg" alt=""></li>
      <ul>
             */

      function spyImageTrans(type) {
        var _imgIds = $el.data('img-ids');

        if ((0,esm_typeof/* default */.Z)(_imgIds) !== ( true ? "undefined" : 0)) {
          //add
          if (type == 'show') {
            _imgIds.forEach(function (element) {
              $(element).each(function (index) {
                $(this).delay(50 * index).queue('fx', function () {
                  $(this).addClass('is-active');
                  $(this).dequeue();
                });
              });
            });
          } else {
            //remove 
            _imgIds.forEach(function (element) {
              $(element).removeClass('is-active');
            });
          }
        }
      }
    }); //end each        
  };

  module.components.documentReady.push(module.SCROLL_REVEAL.documentReady);
  return /*#__PURE__*/_createClass(function SCROLL_REVEAL() {
    _classCallCheck(this, SCROLL_REVEAL);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/scrollspy-animate/js/index.js



/* 
 *************************************
 * <!-- Scrollspy Animate -->
 *************************************
 */

var SCROLLSPY_ANIM = function (module, $, window, document) {
  if (window.SCROLLSPY_ANIM === null) return false;
  module.SCROLLSPY_ANIM = module.SCROLLSPY_ANIM || {};
  module.SCROLLSPY_ANIM.version = '0.0.7';

  module.SCROLLSPY_ANIM.documentReady = function ($) {
    // Remove pixi.js banner from the console
    PIXI.utils.skipHello();
    var $el = $('#scrollspy-animate-demo'),
        panelHeight = 0; //Prevent this module from loading in other pages

    if ($el.length == 0) return false;
    var windowWidth = window.innerWidth,
        windowHeight = window.innerHeight;
    var curSprite;
    var filterSprite; //-------- Text Affect

    if (Modernizr.webgl) {
      var $txtContainer = $el.find('.row canvas'),
          text = $txtContainer.data('txt').split(''),
          tHeight = 45,
          tWidth = 25,
          renderer = new PIXI.Application({
        width: tWidth * (text.length + 2),
        height: tHeight * 2,
        antialias: true,
        transparent: true,
        resolution: 1,
        autoResize: 1,
        view: document.getElementById('scrollspy-animate-demo--txt')
      });
      var stage = new PIXI.Container();
      filterSprite = PIXI.Sprite.from($txtContainer.data('filter-texture'));
      filterSprite.texture.baseTexture.wrapMode = PIXI.WRAP_MODES.REPEAT;
      var filter = new PIXI.filters.DisplacementFilter(filterSprite);
      var txtStyle = new PIXI.TextStyle({
        fontSize: tHeight,
        letterSpacing: 0,
        breakWords: true,
        dropShadow: true,
        dropShadowAngle: Math.PI / 6,
        dropShadowAlpha: 0.5,
        dropShadowColor: '#333',
        dropShadowBlur: 1,
        fill: 'white',
        fontFamily: 'Arial Black',
        fontStyle: 'normal',
        fontWeight: 'bold',
        wordWrap: false,
        align: 'left'
      });
      curSprite = new PIXI.Text($txtContainer.data('txt'), txtStyle);
      curSprite.x = 0;
      curSprite.y = 0;
      renderer.stage.addChild(curSprite);
      curSprite.anchor.set(0);
      curSprite.scale.set(1);
      filterSprite.anchor.set(0);
      filterSprite.scale.set(0.3);
      filterSprite.x = -50;
      filterSprite.y = 0;
      renderer.stage.filterArea = renderer.screen;
      renderer.stage.addChild(curSprite, filterSprite);
      renderer.stage.filters = [filter];
      var ticker = new PIXI.Ticker();
      ticker.autoStart = true;
      ticker.add(function (delta) {
        filterSprite.y += 0.2 * delta; // Render updated scene

        renderer.render(stage);
      });
    }

    function scrollUpdate() {
      var elHeight = $el.height(),
          elOffsetTop = $el.offset().top - panelHeight;
      var scrolled = $(window).scrollTop(),
          translateTitle = scrolled / 2,
          translateBackground = scrolled / 3,
          scale = scrolled / elHeight,
          backgroundScale = 1,
          // + scale / 10
      titleScale = 1 - scale * 0.1,
          titleOpacity = 1 - scale,
          scrollProgress = (scrolled - elOffsetTop) / (elHeight - windowHeight / 6); //-------- Animation

      var spyTop = $el[0].getBoundingClientRect().top;

      if (spyTop < window.innerHeight) {
        $el.find('.row').css({
          'transition': 'none',
          'transform': 'translateY(' + translateTitle + 'px) scale(' + titleScale + ')',
          'opacity': titleOpacity
        });
        $('body').removeClass('js-uix-content-part').removeClass('js-uix-bottom-part');
      } else {
        $('body').addClass('js-uix-content-part').removeClass('js-uix-bottom-part');
      } //-------- Display progress


      $el.find('.row h3 em').text(scrollProgress.toFixed(2));

      if (Modernizr.webgl) {
        TweenMax.set(filterSprite, {
          x: windowHeight * scrollProgress
        });
      }
    } // Add function to the element that should be used as the scrollable area.


    var throttleFunc = UixThrottle(scrollUpdate, 5);
    window.removeEventListener('scroll', throttleFunc);
    window.removeEventListener('touchmove', throttleFunc);
    window.addEventListener('scroll', throttleFunc);
    window.addEventListener('touchmove', throttleFunc);
    throttleFunc();
  };

  module.components.documentReady.push(module.SCROLLSPY_ANIM.documentReady);
  return /*#__PURE__*/_createClass(function SCROLLSPY_ANIM() {
    _classCallCheck(this, SCROLLSPY_ANIM);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/show-more-less/js/index.js



/* 
 *************************************
 * <!-- Show More Less -->
 *************************************
 */


var SHOW_MORELESS = function (module, $, window, document) {
  if (window.SHOW_MORELESS === null) return false;
  module.SHOW_MORELESS = module.SHOW_MORELESS || {};
  module.SHOW_MORELESS.version = '0.0.3';

  module.SHOW_MORELESS.documentReady = function ($) {
    $('.uix-more-btn__link').each(function () {
      var $btn = $(this),
          $con = $btn.parent().prev('.uix-more-btn'),
          $btnTxt = $btn.find('> span'),
          defaultHeight = $con.height();
      $btn.off('click').on('click', function (e) {
        e.preventDefault();
        var expanded = $(this).attr('aria-expanded') == 'true' ? false : true;

        if (expanded) {
          $con.addClass('is-active').attr('aria-expanded', true);
          $(this).addClass('is-active').attr('aria-expanded', true); //to open
          // - temporarilty set height:auto
          // - tween from height:0

          TweenMax.set($con, {
            height: 'auto'
          });
          TweenMax.from($con, 0.5, {
            height: defaultHeight
          }); //change text

          $btnTxt.eq(0).hide();
          $btnTxt.eq(1).show();
        } else {
          $con.removeClass('is-active').attr('aria-expanded', false);
          $(this).removeClass('is-active').attr('aria-expanded', false); //to close

          TweenMax.to($con, 0.5, {
            height: defaultHeight
          }); //change text

          $btnTxt.eq(0).show();
          $btnTxt.eq(1).hide();
        }
      });
    });
  };

  module.components.documentReady.push(module.SHOW_MORELESS.documentReady);
  return /*#__PURE__*/_createClass(function SHOW_MORELESS() {
    _classCallCheck(this, SHOW_MORELESS);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/skew-on-scroll/js/index.js



/* 
 *************************************
 * <!-- Skew Based On Velocity of Scroll -->
 *************************************
 */

var SKEW_ON_SCROLL = function (module, $, window, document) {
  if (window.SKEW_ON_SCROLL === null) return false;
  module.SKEW_ON_SCROLL = module.SKEW_ON_SCROLL || {};
  module.SKEW_ON_SCROLL.version = '0.0.1';

  module.SKEW_ON_SCROLL.documentReady = function ($) {
    $('.uix-skewscroll-container').each(function () {
      var $this = $(this),
          $animObj = $this.find('p'),
          ease = 0.15;
      var followY = 0;
      TweenMax.set($animObj, {
        transformOrigin: "center left"
      });
      TweenMax.ticker.addEventListener('tick', function () {
        followY += (window.scrollY - followY) * ease;
        var dy = (window.scrollY - followY) / 20;
        dy = Math.min(Math.max(dy, -15), 15);
        TweenLite.set($animObj, {
          skewY: dy
        });
      });
    });
  };

  module.components.documentReady.push(module.SKEW_ON_SCROLL.documentReady);
  return /*#__PURE__*/_createClass(function SKEW_ON_SCROLL() {
    _classCallCheck(this, SKEW_ON_SCROLL);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/smooth-scrolling-anchor-link/js/index.js



/* 
 *************************************
 * <!-- Smooth Scrolling When Clicking An Anchor Link -->
 *************************************
 */


var SMOOTH_SCROLLING_ANCHORLINK = function (module, $, window, document) {
  if (window.SMOOTH_SCROLLING_ANCHORLINK === null) return false;
  module.SMOOTH_SCROLLING_ANCHORLINK = module.SMOOTH_SCROLLING_ANCHORLINK || {};
  module.SMOOTH_SCROLLING_ANCHORLINK.version = '0.0.8';

  module.SMOOTH_SCROLLING_ANCHORLINK.documentReady = function ($) {
    //Prevent this module from loading in other pages
    if ($('body').hasClass('onepage')) return false;
    var browserURL = window.location.href; //Prevent anchor behaviour
    //Do not add off() to this

    $('a').on('click', function (e) {
      if ($(this).data('smooth-scrolling') != false) {
        var linkURL = $(this).attr('href'),
            locIndex,
            locURL;

        if (linkURL.indexOf('#') >= 0 && linkURL != '#') {
          e.preventDefault();
          var locArr = linkURL.split('#');
          locIndex = locArr[1];
          locURL = locArr[0];

          if (browserURL.indexOf(locURL) < 0) {
            window.location.href = locURL + '#!!' + locIndex;
          }
        }
      }
    }); //Page automatically slide to jump to the corresponding position

    if (browserURL.indexOf('#!!') >= 0) {
      var curndex = browserURL.split('#!!'),
          $target = $('#' + curndex[1]); //Smooth scrolling

      if ($target.length) {
        TweenMax.to(window, 0.5, {
          scrollTo: {
            y: $target.offset().top,
            autoKill: false
          },
          ease: Power2.easeOut,
          onComplete: function onComplete() {
            //Fixed an error that offset().top returns wrong value
            var spyTop = $target[0].getBoundingClientRect().top;

            if (spyTop < 0 || spyTop > 30) {
              $('a[href*="#' + curndex[1] + '"]').trigger('click');
            }
          }
        });
      }
    } //Hyperlink click event
    //Do not add off() to this


    $('a[href*="#"]').on('click', function (e) {
      if (location.pathname.replace(/^\//, '') == this.pathname.replace(/^\//, '') && location.hostname == this.hostname && $(this).attr('href') != '#' & $(this).attr('href').indexOf('#?') < 0) {
        // Figure out element to scroll to
        var target = $(this.hash);
        target = target.length ? target : $('[name=' + this.hash.slice(1) + ']'); // Does a scroll target exist?

        if (target.length) {
          // Only prevent default if animation is actually gonna happen
          e.preventDefault();
          TweenMax.to(window, 0.5, {
            scrollTo: {
              y: target.offset().top,
              autoKill: false
            },
            ease: Power2.easeOut,
            onComplete: function onComplete() {
              // Callback after animation
              // Must change focus!
              var $target = $(target);
              $target.focus();

              if ($target.is(':focus')) {
                // Checking if the target was focused
                return false;
              } else {
                $target.attr('tabindex', '-1'); // Adding tabindex for elements not focusable

                $target.focus();
              }
            }
          });
        }
      }
    });
  };

  module.components.documentReady.push(module.SMOOTH_SCROLLING_ANCHORLINK.documentReady);
  return /*#__PURE__*/_createClass(function SMOOTH_SCROLLING_ANCHORLINK() {
    _classCallCheck(this, SMOOTH_SCROLLING_ANCHORLINK);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/smooth-scrolling-page/js/index.js



/* 
 *************************************
 * <!-- Smooth Scrolling Page -->
 *************************************
 */

var SMOOTH_SCROLLING_PAGE = function (module, $, window, document) {
  if (window.SMOOTH_SCROLLING_PAGE === null) return false;
  module.SMOOTH_SCROLLING_PAGE = module.SMOOTH_SCROLLING_PAGE || {};
  module.SMOOTH_SCROLLING_PAGE.version = '0.1.4';

  module.SMOOTH_SCROLLING_PAGE.pageLoaded = function () {
    //Prevent this module from loading in other pages
    //--------------
    if (!$('body').hasClass('smooth-scrolling-page')) return false; // Core params
    //--------------

    var windowWidth = window.innerWidth,
        windowHeight = window.innerHeight;
    var html = document.documentElement,
        body = document.body,
        scroller = {
      target: '#uix-scrollspy-area',
      ease: 0.05,
      // <= scroll speed
      endY: 0,
      y: 0,
      resizeRequest: 1,
      scrollRequest: 0
    };
    var requestId = null;
    var lastScrollTop = 0; // Determine the direction of scrolling

    TweenMax.set(scroller.target, {
      rotation: 0.01,
      force3D: true
    }); //Increase the viewport to display the visual area

    var elTop = $(scroller.target).offset().top; // Scrolling Progress
    //--------------

    var tlTarget1 = '#app-scrolling-progress1';
    var tlTarget2 = '#app-scrolling-progress2';
    var tlTarget3 = '#app-scrolling-progress3';
    TweenMax.set(tlTarget1, {
      toAlpha: 1
    }); // time should be adjusted relative to window width or height
    // Animation progress has nothing to do with time
    //
    //

    var time = 10;
    var time02 = 2;
    var timestop01 = time / 9.9999;
    var timestop02 = time / 8.1;
    var tlAction = new TimelineMax({
      paused: true
    }).to(tlTarget1, time, {
      height: $(scroller.target).height() - windowHeight * 2 - 200
    }).to(tlTarget1, time02, {
      height: $(scroller.target).height() - windowHeight * 2
    }).to(tlTarget1, time, {
      width: 15
    }, 0).to(tlTarget2, 0.3, {
      rotation: -10,
      scale: 0.5,
      transformOrigin: 'center'
    }, timestop01).to(tlTarget3, 0.3, {
      rotation: 1125,
      scale: 0.1,
      transformOrigin: 'center'
    }, timestop02); //
    //

    var scene2_progress = 0;
    var scene2Action = new TimelineMax({
      paused: true
    }).to('#app-scene-2 p', 0.3, {
      x: 100
    }, 0); //
    //

    var scene3_progress = 0;
    var scene3Action = new TimelineMax({
      paused: true
    }).to('#app-scene-3 p', 0.3, {
      x: 200
    }, 0); // Core Actions
    //--------------

    var initSmoothScrollingPageWrapper = 'js-uix-smooth-scrolling-page-wrapper';

    if (!$('body').hasClass(initSmoothScrollingPageWrapper)) {
      $('body').addClass(initSmoothScrollingPageWrapper);
      $(scroller.target).wrap('<div id="uix-scrollspy-area__wrapper" style="overflow:hidden;position:fixed;height:100%;width:100%;top:0;left:0;right:0;bottom:0;"></div>').css('margin-top', elTop + 'px');
    }

    function scrollAnimate() {
      var resized = scroller.resizeRequest > 0;

      if (resized) {
        var height = $(scroller.target).height();
        body.style.height = parseFloat(height + elTop) + "px";
        scroller.resizeRequest = 0;
      }

      var scrollY = window.pageYOffset || html.scrollTop || body.scrollTop || 0;
      scroller.endY = scrollY;
      scroller.y += (scrollY - scroller.y) * scroller.ease;

      if (Math.abs(scrollY - scroller.y) < 0.05 || resized) {
        scroller.y = scrollY;
        scroller.scrollRequest = 0;
      }

      TweenMax.set(scroller.target, {
        y: -scroller.y,
        onComplete: function onComplete() {//-----Spy scrollTop and elements of page
          //your code here...
        }
      }); // update requestId

      requestId = scroller.scrollRequest > 0 ? requestAnimationFrame(scrollAnimate) : null; //+++++++++++++++++++++++++++++++++++++++++++++++++
      // Custom Functions
      //+++++++++++++++++++++++++++++++++++++++++++++++++

      var scrolled = scroller.y,
          topSpacing = window.innerWidth <= 768 ? 0 : $('.uix-header__container').outerHeight(true); //with margin 
      //----------------------------------------------------------------------------------
      //--------------------------------- Scrollspy Animate -------------------------------	
      //----------------------------------------------------------------------------------   
      // Parallax 
      //-------------------------------------	

      $('.uix-scrollspy-animate--parallax__wrapper').each(function () {
        var $wrapper = $(this);
        var $target = $wrapper.find('.uix-scrollspy-animate--parallax');
        var rect = $target[0].getBoundingClientRect();
        var spyTop = rect.top;
        var speed = -parseFloat($wrapper.data('scrollspy-speed')); //

        $wrapper.css({
          'overflow': 'hidden',
          'height': rect.height - rect.height * 0.3
        });
        $target.css({
          'margin-top': -rect.height * 0.15
        }); //

        TweenMax.set($wrapper, {
          css: {
            'transform': 'matrix(1, 0, 0, 1, 0, ' + (0 - spyTop * speed) + ')',
            'transition': 'none'
          }
        });
        TweenMax.set($target, {
          css: {
            'transform': 'matrix(1, 0, 0, 1, 0, ' + (0 - spyTop * (speed / 2)) + ')',
            'transition': 'none'
          }
        });
      }); // Transparency
      //-------------------------------------	

      $('.uix-scrollspy-animate--transparency').each(function () {
        var $this = $(this);
        var rect = $this[0].getBoundingClientRect();
        var spyTop = rect.top;
        var speed = -parseFloat($this.data('scrollspy-speed'));
        var scale = (0 - spyTop * speed) / rect.height,
            elOpacity = scale;
        TweenMax.set($this, {
          alpha: $this.data('scrollspy-reverse') ? 1 - elOpacity : elOpacity
        });
      }); //----------------------------------------------------------------------------------
      //--------------------------------- Scrolling Progress -------------------------------	
      //----------------------------------------------------------------------------------   

      var scrollDistance = $(scroller.target).height(),
          visibleAreaDistance = windowHeight,
          scrollPercent = scrolled / (scrollDistance - visibleAreaDistance); //

      console.log('Body progress: ' + scrollPercent);
      var progressBlobs = scrollPercent * 1; // slower (= <) or faster and/or change height of 'scrollDistance'

      var scrollDir = scrolled > lastScrollTop ? 'down' : 'up';
      TweenMax.to(tlAction, 1, {
        progress: progressBlobs,
        ease: Sine.easeOut
      }); //----------------------------------------------------------------------------------
      //---------------------- SCROLLING PROGRESS HELPER ----------------------------------	
      //----------------------------------------------------------------------------------   

      var triggerViewport = 0.5; //Scene 2 progress
      //-----------------

      var scene2_height = $('#app-scene-2').outerHeight(true),
          // do not use .height()
      scene2_spyTop = $('#app-scene-2')[0].getBoundingClientRect().top;
      var scene2_scrollPercent = parseFloat(scene2_spyTop / scene2_height) - triggerViewport;

      if (scene2_scrollPercent <= 0 && scene2_scrollPercent >= -1) {
        console.log('Scene 2 progress: ' + Math.abs(scene2_scrollPercent));
        scene2_progress = Math.abs(scene2_scrollPercent);
      }

      TweenMax.to(scene2Action, 1, {
        progress: scene2_progress
      }); //Scene 3 progress
      //-----------------

      var scene3_height = $('#app-scene-3').outerHeight(true),
          // do not use .height()
      scene3_spyTop = $('#app-scene-3')[0].getBoundingClientRect().top;
      var scene3_scrollPercent = parseFloat(scene3_spyTop / scene3_height) - triggerViewport;

      if (scene3_scrollPercent <= 0 && scene3_scrollPercent >= -1) {
        console.log('Scene 3 progress: ' + Math.abs(scene3_scrollPercent));
        scene3_progress = Math.abs(scene3_scrollPercent);
      }

      TweenMax.to(scene3Action, 1, {
        progress: scene3_progress
      }); //----------------------------------------------------------------------------------
      //---------------------------------------------------------------------------------	
      //----------------------------------------------------------------------------------  
      //

      lastScrollTop = scrolled;
    } //end scrollAnimate()


    function scrollUpdate() {
      scroller.scrollRequest++;

      if (!requestId) {
        requestId = requestAnimationFrame(scrollAnimate);
      }
    } // Add function to the element that should be used as the scrollable area.


    var throttleFunc = UixThrottle(scrollUpdate, 5);
    window.removeEventListener('scroll', throttleFunc);
    window.removeEventListener('touchmove', throttleFunc);
    window.addEventListener('scroll', throttleFunc);
    window.addEventListener('touchmove', throttleFunc);
    throttleFunc();

    function windowUpdate() {
      // Check window width has actually changed and it's not just iOS triggering a resize event on scroll
      if (window.innerWidth != windowWidth) {
        // Update the window width for next time
        windowWidth = window.innerWidth; // Do stuff here

        scroller.resizeRequest++;

        if (!requestId) {
          requestId = requestAnimationFrame(scrollAnimate);
        }
      }
    } // Add function to the window that should be resized


    var debounceFuncWindow = UixDebounce(windowUpdate, 50);
    window.removeEventListener('resize', debounceFuncWindow);
    window.addEventListener('resize', debounceFuncWindow);
  };

  module.components.pageLoaded.push(module.SMOOTH_SCROLLING_PAGE.pageLoaded);
  return /*#__PURE__*/_createClass(function SMOOTH_SCROLLING_PAGE() {
    _classCallCheck(this, SMOOTH_SCROLLING_PAGE);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/sticky-elements/js/index.js




/* 
 *************************************
 *  <!-- Sticky Elements -->
 *************************************
 */


var STICKY_EL = function (module, $, window, document) {
  if (window.STICKY_EL === null) return false;
  module.STICKY_EL = module.STICKY_EL || {};
  module.STICKY_EL.version = '0.0.8';

  module.STICKY_EL.pageLoaded = function () {
    var windowWidth = window.innerWidth,
        windowHeight = window.innerHeight;
    var topSpacing = windowWidth <= 768 ? 0 : $('.uix-header__container').outerHeight(true); //with margin
    //prepend a placeholder

    $('.js-uix-sticky-el').each(function () {
      var $el = $(this),
          elHeight = $el.outerHeight(true),
          //with margin
      elClass = $el.attr('class').replace('js-uix-sticky-el', ''),
          tempID = 'sticky-' + UixGUID.create();
      $el.attr('data-sticky-id', tempID);

      if (!$el.hasClass('is-placeholder')) {
        $('<div class="' + elClass + ' is-placeholder"></div>').css({
          'height': elHeight + 'px',
          'width': '100%',
          'display': 'none',
          'visibility': 'hidden'
        }).attr('data-sticky-id', tempID).insertBefore($el);
      }
    }); //  Initialize

    stickyInit(windowWidth);

    function windowUpdate() {
      // Check window width has actually changed and it's not just iOS triggering a resize event on scroll
      if (window.innerWidth != windowWidth) {
        // Update the window width for next time
        windowWidth = window.innerWidth; // Do stuff here

        stickyInit(windowWidth);
      }
    } // Add function to the window that should be resized


    var debounceFuncWindow = UixDebounce(windowUpdate, 50);
    window.removeEventListener('resize', debounceFuncWindow);
    window.addEventListener('resize', debounceFuncWindow);
    /*
     * Initialize Sticky Elements settings
     *
     * @param  {Number} w         - Returns width of browser viewport
     * @return {Void}
     */

    function stickyInit(w) {
      if (w > 768) {
        $('.js-uix-sticky-el').each(function () {
          var $el = $(this),
              elTop = $el.offset().top,
              oWidth = $el.width(),
              clsID = $el.data('sticky-id'),
              $ph = $('[data-sticky-id="' + clsID + '"].is-placeholder');

          function scrollUpdate() {
            var scrolled = $(window).scrollTop(),
                spyTop = parseFloat(scrolled + window.innerHeight); //------

            if (parseFloat(scrolled + topSpacing) > elTop) {
              $el.addClass('is-active').css({
                'width': oWidth + 'px',
                'top': topSpacing + 'px'
              });
              $ph.css('display', 'block');
            } else {
              $el.removeClass('is-active').css({
                'top': 0
              });
              $ph.css('display', 'none');
            } //------


            if ((0,esm_typeof/* default */.Z)($el.data('stop-trigger')) != ( true ? "undefined" : 0) && $($el.data('stop-trigger')).length > 0) {
              var diff = (0,esm_typeof/* default */.Z)($el.data('stop-trigger-diff')) != ( true ? "undefined" : 0) && $el.data('stop-trigger-diff').length > 0 ? UixMath.evaluate($el.data('stop-trigger-diff').replace(/\s/g, '').replace(/\%\h/g, windowHeight).replace(/\%\w/g, windowWidth)) : 0,
                  targetTop = $($el.data('stop-trigger')).offset().top - diff; //Detecting when user scrolls to bottom of div

              if (spyTop >= targetTop) {
                $el.css({
                  'top': parseFloat(topSpacing - (spyTop - targetTop)) + 'px'
                });
              } else {
                if ($el.length > 0 && $el.position().top < topSpacing) {
                  $el.css({
                    'top': topSpacing + 'px'
                  });
                }
              }
            }
          } // Add function to the element that should be used as the scrollable area.


          var throttleFunc = UixThrottle(scrollUpdate, 5);
          window.removeEventListener('scroll', throttleFunc);
          window.removeEventListener('touchmove', throttleFunc);
          window.addEventListener('scroll', throttleFunc);
          window.addEventListener('touchmove', throttleFunc);
          throttleFunc();
        }); //endif $( '.js-uix-sticky-el' )
      } else {
        $('.js-uix-sticky-el').removeClass('is-active');
        $('[data-sticky-id].is-placeholder').css('display', 'none');
      } // endif w > 768

    }
  };

  module.components.pageLoaded.push(module.STICKY_EL.pageLoaded);
  return /*#__PURE__*/_createClass(function STICKY_EL() {
    _classCallCheck(this, STICKY_EL);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/svg-map/js/china.js



/* 
 *************************************
 * <!-- SVG Map (China) -->
 *************************************
 */


var SVG_MAP_CHINA = function (module, $, window, document) {
  if (window.SVG_MAP_CHINA === null) return false;
  module.SVG_MAP_CHINA = module.SVG_MAP_CHINA || {};
  module.SVG_MAP_CHINA.version = '0.0.2';

  module.SVG_MAP_CHINA.documentReady = function ($) {
    var $svgEl = $('.uix-svgmap--china');
    $(document).off('click.SVG_MAP_CHINA').on('click.SVG_MAP_CHINA', '.uix-svgmap--china__trigger a', function (e) {
      // stop propagation of this event, it will never reach body in bubbling phase.
      e.stopPropagation();
      var goName = $(this).data('title'),
          goText = $(this).text();
      var svgCurName = '',
          svgNameIndex = 0;
      $('.uix-svgmap--china .uix-svgmap--china__name').each(function () {
        if (goName == $(this).data('title')) {
          svgCurName = $(this).data('title');
          return false;
        }
      });
      svgNameIndex = $('.uix-svgmap--china .uix-svgmap--china__name[data-title="' + svgCurName + '"]').index(); //Hide all elements

      svgMapRestore(1); //Display current element

      svgMapActive(svgNameIndex, goText);
    }); //Restore all elements
    //Do not add off() to this

    $(document.body).on('click', function (e) {
      svgMapRestore(2);
    });

    function svgMapRestore(type) {
      var alpha = type == 1 ? 0.3 : 1;
      $svgEl.children().removeClass('is-show');
      $svgEl.find('circle').css({
        'r': 6,
        'font-size': '6px',
        'z-index': 1,
        'opacity': alpha
      });
      $svgEl.find('.uix-svgmap--china__name').each(function () {
        $(this).css({
          'transform': 'translate(0,15px)',
          'z-index': 1,
          'opacity': alpha
        }).text($(this).data('title'));
      });
      $svgEl.find('.uix-svgmap--china__num').css({
        'font-size': '6px',
        'z-index': 1,
        'opacity': alpha
      });
    }

    function svgMapActive(index, text) {
      $svgEl.each(function () {
        $(this).children().eq(index).addClass('is-show');
        $(this).find('circle').eq(index).css({
          'r': 15,
          'z-index': 2,
          'opacity': 1
        });
        $(this).find('.uix-svgmap--china__name').eq(index).css({
          'transform': 'translate(0,25px)',
          'z-index': 2,
          'opacity': 1
        }).text(text);
        $(this).find('.uix-svgmap--china__num').eq(index).css({
          'font-size': '10px',
          'z-index': 2,
          'opacity': 1
        });
      });
    }
  };

  module.components.documentReady.push(module.SVG_MAP_CHINA.documentReady);
  return /*#__PURE__*/_createClass(function SVG_MAP_CHINA() {
    _classCallCheck(this, SVG_MAP_CHINA);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/svg-map/js/world.js



/* 
 *************************************
 * <!-- SVG Map (World) -->
 *************************************
 */


var SVG_MAP_WORLD = function (module, $, window, document) {
  if (window.SVG_MAP_WORLD === null) return false;
  module.SVG_MAP_WORLD = module.SVG_MAP_WORLD || {};
  module.SVG_MAP_WORLD.version = '0.0.2';

  module.SVG_MAP_WORLD.documentReady = function ($) {
    var $svgEl = $('.uix-svgmap--world');
    $(document).off('click.SVG_MAP_WORLD').on('click.SVG_MAP_WORLD', '.uix-svgmap--world__trigger a', function (e) {
      // stop propagation of this event, it will never reach body in bubbling phase.
      e.stopPropagation();
      var goName = $(this).data('title'),
          goText = $(this).text();
      var svgCurName = '',
          svgNameIndex = 0;
      $('.uix-svgmap--world .uix-svgmap--world__name').each(function (index) {
        if (goName == $(this).data('title')) {
          svgCurName = $(this).data('title');
          svgNameIndex = index;
          return false;
        }
      }); //Hide all elements

      svgMapRestore(1); //Display current element

      svgMapActive(svgNameIndex, goText);
    }); //Restore all elements
    //Do not add off() to this

    $(document.body).on('click', function (e) {
      svgMapRestore(2);
    });

    function svgMapRestore(type) {
      var alpha = type == 1 ? 0.3 : 1;
      $svgEl.children().removeClass('is-show');
      $svgEl.find('path').css({
        'z-index': 1,
        'opacity': alpha
      });
      $svgEl.find('.uix-svgmap--world__name').each(function () {
        $(this).css({
          'z-index': 1,
          'opacity': alpha,
          'font-size': '3px'
        }).text($(this).data('title'));
      });
      $svgEl.find('.uix-svgmap--world__num').css({
        'font-size': '6px',
        'z-index': 1,
        'opacity': alpha
      });
    }

    function svgMapActive(index, text) {
      $svgEl.each(function () {
        $(this).children().eq(index).addClass('is-show');
        $(this).find('path').eq(index).css({
          'z-index': 2,
          'opacity': 1
        });
        $(this).find('.uix-svgmap--world__name').eq(index).css({
          'z-index': 2,
          'opacity': 1,
          'font-size': '10px'
        }).text(text);
        $(this).find('.uix-svgmap--world__num').eq(index).css({
          'font-size': '10px',
          'z-index': 2,
          'opacity': 1
        });
      });
    }
  };

  module.components.documentReady.push(module.SVG_MAP_WORLD.documentReady);
  return /*#__PURE__*/_createClass(function SVG_MAP_WORLD() {
    _classCallCheck(this, SVG_MAP_WORLD);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/svg-mask-slider/js/index.js




/* 
 *************************************
 * <!-- SVG Mask Slider -->
 *************************************
 */


var SVG_MASK_SLIDER = function (module, $, window, document) {
  if (window.SVG_MASK_SLIDER === null) return false;
  module.SVG_MASK_SLIDER = module.SVG_MASK_SLIDER || {};
  module.SVG_MASK_SLIDER.version = '0.0.5';

  module.SVG_MASK_SLIDER.pageLoaded = function () {
    var windowWidth = window.innerWidth,
        windowHeight = window.innerHeight;
    var animDelay = 0;
    var animSpeed = 1000;
    var $sliderWrapper = $('.uix-svgMask-slider');
    var svgAnimating = false; //

    sliderInit(false);

    function windowUpdate() {
      // Check window width has actually changed and it's not just iOS triggering a resize event on scroll
      if (window.innerWidth != windowWidth) {
        // Update the window width for next time
        windowWidth = window.innerWidth; // Do stuff here

        sliderInit(true);
      }
    } // Add function to the window that should be resized


    var debounceFuncWindow = UixDebounce(windowUpdate, 50);
    window.removeEventListener('resize', debounceFuncWindow);
    window.addEventListener('resize', debounceFuncWindow);
    /*
     * Initialize slideshow
     *
     * @param  {Boolean} resize            - Determine whether the window size changes.
     * @return {Void}
     */

    function sliderInit(resize) {
      $sliderWrapper.each(function () {
        var $this = $(this);
        var $items = $this.find('.uix-svgMask-slider__item'),
            $first = $items.first(),
            activated = $this.data('activated');
        var nativeItemW, nativeItemH;

        if ((0,esm_typeof/* default */.Z)(activated) === ( true ? "undefined" : 0) || activated === 0) {
          //Get parameter configuration from the data-* attribute of HTML
          var dataControlsPagination = $this.data('controls-pagination'),
              dataControlsArrows = $this.data('controls-arrows'),
              dataDraggable = $this.data('draggable'),
              dataDraggableCursor = $this.data('draggable-cursor'),
              dataCountTotal = $this.data('count-total'),
              dataCountCur = $this.data('count-now'),
              dataSpeed = $this.data('speed');
          if ((0,esm_typeof/* default */.Z)(dataControlsPagination) === ( true ? "undefined" : 0)) dataControlsPagination = '.uix-svgMask-slider__pagination';
          if ((0,esm_typeof/* default */.Z)(dataControlsArrows) === ( true ? "undefined" : 0) || dataControlsArrows == false) dataControlsArrows = '.uix-svgMask-slider__arrows';
          if ((0,esm_typeof/* default */.Z)(dataDraggable) === ( true ? "undefined" : 0)) dataDraggable = false;
          if ((0,esm_typeof/* default */.Z)(dataDraggableCursor) === ( true ? "undefined" : 0) || dataDraggableCursor == false) dataDraggableCursor = 'move';
          if ((0,esm_typeof/* default */.Z)(dataCountTotal) === ( true ? "undefined" : 0)) dataCountTotal = 'p.count em.count';
          if ((0,esm_typeof/* default */.Z)(dataCountCur) === ( true ? "undefined" : 0)) dataCountCur = 'p.count em.current'; //Autoplay parameters

          var dataAuto = $this.data('auto'),
              dataTiming = $this.data('timing'),
              dataLoop = $this.data('loop');
          if ((0,esm_typeof/* default */.Z)(dataAuto) === ( true ? "undefined" : 0)) dataAuto = false;
          if ((0,esm_typeof/* default */.Z)(dataTiming) === ( true ? "undefined" : 0)) dataTiming = 10000;
          if ((0,esm_typeof/* default */.Z)(dataLoop) === ( true ? "undefined" : 0)) dataLoop = false; //Autoplay times

          var playTimes; //A function called "timer" once every second (like a digital watch).

          $this[0].animatedSlides; //Get the animation speed
          //-------------------------------------	

          if ((0,esm_typeof/* default */.Z)(dataSpeed) != ( true ? "undefined" : 0) && dataSpeed != false) {
            animSpeed = dataSpeed;
          } //Get the duration of the animation
          //-------------------------------------	


          animDelay = animSpeed; //Get timeline elements
          //-------------------------------------	

          var txtTimeline = new TimelineMax({
            delay: 0
          });
          var txtMaskTimeline = new TimelineMax({
            delay: 0
          });
          txtTimeline.to($items.find('.uix-svgMask-slider__txt__content'), 0.1, {
            opacity: 0
          }).to($items.find('svg image'), 0.2, {
            scale: 1.1
          }, '-=0.1').to($this.find('.uix-svgMask-slider__inner'), 0.9, {
            ease: Circ.easeOut,
            scale: 0.85
          }, '-=0.2').to($this.find('.uix-svgMask-slider__inner'), 0.75, {
            ease: Elastic.easeOut.config(4, 1.5),
            scale: 1
          }).pause();
          txtMaskTimeline.to($items.find('.uix-svgMask-slider__txt__mask'), 0.6, {
            css: {
              marginLeft: 0
            }
          }).to($items.find('.uix-svgMask-slider__txt__content'), 0.1, {
            opacity: 1
          }, "-=0.1").to($items.find('svg image'), 0.2, {
            scale: 1
          }, '-=0.1').to($items.find('.uix-svgMask-slider__txt__mask'), 0.6, {
            css: {
              marginLeft: '-100vw'
            }
          }); //Initialize the properties of each Item
          //-------------------------------------	

          $items.each(function (index) {
            var _id = UixGUID.create();

            var _item = $(this);

            _item.find('clipPath').attr('id', _id + '-img');

            _item.find('image').attr('clip-path', 'url(#' + _id + '-img)');

            _item.delay(animDelay * index).queue('fx', function () {
              $(this).addClass('is-loaded').dequeue();
            });
          }); //Initialize the first item container
          //-------------------------------------		

          $items.addClass('next');
          setTimeout(function () {
            $first.addClass('is-active');
          }, animDelay); //

          var imgURL = $first.find('img').attr('src');

          if ((0,esm_typeof/* default */.Z)(imgURL) != ( true ? "undefined" : 0)) {
            var img = new Image();

            img.onload = function () {
              $this.css('height', $this.width() * (this.height / this.width) + 'px');
              nativeItemW = this.width;
              nativeItemH = this.height; //Initialize all the items to the stage

              addItemsToStage($this, nativeItemW, nativeItemH, dataControlsPagination, dataControlsArrows, dataLoop, dataDraggable, dataDraggableCursor, dataCountTotal, dataCountCur, txtTimeline, txtMaskTimeline);
            };

            img.src = imgURL;
          } //Autoplay Slider
          //-------------------------------------		


          if (!resize) {
            if (dataAuto && !isNaN(parseFloat(dataTiming)) && isFinite(dataTiming)) {
              sliderAutoPlay(playTimes, dataTiming, dataLoop, $this, dataCountTotal, dataCountCur, dataControlsPagination, dataControlsArrows);

              var autoplayEnter = function autoplayEnter() {
                clearInterval($this[0].animatedSlides);
              };

              var autoplayLeave = function autoplayLeave() {
                sliderAutoPlay(playTimes, dataTiming, dataLoop, $this, dataCountTotal, dataCountCur, dataControlsPagination, dataControlsArrows);
              }; // Do not use the `off()` method, otherwise it will cause the second mouseenter to be invalid


              $this.on('mouseenter', autoplayEnter);
              $this.on('mouseleave', autoplayLeave); // To determine if it is a touch screen.

              if (Modernizr.touchevents) {
                $this.on('pointerenter', autoplayEnter);
                $this.on('pointerleave', autoplayLeave);
              }
            }
          } //Prevents front-end javascripts that are activated with AJAX to repeat loading.


          $this.data('activated', 1);
        } //endif activated

      });
    }
    /*
    * Trigger slider autoplay
    *
    * @param  {Function} playTimes            - Number of times.
    * @param  {Number} timing                 - Autoplay interval.
    * @param  {Boolean} loop                  - Gives the slider a seamless infinite loop.
    * @param  {Element} slider                 - Selector of the slider .
     * @param  {String} countTotalID           - Total number ID or class of counter.
     * @param  {String} countCurID             - Current number ID or class of counter.
     * @param  {String} paginationID           - Navigation ID for paging control of each slide.
     * @param  {String} arrowsID               - Previous/Next arrow navigation ID.
    * @return {Void}                          - The constructor.
    */


    function sliderAutoPlay(playTimes, timing, loop, slider, countTotalID, countCurID, paginationID, arrowsID) {
      var items = slider.find('.uix-svgMask-slider__item'),
          total = items.length;
      slider[0].animatedSlides = setInterval(function () {
        playTimes = parseFloat(items.filter('.is-active').index());
        playTimes++;

        if (!loop) {
          if (playTimes < total && playTimes >= 0) sliderUpdates(playTimes, slider, 'next', countTotalID, countCurID, paginationID, arrowsID, loop);
        } else {
          if (playTimes == total) playTimes = 0;
          if (playTimes < 0) playTimes = total - 1;
          sliderUpdates(playTimes, slider, 'next', countTotalID, countCurID, paginationID, arrowsID, loop);
        }
      }, timing);
    }
    /*
    * Initialize all the items to the stage
    *
    * @param  {Element} slider                 - Current selector of each slider.
    * @param  {Number} nativeItemW            - Returns the intrinsic width of the image.
    * @param  {Number} nativeItemH            - Returns the intrinsic height of the image.
     * @param  {String} paginationID           - Navigation ID for paging control of each slide.
     * @param  {String} arrowsID               - Previous/Next arrow navigation ID.
     * @param  {Boolean} loop                  - Gives the slider a seamless infinite loop. 
     * @param  {Boolean} draggable             - Allow drag and drop on the slider.
     * @param  {String} draggableCursor        - Drag & Drop Change icon/cursor while dragging.
     * @param  {String} countTotalID           - Total number ID or class of counter.
     * @param  {String} countCurID             - Current number ID or class of counter.
     * @param  {Function} tl1                  - Timeline animation of text field.
     * @param  {Function} tl2                  - Timeline animation of text mask field.
    * @return {Void}
    */


    function addItemsToStage(slider, nativeItemW, nativeItemH, paginationID, arrowsID, loop, draggable, draggableCursor, countTotalID, countCurID, tl1, tl2) {
      var $this = slider,
          $items = $this.find('.uix-svgMask-slider__item'),
          $first = $items.first(),
          itemsTotal = $items.length; //If arrows does not exist on the page, it will be added by default, 
      //and the drag and drop function will be activated.

      if ($(arrowsID).length == 0) {
        $('body').prepend('<div style="display:none;" class="uix-svgMask-slider__arrows ' + arrowsID.replace('#', '').replace('.', '') + '"><a href="#" class="uix-svgMask-slider__arrows--prev"></a><a href="#" class="uix-svgMask-slider__arrows--next"></a></div>');
      } //Add identifiers for the first and last items


      $items.last().addClass('last');
      $items.first().addClass('first'); //Prevent bubbling

      if (itemsTotal == 1) {
        $(paginationID).hide();
        $(arrowsID).hide();
      } //Pagination dots 
      //-------------------------------------	


      var _dot = '',
          _dotActive = '';
      _dot += '<ul>';

      for (var i = 0; i < itemsTotal; i++) {
        _dotActive = i == 0 ? 'class="is-active"' : '';
        _dot += '<li><a ' + _dotActive + ' data-index="' + i + '" href="javascript:"></a></li>';
      }

      _dot += '</ul>';
      if ($(paginationID).html() == '') $(paginationID).html(_dot);
      $(paginationID).find('li a').off('click').on('click', function (e) {
        e.preventDefault();
        if (svgAnimating) return false; //Prevent buttons' events from firing multiple times

        var $btn = $(this);
        if ($btn.attr('aria-disabled') == 'true') return false;
        $(paginationID).find('li a').attr('aria-disabled', 'true');
        $(paginationID).find('li a').delay(animDelay).queue(function (next) {
          $(paginationID).find('li a').attr('aria-disabled', 'false');
          next();
        }); //

        if (!$(this).hasClass('is-active')) {
          //Text animation from timeline
          tl1.restart();
          setTimeout(function () {
            tl2.restart();
          }, 1500); //Determine the direction

          var curDir = 'prev';

          if ($(this).attr('data-index') > parseFloat($items.filter('.is-active').index())) {
            curDir = 'next';
          }

          sliderUpdates($(this).attr('data-index'), $this, curDir, countTotalID, countCurID, paginationID, arrowsID, loop); //Pause the auto play event

          clearInterval($this[0].animatedSlides);
        }
      }); //Next/Prev buttons
      //-------------------------------------		

      var _prev = $(arrowsID).find('.uix-svgMask-slider__arrows--prev'),
          _next = $(arrowsID).find('.uix-svgMask-slider__arrows--next');

      $(arrowsID).find('a').attr('href', 'javascript:');
      $(arrowsID).find('a').removeClass('is-disabled');

      if (!loop) {
        _prev.addClass('is-disabled');
      }

      _prev.off('click').on('click', function (e) {
        e.preventDefault(); //Pause the auto play event

        clearInterval($this[0].animatedSlides); //Move animation

        prevMove();
      });

      _next.off('click').on('click', function (e) {
        e.preventDefault(); //Pause the auto play event

        clearInterval($this[0].animatedSlides); //Move animation

        nextMove();
      });

      function prevMove() {
        if (svgAnimating) return false; //Prevent buttons' events from firing multiple times

        if (_prev.attr('aria-disabled') == 'true') return false;

        _prev.attr('aria-disabled', 'true');

        _prev.delay(animDelay).queue(function (next) {
          _prev.attr('aria-disabled', 'false');

          next();
        }); //


        if (_prev.hasClass('is-disabled')) return false; //Text animation from timeline

        tl1.restart();
        setTimeout(function () {
          tl2.restart();
        }, 1500); //

        sliderUpdates(parseFloat($items.filter('.is-active').index()) - 1, $this, 'prev', countTotalID, countCurID, paginationID, arrowsID, loop);
      }

      function nextMove() {
        if (svgAnimating) return false; //Prevent buttons' events from firing multiple times

        if (_next.attr('aria-disabled') == 'true') return false;

        _next.attr('aria-disabled', 'true');

        _next.delay(animDelay).queue(function (next) {
          _next.attr('aria-disabled', 'false');

          next();
        }); //


        if (_next.hasClass('is-disabled')) return false; //Text animation from timeline

        tl1.restart();
        setTimeout(function () {
          tl2.restart();
        }, 1500); //

        sliderUpdates(parseFloat($items.filter('.is-active').index()) + 1, $this, 'next', countTotalID, countCurID, paginationID, arrowsID, loop);
      } //Added touch method to mobile device and desktop
      //-------------------------------------	


      var $dragTrigger = $this.find('.uix-svgMask-slider__inner');
      var mouseX, mouseY;
      var isMoving = false; //Avoid images causing mouseup to fail

      $dragTrigger.find('img').css({
        'pointer-events': 'none',
        'user-select': 'none'
      }); //Make the cursor a move icon when a user hovers over an item

      if (draggable && draggableCursor != '' && draggableCursor != false) $dragTrigger.css('cursor', draggableCursor); //draggable for touch devices

      if (Modernizr.touchevents) draggable = true;

      if (draggable) {
        $dragTrigger[0].removeEventListener('mousedown', dragStart);
        document.removeEventListener('mouseup', dragEnd);
        $dragTrigger[0].removeEventListener('touchstart', dragStart);
        document.removeEventListener('touchend', dragEnd); //

        $dragTrigger[0].addEventListener('mousedown', dragStart);
        $dragTrigger[0].addEventListener('touchstart', dragStart);
      }

      function dragStart(e) {
        //Do not use "e.preventDefault()" to avoid prevention page scroll on drag in IOS and Android
        var touches = e.touches;

        if (touches && touches.length) {
          mouseX = touches[0].clientX;
          mouseY = touches[0].clientY;
        } else {
          mouseX = e.clientX;
          mouseY = e.clientY;
        }

        document.addEventListener('mouseup', dragEnd);
        document.addEventListener('mousemove', dragProcess);
        document.addEventListener('touchend', dragEnd);
        document.addEventListener('touchmove', dragProcess);
      }

      function dragProcess(e) {
        var touches = e.touches;
        var offsetX, offsetY;

        if (touches && touches.length) {
          offsetX = mouseX - touches[0].clientX, offsetY = mouseY - touches[0].clientY;
        } else {
          offsetX = mouseX - e.clientX, offsetY = mouseY - e.clientY;
        } //--- left


        if (offsetX >= 50) {
          if (!isMoving) {
            isMoving = true;
            nextMove();
          }
        } //--- right


        if (offsetX <= -50) {
          if (!isMoving) {
            isMoving = true;
            prevMove();
          }
        } //--- up


        if (offsetY >= 50) {} //--- down


        if (offsetY <= -50) {}
      }

      function dragEnd(e) {
        document.removeEventListener('mousemove', dragProcess);
        document.removeEventListener('touchmove', dragProcess); //restore move action status

        setTimeout(function () {
          isMoving = false;
        }, animDelay);
      }
    }
    /*
     * Transition Between Slides
     *
     * @param  {Number} elementIndex           - Index of current slider.
     * @param  {Element} slider                 - Selector of the slider .
     * @param  {String} dir                    - Switching direction indicator.
           * @param  {String} countTotalID           - Total number ID or class of counter.
           * @param  {String} countCurID             - Current number ID or class of counter.
           * @param  {String} paginationID           - Navigation ID for paging control of each slide.
           * @param  {String} arrowsID               - Previous/Next arrow navigation ID.
           * @param  {Boolean} loop                  - Gives the slider a seamless infinite loop.
     * @return {Void}
     */


    function sliderUpdates(elementIndex, slider, dir, countTotalID, countCurID, paginationID, arrowsID, loop) {
      var $items = slider.find('.uix-svgMask-slider__item'),
          total = $items.length; //Prevent bubbling

      if (total == 1) {
        $(paginationID).hide();
        $(arrowsID).hide();
        return false;
      } //Transition Interception
      //-------------------------------------


      if (loop) {
        if (elementIndex == total) elementIndex = 0;
        if (elementIndex < 0) elementIndex = total - 1;
      } else {
        $(arrowsID).find('a').removeClass('is-disabled');
        if (elementIndex == total - 1) $(arrowsID).find('.uix-svgMask-slider__arrows--next').addClass('is-disabled');
        if (elementIndex == 0) $(arrowsID).find('.uix-svgMask-slider__arrows--prev').addClass('is-disabled');
      } // To determine if it is a touch screen.


      if (Modernizr.touchevents) {
        if (elementIndex == total) elementIndex = total - 1;
        if (elementIndex < 0) elementIndex = 0; //Prevent bubbling

        if (!loop) {
          //first item
          if (elementIndex == 0) {
            $(arrowsID).find('.uix-svgMask-slider__arrows--prev').addClass('is-disabled');
          } //last item


          if (elementIndex == total - 1) {
            $(arrowsID).find('.uix-svgMask-slider__arrows--next').addClass('is-disabled');
          }
        }
      } // call the current item
      //-------------------------------------


      var $current = $items.eq(elementIndex); //Determine the direction and add class to switching direction indicator.

      var dirIndicatorClass = '';
      if (dir == 'prev') dirIndicatorClass = 'prev';
      if (dir == 'next') dirIndicatorClass = 'next'; //Add transition class to Controls Pagination

      $(paginationID).find('li a').removeClass('leave');
      $(paginationID).find('li a.is-active').removeClass('is-active').addClass('leave');
      $(paginationID).find('li a[data-index="' + elementIndex + '"]').addClass('is-active').removeClass('leave'); //Add transition class to each item

      $items.removeClass('leave prev next');
      $items.addClass(dirIndicatorClass);
      slider.find('.uix-svgMask-slider__item.is-active').removeClass('is-active').addClass('leave ' + dirIndicatorClass);
      $current.addClass('is-active ' + dirIndicatorClass).removeClass('leave'); //SVG Animation
      //-------------------------------------

      if (!svgAnimating) {
        //don't animate if already animating
        svgAnimating = true;
        var path1 = '1 0.5 1 540.5 1 1080.5 0 1080.5 4 1080.5 4 540.5 4 0.5 0 0.5 1 0.5',
            path2 = '0.5 0.5 0.5 540.5 0.5 1080.5 1519.5 1080.5 1531.5 1080.5 1066.5 525.5 601.5 1.5 589.5 1.5 0.5 0.5',
            path3 = '0.5 0.5 0.5 540.5 0.5 1080.5 960.5 1080.5 1920.5 1080.5 1920.5 540.5 1920.5 0.5 960.5 0.5 0.5 0.5';

        if (dir == 'next') {
          $current.find('polygon').css({
            'transform-origin': 'center',
            'transform': 'rotate(180deg)'
          });
        } else {
          $current.find('polygon').css({
            'transform-origin': 'center',
            'transform': 'rotate(0)'
          });
        } //----
        //@required: MorphSVGPlugin

        /*
        TweenMax.set( $current.find('polygon')[0], {
        	attr: {
        			  points: path1
        		  },
        	onComplete: function() {
        			TweenMax.to( this.target, animSpeed/1000, {
        			morphSVG: path2,
        			delay: 0,
        			ease: Power2.easeOut,
        			onComplete: function() {
        					TweenMax.to( this.target, animSpeed/1000, {
        					morphSVG: path3,
        					delay: 0,
        					ease: Power2.easeInOut,
        					onComplete: function() {
        						svgAnimating = false;
        					}
        				});	
        					}
        		});	
        		}
        });
        */


        TweenMax.set($current.find('polygon')[0], {
          attr: {
            points: path1
          },
          onComplete: function onComplete() {
            anime.timeline({
              loop: false
            }).add({
              targets: $current.find('polygon')[0],
              points: [{
                value: path2
              }],
              duration: animSpeed,
              easing: "easeOutExpo"
            }).add({
              targets: $current.find('polygon')[0],
              points: [{
                value: path3
              }],
              duration: animSpeed,
              easing: "easeOutExpo",
              complete: function complete() {
                svgAnimating = false;
              }
            });
          }
        });
      } //endif svgAnimating
      //Display counter
      //-------------------------------------


      $(countTotalID).text(total);
      $(countCurID).text(parseFloat(elementIndex) + 1); //Reset the default height of item
      //-------------------------------------	

      itemDefaultInit(slider, $current);
    }
    /*
     * Initialize the default height of item
     *
           * @param  {Element} slider                 - Selector of the slider .
     * @param  {Element} currentLlement         - Current selector of each slider.
     * @return {Void}
     */


    function itemDefaultInit(slider, currentLlement) {
      //
      var imgURL = currentLlement.find('img').attr('src');

      if ((0,esm_typeof/* default */.Z)(imgURL) != ( true ? "undefined" : 0)) {
        var img = new Image();

        img.onload = function () {
          slider.css('height', currentLlement.closest('.uix-svgMask-slider__outline').width() * (this.height / this.width) + 'px');
        };

        img.src = imgURL;
      }
    }
  };

  module.components.pageLoaded.push(module.SVG_MASK_SLIDER.pageLoaded);
  return /*#__PURE__*/_createClass(function SVG_MASK_SLIDER() {
    _classCallCheck(this, SVG_MASK_SLIDER);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/defineProperty.js
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/ssr-window/package/ssr-window.esm.js


/**
 * SSR Window 3.0.0
 * Better handling for window object in SSR environment
 * https://github.com/nolimits4web/ssr-window
 *
 * Copyright 2021, Vladimir Kharlampidi
 *
 * Licensed under MIT
 *
 * Released on: February 15, 2021
 */

/* eslint-disable no-param-reassign */
function isObject(obj) {
  return obj !== null && (0,esm_typeof/* default */.Z)(obj) === 'object' && 'constructor' in obj && obj.constructor === Object;
}

function extend(target, src) {
  if (target === void 0) {
    target = {};
  }

  if (src === void 0) {
    src = {};
  }

  Object.keys(src).forEach(function (key) {
    if (typeof target[key] === 'undefined') target[key] = src[key];else if (isObject(src[key]) && isObject(target[key]) && Object.keys(src[key]).length > 0) {
      extend(target[key], src[key]);
    }
  });
}

var ssrDocument = {
  body: {},
  addEventListener: function addEventListener() {},
  removeEventListener: function removeEventListener() {},
  activeElement: {
    blur: function blur() {},
    nodeName: ''
  },
  querySelector: function querySelector() {
    return null;
  },
  querySelectorAll: function querySelectorAll() {
    return [];
  },
  getElementById: function getElementById() {
    return null;
  },
  createEvent: function createEvent() {
    return {
      initEvent: function initEvent() {}
    };
  },
  createElement: function createElement() {
    return {
      children: [],
      childNodes: [],
      style: {},
      setAttribute: function setAttribute() {},
      getElementsByTagName: function getElementsByTagName() {
        return [];
      }
    };
  },
  createElementNS: function createElementNS() {
    return {};
  },
  importNode: function importNode() {
    return null;
  },
  location: {
    hash: '',
    host: '',
    hostname: '',
    href: '',
    origin: '',
    pathname: '',
    protocol: '',
    search: ''
  }
};

function getDocument() {
  var doc = typeof document !== 'undefined' ? document : {};
  extend(doc, ssrDocument);
  return doc;
}

var ssrWindow = {
  document: ssrDocument,
  navigator: {
    userAgent: ''
  },
  location: {
    hash: '',
    host: '',
    hostname: '',
    href: '',
    origin: '',
    pathname: '',
    protocol: '',
    search: ''
  },
  history: {
    replaceState: function replaceState() {},
    pushState: function pushState() {},
    go: function go() {},
    back: function back() {}
  },
  CustomEvent: function CustomEvent() {
    return this;
  },
  addEventListener: function addEventListener() {},
  removeEventListener: function removeEventListener() {},
  getComputedStyle: function getComputedStyle() {
    return {
      getPropertyValue: function getPropertyValue() {
        return '';
      }
    };
  },
  Image: function Image() {},
  Date: function Date() {},
  screen: {},
  setTimeout: function setTimeout() {},
  clearTimeout: function clearTimeout() {},
  matchMedia: function matchMedia() {
    return {};
  },
  requestAnimationFrame: function requestAnimationFrame(callback) {
    if (typeof setTimeout === 'undefined') {
      callback();
      return null;
    }

    return setTimeout(callback, 0);
  },
  cancelAnimationFrame: function cancelAnimationFrame(id) {
    if (typeof setTimeout === 'undefined') {
      return;
    }

    clearTimeout(id);
  }
};

function ssr_window_esm_getWindow() {
  var win = typeof window !== 'undefined' ? window : {};
  extend(win, ssrWindow);
  return win;
}


;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/dom7/package/dom7.esm.js
/**
 * Dom7 3.0.0
 * Minimalistic JavaScript library for DOM manipulation, with a jQuery-compatible API
 * https://framework7.io/docs/dom7.html
 *
 * Copyright 2021, Vladimir Kharlampidi
 *
 * Licensed under MIT
 *
 * Released on: February 15, 2021
 */


function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;

  _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}
/* eslint-disable no-proto */


function makeReactive(obj) {
  var proto = obj.__proto__;
  Object.defineProperty(obj, '__proto__', {
    get: function get() {
      return proto;
    },
    set: function set(value) {
      proto.__proto__ = value;
    }
  });
}

var Dom7 = /*#__PURE__*/function (_Array) {
  _inheritsLoose(Dom7, _Array);

  function Dom7(items) {
    var _this;

    _this = _Array.call.apply(_Array, [this].concat(items)) || this;
    makeReactive(_assertThisInitialized(_this));
    return _this;
  }

  return Dom7;
}( /*#__PURE__*/_wrapNativeSuper(Array));

function arrayFlat(arr) {
  if (arr === void 0) {
    arr = [];
  }

  var res = [];
  arr.forEach(function (el) {
    if (Array.isArray(el)) {
      res.push.apply(res, arrayFlat(el));
    } else {
      res.push(el);
    }
  });
  return res;
}

function arrayFilter(arr, callback) {
  return Array.prototype.filter.call(arr, callback);
}

function arrayUnique(arr) {
  var uniqueArray = [];

  for (var i = 0; i < arr.length; i += 1) {
    if (uniqueArray.indexOf(arr[i]) === -1) uniqueArray.push(arr[i]);
  }

  return uniqueArray;
}

function toCamelCase(string) {
  return string.toLowerCase().replace(/-(.)/g, function (match, group) {
    return group.toUpperCase();
  });
}

function qsa(selector, context) {
  if (typeof selector !== 'string') {
    return [selector];
  }

  var a = [];
  var res = context.querySelectorAll(selector);

  for (var i = 0; i < res.length; i += 1) {
    a.push(res[i]);
  }

  return a;
}

function dom7_esm_$(selector, context) {
  var window = ssr_window_esm_getWindow();
  var document = getDocument();
  var arr = [];

  if (!context && selector instanceof Dom7) {
    return selector;
  }

  if (!selector) {
    return new Dom7(arr);
  }

  if (typeof selector === 'string') {
    var html = selector.trim();

    if (html.indexOf('<') >= 0 && html.indexOf('>') >= 0) {
      var toCreate = 'div';
      if (html.indexOf('<li') === 0) toCreate = 'ul';
      if (html.indexOf('<tr') === 0) toCreate = 'tbody';
      if (html.indexOf('<td') === 0 || html.indexOf('<th') === 0) toCreate = 'tr';
      if (html.indexOf('<tbody') === 0) toCreate = 'table';
      if (html.indexOf('<option') === 0) toCreate = 'select';
      var tempParent = document.createElement(toCreate);
      tempParent.innerHTML = html;

      for (var i = 0; i < tempParent.childNodes.length; i += 1) {
        arr.push(tempParent.childNodes[i]);
      }
    } else {
      arr = qsa(selector.trim(), context || document);
    } // arr = qsa(selector, document);

  } else if (selector.nodeType || selector === window || selector === document) {
    arr.push(selector);
  } else if (Array.isArray(selector)) {
    if (selector instanceof Dom7) return selector;
    arr = selector;
  }

  return new Dom7(arrayUnique(arr));
}

dom7_esm_$.fn = Dom7.prototype;

function addClass() {
  for (var _len = arguments.length, classes = new Array(_len), _key = 0; _key < _len; _key++) {
    classes[_key] = arguments[_key];
  }

  var classNames = arrayFlat(classes.map(function (c) {
    return c.split(' ');
  }));
  this.forEach(function (el) {
    var _el$classList;

    (_el$classList = el.classList).add.apply(_el$classList, classNames);
  });
  return this;
}

function removeClass() {
  for (var _len2 = arguments.length, classes = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    classes[_key2] = arguments[_key2];
  }

  var classNames = arrayFlat(classes.map(function (c) {
    return c.split(' ');
  }));
  this.forEach(function (el) {
    var _el$classList2;

    (_el$classList2 = el.classList).remove.apply(_el$classList2, classNames);
  });
  return this;
}

function toggleClass() {
  for (var _len3 = arguments.length, classes = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    classes[_key3] = arguments[_key3];
  }

  var classNames = arrayFlat(classes.map(function (c) {
    return c.split(' ');
  }));
  this.forEach(function (el) {
    classNames.forEach(function (className) {
      el.classList.toggle(className);
    });
  });
}

function hasClass() {
  for (var _len4 = arguments.length, classes = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
    classes[_key4] = arguments[_key4];
  }

  var classNames = arrayFlat(classes.map(function (c) {
    return c.split(' ');
  }));
  return arrayFilter(this, function (el) {
    return classNames.filter(function (className) {
      return el.classList.contains(className);
    }).length > 0;
  }).length > 0;
}

function attr(attrs, value) {
  if (arguments.length === 1 && typeof attrs === 'string') {
    // Get attr
    if (this[0]) return this[0].getAttribute(attrs);
    return undefined;
  } // Set attrs


  for (var i = 0; i < this.length; i += 1) {
    if (arguments.length === 2) {
      // String
      this[i].setAttribute(attrs, value);
    } else {
      // Object
      for (var attrName in attrs) {
        this[i][attrName] = attrs[attrName];
        this[i].setAttribute(attrName, attrs[attrName]);
      }
    }
  }

  return this;
}

function removeAttr(attr) {
  for (var i = 0; i < this.length; i += 1) {
    this[i].removeAttribute(attr);
  }

  return this;
}

function prop(props, value) {
  if (arguments.length === 1 && typeof props === 'string') {
    // Get prop
    if (this[0]) return this[0][props];
  } else {
    // Set props
    for (var i = 0; i < this.length; i += 1) {
      if (arguments.length === 2) {
        // String
        this[i][props] = value;
      } else {
        // Object
        for (var propName in props) {
          this[i][propName] = props[propName];
        }
      }
    }

    return this;
  }

  return this;
}

function data(key, value) {
  var el;

  if (typeof value === 'undefined') {
    el = this[0];
    if (!el) return undefined; // Get value

    if (el.dom7ElementDataStorage && key in el.dom7ElementDataStorage) {
      return el.dom7ElementDataStorage[key];
    }

    var dataKey = el.getAttribute("data-" + key);

    if (dataKey) {
      return dataKey;
    }

    return undefined;
  } // Set value


  for (var i = 0; i < this.length; i += 1) {
    el = this[i];
    if (!el.dom7ElementDataStorage) el.dom7ElementDataStorage = {};
    el.dom7ElementDataStorage[key] = value;
  }

  return this;
}

function removeData(key) {
  for (var i = 0; i < this.length; i += 1) {
    var el = this[i];

    if (el.dom7ElementDataStorage && el.dom7ElementDataStorage[key]) {
      el.dom7ElementDataStorage[key] = null;
      delete el.dom7ElementDataStorage[key];
    }
  }
}

function dataset() {
  var el = this[0];
  if (!el) return undefined;
  var dataset = {}; // eslint-disable-line

  if (el.dataset) {
    for (var dataKey in el.dataset) {
      dataset[dataKey] = el.dataset[dataKey];
    }
  } else {
    for (var i = 0; i < el.attributes.length; i += 1) {
      var _attr = el.attributes[i];

      if (_attr.name.indexOf('data-') >= 0) {
        dataset[toCamelCase(_attr.name.split('data-')[1])] = _attr.value;
      }
    }
  }

  for (var key in dataset) {
    if (dataset[key] === 'false') dataset[key] = false;else if (dataset[key] === 'true') dataset[key] = true;else if (parseFloat(dataset[key]) === dataset[key] * 1) dataset[key] *= 1;
  }

  return dataset;
}

function val(value) {
  if (typeof value === 'undefined') {
    // get value
    var el = this[0];
    if (!el) return undefined;

    if (el.multiple && el.nodeName.toLowerCase() === 'select') {
      var values = [];

      for (var i = 0; i < el.selectedOptions.length; i += 1) {
        values.push(el.selectedOptions[i].value);
      }

      return values;
    }

    return el.value;
  } // set value


  for (var _i = 0; _i < this.length; _i += 1) {
    var _el = this[_i];

    if (Array.isArray(value) && _el.multiple && _el.nodeName.toLowerCase() === 'select') {
      for (var j = 0; j < _el.options.length; j += 1) {
        _el.options[j].selected = value.indexOf(_el.options[j].value) >= 0;
      }
    } else {
      _el.value = value;
    }
  }

  return this;
}

function value(value) {
  return this.val(value);
}

function transform(transform) {
  for (var i = 0; i < this.length; i += 1) {
    this[i].style.transform = transform;
  }

  return this;
}

function transition(duration) {
  for (var i = 0; i < this.length; i += 1) {
    this[i].style.transitionDuration = typeof duration !== 'string' ? duration + "ms" : duration;
  }

  return this;
}

function on() {
  for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
    args[_key5] = arguments[_key5];
  }

  var eventType = args[0],
      targetSelector = args[1],
      listener = args[2],
      capture = args[3];

  if (typeof args[1] === 'function') {
    eventType = args[0];
    listener = args[1];
    capture = args[2];
    targetSelector = undefined;
  }

  if (!capture) capture = false;

  function handleLiveEvent(e) {
    var target = e.target;
    if (!target) return;
    var eventData = e.target.dom7EventData || [];

    if (eventData.indexOf(e) < 0) {
      eventData.unshift(e);
    }

    if (dom7_esm_$(target).is(targetSelector)) listener.apply(target, eventData);else {
      var _parents = dom7_esm_$(target).parents(); // eslint-disable-line


      for (var k = 0; k < _parents.length; k += 1) {
        if (dom7_esm_$(_parents[k]).is(targetSelector)) listener.apply(_parents[k], eventData);
      }
    }
  }

  function handleEvent(e) {
    var eventData = e && e.target ? e.target.dom7EventData || [] : [];

    if (eventData.indexOf(e) < 0) {
      eventData.unshift(e);
    }

    listener.apply(this, eventData);
  }

  var events = eventType.split(' ');
  var j;

  for (var i = 0; i < this.length; i += 1) {
    var el = this[i];

    if (!targetSelector) {
      for (j = 0; j < events.length; j += 1) {
        var event = events[j];
        if (!el.dom7Listeners) el.dom7Listeners = {};
        if (!el.dom7Listeners[event]) el.dom7Listeners[event] = [];
        el.dom7Listeners[event].push({
          listener: listener,
          proxyListener: handleEvent
        });
        el.addEventListener(event, handleEvent, capture);
      }
    } else {
      // Live events
      for (j = 0; j < events.length; j += 1) {
        var _event = events[j];
        if (!el.dom7LiveListeners) el.dom7LiveListeners = {};
        if (!el.dom7LiveListeners[_event]) el.dom7LiveListeners[_event] = [];

        el.dom7LiveListeners[_event].push({
          listener: listener,
          proxyListener: handleLiveEvent
        });

        el.addEventListener(_event, handleLiveEvent, capture);
      }
    }
  }

  return this;
}

function off() {
  for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
    args[_key6] = arguments[_key6];
  }

  var eventType = args[0],
      targetSelector = args[1],
      listener = args[2],
      capture = args[3];

  if (typeof args[1] === 'function') {
    eventType = args[0];
    listener = args[1];
    capture = args[2];
    targetSelector = undefined;
  }

  if (!capture) capture = false;
  var events = eventType.split(' ');

  for (var i = 0; i < events.length; i += 1) {
    var event = events[i];

    for (var j = 0; j < this.length; j += 1) {
      var el = this[j];
      var handlers = void 0;

      if (!targetSelector && el.dom7Listeners) {
        handlers = el.dom7Listeners[event];
      } else if (targetSelector && el.dom7LiveListeners) {
        handlers = el.dom7LiveListeners[event];
      }

      if (handlers && handlers.length) {
        for (var k = handlers.length - 1; k >= 0; k -= 1) {
          var handler = handlers[k];

          if (listener && handler.listener === listener) {
            el.removeEventListener(event, handler.proxyListener, capture);
            handlers.splice(k, 1);
          } else if (listener && handler.listener && handler.listener.dom7proxy && handler.listener.dom7proxy === listener) {
            el.removeEventListener(event, handler.proxyListener, capture);
            handlers.splice(k, 1);
          } else if (!listener) {
            el.removeEventListener(event, handler.proxyListener, capture);
            handlers.splice(k, 1);
          }
        }
      }
    }
  }

  return this;
}

function once() {
  var dom = this;

  for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
    args[_key7] = arguments[_key7];
  }

  var eventName = args[0],
      targetSelector = args[1],
      listener = args[2],
      capture = args[3];

  if (typeof args[1] === 'function') {
    eventName = args[0];
    listener = args[1];
    capture = args[2];
    targetSelector = undefined;
  }

  function onceHandler() {
    for (var _len8 = arguments.length, eventArgs = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
      eventArgs[_key8] = arguments[_key8];
    }

    listener.apply(this, eventArgs);
    dom.off(eventName, targetSelector, onceHandler, capture);

    if (onceHandler.dom7proxy) {
      delete onceHandler.dom7proxy;
    }
  }

  onceHandler.dom7proxy = listener;
  return dom.on(eventName, targetSelector, onceHandler, capture);
}

function trigger() {
  var window = ssr_window_esm_getWindow();

  for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
    args[_key9] = arguments[_key9];
  }

  var events = args[0].split(' ');
  var eventData = args[1];

  for (var i = 0; i < events.length; i += 1) {
    var event = events[i];

    for (var j = 0; j < this.length; j += 1) {
      var el = this[j];

      if (window.CustomEvent) {
        var evt = new window.CustomEvent(event, {
          detail: eventData,
          bubbles: true,
          cancelable: true
        });
        el.dom7EventData = args.filter(function (data, dataIndex) {
          return dataIndex > 0;
        });
        el.dispatchEvent(evt);
        el.dom7EventData = [];
        delete el.dom7EventData;
      }
    }
  }

  return this;
}

function transitionEnd(callback) {
  var dom = this;

  function fireCallBack(e) {
    if (e.target !== this) return;
    callback.call(this, e);
    dom.off('transitionend', fireCallBack);
  }

  if (callback) {
    dom.on('transitionend', fireCallBack);
  }

  return this;
}

function animationEnd(callback) {
  var dom = this;

  function fireCallBack(e) {
    if (e.target !== this) return;
    callback.call(this, e);
    dom.off('animationend', fireCallBack);
  }

  if (callback) {
    dom.on('animationend', fireCallBack);
  }

  return this;
}

function width() {
  var window = getWindow();

  if (this[0] === window) {
    return window.innerWidth;
  }

  if (this.length > 0) {
    return parseFloat(this.css('width'));
  }

  return null;
}

function dom7_esm_outerWidth(includeMargins) {
  if (this.length > 0) {
    if (includeMargins) {
      var _styles = this.styles();

      return this[0].offsetWidth + parseFloat(_styles.getPropertyValue('margin-right')) + parseFloat(_styles.getPropertyValue('margin-left'));
    }

    return this[0].offsetWidth;
  }

  return null;
}

function height() {
  var window = getWindow();

  if (this[0] === window) {
    return window.innerHeight;
  }

  if (this.length > 0) {
    return parseFloat(this.css('height'));
  }

  return null;
}

function dom7_esm_outerHeight(includeMargins) {
  if (this.length > 0) {
    if (includeMargins) {
      var _styles2 = this.styles();

      return this[0].offsetHeight + parseFloat(_styles2.getPropertyValue('margin-top')) + parseFloat(_styles2.getPropertyValue('margin-bottom'));
    }

    return this[0].offsetHeight;
  }

  return null;
}

function offset() {
  if (this.length > 0) {
    var window = ssr_window_esm_getWindow();
    var document = getDocument();
    var el = this[0];
    var box = el.getBoundingClientRect();
    var body = document.body;
    var clientTop = el.clientTop || body.clientTop || 0;
    var clientLeft = el.clientLeft || body.clientLeft || 0;
    var scrollTop = el === window ? window.scrollY : el.scrollTop;
    var scrollLeft = el === window ? window.scrollX : el.scrollLeft;
    return {
      top: box.top + scrollTop - clientTop,
      left: box.left + scrollLeft - clientLeft
    };
  }

  return null;
}

function hide() {
  for (var i = 0; i < this.length; i += 1) {
    this[i].style.display = 'none';
  }

  return this;
}

function show() {
  var window = getWindow();

  for (var i = 0; i < this.length; i += 1) {
    var el = this[i];

    if (el.style.display === 'none') {
      el.style.display = '';
    }

    if (window.getComputedStyle(el, null).getPropertyValue('display') === 'none') {
      // Still not visible
      el.style.display = 'block';
    }
  }

  return this;
}

function styles() {
  var window = ssr_window_esm_getWindow();
  if (this[0]) return window.getComputedStyle(this[0], null);
  return {};
}

function css(props, value) {
  var window = ssr_window_esm_getWindow();
  var i;

  if (arguments.length === 1) {
    if (typeof props === 'string') {
      // .css('width')
      if (this[0]) return window.getComputedStyle(this[0], null).getPropertyValue(props);
    } else {
      // .css({ width: '100px' })
      for (i = 0; i < this.length; i += 1) {
        for (var _prop in props) {
          this[i].style[_prop] = props[_prop];
        }
      }

      return this;
    }
  }

  if (arguments.length === 2 && typeof props === 'string') {
    // .css('width', '100px')
    for (i = 0; i < this.length; i += 1) {
      this[i].style[props] = value;
    }

    return this;
  }

  return this;
}

function each(callback) {
  if (!callback) return this;
  this.forEach(function (el, index) {
    callback.apply(el, [el, index]);
  });
  return this;
}

function filter(callback) {
  var result = arrayFilter(this, callback);
  return dom7_esm_$(result);
}

function html(html) {
  if (typeof html === 'undefined') {
    return this[0] ? this[0].innerHTML : null;
  }

  for (var i = 0; i < this.length; i += 1) {
    this[i].innerHTML = html;
  }

  return this;
}

function dom7_esm_text(text) {
  if (typeof text === 'undefined') {
    return this[0] ? this[0].textContent.trim() : null;
  }

  for (var i = 0; i < this.length; i += 1) {
    this[i].textContent = text;
  }

  return this;
}

function is(selector) {
  var window = ssr_window_esm_getWindow();
  var document = getDocument();
  var el = this[0];
  var compareWith;
  var i;
  if (!el || typeof selector === 'undefined') return false;

  if (typeof selector === 'string') {
    if (el.matches) return el.matches(selector);
    if (el.webkitMatchesSelector) return el.webkitMatchesSelector(selector);
    if (el.msMatchesSelector) return el.msMatchesSelector(selector);
    compareWith = dom7_esm_$(selector);

    for (i = 0; i < compareWith.length; i += 1) {
      if (compareWith[i] === el) return true;
    }

    return false;
  }

  if (selector === document) {
    return el === document;
  }

  if (selector === window) {
    return el === window;
  }

  if (selector.nodeType || selector instanceof Dom7) {
    compareWith = selector.nodeType ? [selector] : selector;

    for (i = 0; i < compareWith.length; i += 1) {
      if (compareWith[i] === el) return true;
    }

    return false;
  }

  return false;
}

function index() {
  var child = this[0];
  var i;

  if (child) {
    i = 0; // eslint-disable-next-line

    while ((child = child.previousSibling) !== null) {
      if (child.nodeType === 1) i += 1;
    }

    return i;
  }

  return undefined;
}

function eq(index) {
  if (typeof index === 'undefined') return this;
  var length = this.length;

  if (index > length - 1) {
    return dom7_esm_$([]);
  }

  if (index < 0) {
    var returnIndex = length + index;
    if (returnIndex < 0) return dom7_esm_$([]);
    return dom7_esm_$([this[returnIndex]]);
  }

  return dom7_esm_$([this[index]]);
}

function append() {
  var newChild;
  var document = getDocument();

  for (var k = 0; k < arguments.length; k += 1) {
    newChild = k < 0 || arguments.length <= k ? undefined : arguments[k];

    for (var i = 0; i < this.length; i += 1) {
      if (typeof newChild === 'string') {
        var tempDiv = document.createElement('div');
        tempDiv.innerHTML = newChild;

        while (tempDiv.firstChild) {
          this[i].appendChild(tempDiv.firstChild);
        }
      } else if (newChild instanceof Dom7) {
        for (var j = 0; j < newChild.length; j += 1) {
          this[i].appendChild(newChild[j]);
        }
      } else {
        this[i].appendChild(newChild);
      }
    }
  }

  return this;
}

function appendTo(parent) {
  dom7_esm_$(parent).append(this);
  return this;
}

function prepend(newChild) {
  var document = getDocument();
  var i;
  var j;

  for (i = 0; i < this.length; i += 1) {
    if (typeof newChild === 'string') {
      var tempDiv = document.createElement('div');
      tempDiv.innerHTML = newChild;

      for (j = tempDiv.childNodes.length - 1; j >= 0; j -= 1) {
        this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);
      }
    } else if (newChild instanceof Dom7) {
      for (j = 0; j < newChild.length; j += 1) {
        this[i].insertBefore(newChild[j], this[i].childNodes[0]);
      }
    } else {
      this[i].insertBefore(newChild, this[i].childNodes[0]);
    }
  }

  return this;
}

function prependTo(parent) {
  dom7_esm_$(parent).prepend(this);
  return this;
}

function insertBefore(selector) {
  var before = dom7_esm_$(selector);

  for (var i = 0; i < this.length; i += 1) {
    if (before.length === 1) {
      before[0].parentNode.insertBefore(this[i], before[0]);
    } else if (before.length > 1) {
      for (var j = 0; j < before.length; j += 1) {
        before[j].parentNode.insertBefore(this[i].cloneNode(true), before[j]);
      }
    }
  }
}

function insertAfter(selector) {
  var after = dom7_esm_$(selector);

  for (var i = 0; i < this.length; i += 1) {
    if (after.length === 1) {
      after[0].parentNode.insertBefore(this[i], after[0].nextSibling);
    } else if (after.length > 1) {
      for (var j = 0; j < after.length; j += 1) {
        after[j].parentNode.insertBefore(this[i].cloneNode(true), after[j].nextSibling);
      }
    }
  }
}

function next(selector) {
  if (this.length > 0) {
    if (selector) {
      if (this[0].nextElementSibling && dom7_esm_$(this[0].nextElementSibling).is(selector)) {
        return dom7_esm_$([this[0].nextElementSibling]);
      }

      return dom7_esm_$([]);
    }

    if (this[0].nextElementSibling) return dom7_esm_$([this[0].nextElementSibling]);
    return dom7_esm_$([]);
  }

  return dom7_esm_$([]);
}

function nextAll(selector) {
  var nextEls = [];
  var el = this[0];
  if (!el) return dom7_esm_$([]);

  while (el.nextElementSibling) {
    var _next = el.nextElementSibling; // eslint-disable-line

    if (selector) {
      if (dom7_esm_$(_next).is(selector)) nextEls.push(_next);
    } else nextEls.push(_next);

    el = _next;
  }

  return dom7_esm_$(nextEls);
}

function prev(selector) {
  if (this.length > 0) {
    var el = this[0];

    if (selector) {
      if (el.previousElementSibling && dom7_esm_$(el.previousElementSibling).is(selector)) {
        return dom7_esm_$([el.previousElementSibling]);
      }

      return dom7_esm_$([]);
    }

    if (el.previousElementSibling) return dom7_esm_$([el.previousElementSibling]);
    return dom7_esm_$([]);
  }

  return dom7_esm_$([]);
}

function prevAll(selector) {
  var prevEls = [];
  var el = this[0];
  if (!el) return dom7_esm_$([]);

  while (el.previousElementSibling) {
    var _prev = el.previousElementSibling; // eslint-disable-line

    if (selector) {
      if (dom7_esm_$(_prev).is(selector)) prevEls.push(_prev);
    } else prevEls.push(_prev);

    el = _prev;
  }

  return dom7_esm_$(prevEls);
}

function siblings(selector) {
  return this.nextAll(selector).add(this.prevAll(selector));
}

function dom7_esm_parent(selector) {
  var parents = []; // eslint-disable-line

  for (var i = 0; i < this.length; i += 1) {
    if (this[i].parentNode !== null) {
      if (selector) {
        if (dom7_esm_$(this[i].parentNode).is(selector)) parents.push(this[i].parentNode);
      } else {
        parents.push(this[i].parentNode);
      }
    }
  }

  return dom7_esm_$(parents);
}

function parents(selector) {
  var parents = []; // eslint-disable-line

  for (var i = 0; i < this.length; i += 1) {
    var _parent = this[i].parentNode; // eslint-disable-line

    while (_parent) {
      if (selector) {
        if (dom7_esm_$(_parent).is(selector)) parents.push(_parent);
      } else {
        parents.push(_parent);
      }

      _parent = _parent.parentNode;
    }
  }

  return dom7_esm_$(parents);
}

function closest(selector) {
  var closest = this; // eslint-disable-line

  if (typeof selector === 'undefined') {
    return dom7_esm_$([]);
  }

  if (!closest.is(selector)) {
    closest = closest.parents(selector).eq(0);
  }

  return closest;
}

function find(selector) {
  var foundElements = [];

  for (var i = 0; i < this.length; i += 1) {
    var found = this[i].querySelectorAll(selector);

    for (var j = 0; j < found.length; j += 1) {
      foundElements.push(found[j]);
    }
  }

  return dom7_esm_$(foundElements);
}

function children(selector) {
  var children = []; // eslint-disable-line

  for (var i = 0; i < this.length; i += 1) {
    var childNodes = this[i].children;

    for (var j = 0; j < childNodes.length; j += 1) {
      if (!selector || dom7_esm_$(childNodes[j]).is(selector)) {
        children.push(childNodes[j]);
      }
    }
  }

  return dom7_esm_$(children);
}

function remove() {
  for (var i = 0; i < this.length; i += 1) {
    if (this[i].parentNode) this[i].parentNode.removeChild(this[i]);
  }

  return this;
}

function detach() {
  return this.remove();
}

function add() {
  var dom = this;
  var i;
  var j;

  for (var _len10 = arguments.length, els = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
    els[_key10] = arguments[_key10];
  }

  for (i = 0; i < els.length; i += 1) {
    var toAdd = dom7_esm_$(els[i]);

    for (j = 0; j < toAdd.length; j += 1) {
      dom.push(toAdd[j]);
    }
  }

  return dom;
}

function empty() {
  for (var i = 0; i < this.length; i += 1) {
    var el = this[i];

    if (el.nodeType === 1) {
      for (var j = 0; j < el.childNodes.length; j += 1) {
        if (el.childNodes[j].parentNode) {
          el.childNodes[j].parentNode.removeChild(el.childNodes[j]);
        }
      }

      el.textContent = '';
    }
  }

  return this;
}

function scrollTo() {
  var window = getWindow();

  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  var left = args[0],
      top = args[1],
      duration = args[2],
      easing = args[3],
      callback = args[4];

  if (args.length === 4 && typeof easing === 'function') {
    callback = easing;
    left = args[0];
    top = args[1];
    duration = args[2];
    callback = args[3];
    easing = args[4];
  }

  if (typeof easing === 'undefined') easing = 'swing';
  return this.each(function animate() {
    var el = this;
    var currentTop;
    var currentLeft;
    var maxTop;
    var maxLeft;
    var newTop;
    var newLeft;
    var scrollTop; // eslint-disable-line

    var scrollLeft; // eslint-disable-line

    var animateTop = top > 0 || top === 0;
    var animateLeft = left > 0 || left === 0;

    if (typeof easing === 'undefined') {
      easing = 'swing';
    }

    if (animateTop) {
      currentTop = el.scrollTop;

      if (!duration) {
        el.scrollTop = top;
      }
    }

    if (animateLeft) {
      currentLeft = el.scrollLeft;

      if (!duration) {
        el.scrollLeft = left;
      }
    }

    if (!duration) return;

    if (animateTop) {
      maxTop = el.scrollHeight - el.offsetHeight;
      newTop = Math.max(Math.min(top, maxTop), 0);
    }

    if (animateLeft) {
      maxLeft = el.scrollWidth - el.offsetWidth;
      newLeft = Math.max(Math.min(left, maxLeft), 0);
    }

    var startTime = null;
    if (animateTop && newTop === currentTop) animateTop = false;
    if (animateLeft && newLeft === currentLeft) animateLeft = false;

    function render(time) {
      if (time === void 0) {
        time = new Date().getTime();
      }

      if (startTime === null) {
        startTime = time;
      }

      var progress = Math.max(Math.min((time - startTime) / duration, 1), 0);
      var easeProgress = easing === 'linear' ? progress : 0.5 - Math.cos(progress * Math.PI) / 2;
      var done;
      if (animateTop) scrollTop = currentTop + easeProgress * (newTop - currentTop);
      if (animateLeft) scrollLeft = currentLeft + easeProgress * (newLeft - currentLeft);

      if (animateTop && newTop > currentTop && scrollTop >= newTop) {
        el.scrollTop = newTop;
        done = true;
      }

      if (animateTop && newTop < currentTop && scrollTop <= newTop) {
        el.scrollTop = newTop;
        done = true;
      }

      if (animateLeft && newLeft > currentLeft && scrollLeft >= newLeft) {
        el.scrollLeft = newLeft;
        done = true;
      }

      if (animateLeft && newLeft < currentLeft && scrollLeft <= newLeft) {
        el.scrollLeft = newLeft;
        done = true;
      }

      if (done) {
        if (callback) callback();
        return;
      }

      if (animateTop) el.scrollTop = scrollTop;
      if (animateLeft) el.scrollLeft = scrollLeft;
      window.requestAnimationFrame(render);
    }

    window.requestAnimationFrame(render);
  });
} // scrollTop(top, duration, easing, callback) {


function scrollTop() {
  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }

  var top = args[0],
      duration = args[1],
      easing = args[2],
      callback = args[3];

  if (args.length === 3 && typeof easing === 'function') {
    top = args[0];
    duration = args[1];
    callback = args[2];
    easing = args[3];
  }

  var dom = this;

  if (typeof top === 'undefined') {
    if (dom.length > 0) return dom[0].scrollTop;
    return null;
  }

  return dom.scrollTo(undefined, top, duration, easing, callback);
}

function scrollLeft() {
  for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    args[_key3] = arguments[_key3];
  }

  var left = args[0],
      duration = args[1],
      easing = args[2],
      callback = args[3];

  if (args.length === 3 && typeof easing === 'function') {
    left = args[0];
    duration = args[1];
    callback = args[2];
    easing = args[3];
  }

  var dom = this;

  if (typeof left === 'undefined') {
    if (dom.length > 0) return dom[0].scrollLeft;
    return null;
  }

  return dom.scrollTo(left, undefined, duration, easing, callback);
}

function animate(initialProps, initialParams) {
  var window = getWindow();
  var els = this;
  var a = {
    props: Object.assign({}, initialProps),
    params: Object.assign({
      duration: 300,
      easing: 'swing' // or 'linear'

      /* Callbacks
      begin(elements)
      complete(elements)
      progress(elements, complete, remaining, start, tweenValue)
      */

    }, initialParams),
    elements: els,
    animating: false,
    que: [],
    easingProgress: function easingProgress(easing, progress) {
      if (easing === 'swing') {
        return 0.5 - Math.cos(progress * Math.PI) / 2;
      }

      if (typeof easing === 'function') {
        return easing(progress);
      }

      return progress;
    },
    stop: function stop() {
      if (a.frameId) {
        window.cancelAnimationFrame(a.frameId);
      }

      a.animating = false;
      a.elements.each(function (el) {
        var element = el;
        delete element.dom7AnimateInstance;
      });
      a.que = [];
    },
    done: function done(complete) {
      a.animating = false;
      a.elements.each(function (el) {
        var element = el;
        delete element.dom7AnimateInstance;
      });
      if (complete) complete(els);

      if (a.que.length > 0) {
        var que = a.que.shift();
        a.animate(que[0], que[1]);
      }
    },
    animate: function animate(props, params) {
      if (a.animating) {
        a.que.push([props, params]);
        return a;
      }

      var elements = []; // Define & Cache Initials & Units

      a.elements.each(function (el, index) {
        var initialFullValue;
        var initialValue;
        var unit;
        var finalValue;
        var finalFullValue;
        if (!el.dom7AnimateInstance) a.elements[index].dom7AnimateInstance = a;
        elements[index] = {
          container: el
        };
        Object.keys(props).forEach(function (prop) {
          initialFullValue = window.getComputedStyle(el, null).getPropertyValue(prop).replace(',', '.');
          initialValue = parseFloat(initialFullValue);
          unit = initialFullValue.replace(initialValue, '');
          finalValue = parseFloat(props[prop]);
          finalFullValue = props[prop] + unit;
          elements[index][prop] = {
            initialFullValue: initialFullValue,
            initialValue: initialValue,
            unit: unit,
            finalValue: finalValue,
            finalFullValue: finalFullValue,
            currentValue: initialValue
          };
        });
      });
      var startTime = null;
      var time;
      var elementsDone = 0;
      var propsDone = 0;
      var done;
      var began = false;
      a.animating = true;

      function render() {
        time = new Date().getTime();
        var progress;
        var easeProgress; // let el;

        if (!began) {
          began = true;
          if (params.begin) params.begin(els);
        }

        if (startTime === null) {
          startTime = time;
        }

        if (params.progress) {
          // eslint-disable-next-line
          params.progress(els, Math.max(Math.min((time - startTime) / params.duration, 1), 0), startTime + params.duration - time < 0 ? 0 : startTime + params.duration - time, startTime);
        }

        elements.forEach(function (element) {
          var el = element;
          if (done || el.done) return;
          Object.keys(props).forEach(function (prop) {
            if (done || el.done) return;
            progress = Math.max(Math.min((time - startTime) / params.duration, 1), 0);
            easeProgress = a.easingProgress(params.easing, progress);
            var _el$prop = el[prop],
                initialValue = _el$prop.initialValue,
                finalValue = _el$prop.finalValue,
                unit = _el$prop.unit;
            el[prop].currentValue = initialValue + easeProgress * (finalValue - initialValue);
            var currentValue = el[prop].currentValue;

            if (finalValue > initialValue && currentValue >= finalValue || finalValue < initialValue && currentValue <= finalValue) {
              el.container.style[prop] = finalValue + unit;
              propsDone += 1;

              if (propsDone === Object.keys(props).length) {
                el.done = true;
                elementsDone += 1;
              }

              if (elementsDone === elements.length) {
                done = true;
              }
            }

            if (done) {
              a.done(params.complete);
              return;
            }

            el.container.style[prop] = currentValue + unit;
          });
        });
        if (done) return; // Then call

        a.frameId = window.requestAnimationFrame(render);
      }

      a.frameId = window.requestAnimationFrame(render);
      return a;
    }
  };

  if (a.elements.length === 0) {
    return els;
  }

  var animateInstance;

  for (var i = 0; i < a.elements.length; i += 1) {
    if (a.elements[i].dom7AnimateInstance) {
      animateInstance = a.elements[i].dom7AnimateInstance;
    } else a.elements[i].dom7AnimateInstance = a;
  }

  if (!animateInstance) {
    animateInstance = a;
  }

  if (initialProps === 'stop') {
    animateInstance.stop();
  } else {
    animateInstance.animate(a.props, a.params);
  }

  return els;
}

function stop() {
  var els = this;

  for (var i = 0; i < els.length; i += 1) {
    if (els[i].dom7AnimateInstance) {
      els[i].dom7AnimateInstance.stop();
    }
  }
}

var noTrigger = 'resize scroll'.split(' ');

function shortcut(name) {
  function eventHandler() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    if (typeof args[0] === 'undefined') {
      for (var i = 0; i < this.length; i += 1) {
        if (noTrigger.indexOf(name) < 0) {
          if (name in this[i]) this[i][name]();else {
            dom7_esm_$(this[i]).trigger(name);
          }
        }
      }

      return this;
    }

    return this.on.apply(this, [name].concat(args));
  }

  return eventHandler;
}

var click = shortcut('click');
var dom7_esm_blur = shortcut('blur');
var dom7_esm_focus = shortcut('focus');
var focusin = shortcut('focusin');
var focusout = shortcut('focusout');
var keyup = shortcut('keyup');
var keydown = shortcut('keydown');
var keypress = shortcut('keypress');
var dom7_esm_submit = shortcut('submit');
var change = shortcut('change');
var mousedown = shortcut('mousedown');
var mousemove = shortcut('mousemove');
var mouseup = shortcut('mouseup');
var mouseenter = shortcut('mouseenter');
var mouseleave = shortcut('mouseleave');
var mouseout = shortcut('mouseout');
var mouseover = shortcut('mouseover');
var touchstart = shortcut('touchstart');
var touchend = shortcut('touchend');
var touchmove = shortcut('touchmove');
var resize = shortcut('resize');
var dom7_esm_scroll = shortcut('scroll');
/* harmony default export */ const dom7_esm = ((/* unused pure expression or super */ null && (dom7_esm_$)));

;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/utils/dom.js

var Methods = {
  addClass: addClass,
  removeClass: removeClass,
  hasClass: hasClass,
  toggleClass: toggleClass,
  attr: attr,
  removeAttr: removeAttr,
  transform: transform,
  transition: transition,
  on: on,
  off: off,
  trigger: trigger,
  transitionEnd: transitionEnd,
  outerWidth: dom7_esm_outerWidth,
  outerHeight: dom7_esm_outerHeight,
  styles: styles,
  offset: offset,
  css: css,
  each: each,
  html: html,
  text: dom7_esm_text,
  is: is,
  index: index,
  eq: eq,
  append: append,
  prepend: prepend,
  next: next,
  nextAll: nextAll,
  prev: prev,
  prevAll: prevAll,
  parent: dom7_esm_parent,
  parents: parents,
  closest: closest,
  find: find,
  children: children,
  filter: filter,
  remove: remove
};
Object.keys(Methods).forEach(function (methodName) {
  Object.defineProperty(dom7_esm_$.fn, methodName, {
    value: Methods[methodName],
    writable: true
  });
});
/* harmony default export */ const dom = (dom7_esm_$);
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/utils/utils.js



function deleteProps(obj) {
  var object = obj;
  Object.keys(object).forEach(function (key) {
    try {
      object[key] = null;
    } catch (e) {// no getter for object
    }

    try {
      delete object[key];
    } catch (e) {// something got wrong
    }
  });
}

function nextTick(callback) {
  var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  return setTimeout(callback, delay);
}

function now() {
  return Date.now();
}

function utils_getComputedStyle(el) {
  var window = ssr_window_esm_getWindow();
  var style;

  if (window.getComputedStyle) {
    style = window.getComputedStyle(el, null);
  }

  if (!style && el.currentStyle) {
    style = el.currentStyle;
  }

  if (!style) {
    style = el.style;
  }

  return style;
}

function getTranslate(el) {
  var axis = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'x';
  var window = ssr_window_esm_getWindow();
  var matrix;
  var curTransform;
  var transformMatrix;
  var curStyle = utils_getComputedStyle(el, null);

  if (window.WebKitCSSMatrix) {
    curTransform = curStyle.transform || curStyle.webkitTransform;

    if (curTransform.split(',').length > 6) {
      curTransform = curTransform.split(', ').map(function (a) {
        return a.replace(',', '.');
      }).join(', ');
    } // Some old versions of Webkit choke when 'none' is passed; pass
    // empty string instead in this case


    transformMatrix = new window.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);
  } else {
    transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');
    matrix = transformMatrix.toString().split(',');
  }

  if (axis === 'x') {
    // Latest Chrome and webkits Fix
    if (window.WebKitCSSMatrix) curTransform = transformMatrix.m41; // Crazy IE10 Matrix
    else if (matrix.length === 16) curTransform = parseFloat(matrix[12]); // Normal Browsers
    else curTransform = parseFloat(matrix[4]);
  }

  if (axis === 'y') {
    // Latest Chrome and webkits Fix
    if (window.WebKitCSSMatrix) curTransform = transformMatrix.m42; // Crazy IE10 Matrix
    else if (matrix.length === 16) curTransform = parseFloat(matrix[13]); // Normal Browsers
    else curTransform = parseFloat(matrix[5]);
  }

  return curTransform || 0;
}

function utils_isObject(o) {
  return (0,esm_typeof/* default */.Z)(o) === 'object' && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === 'Object';
}

function utils_extend() {
  var to = Object(arguments.length <= 0 ? undefined : arguments[0]);
  var noExtend = ['__proto__', 'constructor', 'prototype'];

  for (var i = 1; i < arguments.length; i += 1) {
    var nextSource = i < 0 || arguments.length <= i ? undefined : arguments[i];

    if (nextSource !== undefined && nextSource !== null) {
      var keysArray = Object.keys(Object(nextSource)).filter(function (key) {
        return noExtend.indexOf(key) < 0;
      });

      for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
        var nextKey = keysArray[nextIndex];
        var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);

        if (desc !== undefined && desc.enumerable) {
          if (utils_isObject(to[nextKey]) && utils_isObject(nextSource[nextKey])) {
            if (nextSource[nextKey].__swiper__) {
              to[nextKey] = nextSource[nextKey];
            } else {
              utils_extend(to[nextKey], nextSource[nextKey]);
            }
          } else if (!utils_isObject(to[nextKey]) && utils_isObject(nextSource[nextKey])) {
            to[nextKey] = {};

            if (nextSource[nextKey].__swiper__) {
              to[nextKey] = nextSource[nextKey];
            } else {
              utils_extend(to[nextKey], nextSource[nextKey]);
            }
          } else {
            to[nextKey] = nextSource[nextKey];
          }
        }
      }
    }
  }

  return to;
}

function bindModuleMethods(instance, obj) {
  Object.keys(obj).forEach(function (key) {
    if (utils_isObject(obj[key])) {
      Object.keys(obj[key]).forEach(function (subKey) {
        if (typeof obj[key][subKey] === 'function') {
          obj[key][subKey] = obj[key][subKey].bind(instance);
        }
      });
    }

    instance[key] = obj[key];
  });
}

function classesToSelector() {
  var classes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  return ".".concat(classes.trim().replace(/([\.:\/])/g, '\\$1') // eslint-disable-line
  .replace(/ /g, '.'));
}


;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/utils/get-support.js

var support;

function calcSupport() {
  var window = ssr_window_esm_getWindow();
  var document = getDocument();
  return {
    touch: !!('ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch),
    pointerEvents: !!window.PointerEvent && 'maxTouchPoints' in window.navigator && window.navigator.maxTouchPoints >= 0,
    observer: function checkObserver() {
      return 'MutationObserver' in window || 'WebkitMutationObserver' in window;
    }(),
    passiveListener: function checkPassiveListener() {
      var supportsPassive = false;

      try {
        var opts = Object.defineProperty({}, 'passive', {
          // eslint-disable-next-line
          get: function get() {
            supportsPassive = true;
          }
        });
        window.addEventListener('testPassiveListener', null, opts);
      } catch (e) {// No support
      }

      return supportsPassive;
    }(),
    gestures: function checkGestures() {
      return 'ongesturestart' in window;
    }()
  };
}

function getSupport() {
  if (!support) {
    support = calcSupport();
  }

  return support;
}


;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/utils/get-device.js


var device;

function calcDevice() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      userAgent = _ref.userAgent;

  var support = getSupport();
  var window = ssr_window_esm_getWindow();
  var platform = window.navigator.platform;
  var ua = userAgent || window.navigator.userAgent;
  var device = {
    ios: false,
    android: false
  };
  var screenWidth = window.screen.width;
  var screenHeight = window.screen.height;
  var android = ua.match(/(Android);?[\s\/]+([\d.]+)?/); // eslint-disable-line

  var ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
  var ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
  var iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
  var windows = platform === 'Win32';
  var macos = platform === 'MacIntel'; // iPadOs 13 fix

  var iPadScreens = ['1024x1366', '1366x1024', '834x1194', '1194x834', '834x1112', '1112x834', '768x1024', '1024x768', '820x1180', '1180x820', '810x1080', '1080x810'];

  if (!ipad && macos && support.touch && iPadScreens.indexOf("".concat(screenWidth, "x").concat(screenHeight)) >= 0) {
    ipad = ua.match(/(Version)\/([\d.]+)/);
    if (!ipad) ipad = [0, 1, '13_0_0'];
    macos = false;
  } // Android


  if (android && !windows) {
    device.os = 'android';
    device.android = true;
  }

  if (ipad || iphone || ipod) {
    device.os = 'ios';
    device.ios = true;
  } // Export object


  return device;
}

function getDevice() {
  var overrides = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  if (!device) {
    device = calcDevice(overrides);
  }

  return device;
}


;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/utils/get-browser.js

var get_browser_browser;

function calcBrowser() {
  var window = ssr_window_esm_getWindow();

  function isSafari() {
    var ua = window.navigator.userAgent.toLowerCase();
    return ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0;
  }

  return {
    isEdge: !!window.navigator.userAgent.match(/Edge/g),
    isSafari: isSafari(),
    isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window.navigator.userAgent)
  };
}

function getBrowser() {
  if (!get_browser_browser) {
    get_browser_browser = calcBrowser();
  }

  return get_browser_browser;
}


;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/modules/resize/resize.js



var supportsResizeObserver = function supportsResizeObserver() {
  var window = ssr_window_esm_getWindow();
  return typeof window.ResizeObserver !== 'undefined';
};

/* harmony default export */ const resize_resize = ({
  name: 'resize',
  create: function create() {
    var swiper = this;
    utils_extend(swiper, {
      resize: {
        observer: null,
        createObserver: function createObserver() {
          if (!swiper || swiper.destroyed || !swiper.initialized) return;
          swiper.resize.observer = new ResizeObserver(function (entries) {
            var width = swiper.width,
                height = swiper.height;
            var newWidth = width;
            var newHeight = height;
            entries.forEach(function (_ref) {
              var contentBoxSize = _ref.contentBoxSize,
                  contentRect = _ref.contentRect,
                  target = _ref.target;
              if (target && target !== swiper.el) return;
              newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;
              newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;
            });

            if (newWidth !== width || newHeight !== height) {
              swiper.resize.resizeHandler();
            }
          });
          swiper.resize.observer.observe(swiper.el);
        },
        removeObserver: function removeObserver() {
          if (swiper.resize.observer && swiper.resize.observer.unobserve && swiper.el) {
            swiper.resize.observer.unobserve(swiper.el);
            swiper.resize.observer = null;
          }
        },
        resizeHandler: function resizeHandler() {
          if (!swiper || swiper.destroyed || !swiper.initialized) return;
          swiper.emit('beforeResize');
          swiper.emit('resize');
        },
        orientationChangeHandler: function orientationChangeHandler() {
          if (!swiper || swiper.destroyed || !swiper.initialized) return;
          swiper.emit('orientationchange');
        }
      }
    });
  },
  on: {
    init: function init(swiper) {
      var window = ssr_window_esm_getWindow();

      if (swiper.params.resizeObserver && supportsResizeObserver()) {
        swiper.resize.createObserver();
        return;
      } // Emit resize


      window.addEventListener('resize', swiper.resize.resizeHandler); // Emit orientationchange

      window.addEventListener('orientationchange', swiper.resize.orientationChangeHandler);
    },
    destroy: function destroy(swiper) {
      var window = ssr_window_esm_getWindow();
      swiper.resize.removeObserver();
      window.removeEventListener('resize', swiper.resize.resizeHandler);
      window.removeEventListener('orientationchange', swiper.resize.orientationChangeHandler);
    }
  }
});
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/modules/observer/observer.js


function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }



var Observer = {
  attach: function attach(target) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var window = ssr_window_esm_getWindow();
    var swiper = this;
    var ObserverFunc = window.MutationObserver || window.WebkitMutationObserver;
    var observer = new ObserverFunc(function (mutations) {
      // The observerUpdate event should only be triggered
      // once despite the number of mutations.  Additional
      // triggers are redundant and are very costly
      if (mutations.length === 1) {
        swiper.emit('observerUpdate', mutations[0]);
        return;
      }

      var observerUpdate = function observerUpdate() {
        swiper.emit('observerUpdate', mutations[0]);
      };

      if (window.requestAnimationFrame) {
        window.requestAnimationFrame(observerUpdate);
      } else {
        window.setTimeout(observerUpdate, 0);
      }
    });
    observer.observe(target, {
      attributes: typeof options.attributes === 'undefined' ? true : options.attributes,
      childList: typeof options.childList === 'undefined' ? true : options.childList,
      characterData: typeof options.characterData === 'undefined' ? true : options.characterData
    });
    swiper.observer.observers.push(observer);
  },
  init: function init() {
    var swiper = this;
    if (!swiper.support.observer || !swiper.params.observer) return;

    if (swiper.params.observeParents) {
      var containerParents = swiper.$el.parents();

      for (var i = 0; i < containerParents.length; i += 1) {
        swiper.observer.attach(containerParents[i]);
      }
    } // Observe container


    swiper.observer.attach(swiper.$el[0], {
      childList: swiper.params.observeSlideChildren
    }); // Observe wrapper

    swiper.observer.attach(swiper.$wrapperEl[0], {
      attributes: false
    });
  },
  destroy: function destroy() {
    var swiper = this;
    swiper.observer.observers.forEach(function (observer) {
      observer.disconnect();
    });
    swiper.observer.observers = [];
  }
};
/* harmony default export */ const observer = ({
  name: 'observer',
  params: {
    observer: false,
    observeParents: false,
    observeSlideChildren: false
  },
  create: function create() {
    var swiper = this;
    bindModuleMethods(swiper, {
      observer: _objectSpread(_objectSpread({}, Observer), {}, {
        observers: []
      })
    });
  },
  on: {
    init: function init(swiper) {
      swiper.observer.init();
    },
    destroy: function destroy(swiper) {
      swiper.observer.destroy();
    }
  }
});
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/modular.js

/* harmony default export */ const modular = ({
  useParams: function useParams(instanceParams) {
    var instance = this;
    if (!instance.modules) return;
    Object.keys(instance.modules).forEach(function (moduleName) {
      var module = instance.modules[moduleName]; // Extend params

      if (module.params) {
        utils_extend(instanceParams, module.params);
      }
    });
  },
  useModules: function useModules() {
    var modulesParams = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var instance = this;
    if (!instance.modules) return;
    Object.keys(instance.modules).forEach(function (moduleName) {
      var module = instance.modules[moduleName];
      var moduleParams = modulesParams[moduleName] || {}; // Add event listeners

      if (module.on && instance.on) {
        Object.keys(module.on).forEach(function (moduleEventName) {
          instance.on(moduleEventName, module.on[moduleEventName]);
        });
      } // Module create callback


      if (module.create) {
        module.create.bind(instance)(moduleParams);
      }
    });
  }
});
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/iterableToArray.js
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js




function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/events-emitter.js


/* eslint-disable no-underscore-dangle */
/* harmony default export */ const events_emitter = ({
  on: function on(events, handler, priority) {
    var self = this;
    if (typeof handler !== 'function') return self;
    var method = priority ? 'unshift' : 'push';
    events.split(' ').forEach(function (event) {
      if (!self.eventsListeners[event]) self.eventsListeners[event] = [];
      self.eventsListeners[event][method](handler);
    });
    return self;
  },
  once: function once(events, handler, priority) {
    var self = this;
    if (typeof handler !== 'function') return self;

    function onceHandler() {
      self.off(events, onceHandler);

      if (onceHandler.__emitterProxy) {
        delete onceHandler.__emitterProxy;
      }

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      handler.apply(self, args);
    }

    onceHandler.__emitterProxy = handler;
    return self.on(events, onceHandler, priority);
  },
  onAny: function onAny(handler, priority) {
    var self = this;
    if (typeof handler !== 'function') return self;
    var method = priority ? 'unshift' : 'push';

    if (self.eventsAnyListeners.indexOf(handler) < 0) {
      self.eventsAnyListeners[method](handler);
    }

    return self;
  },
  offAny: function offAny(handler) {
    var self = this;
    if (!self.eventsAnyListeners) return self;
    var index = self.eventsAnyListeners.indexOf(handler);

    if (index >= 0) {
      self.eventsAnyListeners.splice(index, 1);
    }

    return self;
  },
  off: function off(events, handler) {
    var self = this;
    if (!self.eventsListeners) return self;
    events.split(' ').forEach(function (event) {
      if (typeof handler === 'undefined') {
        self.eventsListeners[event] = [];
      } else if (self.eventsListeners[event]) {
        self.eventsListeners[event].forEach(function (eventHandler, index) {
          if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) {
            self.eventsListeners[event].splice(index, 1);
          }
        });
      }
    });
    return self;
  },
  emit: function emit() {
    var self = this;
    if (!self.eventsListeners) return self;
    var events;
    var data;
    var context;

    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    if (typeof args[0] === 'string' || Array.isArray(args[0])) {
      events = args[0];
      data = args.slice(1, args.length);
      context = self;
    } else {
      events = args[0].events;
      data = args[0].data;
      context = args[0].context || self;
    }

    data.unshift(context);
    var eventsArray = Array.isArray(events) ? events : events.split(' ');
    eventsArray.forEach(function (event) {
      if (self.eventsAnyListeners && self.eventsAnyListeners.length) {
        self.eventsAnyListeners.forEach(function (eventHandler) {
          eventHandler.apply(context, [event].concat(_toConsumableArray(data)));
        });
      }

      if (self.eventsListeners && self.eventsListeners[event]) {
        self.eventsListeners[event].forEach(function (eventHandler) {
          eventHandler.apply(context, data);
        });
      }
    });
    return self;
  }
});
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/update/updateSize.js

function updateSize() {
  var swiper = this;
  var width;
  var height;
  var $el = swiper.$el;

  if (typeof swiper.params.width !== 'undefined' && swiper.params.width !== null) {
    width = swiper.params.width;
  } else {
    width = $el[0].clientWidth;
  }

  if (typeof swiper.params.height !== 'undefined' && swiper.params.height !== null) {
    height = swiper.params.height;
  } else {
    height = $el[0].clientHeight;
  }

  if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) {
    return;
  } // Subtract paddings


  width = width - parseInt($el.css('padding-left') || 0, 10) - parseInt($el.css('padding-right') || 0, 10);
  height = height - parseInt($el.css('padding-top') || 0, 10) - parseInt($el.css('padding-bottom') || 0, 10);
  if (Number.isNaN(width)) width = 0;
  if (Number.isNaN(height)) height = 0;
  utils_extend(swiper, {
    width: width,
    height: height,
    size: swiper.isHorizontal() ? width : height
  });
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/update/updateSlides.js


function updateSlides() {
  var swiper = this;

  var getDirectionLabel = function getDirectionLabel(property) {
    if (swiper.isHorizontal()) {
      return property;
    } // prettier-ignore


    return {
      'width': 'height',
      'margin-top': 'margin-left',
      'margin-bottom ': 'margin-right',
      'margin-left': 'margin-top',
      'margin-right': 'margin-bottom',
      'padding-left': 'padding-top',
      'padding-right': 'padding-bottom',
      'marginRight': 'marginBottom'
    }[property];
  };

  var getDirectionPropertyValue = function getDirectionPropertyValue(node, label) {
    return parseFloat(node.getPropertyValue(getDirectionLabel(label)) || 0);
  };

  var params = swiper.params;
  var $wrapperEl = swiper.$wrapperEl,
      swiperSize = swiper.size,
      rtl = swiper.rtlTranslate,
      wrongRTL = swiper.wrongRTL;
  var isVirtual = swiper.virtual && params.virtual.enabled;
  var previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
  var slides = $wrapperEl.children(".".concat(swiper.params.slideClass));
  var slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
  var snapGrid = [];
  var slidesGrid = [];
  var slidesSizesGrid = [];

  function slidesForMargin(slideEl, slideIndex) {
    if (!params.cssMode) return true;

    if (slideIndex === slides.length - 1) {
      return false;
    }

    return true;
  }

  var offsetBefore = params.slidesOffsetBefore;

  if (typeof offsetBefore === 'function') {
    offsetBefore = params.slidesOffsetBefore.call(swiper);
  }

  var offsetAfter = params.slidesOffsetAfter;

  if (typeof offsetAfter === 'function') {
    offsetAfter = params.slidesOffsetAfter.call(swiper);
  }

  var previousSnapGridLength = swiper.snapGrid.length;
  var previousSlidesGridLength = swiper.slidesGrid.length;
  var spaceBetween = params.spaceBetween;
  var slidePosition = -offsetBefore;
  var prevSlideSize = 0;
  var index = 0;

  if (typeof swiperSize === 'undefined') {
    return;
  }

  if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
    spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiperSize;
  }

  swiper.virtualSize = -spaceBetween; // reset margins

  if (rtl) slides.css({
    marginLeft: '',
    marginTop: ''
  });else slides.css({
    marginRight: '',
    marginBottom: ''
  });
  var slidesNumberEvenToRows;

  if (params.slidesPerColumn > 1) {
    if (Math.floor(slidesLength / params.slidesPerColumn) === slidesLength / swiper.params.slidesPerColumn) {
      slidesNumberEvenToRows = slidesLength;
    } else {
      slidesNumberEvenToRows = Math.ceil(slidesLength / params.slidesPerColumn) * params.slidesPerColumn;
    }

    if (params.slidesPerView !== 'auto' && params.slidesPerColumnFill === 'row') {
      slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, params.slidesPerView * params.slidesPerColumn);
    }
  } // Calc slides


  var slideSize;
  var slidesPerColumn = params.slidesPerColumn;
  var slidesPerRow = slidesNumberEvenToRows / slidesPerColumn;
  var numFullColumns = Math.floor(slidesLength / params.slidesPerColumn);

  for (var i = 0; i < slidesLength; i += 1) {
    slideSize = 0;
    var slide = slides.eq(i);

    if (params.slidesPerColumn > 1) {
      // Set slides order
      var newSlideOrderIndex = void 0;
      var column = void 0;
      var row = void 0;

      if (params.slidesPerColumnFill === 'row' && params.slidesPerGroup > 1) {
        var groupIndex = Math.floor(i / (params.slidesPerGroup * params.slidesPerColumn));
        var slideIndexInGroup = i - params.slidesPerColumn * params.slidesPerGroup * groupIndex;
        var columnsInGroup = groupIndex === 0 ? params.slidesPerGroup : Math.min(Math.ceil((slidesLength - groupIndex * slidesPerColumn * params.slidesPerGroup) / slidesPerColumn), params.slidesPerGroup);
        row = Math.floor(slideIndexInGroup / columnsInGroup);
        column = slideIndexInGroup - row * columnsInGroup + groupIndex * params.slidesPerGroup;
        newSlideOrderIndex = column + row * slidesNumberEvenToRows / slidesPerColumn;
        slide.css({
          '-webkit-box-ordinal-group': newSlideOrderIndex,
          '-moz-box-ordinal-group': newSlideOrderIndex,
          '-ms-flex-order': newSlideOrderIndex,
          '-webkit-order': newSlideOrderIndex,
          order: newSlideOrderIndex
        });
      } else if (params.slidesPerColumnFill === 'column') {
        column = Math.floor(i / slidesPerColumn);
        row = i - column * slidesPerColumn;

        if (column > numFullColumns || column === numFullColumns && row === slidesPerColumn - 1) {
          row += 1;

          if (row >= slidesPerColumn) {
            row = 0;
            column += 1;
          }
        }
      } else {
        row = Math.floor(i / slidesPerRow);
        column = i - row * slidesPerRow;
      }

      slide.css(getDirectionLabel('margin-top'), row !== 0 && params.spaceBetween && "".concat(params.spaceBetween, "px"));
    }

    if (slide.css('display') === 'none') continue; // eslint-disable-line

    if (params.slidesPerView === 'auto') {
      var slideStyles = getComputedStyle(slide[0]);
      var currentTransform = slide[0].style.transform;
      var currentWebKitTransform = slide[0].style.webkitTransform;

      if (currentTransform) {
        slide[0].style.transform = 'none';
      }

      if (currentWebKitTransform) {
        slide[0].style.webkitTransform = 'none';
      }

      if (params.roundLengths) {
        slideSize = swiper.isHorizontal() ? slide.outerWidth(true) : slide.outerHeight(true);
      } else {
        // eslint-disable-next-line
        var width = getDirectionPropertyValue(slideStyles, 'width');
        var paddingLeft = getDirectionPropertyValue(slideStyles, 'padding-left');
        var paddingRight = getDirectionPropertyValue(slideStyles, 'padding-right');
        var marginLeft = getDirectionPropertyValue(slideStyles, 'margin-left');
        var marginRight = getDirectionPropertyValue(slideStyles, 'margin-right');
        var boxSizing = slideStyles.getPropertyValue('box-sizing');

        if (boxSizing && boxSizing === 'border-box') {
          slideSize = width + marginLeft + marginRight;
        } else {
          var _slide$ = slide[0],
              clientWidth = _slide$.clientWidth,
              offsetWidth = _slide$.offsetWidth;
          slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);
        }
      }

      if (currentTransform) {
        slide[0].style.transform = currentTransform;
      }

      if (currentWebKitTransform) {
        slide[0].style.webkitTransform = currentWebKitTransform;
      }

      if (params.roundLengths) slideSize = Math.floor(slideSize);
    } else {
      slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;
      if (params.roundLengths) slideSize = Math.floor(slideSize);

      if (slides[i]) {
        slides[i].style[getDirectionLabel('width')] = "".concat(slideSize, "px");
      }
    }

    if (slides[i]) {
      slides[i].swiperSlideSize = slideSize;
    }

    slidesSizesGrid.push(slideSize);

    if (params.centeredSlides) {
      slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
      if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
      if (i === 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
      if (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;
      if (params.roundLengths) slidePosition = Math.floor(slidePosition);
      if (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);
      slidesGrid.push(slidePosition);
    } else {
      if (params.roundLengths) slidePosition = Math.floor(slidePosition);
      if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);
      slidesGrid.push(slidePosition);
      slidePosition = slidePosition + slideSize + spaceBetween;
    }

    swiper.virtualSize += slideSize + spaceBetween;
    prevSlideSize = slideSize;
    index += 1;
  }

  swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;
  var newSlidesGrid;

  if (rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {
    $wrapperEl.css({
      width: "".concat(swiper.virtualSize + params.spaceBetween, "px")
    });
  }

  if (params.setWrapperSize) {
    $wrapperEl.css(_defineProperty({}, getDirectionLabel('width'), "".concat(swiper.virtualSize + params.spaceBetween, "px")));
  }

  if (params.slidesPerColumn > 1) {
    swiper.virtualSize = (slideSize + params.spaceBetween) * slidesNumberEvenToRows;
    swiper.virtualSize = Math.ceil(swiper.virtualSize / params.slidesPerColumn) - params.spaceBetween;
    $wrapperEl.css(_defineProperty({}, getDirectionLabel('width'), "".concat(swiper.virtualSize + params.spaceBetween, "px")));

    if (params.centeredSlides) {
      newSlidesGrid = [];

      for (var _i = 0; _i < snapGrid.length; _i += 1) {
        var slidesGridItem = snapGrid[_i];
        if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);
        if (snapGrid[_i] < swiper.virtualSize + snapGrid[0]) newSlidesGrid.push(slidesGridItem);
      }

      snapGrid = newSlidesGrid;
    }
  } // Remove last grid elements depending on width


  if (!params.centeredSlides) {
    newSlidesGrid = [];

    for (var _i2 = 0; _i2 < snapGrid.length; _i2 += 1) {
      var _slidesGridItem = snapGrid[_i2];
      if (params.roundLengths) _slidesGridItem = Math.floor(_slidesGridItem);

      if (snapGrid[_i2] <= swiper.virtualSize - swiperSize) {
        newSlidesGrid.push(_slidesGridItem);
      }
    }

    snapGrid = newSlidesGrid;

    if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {
      snapGrid.push(swiper.virtualSize - swiperSize);
    }
  }

  if (snapGrid.length === 0) snapGrid = [0];

  if (params.spaceBetween !== 0) {
    var key = swiper.isHorizontal() && rtl ? 'marginLeft' : getDirectionLabel('marginRight');
    slides.filter(slidesForMargin).css(_defineProperty({}, key, "".concat(spaceBetween, "px")));
  }

  if (params.centeredSlides && params.centeredSlidesBounds) {
    var allSlidesSize = 0;
    slidesSizesGrid.forEach(function (slideSizeValue) {
      allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
    });
    allSlidesSize -= params.spaceBetween;
    var maxSnap = allSlidesSize - swiperSize;
    snapGrid = snapGrid.map(function (snap) {
      if (snap < 0) return -offsetBefore;
      if (snap > maxSnap) return maxSnap + offsetAfter;
      return snap;
    });
  }

  if (params.centerInsufficientSlides) {
    var _allSlidesSize = 0;
    slidesSizesGrid.forEach(function (slideSizeValue) {
      _allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
    });
    _allSlidesSize -= params.spaceBetween;

    if (_allSlidesSize < swiperSize) {
      var allSlidesOffset = (swiperSize - _allSlidesSize) / 2;
      snapGrid.forEach(function (snap, snapIndex) {
        snapGrid[snapIndex] = snap - allSlidesOffset;
      });
      slidesGrid.forEach(function (snap, snapIndex) {
        slidesGrid[snapIndex] = snap + allSlidesOffset;
      });
    }
  }

  utils_extend(swiper, {
    slides: slides,
    snapGrid: snapGrid,
    slidesGrid: slidesGrid,
    slidesSizesGrid: slidesSizesGrid
  });

  if (slidesLength !== previousSlidesLength) {
    swiper.emit('slidesLengthChange');
  }

  if (snapGrid.length !== previousSnapGridLength) {
    if (swiper.params.watchOverflow) swiper.checkOverflow();
    swiper.emit('snapGridLengthChange');
  }

  if (slidesGrid.length !== previousSlidesGridLength) {
    swiper.emit('slidesGridLengthChange');
  }

  if (params.watchSlidesProgress || params.watchSlidesVisibility) {
    swiper.updateSlidesOffset();
  }
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/update/updateAutoHeight.js
function updateAutoHeight(speed) {
  var swiper = this;
  var activeSlides = [];
  var newHeight = 0;
  var i;

  if (typeof speed === 'number') {
    swiper.setTransition(speed);
  } else if (speed === true) {
    swiper.setTransition(swiper.params.speed);
  } // Find slides currently in view


  if (swiper.params.slidesPerView !== 'auto' && swiper.params.slidesPerView > 1) {
    if (swiper.params.centeredSlides) {
      swiper.visibleSlides.each(function (slide) {
        activeSlides.push(slide);
      });
    } else {
      for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {
        var index = swiper.activeIndex + i;
        if (index > swiper.slides.length) break;
        activeSlides.push(swiper.slides.eq(index)[0]);
      }
    }
  } else {
    activeSlides.push(swiper.slides.eq(swiper.activeIndex)[0]);
  } // Find new height from highest slide in view


  for (i = 0; i < activeSlides.length; i += 1) {
    if (typeof activeSlides[i] !== 'undefined') {
      var height = activeSlides[i].offsetHeight;
      newHeight = height > newHeight ? height : newHeight;
    }
  } // Update Height


  if (newHeight) swiper.$wrapperEl.css('height', "".concat(newHeight, "px"));
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/update/updateSlidesOffset.js
function updateSlidesOffset() {
  var swiper = this;
  var slides = swiper.slides;

  for (var i = 0; i < slides.length; i += 1) {
    slides[i].swiperSlideOffset = swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop;
  }
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/update/updateSlidesProgress.js

function updateSlidesProgress() {
  var translate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this && this.translate || 0;
  var swiper = this;
  var params = swiper.params;
  var slides = swiper.slides,
      rtl = swiper.rtlTranslate;
  if (slides.length === 0) return;
  if (typeof slides[0].swiperSlideOffset === 'undefined') swiper.updateSlidesOffset();
  var offsetCenter = -translate;
  if (rtl) offsetCenter = translate; // Visible Slides

  slides.removeClass(params.slideVisibleClass);
  swiper.visibleSlidesIndexes = [];
  swiper.visibleSlides = [];

  for (var i = 0; i < slides.length; i += 1) {
    var slide = slides[i];
    var slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slide.swiperSlideOffset) / (slide.swiperSlideSize + params.spaceBetween);

    if (params.watchSlidesVisibility || params.centeredSlides && params.autoHeight) {
      var slideBefore = -(offsetCenter - slide.swiperSlideOffset);
      var slideAfter = slideBefore + swiper.slidesSizesGrid[i];
      var isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;

      if (isVisible) {
        swiper.visibleSlides.push(slide);
        swiper.visibleSlidesIndexes.push(i);
        slides.eq(i).addClass(params.slideVisibleClass);
      }
    }

    slide.progress = rtl ? -slideProgress : slideProgress;
  }

  swiper.visibleSlides = dom(swiper.visibleSlides);
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/update/updateProgress.js

function updateProgress(translate) {
  var swiper = this;

  if (typeof translate === 'undefined') {
    var multiplier = swiper.rtlTranslate ? -1 : 1; // eslint-disable-next-line

    translate = swiper && swiper.translate && swiper.translate * multiplier || 0;
  }

  var params = swiper.params;
  var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
  var progress = swiper.progress,
      isBeginning = swiper.isBeginning,
      isEnd = swiper.isEnd;
  var wasBeginning = isBeginning;
  var wasEnd = isEnd;

  if (translatesDiff === 0) {
    progress = 0;
    isBeginning = true;
    isEnd = true;
  } else {
    progress = (translate - swiper.minTranslate()) / translatesDiff;
    isBeginning = progress <= 0;
    isEnd = progress >= 1;
  }

  utils_extend(swiper, {
    progress: progress,
    isBeginning: isBeginning,
    isEnd: isEnd
  });
  if (params.watchSlidesProgress || params.watchSlidesVisibility || params.centeredSlides && params.autoHeight) swiper.updateSlidesProgress(translate);

  if (isBeginning && !wasBeginning) {
    swiper.emit('reachBeginning toEdge');
  }

  if (isEnd && !wasEnd) {
    swiper.emit('reachEnd toEdge');
  }

  if (wasBeginning && !isBeginning || wasEnd && !isEnd) {
    swiper.emit('fromEdge');
  }

  swiper.emit('progress', progress);
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/update/updateSlidesClasses.js
function updateSlidesClasses() {
  var swiper = this;
  var slides = swiper.slides,
      params = swiper.params,
      $wrapperEl = swiper.$wrapperEl,
      activeIndex = swiper.activeIndex,
      realIndex = swiper.realIndex;
  var isVirtual = swiper.virtual && params.virtual.enabled;
  slides.removeClass("".concat(params.slideActiveClass, " ").concat(params.slideNextClass, " ").concat(params.slidePrevClass, " ").concat(params.slideDuplicateActiveClass, " ").concat(params.slideDuplicateNextClass, " ").concat(params.slideDuplicatePrevClass));
  var activeSlide;

  if (isVirtual) {
    activeSlide = swiper.$wrapperEl.find(".".concat(params.slideClass, "[data-swiper-slide-index=\"").concat(activeIndex, "\"]"));
  } else {
    activeSlide = slides.eq(activeIndex);
  } // Active classes


  activeSlide.addClass(params.slideActiveClass);

  if (params.loop) {
    // Duplicate to all looped slides
    if (activeSlide.hasClass(params.slideDuplicateClass)) {
      $wrapperEl.children(".".concat(params.slideClass, ":not(.").concat(params.slideDuplicateClass, ")[data-swiper-slide-index=\"").concat(realIndex, "\"]")).addClass(params.slideDuplicateActiveClass);
    } else {
      $wrapperEl.children(".".concat(params.slideClass, ".").concat(params.slideDuplicateClass, "[data-swiper-slide-index=\"").concat(realIndex, "\"]")).addClass(params.slideDuplicateActiveClass);
    }
  } // Next Slide


  var nextSlide = activeSlide.nextAll(".".concat(params.slideClass)).eq(0).addClass(params.slideNextClass);

  if (params.loop && nextSlide.length === 0) {
    nextSlide = slides.eq(0);
    nextSlide.addClass(params.slideNextClass);
  } // Prev Slide


  var prevSlide = activeSlide.prevAll(".".concat(params.slideClass)).eq(0).addClass(params.slidePrevClass);

  if (params.loop && prevSlide.length === 0) {
    prevSlide = slides.eq(-1);
    prevSlide.addClass(params.slidePrevClass);
  }

  if (params.loop) {
    // Duplicate to all looped slides
    if (nextSlide.hasClass(params.slideDuplicateClass)) {
      $wrapperEl.children(".".concat(params.slideClass, ":not(.").concat(params.slideDuplicateClass, ")[data-swiper-slide-index=\"").concat(nextSlide.attr('data-swiper-slide-index'), "\"]")).addClass(params.slideDuplicateNextClass);
    } else {
      $wrapperEl.children(".".concat(params.slideClass, ".").concat(params.slideDuplicateClass, "[data-swiper-slide-index=\"").concat(nextSlide.attr('data-swiper-slide-index'), "\"]")).addClass(params.slideDuplicateNextClass);
    }

    if (prevSlide.hasClass(params.slideDuplicateClass)) {
      $wrapperEl.children(".".concat(params.slideClass, ":not(.").concat(params.slideDuplicateClass, ")[data-swiper-slide-index=\"").concat(prevSlide.attr('data-swiper-slide-index'), "\"]")).addClass(params.slideDuplicatePrevClass);
    } else {
      $wrapperEl.children(".".concat(params.slideClass, ".").concat(params.slideDuplicateClass, "[data-swiper-slide-index=\"").concat(prevSlide.attr('data-swiper-slide-index'), "\"]")).addClass(params.slideDuplicatePrevClass);
    }
  }

  swiper.emitSlidesClasses();
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/update/updateActiveIndex.js

function updateActiveIndex(newActiveIndex) {
  var swiper = this;
  var translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
  var slidesGrid = swiper.slidesGrid,
      snapGrid = swiper.snapGrid,
      params = swiper.params,
      previousIndex = swiper.activeIndex,
      previousRealIndex = swiper.realIndex,
      previousSnapIndex = swiper.snapIndex;
  var activeIndex = newActiveIndex;
  var snapIndex;

  if (typeof activeIndex === 'undefined') {
    for (var i = 0; i < slidesGrid.length; i += 1) {
      if (typeof slidesGrid[i + 1] !== 'undefined') {
        if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) {
          activeIndex = i;
        } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {
          activeIndex = i + 1;
        }
      } else if (translate >= slidesGrid[i]) {
        activeIndex = i;
      }
    } // Normalize slideIndex


    if (params.normalizeSlideIndex) {
      if (activeIndex < 0 || typeof activeIndex === 'undefined') activeIndex = 0;
    }
  }

  if (snapGrid.indexOf(translate) >= 0) {
    snapIndex = snapGrid.indexOf(translate);
  } else {
    var skip = Math.min(params.slidesPerGroupSkip, activeIndex);
    snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
  }

  if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;

  if (activeIndex === previousIndex) {
    if (snapIndex !== previousSnapIndex) {
      swiper.snapIndex = snapIndex;
      swiper.emit('snapIndexChange');
    }

    return;
  } // Get real index


  var realIndex = parseInt(swiper.slides.eq(activeIndex).attr('data-swiper-slide-index') || activeIndex, 10);
  utils_extend(swiper, {
    snapIndex: snapIndex,
    realIndex: realIndex,
    previousIndex: previousIndex,
    activeIndex: activeIndex
  });
  swiper.emit('activeIndexChange');
  swiper.emit('snapIndexChange');

  if (previousRealIndex !== realIndex) {
    swiper.emit('realIndexChange');
  }

  if (swiper.initialized || swiper.params.runCallbacksOnInit) {
    swiper.emit('slideChange');
  }
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/update/updateClickedSlide.js

function updateClickedSlide(e) {
  var swiper = this;
  var params = swiper.params;
  var slide = dom(e.target).closest(".".concat(params.slideClass))[0];
  var slideFound = false;
  var slideIndex;

  if (slide) {
    for (var i = 0; i < swiper.slides.length; i += 1) {
      if (swiper.slides[i] === slide) {
        slideFound = true;
        slideIndex = i;
        break;
      }
    }
  }

  if (slide && slideFound) {
    swiper.clickedSlide = slide;

    if (swiper.virtual && swiper.params.virtual.enabled) {
      swiper.clickedIndex = parseInt(dom(slide).attr('data-swiper-slide-index'), 10);
    } else {
      swiper.clickedIndex = slideIndex;
    }
  } else {
    swiper.clickedSlide = undefined;
    swiper.clickedIndex = undefined;
    return;
  }

  if (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) {
    swiper.slideToClickedSlide();
  }
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/update/index.js









/* harmony default export */ const update = ({
  updateSize: updateSize,
  updateSlides: updateSlides,
  updateAutoHeight: updateAutoHeight,
  updateSlidesOffset: updateSlidesOffset,
  updateSlidesProgress: updateSlidesProgress,
  updateProgress: updateProgress,
  updateSlidesClasses: updateSlidesClasses,
  updateActiveIndex: updateActiveIndex,
  updateClickedSlide: updateClickedSlide
});
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/translate/getTranslate.js

function getSwiperTranslate() {
  var axis = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.isHorizontal() ? 'x' : 'y';
  var swiper = this;
  var params = swiper.params,
      rtl = swiper.rtlTranslate,
      translate = swiper.translate,
      $wrapperEl = swiper.$wrapperEl;

  if (params.virtualTranslate) {
    return rtl ? -translate : translate;
  }

  if (params.cssMode) {
    return translate;
  }

  var currentTranslate = getTranslate($wrapperEl[0], axis);
  if (rtl) currentTranslate = -currentTranslate;
  return currentTranslate || 0;
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/translate/setTranslate.js
function setTranslate(translate, byController) {
  var swiper = this;
  var rtl = swiper.rtlTranslate,
      params = swiper.params,
      $wrapperEl = swiper.$wrapperEl,
      wrapperEl = swiper.wrapperEl,
      progress = swiper.progress;
  var x = 0;
  var y = 0;
  var z = 0;

  if (swiper.isHorizontal()) {
    x = rtl ? -translate : translate;
  } else {
    y = translate;
  }

  if (params.roundLengths) {
    x = Math.floor(x);
    y = Math.floor(y);
  }

  if (params.cssMode) {
    wrapperEl[swiper.isHorizontal() ? 'scrollLeft' : 'scrollTop'] = swiper.isHorizontal() ? -x : -y;
  } else if (!params.virtualTranslate) {
    $wrapperEl.transform("translate3d(".concat(x, "px, ").concat(y, "px, ").concat(z, "px)"));
  }

  swiper.previousTranslate = swiper.translate;
  swiper.translate = swiper.isHorizontal() ? x : y; // Check if we need to update progress

  var newProgress;
  var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();

  if (translatesDiff === 0) {
    newProgress = 0;
  } else {
    newProgress = (translate - swiper.minTranslate()) / translatesDiff;
  }

  if (newProgress !== progress) {
    swiper.updateProgress(translate);
  }

  swiper.emit('setTranslate', swiper.translate, byController);
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/translate/minTranslate.js
function minTranslate() {
  return -this.snapGrid[0];
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/translate/maxTranslate.js
function maxTranslate() {
  return -this.snapGrid[this.snapGrid.length - 1];
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/translate/translateTo.js

function translateTo() {
  var translate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  var speed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.params.speed;
  var runCallbacks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  var translateBounds = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
  var internal = arguments.length > 4 ? arguments[4] : undefined;
  var swiper = this;
  var params = swiper.params,
      wrapperEl = swiper.wrapperEl;

  if (swiper.animating && params.preventInteractionOnTransition) {
    return false;
  }

  var minTranslate = swiper.minTranslate();
  var maxTranslate = swiper.maxTranslate();
  var newTranslate;
  if (translateBounds && translate > minTranslate) newTranslate = minTranslate;else if (translateBounds && translate < maxTranslate) newTranslate = maxTranslate;else newTranslate = translate; // Update progress

  swiper.updateProgress(newTranslate);

  if (params.cssMode) {
    var isH = swiper.isHorizontal();

    if (speed === 0) {
      wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;
    } else {
      // eslint-disable-next-line
      if (wrapperEl.scrollTo) {
        var _wrapperEl$scrollTo;

        wrapperEl.scrollTo((_wrapperEl$scrollTo = {}, _defineProperty(_wrapperEl$scrollTo, isH ? 'left' : 'top', -newTranslate), _defineProperty(_wrapperEl$scrollTo, "behavior", 'smooth'), _wrapperEl$scrollTo));
      } else {
        wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;
      }
    }

    return true;
  }

  if (speed === 0) {
    swiper.setTransition(0);
    swiper.setTranslate(newTranslate);

    if (runCallbacks) {
      swiper.emit('beforeTransitionStart', speed, internal);
      swiper.emit('transitionEnd');
    }
  } else {
    swiper.setTransition(speed);
    swiper.setTranslate(newTranslate);

    if (runCallbacks) {
      swiper.emit('beforeTransitionStart', speed, internal);
      swiper.emit('transitionStart');
    }

    if (!swiper.animating) {
      swiper.animating = true;

      if (!swiper.onTranslateToWrapperTransitionEnd) {
        swiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {
          if (!swiper || swiper.destroyed) return;
          if (e.target !== this) return;
          swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
          swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onTranslateToWrapperTransitionEnd);
          swiper.onTranslateToWrapperTransitionEnd = null;
          delete swiper.onTranslateToWrapperTransitionEnd;

          if (runCallbacks) {
            swiper.emit('transitionEnd');
          }
        };
      }

      swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
      swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onTranslateToWrapperTransitionEnd);
    }
  }

  return true;
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/translate/index.js





/* harmony default export */ const translate = ({
  getTranslate: getSwiperTranslate,
  setTranslate: setTranslate,
  minTranslate: minTranslate,
  maxTranslate: maxTranslate,
  translateTo: translateTo
});
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/transition/setTransition.js
function setTransition(duration, byController) {
  var swiper = this;

  if (!swiper.params.cssMode) {
    swiper.$wrapperEl.transition(duration);
  }

  swiper.emit('setTransition', duration, byController);
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/transition/transitionStart.js
function transitionStart() {
  var runCallbacks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
  var direction = arguments.length > 1 ? arguments[1] : undefined;
  var swiper = this;
  var activeIndex = swiper.activeIndex,
      params = swiper.params,
      previousIndex = swiper.previousIndex;
  if (params.cssMode) return;

  if (params.autoHeight) {
    swiper.updateAutoHeight();
  }

  var dir = direction;

  if (!dir) {
    if (activeIndex > previousIndex) dir = 'next';else if (activeIndex < previousIndex) dir = 'prev';else dir = 'reset';
  }

  swiper.emit('transitionStart');

  if (runCallbacks && activeIndex !== previousIndex) {
    if (dir === 'reset') {
      swiper.emit('slideResetTransitionStart');
      return;
    }

    swiper.emit('slideChangeTransitionStart');

    if (dir === 'next') {
      swiper.emit('slideNextTransitionStart');
    } else {
      swiper.emit('slidePrevTransitionStart');
    }
  }
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/transition/transitionEnd.js
function transitionEnd_transitionEnd() {
  var runCallbacks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
  var direction = arguments.length > 1 ? arguments[1] : undefined;
  var swiper = this;
  var activeIndex = swiper.activeIndex,
      previousIndex = swiper.previousIndex,
      params = swiper.params;
  swiper.animating = false;
  if (params.cssMode) return;
  swiper.setTransition(0);
  var dir = direction;

  if (!dir) {
    if (activeIndex > previousIndex) dir = 'next';else if (activeIndex < previousIndex) dir = 'prev';else dir = 'reset';
  }

  swiper.emit('transitionEnd');

  if (runCallbacks && activeIndex !== previousIndex) {
    if (dir === 'reset') {
      swiper.emit('slideResetTransitionEnd');
      return;
    }

    swiper.emit('slideChangeTransitionEnd');

    if (dir === 'next') {
      swiper.emit('slideNextTransitionEnd');
    } else {
      swiper.emit('slidePrevTransitionEnd');
    }
  }
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/transition/index.js



/* harmony default export */ const core_transition = ({
  setTransition: setTransition,
  transitionStart: transitionStart,
  transitionEnd: transitionEnd_transitionEnd
});
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/slide/slideTo.js


function slideTo() {
  var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  var speed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.params.speed;
  var runCallbacks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  var internal = arguments.length > 3 ? arguments[3] : undefined;

  if (typeof index !== 'number' && typeof index !== 'string') {
    throw new Error("The 'index' argument cannot have type other than 'number' or 'string'. [".concat((0,esm_typeof/* default */.Z)(index), "] given."));
  }

  if (typeof index === 'string') {
    /**
     * The `index` argument converted from `string` to `number`.
     * @type {number}
     */
    var indexAsNumber = parseInt(index, 10);
    /**
     * Determines whether the `index` argument is a valid `number`
     * after being converted from the `string` type.
     * @type {boolean}
     */

    var isValidNumber = isFinite(indexAsNumber);

    if (!isValidNumber) {
      throw new Error("The passed-in 'index' (string) couldn't be converted to 'number'. [".concat(index, "] given."));
    } // Knowing that the converted `index` is a valid number,
    // we can update the original argument's value.


    index = indexAsNumber;
  }

  var swiper = this;
  var slideIndex = index;
  if (slideIndex < 0) slideIndex = 0;
  var params = swiper.params,
      snapGrid = swiper.snapGrid,
      slidesGrid = swiper.slidesGrid,
      previousIndex = swiper.previousIndex,
      activeIndex = swiper.activeIndex,
      rtl = swiper.rtlTranslate,
      wrapperEl = swiper.wrapperEl;

  if (swiper.animating && params.preventInteractionOnTransition) {
    return false;
  }

  var skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);
  var snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);
  if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;

  if ((activeIndex || params.initialSlide || 0) === (previousIndex || 0) && runCallbacks) {
    swiper.emit('beforeSlideChangeStart');
  }

  var translate = -snapGrid[snapIndex]; // Update progress

  swiper.updateProgress(translate); // Normalize slideIndex

  if (params.normalizeSlideIndex) {
    for (var i = 0; i < slidesGrid.length; i += 1) {
      var normalizedTranslate = -Math.floor(translate * 100);
      var normalizedGird = Math.floor(slidesGrid[i] * 100);
      var normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);

      if (typeof slidesGrid[i + 1] !== 'undefined') {
        if (normalizedTranslate >= normalizedGird && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGird) / 2) {
          slideIndex = i;
        } else if (normalizedTranslate >= normalizedGird && normalizedTranslate < normalizedGridNext) {
          slideIndex = i + 1;
        }
      } else if (normalizedTranslate >= normalizedGird) {
        slideIndex = i;
      }
    }
  } // Directions locks


  if (swiper.initialized && slideIndex !== activeIndex) {
    if (!swiper.allowSlideNext && translate < swiper.translate && translate < swiper.minTranslate()) {
      return false;
    }

    if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {
      if ((activeIndex || 0) !== slideIndex) return false;
    }
  }

  var direction;
  if (slideIndex > activeIndex) direction = 'next';else if (slideIndex < activeIndex) direction = 'prev';else direction = 'reset'; // Update Index

  if (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate) {
    swiper.updateActiveIndex(slideIndex); // Update Height

    if (params.autoHeight) {
      swiper.updateAutoHeight();
    }

    swiper.updateSlidesClasses();

    if (params.effect !== 'slide') {
      swiper.setTranslate(translate);
    }

    if (direction !== 'reset') {
      swiper.transitionStart(runCallbacks, direction);
      swiper.transitionEnd(runCallbacks, direction);
    }

    return false;
  }

  if (params.cssMode) {
    var isH = swiper.isHorizontal();
    var t = -translate;

    if (rtl) {
      t = wrapperEl.scrollWidth - wrapperEl.offsetWidth - t;
    }

    if (speed === 0) {
      wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;
    } else {
      // eslint-disable-next-line
      if (wrapperEl.scrollTo) {
        var _wrapperEl$scrollTo;

        wrapperEl.scrollTo((_wrapperEl$scrollTo = {}, _defineProperty(_wrapperEl$scrollTo, isH ? 'left' : 'top', t), _defineProperty(_wrapperEl$scrollTo, "behavior", 'smooth'), _wrapperEl$scrollTo));
      } else {
        wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;
      }
    }

    return true;
  }

  if (speed === 0) {
    swiper.setTransition(0);
    swiper.setTranslate(translate);
    swiper.updateActiveIndex(slideIndex);
    swiper.updateSlidesClasses();
    swiper.emit('beforeTransitionStart', speed, internal);
    swiper.transitionStart(runCallbacks, direction);
    swiper.transitionEnd(runCallbacks, direction);
  } else {
    swiper.setTransition(speed);
    swiper.setTranslate(translate);
    swiper.updateActiveIndex(slideIndex);
    swiper.updateSlidesClasses();
    swiper.emit('beforeTransitionStart', speed, internal);
    swiper.transitionStart(runCallbacks, direction);

    if (!swiper.animating) {
      swiper.animating = true;

      if (!swiper.onSlideToWrapperTransitionEnd) {
        swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {
          if (!swiper || swiper.destroyed) return;
          if (e.target !== this) return;
          swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
          swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
          swiper.onSlideToWrapperTransitionEnd = null;
          delete swiper.onSlideToWrapperTransitionEnd;
          swiper.transitionEnd(runCallbacks, direction);
        };
      }

      swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
      swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
    }
  }

  return true;
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/slide/slideToLoop.js
function slideToLoop() {
  var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  var speed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.params.speed;
  var runCallbacks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  var internal = arguments.length > 3 ? arguments[3] : undefined;
  var swiper = this;
  var newIndex = index;

  if (swiper.params.loop) {
    newIndex += swiper.loopedSlides;
  }

  return swiper.slideTo(newIndex, speed, runCallbacks, internal);
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/slide/slideNext.js
/* eslint no-unused-vars: "off" */
function slideNext() {
  var speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.params.speed;
  var runCallbacks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  var internal = arguments.length > 2 ? arguments[2] : undefined;
  var swiper = this;
  var params = swiper.params,
      animating = swiper.animating;
  var increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup;

  if (params.loop) {
    if (animating && params.loopPreventsSlide) return false;
    swiper.loopFix(); // eslint-disable-next-line

    swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
  }

  return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/slide/slidePrev.js
/* eslint no-unused-vars: "off" */
function slidePrev() {
  var speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.params.speed;
  var runCallbacks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  var internal = arguments.length > 2 ? arguments[2] : undefined;
  var swiper = this;
  var params = swiper.params,
      animating = swiper.animating,
      snapGrid = swiper.snapGrid,
      slidesGrid = swiper.slidesGrid,
      rtlTranslate = swiper.rtlTranslate;

  if (params.loop) {
    if (animating && params.loopPreventsSlide) return false;
    swiper.loopFix(); // eslint-disable-next-line

    swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
  }

  var translate = rtlTranslate ? swiper.translate : -swiper.translate;

  function normalize(val) {
    if (val < 0) return -Math.floor(Math.abs(val));
    return Math.floor(val);
  }

  var normalizedTranslate = normalize(translate);
  var normalizedSnapGrid = snapGrid.map(function (val) {
    return normalize(val);
  });
  var currentSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate)];
  var prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];

  if (typeof prevSnap === 'undefined' && params.cssMode) {
    snapGrid.forEach(function (snap) {
      if (!prevSnap && normalizedTranslate >= snap) prevSnap = snap;
    });
  }

  var prevIndex;

  if (typeof prevSnap !== 'undefined') {
    prevIndex = slidesGrid.indexOf(prevSnap);
    if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;
  }

  return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/slide/slideReset.js
/* eslint no-unused-vars: "off" */
function slideReset() {
  var speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.params.speed;
  var runCallbacks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  var internal = arguments.length > 2 ? arguments[2] : undefined;
  var swiper = this;
  return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/slide/slideToClosest.js
/* eslint no-unused-vars: "off" */
function slideToClosest() {
  var speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.params.speed;
  var runCallbacks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  var internal = arguments.length > 2 ? arguments[2] : undefined;
  var threshold = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.5;
  var swiper = this;
  var index = swiper.activeIndex;
  var skip = Math.min(swiper.params.slidesPerGroupSkip, index);
  var snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);
  var translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;

  if (translate >= swiper.snapGrid[snapIndex]) {
    // The current translate is on or after the current snap index, so the choice
    // is between the current index and the one after it.
    var currentSnap = swiper.snapGrid[snapIndex];
    var nextSnap = swiper.snapGrid[snapIndex + 1];

    if (translate - currentSnap > (nextSnap - currentSnap) * threshold) {
      index += swiper.params.slidesPerGroup;
    }
  } else {
    // The current translate is before the current snap index, so the choice
    // is between the current index and the one before it.
    var prevSnap = swiper.snapGrid[snapIndex - 1];
    var _currentSnap = swiper.snapGrid[snapIndex];

    if (translate - prevSnap <= (_currentSnap - prevSnap) * threshold) {
      index -= swiper.params.slidesPerGroup;
    }
  }

  index = Math.max(index, 0);
  index = Math.min(index, swiper.slidesGrid.length - 1);
  return swiper.slideTo(index, speed, runCallbacks, internal);
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/slide/slideToClickedSlide.js


function slideToClickedSlide() {
  var swiper = this;
  var params = swiper.params,
      $wrapperEl = swiper.$wrapperEl;
  var slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : params.slidesPerView;
  var slideToIndex = swiper.clickedIndex;
  var realIndex;

  if (params.loop) {
    if (swiper.animating) return;
    realIndex = parseInt(dom(swiper.clickedSlide).attr('data-swiper-slide-index'), 10);

    if (params.centeredSlides) {
      if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {
        swiper.loopFix();
        slideToIndex = $wrapperEl.children(".".concat(params.slideClass, "[data-swiper-slide-index=\"").concat(realIndex, "\"]:not(.").concat(params.slideDuplicateClass, ")")).eq(0).index();
        nextTick(function () {
          swiper.slideTo(slideToIndex);
        });
      } else {
        swiper.slideTo(slideToIndex);
      }
    } else if (slideToIndex > swiper.slides.length - slidesPerView) {
      swiper.loopFix();
      slideToIndex = $wrapperEl.children(".".concat(params.slideClass, "[data-swiper-slide-index=\"").concat(realIndex, "\"]:not(.").concat(params.slideDuplicateClass, ")")).eq(0).index();
      nextTick(function () {
        swiper.slideTo(slideToIndex);
      });
    } else {
      swiper.slideTo(slideToIndex);
    }
  } else {
    swiper.slideTo(slideToIndex);
  }
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/slide/index.js







/* harmony default export */ const slide = ({
  slideTo: slideTo,
  slideToLoop: slideToLoop,
  slideNext: slideNext,
  slidePrev: slidePrev,
  slideReset: slideReset,
  slideToClosest: slideToClosest,
  slideToClickedSlide: slideToClickedSlide
});
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/loop/loopCreate.js


function loopCreate() {
  var swiper = this;
  var document = getDocument();
  var params = swiper.params,
      $wrapperEl = swiper.$wrapperEl; // Remove duplicated slides

  $wrapperEl.children(".".concat(params.slideClass, ".").concat(params.slideDuplicateClass)).remove();
  var slides = $wrapperEl.children(".".concat(params.slideClass));

  if (params.loopFillGroupWithBlank) {
    var blankSlidesNum = params.slidesPerGroup - slides.length % params.slidesPerGroup;

    if (blankSlidesNum !== params.slidesPerGroup) {
      for (var i = 0; i < blankSlidesNum; i += 1) {
        var blankNode = dom(document.createElement('div')).addClass("".concat(params.slideClass, " ").concat(params.slideBlankClass));
        $wrapperEl.append(blankNode);
      }

      slides = $wrapperEl.children(".".concat(params.slideClass));
    }
  }

  if (params.slidesPerView === 'auto' && !params.loopedSlides) params.loopedSlides = slides.length;
  swiper.loopedSlides = Math.ceil(parseFloat(params.loopedSlides || params.slidesPerView, 10));
  swiper.loopedSlides += params.loopAdditionalSlides;

  if (swiper.loopedSlides > slides.length) {
    swiper.loopedSlides = slides.length;
  }

  var prependSlides = [];
  var appendSlides = [];
  slides.each(function (el, index) {
    var slide = dom(el);

    if (index < swiper.loopedSlides) {
      appendSlides.push(el);
    }

    if (index < slides.length && index >= slides.length - swiper.loopedSlides) {
      prependSlides.push(el);
    }

    slide.attr('data-swiper-slide-index', index);
  });

  for (var _i = 0; _i < appendSlides.length; _i += 1) {
    $wrapperEl.append(dom(appendSlides[_i].cloneNode(true)).addClass(params.slideDuplicateClass));
  }

  for (var _i2 = prependSlides.length - 1; _i2 >= 0; _i2 -= 1) {
    $wrapperEl.prepend(dom(prependSlides[_i2].cloneNode(true)).addClass(params.slideDuplicateClass));
  }
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/loop/loopFix.js
function loopFix() {
  var swiper = this;
  swiper.emit('beforeLoopFix');
  var activeIndex = swiper.activeIndex,
      slides = swiper.slides,
      loopedSlides = swiper.loopedSlides,
      allowSlidePrev = swiper.allowSlidePrev,
      allowSlideNext = swiper.allowSlideNext,
      snapGrid = swiper.snapGrid,
      rtl = swiper.rtlTranslate;
  var newIndex;
  swiper.allowSlidePrev = true;
  swiper.allowSlideNext = true;
  var snapTranslate = -snapGrid[activeIndex];
  var diff = snapTranslate - swiper.getTranslate(); // Fix For Negative Oversliding

  if (activeIndex < loopedSlides) {
    newIndex = slides.length - loopedSlides * 3 + activeIndex;
    newIndex += loopedSlides;
    var slideChanged = swiper.slideTo(newIndex, 0, false, true);

    if (slideChanged && diff !== 0) {
      swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
    }
  } else if (activeIndex >= slides.length - loopedSlides) {
    // Fix For Positive Oversliding
    newIndex = -slides.length + activeIndex + loopedSlides;
    newIndex += loopedSlides;

    var _slideChanged = swiper.slideTo(newIndex, 0, false, true);

    if (_slideChanged && diff !== 0) {
      swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
    }
  }

  swiper.allowSlidePrev = allowSlidePrev;
  swiper.allowSlideNext = allowSlideNext;
  swiper.emit('loopFix');
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/loop/loopDestroy.js
function loopDestroy() {
  var swiper = this;
  var $wrapperEl = swiper.$wrapperEl,
      params = swiper.params,
      slides = swiper.slides;
  $wrapperEl.children(".".concat(params.slideClass, ".").concat(params.slideDuplicateClass, ",.").concat(params.slideClass, ".").concat(params.slideBlankClass)).remove();
  slides.removeAttr('data-swiper-slide-index');
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/loop/index.js



/* harmony default export */ const loop = ({
  loopCreate: loopCreate,
  loopFix: loopFix,
  loopDestroy: loopDestroy
});
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/grab-cursor/setGrabCursor.js
function setGrabCursor(moving) {
  var swiper = this;
  if (swiper.support.touch || !swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;
  var el = swiper.el;
  el.style.cursor = 'move';
  el.style.cursor = moving ? '-webkit-grabbing' : '-webkit-grab';
  el.style.cursor = moving ? '-moz-grabbin' : '-moz-grab';
  el.style.cursor = moving ? 'grabbing' : 'grab';
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/grab-cursor/unsetGrabCursor.js
function unsetGrabCursor() {
  var swiper = this;

  if (swiper.support.touch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) {
    return;
  }

  swiper.el.style.cursor = '';
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/grab-cursor/index.js


/* harmony default export */ const grab_cursor = ({
  setGrabCursor: setGrabCursor,
  unsetGrabCursor: unsetGrabCursor
});
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/manipulation/appendSlide.js

function appendSlide(slides) {
  var swiper = this;
  var $wrapperEl = swiper.$wrapperEl,
      params = swiper.params;

  if (params.loop) {
    swiper.loopDestroy();
  }

  if ((0,esm_typeof/* default */.Z)(slides) === 'object' && 'length' in slides) {
    for (var i = 0; i < slides.length; i += 1) {
      if (slides[i]) $wrapperEl.append(slides[i]);
    }
  } else {
    $wrapperEl.append(slides);
  }

  if (params.loop) {
    swiper.loopCreate();
  }

  if (!(params.observer && swiper.support.observer)) {
    swiper.update();
  }
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/manipulation/prependSlide.js

function prependSlide(slides) {
  var swiper = this;
  var params = swiper.params,
      $wrapperEl = swiper.$wrapperEl,
      activeIndex = swiper.activeIndex;

  if (params.loop) {
    swiper.loopDestroy();
  }

  var newActiveIndex = activeIndex + 1;

  if ((0,esm_typeof/* default */.Z)(slides) === 'object' && 'length' in slides) {
    for (var i = 0; i < slides.length; i += 1) {
      if (slides[i]) $wrapperEl.prepend(slides[i]);
    }

    newActiveIndex = activeIndex + slides.length;
  } else {
    $wrapperEl.prepend(slides);
  }

  if (params.loop) {
    swiper.loopCreate();
  }

  if (!(params.observer && swiper.support.observer)) {
    swiper.update();
  }

  swiper.slideTo(newActiveIndex, 0, false);
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/manipulation/addSlide.js

function addSlide(index, slides) {
  var swiper = this;
  var $wrapperEl = swiper.$wrapperEl,
      params = swiper.params,
      activeIndex = swiper.activeIndex;
  var activeIndexBuffer = activeIndex;

  if (params.loop) {
    activeIndexBuffer -= swiper.loopedSlides;
    swiper.loopDestroy();
    swiper.slides = $wrapperEl.children(".".concat(params.slideClass));
  }

  var baseLength = swiper.slides.length;

  if (index <= 0) {
    swiper.prependSlide(slides);
    return;
  }

  if (index >= baseLength) {
    swiper.appendSlide(slides);
    return;
  }

  var newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + 1 : activeIndexBuffer;
  var slidesBuffer = [];

  for (var i = baseLength - 1; i >= index; i -= 1) {
    var currentSlide = swiper.slides.eq(i);
    currentSlide.remove();
    slidesBuffer.unshift(currentSlide);
  }

  if ((0,esm_typeof/* default */.Z)(slides) === 'object' && 'length' in slides) {
    for (var _i = 0; _i < slides.length; _i += 1) {
      if (slides[_i]) $wrapperEl.append(slides[_i]);
    }

    newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + slides.length : activeIndexBuffer;
  } else {
    $wrapperEl.append(slides);
  }

  for (var _i2 = 0; _i2 < slidesBuffer.length; _i2 += 1) {
    $wrapperEl.append(slidesBuffer[_i2]);
  }

  if (params.loop) {
    swiper.loopCreate();
  }

  if (!(params.observer && swiper.support.observer)) {
    swiper.update();
  }

  if (params.loop) {
    swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
  } else {
    swiper.slideTo(newActiveIndex, 0, false);
  }
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/manipulation/removeSlide.js

function removeSlide(slidesIndexes) {
  var swiper = this;
  var params = swiper.params,
      $wrapperEl = swiper.$wrapperEl,
      activeIndex = swiper.activeIndex;
  var activeIndexBuffer = activeIndex;

  if (params.loop) {
    activeIndexBuffer -= swiper.loopedSlides;
    swiper.loopDestroy();
    swiper.slides = $wrapperEl.children(".".concat(params.slideClass));
  }

  var newActiveIndex = activeIndexBuffer;
  var indexToRemove;

  if ((0,esm_typeof/* default */.Z)(slidesIndexes) === 'object' && 'length' in slidesIndexes) {
    for (var i = 0; i < slidesIndexes.length; i += 1) {
      indexToRemove = slidesIndexes[i];
      if (swiper.slides[indexToRemove]) swiper.slides.eq(indexToRemove).remove();
      if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
    }

    newActiveIndex = Math.max(newActiveIndex, 0);
  } else {
    indexToRemove = slidesIndexes;
    if (swiper.slides[indexToRemove]) swiper.slides.eq(indexToRemove).remove();
    if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
    newActiveIndex = Math.max(newActiveIndex, 0);
  }

  if (params.loop) {
    swiper.loopCreate();
  }

  if (!(params.observer && swiper.support.observer)) {
    swiper.update();
  }

  if (params.loop) {
    swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
  } else {
    swiper.slideTo(newActiveIndex, 0, false);
  }
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/manipulation/removeAllSlides.js
function removeAllSlides() {
  var swiper = this;
  var slidesIndexes = [];

  for (var i = 0; i < swiper.slides.length; i += 1) {
    slidesIndexes.push(i);
  }

  swiper.removeSlide(slidesIndexes);
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/manipulation/index.js





/* harmony default export */ const manipulation = ({
  appendSlide: appendSlide,
  prependSlide: prependSlide,
  addSlide: addSlide,
  removeSlide: removeSlide,
  removeAllSlides: removeAllSlides
});
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/events/onTouchStart.js



function onTouchStart(event) {
  var swiper = this;
  var document = getDocument();
  var window = ssr_window_esm_getWindow();
  var data = swiper.touchEventsData;
  var params = swiper.params,
      touches = swiper.touches;

  if (swiper.animating && params.preventInteractionOnTransition) {
    return;
  }

  var e = event;
  if (e.originalEvent) e = e.originalEvent;
  var $targetEl = dom(e.target);

  if (params.touchEventsTarget === 'wrapper') {
    if (!$targetEl.closest(swiper.wrapperEl).length) return;
  }

  data.isTouchEvent = e.type === 'touchstart';
  if (!data.isTouchEvent && 'which' in e && e.which === 3) return;
  if (!data.isTouchEvent && 'button' in e && e.button > 0) return;
  if (data.isTouched && data.isMoved) return; // change target el for shadow root componenet

  var swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== '';

  if (swipingClassHasValue && e.target && e.target.shadowRoot && event.path && event.path[0]) {
    $targetEl = dom(event.path[0]);
  }

  if (params.noSwiping && $targetEl.closest(params.noSwipingSelector ? params.noSwipingSelector : ".".concat(params.noSwipingClass))[0]) {
    swiper.allowClick = true;
    return;
  }

  if (params.swipeHandler) {
    if (!$targetEl.closest(params.swipeHandler)[0]) return;
  }

  touches.currentX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
  touches.currentY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
  var startX = touches.currentX;
  var startY = touches.currentY; // Do NOT start if iOS edge swipe is detected. Otherwise iOS app cannot swipe-to-go-back anymore

  var edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;
  var edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;

  if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window.innerWidth - edgeSwipeThreshold)) {
    if (edgeSwipeDetection === 'prevent') {
      event.preventDefault();
    } else {
      return;
    }
  }

  utils_extend(data, {
    isTouched: true,
    isMoved: false,
    allowTouchCallbacks: true,
    isScrolling: undefined,
    startMoving: undefined
  });
  touches.startX = startX;
  touches.startY = startY;
  data.touchStartTime = now();
  swiper.allowClick = true;
  swiper.updateSize();
  swiper.swipeDirection = undefined;
  if (params.threshold > 0) data.allowThresholdMove = false;

  if (e.type !== 'touchstart') {
    var preventDefault = true;
    if ($targetEl.is(data.formElements)) preventDefault = false;

    if (document.activeElement && dom(document.activeElement).is(data.formElements) && document.activeElement !== $targetEl[0]) {
      document.activeElement.blur();
    }

    var shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;

    if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !$targetEl[0].isContentEditable) {
      e.preventDefault();
    }
  }

  swiper.emit('touchStart', e);
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/events/onTouchMove.js



function onTouchMove(event) {
  var document = getDocument();
  var swiper = this;
  var data = swiper.touchEventsData;
  var params = swiper.params,
      touches = swiper.touches,
      rtl = swiper.rtlTranslate;
  var e = event;
  if (e.originalEvent) e = e.originalEvent;

  if (!data.isTouched) {
    if (data.startMoving && data.isScrolling) {
      swiper.emit('touchMoveOpposite', e);
    }

    return;
  }

  if (data.isTouchEvent && e.type !== 'touchmove') return;
  var targetTouch = e.type === 'touchmove' && e.targetTouches && (e.targetTouches[0] || e.changedTouches[0]);
  var pageX = e.type === 'touchmove' ? targetTouch.pageX : e.pageX;
  var pageY = e.type === 'touchmove' ? targetTouch.pageY : e.pageY;

  if (e.preventedByNestedSwiper) {
    touches.startX = pageX;
    touches.startY = pageY;
    return;
  }

  if (!swiper.allowTouchMove) {
    // isMoved = true;
    swiper.allowClick = false;

    if (data.isTouched) {
      utils_extend(touches, {
        startX: pageX,
        startY: pageY,
        currentX: pageX,
        currentY: pageY
      });
      data.touchStartTime = now();
    }

    return;
  }

  if (data.isTouchEvent && params.touchReleaseOnEdges && !params.loop) {
    if (swiper.isVertical()) {
      // Vertical
      if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {
        data.isTouched = false;
        data.isMoved = false;
        return;
      }
    } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) {
      return;
    }
  }

  if (data.isTouchEvent && document.activeElement) {
    if (e.target === document.activeElement && dom(e.target).is(data.formElements)) {
      data.isMoved = true;
      swiper.allowClick = false;
      return;
    }
  }

  if (data.allowTouchCallbacks) {
    swiper.emit('touchMove', e);
  }

  if (e.targetTouches && e.targetTouches.length > 1) return;
  touches.currentX = pageX;
  touches.currentY = pageY;
  var diffX = touches.currentX - touches.startX;
  var diffY = touches.currentY - touches.startY;
  if (swiper.params.threshold && Math.sqrt(Math.pow(diffX, 2) + Math.pow(diffY, 2)) < swiper.params.threshold) return;

  if (typeof data.isScrolling === 'undefined') {
    var touchAngle;

    if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) {
      data.isScrolling = false;
    } else {
      // eslint-disable-next-line
      if (diffX * diffX + diffY * diffY >= 25) {
        touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;
        data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;
      }
    }
  }

  if (data.isScrolling) {
    swiper.emit('touchMoveOpposite', e);
  }

  if (typeof data.startMoving === 'undefined') {
    if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {
      data.startMoving = true;
    }
  }

  if (data.isScrolling) {
    data.isTouched = false;
    return;
  }

  if (!data.startMoving) {
    return;
  }

  swiper.allowClick = false;

  if (!params.cssMode && e.cancelable) {
    e.preventDefault();
  }

  if (params.touchMoveStopPropagation && !params.nested) {
    e.stopPropagation();
  }

  if (!data.isMoved) {
    if (params.loop) {
      swiper.loopFix();
    }

    data.startTranslate = swiper.getTranslate();
    swiper.setTransition(0);

    if (swiper.animating) {
      swiper.$wrapperEl.trigger('webkitTransitionEnd transitionend');
    }

    data.allowMomentumBounce = false; // Grab Cursor

    if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
      swiper.setGrabCursor(true);
    }

    swiper.emit('sliderFirstMove', e);
  }

  swiper.emit('sliderMove', e);
  data.isMoved = true;
  var diff = swiper.isHorizontal() ? diffX : diffY;
  touches.diff = diff;
  diff *= params.touchRatio;
  if (rtl) diff = -diff;
  swiper.swipeDirection = diff > 0 ? 'prev' : 'next';
  data.currentTranslate = diff + data.startTranslate;
  var disableParentSwiper = true;
  var resistanceRatio = params.resistanceRatio;

  if (params.touchReleaseOnEdges) {
    resistanceRatio = 0;
  }

  if (diff > 0 && data.currentTranslate > swiper.minTranslate()) {
    disableParentSwiper = false;
    if (params.resistance) data.currentTranslate = swiper.minTranslate() - 1 + Math.pow(-swiper.minTranslate() + data.startTranslate + diff, resistanceRatio);
  } else if (diff < 0 && data.currentTranslate < swiper.maxTranslate()) {
    disableParentSwiper = false;
    if (params.resistance) data.currentTranslate = swiper.maxTranslate() + 1 - Math.pow(swiper.maxTranslate() - data.startTranslate - diff, resistanceRatio);
  }

  if (disableParentSwiper) {
    e.preventedByNestedSwiper = true;
  } // Directions locks


  if (!swiper.allowSlideNext && swiper.swipeDirection === 'next' && data.currentTranslate < data.startTranslate) {
    data.currentTranslate = data.startTranslate;
  }

  if (!swiper.allowSlidePrev && swiper.swipeDirection === 'prev' && data.currentTranslate > data.startTranslate) {
    data.currentTranslate = data.startTranslate;
  }

  if (!swiper.allowSlidePrev && !swiper.allowSlideNext) {
    data.currentTranslate = data.startTranslate;
  } // Threshold


  if (params.threshold > 0) {
    if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
      if (!data.allowThresholdMove) {
        data.allowThresholdMove = true;
        touches.startX = touches.currentX;
        touches.startY = touches.currentY;
        data.currentTranslate = data.startTranslate;
        touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
        return;
      }
    } else {
      data.currentTranslate = data.startTranslate;
      return;
    }
  }

  if (!params.followFinger || params.cssMode) return; // Update active index in free mode

  if (params.freeMode || params.watchSlidesProgress || params.watchSlidesVisibility) {
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
  }

  if (params.freeMode) {
    // Velocity
    if (data.velocities.length === 0) {
      data.velocities.push({
        position: touches[swiper.isHorizontal() ? 'startX' : 'startY'],
        time: data.touchStartTime
      });
    }

    data.velocities.push({
      position: touches[swiper.isHorizontal() ? 'currentX' : 'currentY'],
      time: now()
    });
  } // Update progress


  swiper.updateProgress(data.currentTranslate); // Update translate

  swiper.setTranslate(data.currentTranslate);
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/events/onTouchEnd.js

function onTouchEnd(event) {
  var swiper = this;
  var data = swiper.touchEventsData;
  var params = swiper.params,
      touches = swiper.touches,
      rtl = swiper.rtlTranslate,
      $wrapperEl = swiper.$wrapperEl,
      slidesGrid = swiper.slidesGrid,
      snapGrid = swiper.snapGrid;
  var e = event;
  if (e.originalEvent) e = e.originalEvent;

  if (data.allowTouchCallbacks) {
    swiper.emit('touchEnd', e);
  }

  data.allowTouchCallbacks = false;

  if (!data.isTouched) {
    if (data.isMoved && params.grabCursor) {
      swiper.setGrabCursor(false);
    }

    data.isMoved = false;
    data.startMoving = false;
    return;
  } // Return Grab Cursor


  if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
    swiper.setGrabCursor(false);
  } // Time diff


  var touchEndTime = now();
  var timeDiff = touchEndTime - data.touchStartTime; // Tap, doubleTap, Click

  if (swiper.allowClick) {
    swiper.updateClickedSlide(e);
    swiper.emit('tap click', e);

    if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {
      swiper.emit('doubleTap doubleClick', e);
    }
  }

  data.lastClickTime = now();
  nextTick(function () {
    if (!swiper.destroyed) swiper.allowClick = true;
  });

  if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {
    data.isTouched = false;
    data.isMoved = false;
    data.startMoving = false;
    return;
  }

  data.isTouched = false;
  data.isMoved = false;
  data.startMoving = false;
  var currentPos;

  if (params.followFinger) {
    currentPos = rtl ? swiper.translate : -swiper.translate;
  } else {
    currentPos = -data.currentTranslate;
  }

  if (params.cssMode) {
    return;
  }

  if (params.freeMode) {
    if (currentPos < -swiper.minTranslate()) {
      swiper.slideTo(swiper.activeIndex);
      return;
    }

    if (currentPos > -swiper.maxTranslate()) {
      if (swiper.slides.length < snapGrid.length) {
        swiper.slideTo(snapGrid.length - 1);
      } else {
        swiper.slideTo(swiper.slides.length - 1);
      }

      return;
    }

    if (params.freeModeMomentum) {
      if (data.velocities.length > 1) {
        var lastMoveEvent = data.velocities.pop();
        var velocityEvent = data.velocities.pop();
        var distance = lastMoveEvent.position - velocityEvent.position;
        var time = lastMoveEvent.time - velocityEvent.time;
        swiper.velocity = distance / time;
        swiper.velocity /= 2;

        if (Math.abs(swiper.velocity) < params.freeModeMinimumVelocity) {
          swiper.velocity = 0;
        } // this implies that the user stopped moving a finger then released.
        // There would be no events with distance zero, so the last event is stale.


        if (time > 150 || now() - lastMoveEvent.time > 300) {
          swiper.velocity = 0;
        }
      } else {
        swiper.velocity = 0;
      }

      swiper.velocity *= params.freeModeMomentumVelocityRatio;
      data.velocities.length = 0;
      var momentumDuration = 1000 * params.freeModeMomentumRatio;
      var momentumDistance = swiper.velocity * momentumDuration;
      var newPosition = swiper.translate + momentumDistance;
      if (rtl) newPosition = -newPosition;
      var doBounce = false;
      var afterBouncePosition;
      var bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeModeMomentumBounceRatio;
      var needsLoopFix;

      if (newPosition < swiper.maxTranslate()) {
        if (params.freeModeMomentumBounce) {
          if (newPosition + swiper.maxTranslate() < -bounceAmount) {
            newPosition = swiper.maxTranslate() - bounceAmount;
          }

          afterBouncePosition = swiper.maxTranslate();
          doBounce = true;
          data.allowMomentumBounce = true;
        } else {
          newPosition = swiper.maxTranslate();
        }

        if (params.loop && params.centeredSlides) needsLoopFix = true;
      } else if (newPosition > swiper.minTranslate()) {
        if (params.freeModeMomentumBounce) {
          if (newPosition - swiper.minTranslate() > bounceAmount) {
            newPosition = swiper.minTranslate() + bounceAmount;
          }

          afterBouncePosition = swiper.minTranslate();
          doBounce = true;
          data.allowMomentumBounce = true;
        } else {
          newPosition = swiper.minTranslate();
        }

        if (params.loop && params.centeredSlides) needsLoopFix = true;
      } else if (params.freeModeSticky) {
        var nextSlide;

        for (var j = 0; j < snapGrid.length; j += 1) {
          if (snapGrid[j] > -newPosition) {
            nextSlide = j;
            break;
          }
        }

        if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {
          newPosition = snapGrid[nextSlide];
        } else {
          newPosition = snapGrid[nextSlide - 1];
        }

        newPosition = -newPosition;
      }

      if (needsLoopFix) {
        swiper.once('transitionEnd', function () {
          swiper.loopFix();
        });
      } // Fix duration


      if (swiper.velocity !== 0) {
        if (rtl) {
          momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);
        } else {
          momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);
        }

        if (params.freeModeSticky) {
          // If freeModeSticky is active and the user ends a swipe with a slow-velocity
          // event, then durations can be 20+ seconds to slide one (or zero!) slides.
          // It's easy to see this when simulating touch with mouse events. To fix this,
          // limit single-slide swipes to the default slide duration. This also has the
          // nice side effect of matching slide speed if the user stopped moving before
          // lifting finger or mouse vs. moving slowly before lifting the finger/mouse.
          // For faster swipes, also apply limits (albeit higher ones).
          var moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);
          var currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];

          if (moveDistance < currentSlideSize) {
            momentumDuration = params.speed;
          } else if (moveDistance < 2 * currentSlideSize) {
            momentumDuration = params.speed * 1.5;
          } else {
            momentumDuration = params.speed * 2.5;
          }
        }
      } else if (params.freeModeSticky) {
        swiper.slideToClosest();
        return;
      }

      if (params.freeModeMomentumBounce && doBounce) {
        swiper.updateProgress(afterBouncePosition);
        swiper.setTransition(momentumDuration);
        swiper.setTranslate(newPosition);
        swiper.transitionStart(true, swiper.swipeDirection);
        swiper.animating = true;
        $wrapperEl.transitionEnd(function () {
          if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;
          swiper.emit('momentumBounce');
          swiper.setTransition(params.speed);
          setTimeout(function () {
            swiper.setTranslate(afterBouncePosition);
            $wrapperEl.transitionEnd(function () {
              if (!swiper || swiper.destroyed) return;
              swiper.transitionEnd();
            });
          }, 0);
        });
      } else if (swiper.velocity) {
        swiper.updateProgress(newPosition);
        swiper.setTransition(momentumDuration);
        swiper.setTranslate(newPosition);
        swiper.transitionStart(true, swiper.swipeDirection);

        if (!swiper.animating) {
          swiper.animating = true;
          $wrapperEl.transitionEnd(function () {
            if (!swiper || swiper.destroyed) return;
            swiper.transitionEnd();
          });
        }
      } else {
        swiper.emit('_freeModeNoMomentumRelease');
        swiper.updateProgress(newPosition);
      }

      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    } else if (params.freeModeSticky) {
      swiper.slideToClosest();
      return;
    } else if (params.freeMode) {
      swiper.emit('_freeModeNoMomentumRelease');
    }

    if (!params.freeModeMomentum || timeDiff >= params.longSwipesMs) {
      swiper.updateProgress();
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    }

    return;
  } // Find current slide


  var stopIndex = 0;
  var groupSize = swiper.slidesSizesGrid[0];

  for (var i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {
    var _increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;

    if (typeof slidesGrid[i + _increment] !== 'undefined') {
      if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + _increment]) {
        stopIndex = i;
        groupSize = slidesGrid[i + _increment] - slidesGrid[i];
      }
    } else if (currentPos >= slidesGrid[i]) {
      stopIndex = i;
      groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
    }
  } // Find current slide size


  var ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
  var increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;

  if (timeDiff > params.longSwipesMs) {
    // Long touches
    if (!params.longSwipes) {
      swiper.slideTo(swiper.activeIndex);
      return;
    }

    if (swiper.swipeDirection === 'next') {
      if (ratio >= params.longSwipesRatio) swiper.slideTo(stopIndex + increment);else swiper.slideTo(stopIndex);
    }

    if (swiper.swipeDirection === 'prev') {
      if (ratio > 1 - params.longSwipesRatio) swiper.slideTo(stopIndex + increment);else swiper.slideTo(stopIndex);
    }
  } else {
    // Short swipes
    if (!params.shortSwipes) {
      swiper.slideTo(swiper.activeIndex);
      return;
    }

    var isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);

    if (!isNavButtonTarget) {
      if (swiper.swipeDirection === 'next') {
        swiper.slideTo(stopIndex + increment);
      }

      if (swiper.swipeDirection === 'prev') {
        swiper.slideTo(stopIndex);
      }
    } else if (e.target === swiper.navigation.nextEl) {
      swiper.slideTo(stopIndex + increment);
    } else {
      swiper.slideTo(stopIndex);
    }
  }
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/events/onResize.js
function onResize() {
  var swiper = this;
  var params = swiper.params,
      el = swiper.el;
  if (el && el.offsetWidth === 0) return; // Breakpoints

  if (params.breakpoints) {
    swiper.setBreakpoint();
  } // Save locks


  var allowSlideNext = swiper.allowSlideNext,
      allowSlidePrev = swiper.allowSlidePrev,
      snapGrid = swiper.snapGrid; // Disable locks on resize

  swiper.allowSlideNext = true;
  swiper.allowSlidePrev = true;
  swiper.updateSize();
  swiper.updateSlides();
  swiper.updateSlidesClasses();

  if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides) {
    swiper.slideTo(swiper.slides.length - 1, 0, false, true);
  } else {
    swiper.slideTo(swiper.activeIndex, 0, false, true);
  }

  if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
    swiper.autoplay.run();
  } // Return locks after resize


  swiper.allowSlidePrev = allowSlidePrev;
  swiper.allowSlideNext = allowSlideNext;

  if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {
    swiper.checkOverflow();
  }
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/events/onClick.js
function onClick(e) {
  var swiper = this;

  if (!swiper.allowClick) {
    if (swiper.params.preventClicks) e.preventDefault();

    if (swiper.params.preventClicksPropagation && swiper.animating) {
      e.stopPropagation();
      e.stopImmediatePropagation();
    }
  }
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/events/onScroll.js
function onScroll() {
  var swiper = this;
  var wrapperEl = swiper.wrapperEl,
      rtlTranslate = swiper.rtlTranslate;
  swiper.previousTranslate = swiper.translate;

  if (swiper.isHorizontal()) {
    if (rtlTranslate) {
      swiper.translate = wrapperEl.scrollWidth - wrapperEl.offsetWidth - wrapperEl.scrollLeft;
    } else {
      swiper.translate = -wrapperEl.scrollLeft;
    }
  } else {
    swiper.translate = -wrapperEl.scrollTop;
  } // eslint-disable-next-line


  if (swiper.translate === -0) swiper.translate = 0;
  swiper.updateActiveIndex();
  swiper.updateSlidesClasses();
  var newProgress;
  var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();

  if (translatesDiff === 0) {
    newProgress = 0;
  } else {
    newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;
  }

  if (newProgress !== swiper.progress) {
    swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);
  }

  swiper.emit('setTranslate', swiper.translate, false);
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/events/index.js







var dummyEventAttached = false;

function dummyEventListener() {}

function attachEvents() {
  var swiper = this;
  var document = getDocument();
  var params = swiper.params,
      touchEvents = swiper.touchEvents,
      el = swiper.el,
      wrapperEl = swiper.wrapperEl,
      device = swiper.device,
      support = swiper.support;
  swiper.onTouchStart = onTouchStart.bind(swiper);
  swiper.onTouchMove = onTouchMove.bind(swiper);
  swiper.onTouchEnd = onTouchEnd.bind(swiper);

  if (params.cssMode) {
    swiper.onScroll = onScroll.bind(swiper);
  }

  swiper.onClick = onClick.bind(swiper);
  var capture = !!params.nested; // Touch Events

  if (!support.touch && support.pointerEvents) {
    el.addEventListener(touchEvents.start, swiper.onTouchStart, false);
    document.addEventListener(touchEvents.move, swiper.onTouchMove, capture);
    document.addEventListener(touchEvents.end, swiper.onTouchEnd, false);
  } else {
    if (support.touch) {
      var passiveListener = touchEvents.start === 'touchstart' && support.passiveListener && params.passiveListeners ? {
        passive: true,
        capture: false
      } : false;
      el.addEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);
      el.addEventListener(touchEvents.move, swiper.onTouchMove, support.passiveListener ? {
        passive: false,
        capture: capture
      } : capture);
      el.addEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);

      if (touchEvents.cancel) {
        el.addEventListener(touchEvents.cancel, swiper.onTouchEnd, passiveListener);
      }

      if (!dummyEventAttached) {
        document.addEventListener('touchstart', dummyEventListener);
        dummyEventAttached = true;
      }
    }

    if (params.simulateTouch && !device.ios && !device.android || params.simulateTouch && !support.touch && device.ios) {
      el.addEventListener('mousedown', swiper.onTouchStart, false);
      document.addEventListener('mousemove', swiper.onTouchMove, capture);
      document.addEventListener('mouseup', swiper.onTouchEnd, false);
    }
  } // Prevent Links Clicks


  if (params.preventClicks || params.preventClicksPropagation) {
    el.addEventListener('click', swiper.onClick, true);
  }

  if (params.cssMode) {
    wrapperEl.addEventListener('scroll', swiper.onScroll);
  } // Resize handler


  if (params.updateOnWindowResize) {
    swiper.on(device.ios || device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate', onResize, true);
  } else {
    swiper.on('observerUpdate', onResize, true);
  }
}

function detachEvents() {
  var swiper = this;
  var document = getDocument();
  var params = swiper.params,
      touchEvents = swiper.touchEvents,
      el = swiper.el,
      wrapperEl = swiper.wrapperEl,
      device = swiper.device,
      support = swiper.support;
  var capture = !!params.nested; // Touch Events

  if (!support.touch && support.pointerEvents) {
    el.removeEventListener(touchEvents.start, swiper.onTouchStart, false);
    document.removeEventListener(touchEvents.move, swiper.onTouchMove, capture);
    document.removeEventListener(touchEvents.end, swiper.onTouchEnd, false);
  } else {
    if (support.touch) {
      var passiveListener = touchEvents.start === 'onTouchStart' && support.passiveListener && params.passiveListeners ? {
        passive: true,
        capture: false
      } : false;
      el.removeEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);
      el.removeEventListener(touchEvents.move, swiper.onTouchMove, capture);
      el.removeEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);

      if (touchEvents.cancel) {
        el.removeEventListener(touchEvents.cancel, swiper.onTouchEnd, passiveListener);
      }
    }

    if (params.simulateTouch && !device.ios && !device.android || params.simulateTouch && !support.touch && device.ios) {
      el.removeEventListener('mousedown', swiper.onTouchStart, false);
      document.removeEventListener('mousemove', swiper.onTouchMove, capture);
      document.removeEventListener('mouseup', swiper.onTouchEnd, false);
    }
  } // Prevent Links Clicks


  if (params.preventClicks || params.preventClicksPropagation) {
    el.removeEventListener('click', swiper.onClick, true);
  }

  if (params.cssMode) {
    wrapperEl.removeEventListener('scroll', swiper.onScroll);
  } // Resize handler


  swiper.off(device.ios || device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate', onResize);
}

/* harmony default export */ const events = ({
  attachEvents: attachEvents,
  detachEvents: detachEvents
});
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/breakpoints/setBreakpoint.js

function setBreakpoint() {
  var swiper = this;
  var activeIndex = swiper.activeIndex,
      initialized = swiper.initialized,
      _swiper$loopedSlides = swiper.loopedSlides,
      loopedSlides = _swiper$loopedSlides === void 0 ? 0 : _swiper$loopedSlides,
      params = swiper.params,
      $el = swiper.$el;
  var breakpoints = params.breakpoints;
  if (!breakpoints || breakpoints && Object.keys(breakpoints).length === 0) return; // Get breakpoint for window width and update parameters

  var breakpoint = swiper.getBreakpoint(breakpoints, swiper.params.breakpointsBase, swiper.el);

  if (breakpoint && swiper.currentBreakpoint !== breakpoint) {
    var breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;

    if (breakpointOnlyParams) {
      ['slidesPerView', 'spaceBetween', 'slidesPerGroup', 'slidesPerGroupSkip', 'slidesPerColumn'].forEach(function (param) {
        var paramValue = breakpointOnlyParams[param];
        if (typeof paramValue === 'undefined') return;

        if (param === 'slidesPerView' && (paramValue === 'AUTO' || paramValue === 'auto')) {
          breakpointOnlyParams[param] = 'auto';
        } else if (param === 'slidesPerView') {
          breakpointOnlyParams[param] = parseFloat(paramValue);
        } else {
          breakpointOnlyParams[param] = parseInt(paramValue, 10);
        }
      });
    }

    var breakpointParams = breakpointOnlyParams || swiper.originalParams;
    var wasMultiRow = params.slidesPerColumn > 1;
    var isMultiRow = breakpointParams.slidesPerColumn > 1;

    if (wasMultiRow && !isMultiRow) {
      $el.removeClass("".concat(params.containerModifierClass, "multirow ").concat(params.containerModifierClass, "multirow-column"));
      swiper.emitContainerClasses();
    } else if (!wasMultiRow && isMultiRow) {
      $el.addClass("".concat(params.containerModifierClass, "multirow"));

      if (breakpointParams.slidesPerColumnFill === 'column') {
        $el.addClass("".concat(params.containerModifierClass, "multirow-column"));
      }

      swiper.emitContainerClasses();
    }

    var directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
    var needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);

    if (directionChanged && initialized) {
      swiper.changeDirection();
    }

    utils_extend(swiper.params, breakpointParams);
    utils_extend(swiper, {
      allowTouchMove: swiper.params.allowTouchMove,
      allowSlideNext: swiper.params.allowSlideNext,
      allowSlidePrev: swiper.params.allowSlidePrev
    });
    swiper.currentBreakpoint = breakpoint;
    swiper.emit('_beforeBreakpoint', breakpointParams);

    if (needsReLoop && initialized) {
      swiper.loopDestroy();
      swiper.loopCreate();
      swiper.updateSlides();
      swiper.slideTo(activeIndex - loopedSlides + swiper.loopedSlides, 0, false);
    }

    swiper.emit('breakpoint', breakpointParams);
  }
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/breakpoints/getBreakpoint.js

function getBreakpoint(breakpoints) {
  var base = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'window';
  var containerEl = arguments.length > 2 ? arguments[2] : undefined;
  if (!breakpoints || base === 'container' && !containerEl) return undefined;
  var breakpoint = false;
  var window = ssr_window_esm_getWindow();
  var currentWidth = base === 'window' ? window.innerWidth : containerEl.clientWidth;
  var currentHeight = base === 'window' ? window.innerHeight : containerEl.clientHeight;
  var points = Object.keys(breakpoints).map(function (point) {
    if (typeof point === 'string' && point.indexOf('@') === 0) {
      var minRatio = parseFloat(point.substr(1));
      var value = currentHeight * minRatio;
      return {
        value: value,
        point: point
      };
    }

    return {
      value: point,
      point: point
    };
  });
  points.sort(function (a, b) {
    return parseInt(a.value, 10) - parseInt(b.value, 10);
  });

  for (var i = 0; i < points.length; i += 1) {
    var _points$i = points[i],
        point = _points$i.point,
        value = _points$i.value;

    if (value <= currentWidth) {
      breakpoint = point;
    }
  }

  return breakpoint || 'max';
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/breakpoints/index.js


/* harmony default export */ const breakpoints = ({
  setBreakpoint: setBreakpoint,
  getBreakpoint: getBreakpoint
});
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/classes/addClasses.js



function prepareClasses(entries, prefix) {
  var resultClasses = [];
  entries.forEach(function (item) {
    if ((0,esm_typeof/* default */.Z)(item) === 'object') {
      Object.keys(item).forEach(function (classNames) {
        if (item[classNames]) {
          resultClasses.push(prefix + classNames);
        }
      });
    } else if (typeof item === 'string') {
      resultClasses.push(prefix + item);
    }
  });
  return resultClasses;
}

function addClasses() {
  var swiper = this;
  var classNames = swiper.classNames,
      params = swiper.params,
      rtl = swiper.rtl,
      $el = swiper.$el,
      device = swiper.device,
      support = swiper.support; // prettier-ignore

  var suffixes = prepareClasses(['initialized', params.direction, {
    'pointer-events': support.pointerEvents && !support.touch
  }, {
    'free-mode': params.freeMode
  }, {
    'autoheight': params.autoHeight
  }, {
    'rtl': rtl
  }, {
    'multirow': params.slidesPerColumn > 1
  }, {
    'multirow-column': params.slidesPerColumn > 1 && params.slidesPerColumnFill === 'column'
  }, {
    'android': device.android
  }, {
    'ios': device.ios
  }, {
    'css-mode': params.cssMode
  }], params.containerModifierClass);
  classNames.push.apply(classNames, _toConsumableArray(suffixes));
  $el.addClass(_toConsumableArray(classNames).join(' '));
  swiper.emitContainerClasses();
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/classes/removeClasses.js
function removeClasses() {
  var swiper = this;
  var $el = swiper.$el,
      classNames = swiper.classNames;
  $el.removeClass(classNames.join(' '));
  swiper.emitContainerClasses();
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/classes/index.js


/* harmony default export */ const classes = ({
  addClasses: addClasses,
  removeClasses: removeClasses
});
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/images/loadImage.js


function loadImage(imageEl, src, srcset, sizes, checkForComplete, callback) {
  var window = ssr_window_esm_getWindow();
  var image;

  function onReady() {
    if (callback) callback();
  }

  var isPicture = dom(imageEl).parent('picture')[0];

  if (!isPicture && (!imageEl.complete || !checkForComplete)) {
    if (src) {
      image = new window.Image();
      image.onload = onReady;
      image.onerror = onReady;

      if (sizes) {
        image.sizes = sizes;
      }

      if (srcset) {
        image.srcset = srcset;
      }

      if (src) {
        image.src = src;
      }
    } else {
      onReady();
    }
  } else {
    // image already loaded...
    onReady();
  }
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/images/preloadImages.js
function preloadImages() {
  var swiper = this;
  swiper.imagesToLoad = swiper.$el.find('img');

  function onReady() {
    if (typeof swiper === 'undefined' || swiper === null || !swiper || swiper.destroyed) return;
    if (swiper.imagesLoaded !== undefined) swiper.imagesLoaded += 1;

    if (swiper.imagesLoaded === swiper.imagesToLoad.length) {
      if (swiper.params.updateOnImagesReady) swiper.update();
      swiper.emit('imagesReady');
    }
  }

  for (var i = 0; i < swiper.imagesToLoad.length; i += 1) {
    var imageEl = swiper.imagesToLoad[i];
    swiper.loadImage(imageEl, imageEl.currentSrc || imageEl.getAttribute('src'), imageEl.srcset || imageEl.getAttribute('srcset'), imageEl.sizes || imageEl.getAttribute('sizes'), true, onReady);
  }
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/images/index.js


/* harmony default export */ const core_images = ({
  loadImage: loadImage,
  preloadImages: preloadImages
});
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/check-overflow/index.js
function checkOverflow() {
  var swiper = this;
  var params = swiper.params;
  var wasLocked = swiper.isLocked;
  var lastSlidePosition = swiper.slides.length > 0 && params.slidesOffsetBefore + params.spaceBetween * (swiper.slides.length - 1) + swiper.slides[0].offsetWidth * swiper.slides.length;

  if (params.slidesOffsetBefore && params.slidesOffsetAfter && lastSlidePosition) {
    swiper.isLocked = lastSlidePosition <= swiper.size;
  } else {
    swiper.isLocked = swiper.snapGrid.length === 1;
  }

  swiper.allowSlideNext = !swiper.isLocked;
  swiper.allowSlidePrev = !swiper.isLocked; // events

  if (wasLocked !== swiper.isLocked) swiper.emit(swiper.isLocked ? 'lock' : 'unlock');

  if (wasLocked && wasLocked !== swiper.isLocked) {
    swiper.isEnd = false;
    if (swiper.navigation) swiper.navigation.update();
  }
}

/* harmony default export */ const check_overflow = ({
  checkOverflow: checkOverflow
});
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/defaults.js
/* harmony default export */ const defaults = ({
  init: true,
  direction: 'horizontal',
  touchEventsTarget: 'container',
  initialSlide: 0,
  speed: 300,
  cssMode: false,
  updateOnWindowResize: true,
  resizeObserver: false,
  nested: false,
  // Overrides
  width: null,
  height: null,
  //
  preventInteractionOnTransition: false,
  // ssr
  userAgent: null,
  url: null,
  // To support iOS's swipe-to-go-back gesture (when being used in-app).
  edgeSwipeDetection: false,
  edgeSwipeThreshold: 20,
  // Free mode
  freeMode: false,
  freeModeMomentum: true,
  freeModeMomentumRatio: 1,
  freeModeMomentumBounce: true,
  freeModeMomentumBounceRatio: 1,
  freeModeMomentumVelocityRatio: 1,
  freeModeSticky: false,
  freeModeMinimumVelocity: 0.02,
  // Autoheight
  autoHeight: false,
  // Set wrapper width
  setWrapperSize: false,
  // Virtual Translate
  virtualTranslate: false,
  // Effects
  effect: 'slide',
  // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'
  // Breakpoints
  breakpoints: undefined,
  breakpointsBase: 'window',
  // Slides grid
  spaceBetween: 0,
  slidesPerView: 1,
  slidesPerColumn: 1,
  slidesPerColumnFill: 'column',
  slidesPerGroup: 1,
  slidesPerGroupSkip: 0,
  centeredSlides: false,
  centeredSlidesBounds: false,
  slidesOffsetBefore: 0,
  // in px
  slidesOffsetAfter: 0,
  // in px
  normalizeSlideIndex: true,
  centerInsufficientSlides: false,
  // Disable swiper and hide navigation when container not overflow
  watchOverflow: false,
  // Round length
  roundLengths: false,
  // Touches
  touchRatio: 1,
  touchAngle: 45,
  simulateTouch: true,
  shortSwipes: true,
  longSwipes: true,
  longSwipesRatio: 0.5,
  longSwipesMs: 300,
  followFinger: true,
  allowTouchMove: true,
  threshold: 0,
  touchMoveStopPropagation: false,
  touchStartPreventDefault: true,
  touchStartForcePreventDefault: false,
  touchReleaseOnEdges: false,
  // Unique Navigation Elements
  uniqueNavElements: true,
  // Resistance
  resistance: true,
  resistanceRatio: 0.85,
  // Progress
  watchSlidesProgress: false,
  watchSlidesVisibility: false,
  // Cursor
  grabCursor: false,
  // Clicks
  preventClicks: true,
  preventClicksPropagation: true,
  slideToClickedSlide: false,
  // Images
  preloadImages: true,
  updateOnImagesReady: true,
  // loop
  loop: false,
  loopAdditionalSlides: 0,
  loopedSlides: null,
  loopFillGroupWithBlank: false,
  loopPreventsSlide: true,
  // Swiping/no swiping
  allowSlidePrev: true,
  allowSlideNext: true,
  swipeHandler: null,
  // '.swipe-handler',
  noSwiping: true,
  noSwipingClass: 'swiper-no-swiping',
  noSwipingSelector: null,
  // Passive Listeners
  passiveListeners: true,
  // NS
  containerModifierClass: 'swiper-container-',
  // NEW
  slideClass: 'swiper-slide',
  slideBlankClass: 'swiper-slide-invisible-blank',
  slideActiveClass: 'swiper-slide-active',
  slideDuplicateActiveClass: 'swiper-slide-duplicate-active',
  slideVisibleClass: 'swiper-slide-visible',
  slideDuplicateClass: 'swiper-slide-duplicate',
  slideNextClass: 'swiper-slide-next',
  slideDuplicateNextClass: 'swiper-slide-duplicate-next',
  slidePrevClass: 'swiper-slide-prev',
  slideDuplicatePrevClass: 'swiper-slide-duplicate-prev',
  wrapperClass: 'swiper-wrapper',
  // Callbacks
  runCallbacksOnInit: true,
  // Internals
  _emitClasses: false
});
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/core-class.js




/* eslint no-param-reassign: "off" */






















var prototypes = {
  modular: modular,
  eventsEmitter: events_emitter,
  update: update,
  translate: translate,
  transition: core_transition,
  slide: slide,
  loop: loop,
  grabCursor: grab_cursor,
  manipulation: manipulation,
  events: events,
  breakpoints: breakpoints,
  checkOverflow: check_overflow,
  classes: classes,
  images: core_images
};
var extendedDefaults = {};

var Swiper = /*#__PURE__*/function () {
  function Swiper() {
    _classCallCheck(this, Swiper);

    var el;
    var params;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === 'Object') {
      params = args[0];
    } else {
      el = args[0];
      params = args[1];
    }

    if (!params) params = {};
    params = utils_extend({}, params);
    if (el && !params.el) params.el = el;

    if (params.el && dom(params.el).length > 1) {
      var swipers = [];
      dom(params.el).each(function (containerEl) {
        var newParams = utils_extend({}, params, {
          el: containerEl
        });
        swipers.push(new Swiper(newParams));
      });
      return swipers;
    } // Swiper Instance


    var swiper = this;
    swiper.__swiper__ = true;
    swiper.support = getSupport();
    swiper.device = getDevice({
      userAgent: params.userAgent
    });
    swiper.browser = getBrowser();
    swiper.eventsListeners = {};
    swiper.eventsAnyListeners = [];

    if (typeof swiper.modules === 'undefined') {
      swiper.modules = {};
    }

    Object.keys(swiper.modules).forEach(function (moduleName) {
      var module = swiper.modules[moduleName];

      if (module.params) {
        var moduleParamName = Object.keys(module.params)[0];
        var moduleParams = module.params[moduleParamName];
        if ((0,esm_typeof/* default */.Z)(moduleParams) !== 'object' || moduleParams === null) return;
        if (!(moduleParamName in params && 'enabled' in moduleParams)) return;

        if (params[moduleParamName] === true) {
          params[moduleParamName] = {
            enabled: true
          };
        }

        if ((0,esm_typeof/* default */.Z)(params[moduleParamName]) === 'object' && !('enabled' in params[moduleParamName])) {
          params[moduleParamName].enabled = true;
        }

        if (!params[moduleParamName]) params[moduleParamName] = {
          enabled: false
        };
      }
    }); // Extend defaults with modules params

    var swiperParams = utils_extend({}, defaults);
    swiper.useParams(swiperParams); // Extend defaults with passed params

    swiper.params = utils_extend({}, swiperParams, extendedDefaults, params);
    swiper.originalParams = utils_extend({}, swiper.params);
    swiper.passedParams = utils_extend({}, params); // add event listeners

    if (swiper.params && swiper.params.on) {
      Object.keys(swiper.params.on).forEach(function (eventName) {
        swiper.on(eventName, swiper.params.on[eventName]);
      });
    }

    if (swiper.params && swiper.params.onAny) {
      swiper.onAny(swiper.params.onAny);
    } // Save Dom lib


    swiper.$ = dom; // Extend Swiper

    utils_extend(swiper, {
      el: el,
      // Classes
      classNames: [],
      // Slides
      slides: dom(),
      slidesGrid: [],
      snapGrid: [],
      slidesSizesGrid: [],
      // isDirection
      isHorizontal: function isHorizontal() {
        return swiper.params.direction === 'horizontal';
      },
      isVertical: function isVertical() {
        return swiper.params.direction === 'vertical';
      },
      // Indexes
      activeIndex: 0,
      realIndex: 0,
      //
      isBeginning: true,
      isEnd: false,
      // Props
      translate: 0,
      previousTranslate: 0,
      progress: 0,
      velocity: 0,
      animating: false,
      // Locks
      allowSlideNext: swiper.params.allowSlideNext,
      allowSlidePrev: swiper.params.allowSlidePrev,
      // Touch Events
      touchEvents: function touchEvents() {
        var touch = ['touchstart', 'touchmove', 'touchend', 'touchcancel'];
        var desktop = ['mousedown', 'mousemove', 'mouseup'];

        if (swiper.support.pointerEvents) {
          desktop = ['pointerdown', 'pointermove', 'pointerup'];
        }

        swiper.touchEventsTouch = {
          start: touch[0],
          move: touch[1],
          end: touch[2],
          cancel: touch[3]
        };
        swiper.touchEventsDesktop = {
          start: desktop[0],
          move: desktop[1],
          end: desktop[2]
        };
        return swiper.support.touch || !swiper.params.simulateTouch ? swiper.touchEventsTouch : swiper.touchEventsDesktop;
      }(),
      touchEventsData: {
        isTouched: undefined,
        isMoved: undefined,
        allowTouchCallbacks: undefined,
        touchStartTime: undefined,
        isScrolling: undefined,
        currentTranslate: undefined,
        startTranslate: undefined,
        allowThresholdMove: undefined,
        // Form elements to match
        formElements: 'input, select, option, textarea, button, video, label',
        // Last click time
        lastClickTime: now(),
        clickTimeout: undefined,
        // Velocities
        velocities: [],
        allowMomentumBounce: undefined,
        isTouchEvent: undefined,
        startMoving: undefined
      },
      // Clicks
      allowClick: true,
      // Touches
      allowTouchMove: swiper.params.allowTouchMove,
      touches: {
        startX: 0,
        startY: 0,
        currentX: 0,
        currentY: 0,
        diff: 0
      },
      // Images
      imagesToLoad: [],
      imagesLoaded: 0
    }); // Install Modules

    swiper.useModules();
    swiper.emit('_swiper'); // Init

    if (swiper.params.init) {
      swiper.init();
    } // Return app instance


    return swiper;
  }

  _createClass(Swiper, [{
    key: "setProgress",
    value: function setProgress(progress, speed) {
      var swiper = this;
      progress = Math.min(Math.max(progress, 0), 1);
      var min = swiper.minTranslate();
      var max = swiper.maxTranslate();
      var current = (max - min) * progress + min;
      swiper.translateTo(current, typeof speed === 'undefined' ? 0 : speed);
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    }
  }, {
    key: "emitContainerClasses",
    value: function emitContainerClasses() {
      var swiper = this;
      if (!swiper.params._emitClasses || !swiper.el) return;
      var classes = swiper.el.className.split(' ').filter(function (className) {
        return className.indexOf('swiper-container') === 0 || className.indexOf(swiper.params.containerModifierClass) === 0;
      });
      swiper.emit('_containerClasses', classes.join(' '));
    }
  }, {
    key: "getSlideClasses",
    value: function getSlideClasses(slideEl) {
      var swiper = this;
      return slideEl.className.split(' ').filter(function (className) {
        return className.indexOf('swiper-slide') === 0 || className.indexOf(swiper.params.slideClass) === 0;
      }).join(' ');
    }
  }, {
    key: "emitSlidesClasses",
    value: function emitSlidesClasses() {
      var swiper = this;
      if (!swiper.params._emitClasses || !swiper.el) return;
      var updates = [];
      swiper.slides.each(function (slideEl) {
        var classNames = swiper.getSlideClasses(slideEl);
        updates.push({
          slideEl: slideEl,
          classNames: classNames
        });
        swiper.emit('_slideClass', slideEl, classNames);
      });
      swiper.emit('_slideClasses', updates);
    }
  }, {
    key: "slidesPerViewDynamic",
    value: function slidesPerViewDynamic() {
      var swiper = this;
      var params = swiper.params,
          slides = swiper.slides,
          slidesGrid = swiper.slidesGrid,
          swiperSize = swiper.size,
          activeIndex = swiper.activeIndex;
      var spv = 1;

      if (params.centeredSlides) {
        var slideSize = slides[activeIndex].swiperSlideSize;
        var breakLoop;

        for (var i = activeIndex + 1; i < slides.length; i += 1) {
          if (slides[i] && !breakLoop) {
            slideSize += slides[i].swiperSlideSize;
            spv += 1;
            if (slideSize > swiperSize) breakLoop = true;
          }
        }

        for (var _i = activeIndex - 1; _i >= 0; _i -= 1) {
          if (slides[_i] && !breakLoop) {
            slideSize += slides[_i].swiperSlideSize;
            spv += 1;
            if (slideSize > swiperSize) breakLoop = true;
          }
        }
      } else {
        for (var _i2 = activeIndex + 1; _i2 < slides.length; _i2 += 1) {
          if (slidesGrid[_i2] - slidesGrid[activeIndex] < swiperSize) {
            spv += 1;
          }
        }
      }

      return spv;
    }
  }, {
    key: "update",
    value: function update() {
      var swiper = this;
      if (!swiper || swiper.destroyed) return;
      var snapGrid = swiper.snapGrid,
          params = swiper.params; // Breakpoints

      if (params.breakpoints) {
        swiper.setBreakpoint();
      }

      swiper.updateSize();
      swiper.updateSlides();
      swiper.updateProgress();
      swiper.updateSlidesClasses();

      function setTranslate() {
        var translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;
        var newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
        swiper.setTranslate(newTranslate);
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();
      }

      var translated;

      if (swiper.params.freeMode) {
        setTranslate();

        if (swiper.params.autoHeight) {
          swiper.updateAutoHeight();
        }
      } else {
        if ((swiper.params.slidesPerView === 'auto' || swiper.params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {
          translated = swiper.slideTo(swiper.slides.length - 1, 0, false, true);
        } else {
          translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
        }

        if (!translated) {
          setTranslate();
        }
      }

      if (params.watchOverflow && snapGrid !== swiper.snapGrid) {
        swiper.checkOverflow();
      }

      swiper.emit('update');
    }
  }, {
    key: "changeDirection",
    value: function changeDirection(newDirection) {
      var needUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var swiper = this;
      var currentDirection = swiper.params.direction;

      if (!newDirection) {
        // eslint-disable-next-line
        newDirection = currentDirection === 'horizontal' ? 'vertical' : 'horizontal';
      }

      if (newDirection === currentDirection || newDirection !== 'horizontal' && newDirection !== 'vertical') {
        return swiper;
      }

      swiper.$el.removeClass("".concat(swiper.params.containerModifierClass).concat(currentDirection)).addClass("".concat(swiper.params.containerModifierClass).concat(newDirection));
      swiper.emitContainerClasses();
      swiper.params.direction = newDirection;
      swiper.slides.each(function (slideEl) {
        if (newDirection === 'vertical') {
          slideEl.style.width = '';
        } else {
          slideEl.style.height = '';
        }
      });
      swiper.emit('changeDirection');
      if (needUpdate) swiper.update();
      return swiper;
    }
  }, {
    key: "mount",
    value: function mount(el) {
      var swiper = this;
      if (swiper.mounted) return true; // Find el

      var $el = dom(el || swiper.params.el);
      el = $el[0];

      if (!el) {
        return false;
      }

      el.swiper = swiper; // Find Wrapper

      var $wrapperEl;

      if (el && el.shadowRoot && el.shadowRoot.querySelector) {
        $wrapperEl = dom(el.shadowRoot.querySelector(".".concat(swiper.params.wrapperClass))); // Children needs to return slot items

        $wrapperEl.children = function (options) {
          return $el.children(options);
        };
      } else {
        $wrapperEl = $el.children(".".concat(swiper.params.wrapperClass));
      }

      utils_extend(swiper, {
        $el: $el,
        el: el,
        $wrapperEl: $wrapperEl,
        wrapperEl: $wrapperEl[0],
        mounted: true,
        // RTL
        rtl: el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl',
        rtlTranslate: swiper.params.direction === 'horizontal' && (el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl'),
        wrongRTL: $wrapperEl.css('display') === '-webkit-box'
      });
      return true;
    }
  }, {
    key: "init",
    value: function init(el) {
      var swiper = this;
      if (swiper.initialized) return swiper;
      var mounted = swiper.mount(el);
      if (mounted === false) return swiper;
      swiper.emit('beforeInit'); // Set breakpoint

      if (swiper.params.breakpoints) {
        swiper.setBreakpoint();
      } // Add Classes


      swiper.addClasses(); // Create loop

      if (swiper.params.loop) {
        swiper.loopCreate();
      } // Update size


      swiper.updateSize(); // Update slides

      swiper.updateSlides();

      if (swiper.params.watchOverflow) {
        swiper.checkOverflow();
      } // Set Grab Cursor


      if (swiper.params.grabCursor) {
        swiper.setGrabCursor();
      }

      if (swiper.params.preloadImages) {
        swiper.preloadImages();
      } // Slide To Initial Slide


      if (swiper.params.loop) {
        swiper.slideTo(swiper.params.initialSlide + swiper.loopedSlides, 0, swiper.params.runCallbacksOnInit);
      } else {
        swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit);
      } // Attach events


      swiper.attachEvents(); // Init Flag

      swiper.initialized = true; // Emit

      swiper.emit('init');
      swiper.emit('afterInit');
      return swiper;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      var deleteInstance = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      var cleanStyles = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var swiper = this;
      var params = swiper.params,
          $el = swiper.$el,
          $wrapperEl = swiper.$wrapperEl,
          slides = swiper.slides;

      if (typeof swiper.params === 'undefined' || swiper.destroyed) {
        return null;
      }

      swiper.emit('beforeDestroy'); // Init Flag

      swiper.initialized = false; // Detach events

      swiper.detachEvents(); // Destroy loop

      if (params.loop) {
        swiper.loopDestroy();
      } // Cleanup styles


      if (cleanStyles) {
        swiper.removeClasses();
        $el.removeAttr('style');
        $wrapperEl.removeAttr('style');

        if (slides && slides.length) {
          slides.removeClass([params.slideVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass].join(' ')).removeAttr('style').removeAttr('data-swiper-slide-index');
        }
      }

      swiper.emit('destroy'); // Detach emitter events

      Object.keys(swiper.eventsListeners).forEach(function (eventName) {
        swiper.off(eventName);
      });

      if (deleteInstance !== false) {
        swiper.$el[0].swiper = null;
        deleteProps(swiper);
      }

      swiper.destroyed = true;
      return null;
    }
  }], [{
    key: "extendDefaults",
    value: function extendDefaults(newDefaults) {
      utils_extend(extendedDefaults, newDefaults);
    }
  }, {
    key: "extendedDefaults",
    get: function get() {
      return extendedDefaults;
    }
  }, {
    key: "defaults",
    get: function get() {
      return defaults;
    }
  }, {
    key: "installModule",
    value: function installModule(module) {
      if (!Swiper.prototype.modules) Swiper.prototype.modules = {};
      var name = module.name || "".concat(Object.keys(Swiper.prototype.modules).length, "_").concat(now());
      Swiper.prototype.modules[name] = module;
    }
  }, {
    key: "use",
    value: function use(module) {
      if (Array.isArray(module)) {
        module.forEach(function (m) {
          return Swiper.installModule(m);
        });
        return Swiper;
      }

      Swiper.installModule(module);
      return Swiper;
    }
  }]);

  return Swiper;
}();

Object.keys(prototypes).forEach(function (prototypeGroup) {
  Object.keys(prototypes[prototypeGroup]).forEach(function (protoMethod) {
    Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
  });
});
Swiper.use([resize_resize, observer]);
/* harmony default export */ const core_class = (Swiper);
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/zoom/zoom.js


function zoom_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function zoom_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? zoom_ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : zoom_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }




var Zoom = {
  // Calc Scale From Multi-touches
  getDistanceBetweenTouches: function getDistanceBetweenTouches(e) {
    if (e.targetTouches.length < 2) return 1;
    var x1 = e.targetTouches[0].pageX;
    var y1 = e.targetTouches[0].pageY;
    var x2 = e.targetTouches[1].pageX;
    var y2 = e.targetTouches[1].pageY;
    var distance = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
    return distance;
  },
  // Events
  onGestureStart: function onGestureStart(e) {
    var swiper = this;
    var support = swiper.support;
    var params = swiper.params.zoom;
    var zoom = swiper.zoom;
    var gesture = zoom.gesture;
    zoom.fakeGestureTouched = false;
    zoom.fakeGestureMoved = false;

    if (!support.gestures) {
      if (e.type !== 'touchstart' || e.type === 'touchstart' && e.targetTouches.length < 2) {
        return;
      }

      zoom.fakeGestureTouched = true;
      gesture.scaleStart = Zoom.getDistanceBetweenTouches(e);
    }

    if (!gesture.$slideEl || !gesture.$slideEl.length) {
      gesture.$slideEl = dom(e.target).closest(".".concat(swiper.params.slideClass));
      if (gesture.$slideEl.length === 0) gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
      gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas, picture, .swiper-zoom-target');
      gesture.$imageWrapEl = gesture.$imageEl.parent(".".concat(params.containerClass));
      gesture.maxRatio = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;

      if (gesture.$imageWrapEl.length === 0) {
        gesture.$imageEl = undefined;
        return;
      }
    }

    if (gesture.$imageEl) {
      gesture.$imageEl.transition(0);
    }

    swiper.zoom.isScaling = true;
  },
  onGestureChange: function onGestureChange(e) {
    var swiper = this;
    var support = swiper.support;
    var params = swiper.params.zoom;
    var zoom = swiper.zoom;
    var gesture = zoom.gesture;

    if (!support.gestures) {
      if (e.type !== 'touchmove' || e.type === 'touchmove' && e.targetTouches.length < 2) {
        return;
      }

      zoom.fakeGestureMoved = true;
      gesture.scaleMove = Zoom.getDistanceBetweenTouches(e);
    }

    if (!gesture.$imageEl || gesture.$imageEl.length === 0) {
      if (e.type === 'gesturechange') zoom.onGestureStart(e);
      return;
    }

    if (support.gestures) {
      zoom.scale = e.scale * zoom.currentScale;
    } else {
      zoom.scale = gesture.scaleMove / gesture.scaleStart * zoom.currentScale;
    }

    if (zoom.scale > gesture.maxRatio) {
      zoom.scale = gesture.maxRatio - 1 + Math.pow(zoom.scale - gesture.maxRatio + 1, 0.5);
    }

    if (zoom.scale < params.minRatio) {
      zoom.scale = params.minRatio + 1 - Math.pow(params.minRatio - zoom.scale + 1, 0.5);
    }

    gesture.$imageEl.transform("translate3d(0,0,0) scale(".concat(zoom.scale, ")"));
  },
  onGestureEnd: function onGestureEnd(e) {
    var swiper = this;
    var device = swiper.device;
    var support = swiper.support;
    var params = swiper.params.zoom;
    var zoom = swiper.zoom;
    var gesture = zoom.gesture;

    if (!support.gestures) {
      if (!zoom.fakeGestureTouched || !zoom.fakeGestureMoved) {
        return;
      }

      if (e.type !== 'touchend' || e.type === 'touchend' && e.changedTouches.length < 2 && !device.android) {
        return;
      }

      zoom.fakeGestureTouched = false;
      zoom.fakeGestureMoved = false;
    }

    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
    zoom.scale = Math.max(Math.min(zoom.scale, gesture.maxRatio), params.minRatio);
    gesture.$imageEl.transition(swiper.params.speed).transform("translate3d(0,0,0) scale(".concat(zoom.scale, ")"));
    zoom.currentScale = zoom.scale;
    zoom.isScaling = false;
    if (zoom.scale === 1) gesture.$slideEl = undefined;
  },
  onTouchStart: function onTouchStart(e) {
    var swiper = this;
    var device = swiper.device;
    var zoom = swiper.zoom;
    var gesture = zoom.gesture,
        image = zoom.image;
    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
    if (image.isTouched) return;
    if (device.android && e.cancelable) e.preventDefault();
    image.isTouched = true;
    image.touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
    image.touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
  },
  onTouchMove: function onTouchMove(e) {
    var swiper = this;
    var zoom = swiper.zoom;
    var gesture = zoom.gesture,
        image = zoom.image,
        velocity = zoom.velocity;
    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
    swiper.allowClick = false;
    if (!image.isTouched || !gesture.$slideEl) return;

    if (!image.isMoved) {
      image.width = gesture.$imageEl[0].offsetWidth;
      image.height = gesture.$imageEl[0].offsetHeight;
      image.startX = getTranslate(gesture.$imageWrapEl[0], 'x') || 0;
      image.startY = getTranslate(gesture.$imageWrapEl[0], 'y') || 0;
      gesture.slideWidth = gesture.$slideEl[0].offsetWidth;
      gesture.slideHeight = gesture.$slideEl[0].offsetHeight;
      gesture.$imageWrapEl.transition(0);

      if (swiper.rtl) {
        image.startX = -image.startX;
        image.startY = -image.startY;
      }
    } // Define if we need image drag


    var scaledWidth = image.width * zoom.scale;
    var scaledHeight = image.height * zoom.scale;
    if (scaledWidth < gesture.slideWidth && scaledHeight < gesture.slideHeight) return;
    image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);
    image.maxX = -image.minX;
    image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);
    image.maxY = -image.minY;
    image.touchesCurrent.x = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
    image.touchesCurrent.y = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;

    if (!image.isMoved && !zoom.isScaling) {
      if (swiper.isHorizontal() && (Math.floor(image.minX) === Math.floor(image.startX) && image.touchesCurrent.x < image.touchesStart.x || Math.floor(image.maxX) === Math.floor(image.startX) && image.touchesCurrent.x > image.touchesStart.x)) {
        image.isTouched = false;
        return;
      }

      if (!swiper.isHorizontal() && (Math.floor(image.minY) === Math.floor(image.startY) && image.touchesCurrent.y < image.touchesStart.y || Math.floor(image.maxY) === Math.floor(image.startY) && image.touchesCurrent.y > image.touchesStart.y)) {
        image.isTouched = false;
        return;
      }
    }

    if (e.cancelable) {
      e.preventDefault();
    }

    e.stopPropagation();
    image.isMoved = true;
    image.currentX = image.touchesCurrent.x - image.touchesStart.x + image.startX;
    image.currentY = image.touchesCurrent.y - image.touchesStart.y + image.startY;

    if (image.currentX < image.minX) {
      image.currentX = image.minX + 1 - Math.pow(image.minX - image.currentX + 1, 0.8);
    }

    if (image.currentX > image.maxX) {
      image.currentX = image.maxX - 1 + Math.pow(image.currentX - image.maxX + 1, 0.8);
    }

    if (image.currentY < image.minY) {
      image.currentY = image.minY + 1 - Math.pow(image.minY - image.currentY + 1, 0.8);
    }

    if (image.currentY > image.maxY) {
      image.currentY = image.maxY - 1 + Math.pow(image.currentY - image.maxY + 1, 0.8);
    } // Velocity


    if (!velocity.prevPositionX) velocity.prevPositionX = image.touchesCurrent.x;
    if (!velocity.prevPositionY) velocity.prevPositionY = image.touchesCurrent.y;
    if (!velocity.prevTime) velocity.prevTime = Date.now();
    velocity.x = (image.touchesCurrent.x - velocity.prevPositionX) / (Date.now() - velocity.prevTime) / 2;
    velocity.y = (image.touchesCurrent.y - velocity.prevPositionY) / (Date.now() - velocity.prevTime) / 2;
    if (Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2) velocity.x = 0;
    if (Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2) velocity.y = 0;
    velocity.prevPositionX = image.touchesCurrent.x;
    velocity.prevPositionY = image.touchesCurrent.y;
    velocity.prevTime = Date.now();
    gesture.$imageWrapEl.transform("translate3d(".concat(image.currentX, "px, ").concat(image.currentY, "px,0)"));
  },
  onTouchEnd: function onTouchEnd() {
    var swiper = this;
    var zoom = swiper.zoom;
    var gesture = zoom.gesture,
        image = zoom.image,
        velocity = zoom.velocity;
    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;

    if (!image.isTouched || !image.isMoved) {
      image.isTouched = false;
      image.isMoved = false;
      return;
    }

    image.isTouched = false;
    image.isMoved = false;
    var momentumDurationX = 300;
    var momentumDurationY = 300;
    var momentumDistanceX = velocity.x * momentumDurationX;
    var newPositionX = image.currentX + momentumDistanceX;
    var momentumDistanceY = velocity.y * momentumDurationY;
    var newPositionY = image.currentY + momentumDistanceY; // Fix duration

    if (velocity.x !== 0) momentumDurationX = Math.abs((newPositionX - image.currentX) / velocity.x);
    if (velocity.y !== 0) momentumDurationY = Math.abs((newPositionY - image.currentY) / velocity.y);
    var momentumDuration = Math.max(momentumDurationX, momentumDurationY);
    image.currentX = newPositionX;
    image.currentY = newPositionY; // Define if we need image drag

    var scaledWidth = image.width * zoom.scale;
    var scaledHeight = image.height * zoom.scale;
    image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);
    image.maxX = -image.minX;
    image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);
    image.maxY = -image.minY;
    image.currentX = Math.max(Math.min(image.currentX, image.maxX), image.minX);
    image.currentY = Math.max(Math.min(image.currentY, image.maxY), image.minY);
    gesture.$imageWrapEl.transition(momentumDuration).transform("translate3d(".concat(image.currentX, "px, ").concat(image.currentY, "px,0)"));
  },
  onTransitionEnd: function onTransitionEnd() {
    var swiper = this;
    var zoom = swiper.zoom;
    var gesture = zoom.gesture;

    if (gesture.$slideEl && swiper.previousIndex !== swiper.activeIndex) {
      if (gesture.$imageEl) {
        gesture.$imageEl.transform('translate3d(0,0,0) scale(1)');
      }

      if (gesture.$imageWrapEl) {
        gesture.$imageWrapEl.transform('translate3d(0,0,0)');
      }

      zoom.scale = 1;
      zoom.currentScale = 1;
      gesture.$slideEl = undefined;
      gesture.$imageEl = undefined;
      gesture.$imageWrapEl = undefined;
    }
  },
  // Toggle Zoom
  toggle: function toggle(e) {
    var swiper = this;
    var zoom = swiper.zoom;

    if (zoom.scale && zoom.scale !== 1) {
      // Zoom Out
      zoom.out();
    } else {
      // Zoom In
      zoom["in"](e);
    }
  },
  "in": function _in(e) {
    var swiper = this;
    var window = ssr_window_esm_getWindow();
    var zoom = swiper.zoom;
    var params = swiper.params.zoom;
    var gesture = zoom.gesture,
        image = zoom.image;

    if (!gesture.$slideEl) {
      if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {
        gesture.$slideEl = swiper.$wrapperEl.children(".".concat(swiper.params.slideActiveClass));
      } else {
        gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
      }

      gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas, picture, .swiper-zoom-target');
      gesture.$imageWrapEl = gesture.$imageEl.parent(".".concat(params.containerClass));
    }

    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
    gesture.$slideEl.addClass("".concat(params.zoomedSlideClass));
    var touchX;
    var touchY;
    var offsetX;
    var offsetY;
    var diffX;
    var diffY;
    var translateX;
    var translateY;
    var imageWidth;
    var imageHeight;
    var scaledWidth;
    var scaledHeight;
    var translateMinX;
    var translateMinY;
    var translateMaxX;
    var translateMaxY;
    var slideWidth;
    var slideHeight;

    if (typeof image.touchesStart.x === 'undefined' && e) {
      touchX = e.type === 'touchend' ? e.changedTouches[0].pageX : e.pageX;
      touchY = e.type === 'touchend' ? e.changedTouches[0].pageY : e.pageY;
    } else {
      touchX = image.touchesStart.x;
      touchY = image.touchesStart.y;
    }

    zoom.scale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;
    zoom.currentScale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;

    if (e) {
      slideWidth = gesture.$slideEl[0].offsetWidth;
      slideHeight = gesture.$slideEl[0].offsetHeight;
      offsetX = gesture.$slideEl.offset().left + window.scrollX;
      offsetY = gesture.$slideEl.offset().top + window.scrollY;
      diffX = offsetX + slideWidth / 2 - touchX;
      diffY = offsetY + slideHeight / 2 - touchY;
      imageWidth = gesture.$imageEl[0].offsetWidth;
      imageHeight = gesture.$imageEl[0].offsetHeight;
      scaledWidth = imageWidth * zoom.scale;
      scaledHeight = imageHeight * zoom.scale;
      translateMinX = Math.min(slideWidth / 2 - scaledWidth / 2, 0);
      translateMinY = Math.min(slideHeight / 2 - scaledHeight / 2, 0);
      translateMaxX = -translateMinX;
      translateMaxY = -translateMinY;
      translateX = diffX * zoom.scale;
      translateY = diffY * zoom.scale;

      if (translateX < translateMinX) {
        translateX = translateMinX;
      }

      if (translateX > translateMaxX) {
        translateX = translateMaxX;
      }

      if (translateY < translateMinY) {
        translateY = translateMinY;
      }

      if (translateY > translateMaxY) {
        translateY = translateMaxY;
      }
    } else {
      translateX = 0;
      translateY = 0;
    }

    gesture.$imageWrapEl.transition(300).transform("translate3d(".concat(translateX, "px, ").concat(translateY, "px,0)"));
    gesture.$imageEl.transition(300).transform("translate3d(0,0,0) scale(".concat(zoom.scale, ")"));
  },
  out: function out() {
    var swiper = this;
    var zoom = swiper.zoom;
    var params = swiper.params.zoom;
    var gesture = zoom.gesture;

    if (!gesture.$slideEl) {
      if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {
        gesture.$slideEl = swiper.$wrapperEl.children(".".concat(swiper.params.slideActiveClass));
      } else {
        gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
      }

      gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas, picture, .swiper-zoom-target');
      gesture.$imageWrapEl = gesture.$imageEl.parent(".".concat(params.containerClass));
    }

    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
    zoom.scale = 1;
    zoom.currentScale = 1;
    gesture.$imageWrapEl.transition(300).transform('translate3d(0,0,0)');
    gesture.$imageEl.transition(300).transform('translate3d(0,0,0) scale(1)');
    gesture.$slideEl.removeClass("".concat(params.zoomedSlideClass));
    gesture.$slideEl = undefined;
  },
  toggleGestures: function toggleGestures(method) {
    var swiper = this;
    var zoom = swiper.zoom;
    var selector = zoom.slideSelector,
        passive = zoom.passiveListener;
    swiper.$wrapperEl[method]('gesturestart', selector, zoom.onGestureStart, passive);
    swiper.$wrapperEl[method]('gesturechange', selector, zoom.onGestureChange, passive);
    swiper.$wrapperEl[method]('gestureend', selector, zoom.onGestureEnd, passive);
  },
  enableGestures: function enableGestures() {
    if (this.zoom.gesturesEnabled) return;
    this.zoom.gesturesEnabled = true;
    this.zoom.toggleGestures('on');
  },
  disableGestures: function disableGestures() {
    if (!this.zoom.gesturesEnabled) return;
    this.zoom.gesturesEnabled = false;
    this.zoom.toggleGestures('off');
  },
  // Attach/Detach Events
  enable: function enable() {
    var swiper = this;
    var support = swiper.support;
    var zoom = swiper.zoom;
    if (zoom.enabled) return;
    zoom.enabled = true;
    var passiveListener = swiper.touchEvents.start === 'touchstart' && support.passiveListener && swiper.params.passiveListeners ? {
      passive: true,
      capture: false
    } : false;
    var activeListenerWithCapture = support.passiveListener ? {
      passive: false,
      capture: true
    } : true;
    var slideSelector = ".".concat(swiper.params.slideClass);
    swiper.zoom.passiveListener = passiveListener;
    swiper.zoom.slideSelector = slideSelector; // Scale image

    if (support.gestures) {
      swiper.$wrapperEl.on(swiper.touchEvents.start, swiper.zoom.enableGestures, passiveListener);
      swiper.$wrapperEl.on(swiper.touchEvents.end, swiper.zoom.disableGestures, passiveListener);
    } else if (swiper.touchEvents.start === 'touchstart') {
      swiper.$wrapperEl.on(swiper.touchEvents.start, slideSelector, zoom.onGestureStart, passiveListener);
      swiper.$wrapperEl.on(swiper.touchEvents.move, slideSelector, zoom.onGestureChange, activeListenerWithCapture);
      swiper.$wrapperEl.on(swiper.touchEvents.end, slideSelector, zoom.onGestureEnd, passiveListener);

      if (swiper.touchEvents.cancel) {
        swiper.$wrapperEl.on(swiper.touchEvents.cancel, slideSelector, zoom.onGestureEnd, passiveListener);
      }
    } // Move image


    swiper.$wrapperEl.on(swiper.touchEvents.move, ".".concat(swiper.params.zoom.containerClass), zoom.onTouchMove, activeListenerWithCapture);
  },
  disable: function disable() {
    var swiper = this;
    var zoom = swiper.zoom;
    if (!zoom.enabled) return;
    var support = swiper.support;
    swiper.zoom.enabled = false;
    var passiveListener = swiper.touchEvents.start === 'touchstart' && support.passiveListener && swiper.params.passiveListeners ? {
      passive: true,
      capture: false
    } : false;
    var activeListenerWithCapture = support.passiveListener ? {
      passive: false,
      capture: true
    } : true;
    var slideSelector = ".".concat(swiper.params.slideClass); // Scale image

    if (support.gestures) {
      swiper.$wrapperEl.off(swiper.touchEvents.start, swiper.zoom.enableGestures, passiveListener);
      swiper.$wrapperEl.off(swiper.touchEvents.end, swiper.zoom.disableGestures, passiveListener);
    } else if (swiper.touchEvents.start === 'touchstart') {
      swiper.$wrapperEl.off(swiper.touchEvents.start, slideSelector, zoom.onGestureStart, passiveListener);
      swiper.$wrapperEl.off(swiper.touchEvents.move, slideSelector, zoom.onGestureChange, activeListenerWithCapture);
      swiper.$wrapperEl.off(swiper.touchEvents.end, slideSelector, zoom.onGestureEnd, passiveListener);

      if (swiper.touchEvents.cancel) {
        swiper.$wrapperEl.off(swiper.touchEvents.cancel, slideSelector, zoom.onGestureEnd, passiveListener);
      }
    } // Move image


    swiper.$wrapperEl.off(swiper.touchEvents.move, ".".concat(swiper.params.zoom.containerClass), zoom.onTouchMove, activeListenerWithCapture);
  }
};
/* harmony default export */ const zoom = ({
  name: 'zoom',
  params: {
    zoom: {
      enabled: false,
      maxRatio: 3,
      minRatio: 1,
      toggle: true,
      containerClass: 'swiper-zoom-container',
      zoomedSlideClass: 'swiper-slide-zoomed'
    }
  },
  create: function create() {
    var swiper = this;
    bindModuleMethods(swiper, {
      zoom: zoom_objectSpread({
        enabled: false,
        scale: 1,
        currentScale: 1,
        isScaling: false,
        gesture: {
          $slideEl: undefined,
          slideWidth: undefined,
          slideHeight: undefined,
          $imageEl: undefined,
          $imageWrapEl: undefined,
          maxRatio: 3
        },
        image: {
          isTouched: undefined,
          isMoved: undefined,
          currentX: undefined,
          currentY: undefined,
          minX: undefined,
          minY: undefined,
          maxX: undefined,
          maxY: undefined,
          width: undefined,
          height: undefined,
          startX: undefined,
          startY: undefined,
          touchesStart: {},
          touchesCurrent: {}
        },
        velocity: {
          x: undefined,
          y: undefined,
          prevPositionX: undefined,
          prevPositionY: undefined,
          prevTime: undefined
        }
      }, Zoom)
    });
    var scale = 1;
    Object.defineProperty(swiper.zoom, 'scale', {
      get: function get() {
        return scale;
      },
      set: function set(value) {
        if (scale !== value) {
          var imageEl = swiper.zoom.gesture.$imageEl ? swiper.zoom.gesture.$imageEl[0] : undefined;
          var slideEl = swiper.zoom.gesture.$slideEl ? swiper.zoom.gesture.$slideEl[0] : undefined;
          swiper.emit('zoomChange', value, imageEl, slideEl);
        }

        scale = value;
      }
    });
  },
  on: {
    init: function init(swiper) {
      if (swiper.params.zoom.enabled) {
        swiper.zoom.enable();
      }
    },
    destroy: function destroy(swiper) {
      swiper.zoom.disable();
    },
    touchStart: function touchStart(swiper, e) {
      if (!swiper.zoom.enabled) return;
      swiper.zoom.onTouchStart(e);
    },
    touchEnd: function touchEnd(swiper, e) {
      if (!swiper.zoom.enabled) return;
      swiper.zoom.onTouchEnd(e);
    },
    doubleTap: function doubleTap(swiper, e) {
      if (!swiper.animating && swiper.params.zoom.enabled && swiper.zoom.enabled && swiper.params.zoom.toggle) {
        swiper.zoom.toggle(e);
      }
    },
    transitionEnd: function transitionEnd(swiper) {
      if (swiper.zoom.enabled && swiper.params.zoom.enabled) {
        swiper.zoom.onTransitionEnd();
      }
    },
    slideChange: function slideChange(swiper) {
      if (swiper.zoom.enabled && swiper.params.zoom.enabled && swiper.params.cssMode) {
        swiper.zoom.onTransitionEnd();
      }
    }
  }
});
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/virtual/virtual.js



function virtual_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function virtual_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? virtual_ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : virtual_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }



var Virtual = {
  update: function update(force) {
    var swiper = this;
    var _swiper$params = swiper.params,
        slidesPerView = _swiper$params.slidesPerView,
        slidesPerGroup = _swiper$params.slidesPerGroup,
        centeredSlides = _swiper$params.centeredSlides;
    var _swiper$params$virtua = swiper.params.virtual,
        addSlidesBefore = _swiper$params$virtua.addSlidesBefore,
        addSlidesAfter = _swiper$params$virtua.addSlidesAfter;
    var _swiper$virtual = swiper.virtual,
        previousFrom = _swiper$virtual.from,
        previousTo = _swiper$virtual.to,
        slides = _swiper$virtual.slides,
        previousSlidesGrid = _swiper$virtual.slidesGrid,
        renderSlide = _swiper$virtual.renderSlide,
        previousOffset = _swiper$virtual.offset;
    swiper.updateActiveIndex();
    var activeIndex = swiper.activeIndex || 0;
    var offsetProp;
    if (swiper.rtlTranslate) offsetProp = 'right';else offsetProp = swiper.isHorizontal() ? 'left' : 'top';
    var slidesAfter;
    var slidesBefore;

    if (centeredSlides) {
      slidesAfter = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesAfter;
      slidesBefore = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesBefore;
    } else {
      slidesAfter = slidesPerView + (slidesPerGroup - 1) + addSlidesAfter;
      slidesBefore = slidesPerGroup + addSlidesBefore;
    }

    var from = Math.max((activeIndex || 0) - slidesBefore, 0);
    var to = Math.min((activeIndex || 0) + slidesAfter, slides.length - 1);
    var offset = (swiper.slidesGrid[from] || 0) - (swiper.slidesGrid[0] || 0);
    utils_extend(swiper.virtual, {
      from: from,
      to: to,
      offset: offset,
      slidesGrid: swiper.slidesGrid
    });

    function onRendered() {
      swiper.updateSlides();
      swiper.updateProgress();
      swiper.updateSlidesClasses();

      if (swiper.lazy && swiper.params.lazy.enabled) {
        swiper.lazy.load();
      }
    }

    if (previousFrom === from && previousTo === to && !force) {
      if (swiper.slidesGrid !== previousSlidesGrid && offset !== previousOffset) {
        swiper.slides.css(offsetProp, "".concat(offset, "px"));
      }

      swiper.updateProgress();
      return;
    }

    if (swiper.params.virtual.renderExternal) {
      swiper.params.virtual.renderExternal.call(swiper, {
        offset: offset,
        from: from,
        to: to,
        slides: function getSlides() {
          var slidesToRender = [];

          for (var i = from; i <= to; i += 1) {
            slidesToRender.push(slides[i]);
          }

          return slidesToRender;
        }()
      });

      if (swiper.params.virtual.renderExternalUpdate) {
        onRendered();
      }

      return;
    }

    var prependIndexes = [];
    var appendIndexes = [];

    if (force) {
      swiper.$wrapperEl.find(".".concat(swiper.params.slideClass)).remove();
    } else {
      for (var i = previousFrom; i <= previousTo; i += 1) {
        if (i < from || i > to) {
          swiper.$wrapperEl.find(".".concat(swiper.params.slideClass, "[data-swiper-slide-index=\"").concat(i, "\"]")).remove();
        }
      }
    }

    for (var _i = 0; _i < slides.length; _i += 1) {
      if (_i >= from && _i <= to) {
        if (typeof previousTo === 'undefined' || force) {
          appendIndexes.push(_i);
        } else {
          if (_i > previousTo) appendIndexes.push(_i);
          if (_i < previousFrom) prependIndexes.push(_i);
        }
      }
    }

    appendIndexes.forEach(function (index) {
      swiper.$wrapperEl.append(renderSlide(slides[index], index));
    });
    prependIndexes.sort(function (a, b) {
      return b - a;
    }).forEach(function (index) {
      swiper.$wrapperEl.prepend(renderSlide(slides[index], index));
    });
    swiper.$wrapperEl.children('.swiper-slide').css(offsetProp, "".concat(offset, "px"));
    onRendered();
  },
  renderSlide: function renderSlide(slide, index) {
    var swiper = this;
    var params = swiper.params.virtual;

    if (params.cache && swiper.virtual.cache[index]) {
      return swiper.virtual.cache[index];
    }

    var $slideEl = params.renderSlide ? dom(params.renderSlide.call(swiper, slide, index)) : dom("<div class=\"".concat(swiper.params.slideClass, "\" data-swiper-slide-index=\"").concat(index, "\">").concat(slide, "</div>"));
    if (!$slideEl.attr('data-swiper-slide-index')) $slideEl.attr('data-swiper-slide-index', index);
    if (params.cache) swiper.virtual.cache[index] = $slideEl;
    return $slideEl;
  },
  appendSlide: function appendSlide(slides) {
    var swiper = this;

    if ((0,esm_typeof/* default */.Z)(slides) === 'object' && 'length' in slides) {
      for (var i = 0; i < slides.length; i += 1) {
        if (slides[i]) swiper.virtual.slides.push(slides[i]);
      }
    } else {
      swiper.virtual.slides.push(slides);
    }

    swiper.virtual.update(true);
  },
  prependSlide: function prependSlide(slides) {
    var swiper = this;
    var activeIndex = swiper.activeIndex;
    var newActiveIndex = activeIndex + 1;
    var numberOfNewSlides = 1;

    if (Array.isArray(slides)) {
      for (var i = 0; i < slides.length; i += 1) {
        if (slides[i]) swiper.virtual.slides.unshift(slides[i]);
      }

      newActiveIndex = activeIndex + slides.length;
      numberOfNewSlides = slides.length;
    } else {
      swiper.virtual.slides.unshift(slides);
    }

    if (swiper.params.virtual.cache) {
      var cache = swiper.virtual.cache;
      var newCache = {};
      Object.keys(cache).forEach(function (cachedIndex) {
        var $cachedEl = cache[cachedIndex];
        var cachedElIndex = $cachedEl.attr('data-swiper-slide-index');

        if (cachedElIndex) {
          $cachedEl.attr('data-swiper-slide-index', parseInt(cachedElIndex, 10) + 1);
        }

        newCache[parseInt(cachedIndex, 10) + numberOfNewSlides] = $cachedEl;
      });
      swiper.virtual.cache = newCache;
    }

    swiper.virtual.update(true);
    swiper.slideTo(newActiveIndex, 0);
  },
  removeSlide: function removeSlide(slidesIndexes) {
    var swiper = this;
    if (typeof slidesIndexes === 'undefined' || slidesIndexes === null) return;
    var activeIndex = swiper.activeIndex;

    if (Array.isArray(slidesIndexes)) {
      for (var i = slidesIndexes.length - 1; i >= 0; i -= 1) {
        swiper.virtual.slides.splice(slidesIndexes[i], 1);

        if (swiper.params.virtual.cache) {
          delete swiper.virtual.cache[slidesIndexes[i]];
        }

        if (slidesIndexes[i] < activeIndex) activeIndex -= 1;
        activeIndex = Math.max(activeIndex, 0);
      }
    } else {
      swiper.virtual.slides.splice(slidesIndexes, 1);

      if (swiper.params.virtual.cache) {
        delete swiper.virtual.cache[slidesIndexes];
      }

      if (slidesIndexes < activeIndex) activeIndex -= 1;
      activeIndex = Math.max(activeIndex, 0);
    }

    swiper.virtual.update(true);
    swiper.slideTo(activeIndex, 0);
  },
  removeAllSlides: function removeAllSlides() {
    var swiper = this;
    swiper.virtual.slides = [];

    if (swiper.params.virtual.cache) {
      swiper.virtual.cache = {};
    }

    swiper.virtual.update(true);
    swiper.slideTo(0, 0);
  }
};
/* harmony default export */ const virtual = ({
  name: 'virtual',
  params: {
    virtual: {
      enabled: false,
      slides: [],
      cache: true,
      renderSlide: null,
      renderExternal: null,
      renderExternalUpdate: true,
      addSlidesBefore: 0,
      addSlidesAfter: 0
    }
  },
  create: function create() {
    var swiper = this;
    bindModuleMethods(swiper, {
      virtual: virtual_objectSpread(virtual_objectSpread({}, Virtual), {}, {
        slides: swiper.params.virtual.slides,
        cache: {}
      })
    });
  },
  on: {
    beforeInit: function beforeInit(swiper) {
      if (!swiper.params.virtual.enabled) return;
      swiper.classNames.push("".concat(swiper.params.containerModifierClass, "virtual"));
      var overwriteParams = {
        watchSlidesProgress: true
      };
      utils_extend(swiper.params, overwriteParams);
      utils_extend(swiper.originalParams, overwriteParams);

      if (!swiper.params.initialSlide) {
        swiper.virtual.update();
      }
    },
    setTranslate: function setTranslate(swiper) {
      if (!swiper.params.virtual.enabled) return;
      swiper.virtual.update();
    }
  }
});
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/thumbs/thumbs.js


function thumbs_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function thumbs_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? thumbs_ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : thumbs_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }



var Thumbs = {
  init: function init() {
    var swiper = this;
    var thumbsParams = swiper.params.thumbs;
    if (swiper.thumbs.initialized) return false;
    swiper.thumbs.initialized = true;
    var SwiperClass = swiper.constructor;

    if (thumbsParams.swiper instanceof SwiperClass) {
      swiper.thumbs.swiper = thumbsParams.swiper;
      utils_extend(swiper.thumbs.swiper.originalParams, {
        watchSlidesProgress: true,
        slideToClickedSlide: false
      });
      utils_extend(swiper.thumbs.swiper.params, {
        watchSlidesProgress: true,
        slideToClickedSlide: false
      });
    } else if (utils_isObject(thumbsParams.swiper)) {
      swiper.thumbs.swiper = new SwiperClass(utils_extend({}, thumbsParams.swiper, {
        watchSlidesVisibility: true,
        watchSlidesProgress: true,
        slideToClickedSlide: false
      }));
      swiper.thumbs.swiperCreated = true;
    }

    swiper.thumbs.swiper.$el.addClass(swiper.params.thumbs.thumbsContainerClass);
    swiper.thumbs.swiper.on('tap', swiper.thumbs.onThumbClick);
    return true;
  },
  onThumbClick: function onThumbClick() {
    var swiper = this;
    var thumbsSwiper = swiper.thumbs.swiper;
    if (!thumbsSwiper) return;
    var clickedIndex = thumbsSwiper.clickedIndex;
    var clickedSlide = thumbsSwiper.clickedSlide;
    if (clickedSlide && dom(clickedSlide).hasClass(swiper.params.thumbs.slideThumbActiveClass)) return;
    if (typeof clickedIndex === 'undefined' || clickedIndex === null) return;
    var slideToIndex;

    if (thumbsSwiper.params.loop) {
      slideToIndex = parseInt(dom(thumbsSwiper.clickedSlide).attr('data-swiper-slide-index'), 10);
    } else {
      slideToIndex = clickedIndex;
    }

    if (swiper.params.loop) {
      var currentIndex = swiper.activeIndex;

      if (swiper.slides.eq(currentIndex).hasClass(swiper.params.slideDuplicateClass)) {
        swiper.loopFix(); // eslint-disable-next-line

        swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
        currentIndex = swiper.activeIndex;
      }

      var prevIndex = swiper.slides.eq(currentIndex).prevAll("[data-swiper-slide-index=\"".concat(slideToIndex, "\"]")).eq(0).index();
      var nextIndex = swiper.slides.eq(currentIndex).nextAll("[data-swiper-slide-index=\"".concat(slideToIndex, "\"]")).eq(0).index();
      if (typeof prevIndex === 'undefined') slideToIndex = nextIndex;else if (typeof nextIndex === 'undefined') slideToIndex = prevIndex;else if (nextIndex - currentIndex < currentIndex - prevIndex) slideToIndex = nextIndex;else slideToIndex = prevIndex;
    }

    swiper.slideTo(slideToIndex);
  },
  update: function update(initial) {
    var swiper = this;
    var thumbsSwiper = swiper.thumbs.swiper;
    if (!thumbsSwiper) return;
    var slidesPerView = thumbsSwiper.params.slidesPerView === 'auto' ? thumbsSwiper.slidesPerViewDynamic() : thumbsSwiper.params.slidesPerView;
    var autoScrollOffset = swiper.params.thumbs.autoScrollOffset;
    var useOffset = autoScrollOffset && !thumbsSwiper.params.loop;

    if (swiper.realIndex !== thumbsSwiper.realIndex || useOffset) {
      var currentThumbsIndex = thumbsSwiper.activeIndex;
      var newThumbsIndex;
      var direction;

      if (thumbsSwiper.params.loop) {
        if (thumbsSwiper.slides.eq(currentThumbsIndex).hasClass(thumbsSwiper.params.slideDuplicateClass)) {
          thumbsSwiper.loopFix(); // eslint-disable-next-line

          thumbsSwiper._clientLeft = thumbsSwiper.$wrapperEl[0].clientLeft;
          currentThumbsIndex = thumbsSwiper.activeIndex;
        } // Find actual thumbs index to slide to


        var prevThumbsIndex = thumbsSwiper.slides.eq(currentThumbsIndex).prevAll("[data-swiper-slide-index=\"".concat(swiper.realIndex, "\"]")).eq(0).index();
        var nextThumbsIndex = thumbsSwiper.slides.eq(currentThumbsIndex).nextAll("[data-swiper-slide-index=\"".concat(swiper.realIndex, "\"]")).eq(0).index();
        if (typeof prevThumbsIndex === 'undefined') newThumbsIndex = nextThumbsIndex;else if (typeof nextThumbsIndex === 'undefined') newThumbsIndex = prevThumbsIndex;else if (nextThumbsIndex - currentThumbsIndex === currentThumbsIndex - prevThumbsIndex) newThumbsIndex = currentThumbsIndex;else if (nextThumbsIndex - currentThumbsIndex < currentThumbsIndex - prevThumbsIndex) newThumbsIndex = nextThumbsIndex;else newThumbsIndex = prevThumbsIndex;
        direction = swiper.activeIndex > swiper.previousIndex ? 'next' : 'prev';
      } else {
        newThumbsIndex = swiper.realIndex;
        direction = newThumbsIndex > swiper.previousIndex ? 'next' : 'prev';
      }

      if (useOffset) {
        newThumbsIndex += direction === 'next' ? autoScrollOffset : -1 * autoScrollOffset;
      }

      if (thumbsSwiper.visibleSlidesIndexes && thumbsSwiper.visibleSlidesIndexes.indexOf(newThumbsIndex) < 0) {
        if (thumbsSwiper.params.centeredSlides) {
          if (newThumbsIndex > currentThumbsIndex) {
            newThumbsIndex = newThumbsIndex - Math.floor(slidesPerView / 2) + 1;
          } else {
            newThumbsIndex = newThumbsIndex + Math.floor(slidesPerView / 2) - 1;
          }
        } else if (newThumbsIndex > currentThumbsIndex) {
          newThumbsIndex = newThumbsIndex - slidesPerView + 1;
        }

        thumbsSwiper.slideTo(newThumbsIndex, initial ? 0 : undefined);
      }
    } // Activate thumbs


    var thumbsToActivate = 1;
    var thumbActiveClass = swiper.params.thumbs.slideThumbActiveClass;

    if (swiper.params.slidesPerView > 1 && !swiper.params.centeredSlides) {
      thumbsToActivate = swiper.params.slidesPerView;
    }

    if (!swiper.params.thumbs.multipleActiveThumbs) {
      thumbsToActivate = 1;
    }

    thumbsToActivate = Math.floor(thumbsToActivate);
    thumbsSwiper.slides.removeClass(thumbActiveClass);

    if (thumbsSwiper.params.loop || thumbsSwiper.params.virtual && thumbsSwiper.params.virtual.enabled) {
      for (var i = 0; i < thumbsToActivate; i += 1) {
        thumbsSwiper.$wrapperEl.children("[data-swiper-slide-index=\"".concat(swiper.realIndex + i, "\"]")).addClass(thumbActiveClass);
      }
    } else {
      for (var _i = 0; _i < thumbsToActivate; _i += 1) {
        thumbsSwiper.slides.eq(swiper.realIndex + _i).addClass(thumbActiveClass);
      }
    }
  }
};
/* harmony default export */ const thumbs = ({
  name: 'thumbs',
  params: {
    thumbs: {
      swiper: null,
      multipleActiveThumbs: true,
      autoScrollOffset: 0,
      slideThumbActiveClass: 'swiper-slide-thumb-active',
      thumbsContainerClass: 'swiper-container-thumbs'
    }
  },
  create: function create() {
    var swiper = this;
    bindModuleMethods(swiper, {
      thumbs: thumbs_objectSpread({
        swiper: null,
        initialized: false
      }, Thumbs)
    });
  },
  on: {
    beforeInit: function beforeInit(swiper) {
      var thumbs = swiper.params.thumbs;
      if (!thumbs || !thumbs.swiper) return;
      swiper.thumbs.init();
      swiper.thumbs.update(true);
    },
    slideChange: function slideChange(swiper) {
      if (!swiper.thumbs.swiper) return;
      swiper.thumbs.update();
    },
    update: function update(swiper) {
      if (!swiper.thumbs.swiper) return;
      swiper.thumbs.update();
    },
    resize: function resize(swiper) {
      if (!swiper.thumbs.swiper) return;
      swiper.thumbs.update();
    },
    observerUpdate: function observerUpdate(swiper) {
      if (!swiper.thumbs.swiper) return;
      swiper.thumbs.update();
    },
    setTransition: function setTransition(swiper, duration) {
      var thumbsSwiper = swiper.thumbs.swiper;
      if (!thumbsSwiper) return;
      thumbsSwiper.setTransition(duration);
    },
    beforeDestroy: function beforeDestroy(swiper) {
      var thumbsSwiper = swiper.thumbs.swiper;
      if (!thumbsSwiper) return;

      if (swiper.thumbs.swiperCreated && thumbsSwiper) {
        thumbsSwiper.destroy();
      }
    }
  }
});
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/scrollbar/scrollbar.js


function scrollbar_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function scrollbar_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? scrollbar_ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : scrollbar_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }




var Scrollbar = {
  setTranslate: function setTranslate() {
    var swiper = this;
    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
    var scrollbar = swiper.scrollbar,
        rtl = swiper.rtlTranslate,
        progress = swiper.progress;
    var dragSize = scrollbar.dragSize,
        trackSize = scrollbar.trackSize,
        $dragEl = scrollbar.$dragEl,
        $el = scrollbar.$el;
    var params = swiper.params.scrollbar;
    var newSize = dragSize;
    var newPos = (trackSize - dragSize) * progress;

    if (rtl) {
      newPos = -newPos;

      if (newPos > 0) {
        newSize = dragSize - newPos;
        newPos = 0;
      } else if (-newPos + dragSize > trackSize) {
        newSize = trackSize + newPos;
      }
    } else if (newPos < 0) {
      newSize = dragSize + newPos;
      newPos = 0;
    } else if (newPos + dragSize > trackSize) {
      newSize = trackSize - newPos;
    }

    if (swiper.isHorizontal()) {
      $dragEl.transform("translate3d(".concat(newPos, "px, 0, 0)"));
      $dragEl[0].style.width = "".concat(newSize, "px");
    } else {
      $dragEl.transform("translate3d(0px, ".concat(newPos, "px, 0)"));
      $dragEl[0].style.height = "".concat(newSize, "px");
    }

    if (params.hide) {
      clearTimeout(swiper.scrollbar.timeout);
      $el[0].style.opacity = 1;
      swiper.scrollbar.timeout = setTimeout(function () {
        $el[0].style.opacity = 0;
        $el.transition(400);
      }, 1000);
    }
  },
  setTransition: function setTransition(duration) {
    var swiper = this;
    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
    swiper.scrollbar.$dragEl.transition(duration);
  },
  updateSize: function updateSize() {
    var swiper = this;
    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
    var scrollbar = swiper.scrollbar;
    var $dragEl = scrollbar.$dragEl,
        $el = scrollbar.$el;
    $dragEl[0].style.width = '';
    $dragEl[0].style.height = '';
    var trackSize = swiper.isHorizontal() ? $el[0].offsetWidth : $el[0].offsetHeight;
    var divider = swiper.size / swiper.virtualSize;
    var moveDivider = divider * (trackSize / swiper.size);
    var dragSize;

    if (swiper.params.scrollbar.dragSize === 'auto') {
      dragSize = trackSize * divider;
    } else {
      dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);
    }

    if (swiper.isHorizontal()) {
      $dragEl[0].style.width = "".concat(dragSize, "px");
    } else {
      $dragEl[0].style.height = "".concat(dragSize, "px");
    }

    if (divider >= 1) {
      $el[0].style.display = 'none';
    } else {
      $el[0].style.display = '';
    }

    if (swiper.params.scrollbar.hide) {
      $el[0].style.opacity = 0;
    }

    utils_extend(scrollbar, {
      trackSize: trackSize,
      divider: divider,
      moveDivider: moveDivider,
      dragSize: dragSize
    });
    scrollbar.$el[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](swiper.params.scrollbar.lockClass);
  },
  getPointerPosition: function getPointerPosition(e) {
    var swiper = this;

    if (swiper.isHorizontal()) {
      return e.type === 'touchstart' || e.type === 'touchmove' ? e.targetTouches[0].clientX : e.clientX;
    }

    return e.type === 'touchstart' || e.type === 'touchmove' ? e.targetTouches[0].clientY : e.clientY;
  },
  setDragPosition: function setDragPosition(e) {
    var swiper = this;
    var scrollbar = swiper.scrollbar,
        rtl = swiper.rtlTranslate;
    var $el = scrollbar.$el,
        dragSize = scrollbar.dragSize,
        trackSize = scrollbar.trackSize,
        dragStartPos = scrollbar.dragStartPos;
    var positionRatio;
    positionRatio = (scrollbar.getPointerPosition(e) - $el.offset()[swiper.isHorizontal() ? 'left' : 'top'] - (dragStartPos !== null ? dragStartPos : dragSize / 2)) / (trackSize - dragSize);
    positionRatio = Math.max(Math.min(positionRatio, 1), 0);

    if (rtl) {
      positionRatio = 1 - positionRatio;
    }

    var position = swiper.minTranslate() + (swiper.maxTranslate() - swiper.minTranslate()) * positionRatio;
    swiper.updateProgress(position);
    swiper.setTranslate(position);
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
  },
  onDragStart: function onDragStart(e) {
    var swiper = this;
    var params = swiper.params.scrollbar;
    var scrollbar = swiper.scrollbar,
        $wrapperEl = swiper.$wrapperEl;
    var $el = scrollbar.$el,
        $dragEl = scrollbar.$dragEl;
    swiper.scrollbar.isTouched = true;
    swiper.scrollbar.dragStartPos = e.target === $dragEl[0] || e.target === $dragEl ? scrollbar.getPointerPosition(e) - e.target.getBoundingClientRect()[swiper.isHorizontal() ? 'left' : 'top'] : null;
    e.preventDefault();
    e.stopPropagation();
    $wrapperEl.transition(100);
    $dragEl.transition(100);
    scrollbar.setDragPosition(e);
    clearTimeout(swiper.scrollbar.dragTimeout);
    $el.transition(0);

    if (params.hide) {
      $el.css('opacity', 1);
    }

    if (swiper.params.cssMode) {
      swiper.$wrapperEl.css('scroll-snap-type', 'none');
    }

    swiper.emit('scrollbarDragStart', e);
  },
  onDragMove: function onDragMove(e) {
    var swiper = this;
    var scrollbar = swiper.scrollbar,
        $wrapperEl = swiper.$wrapperEl;
    var $el = scrollbar.$el,
        $dragEl = scrollbar.$dragEl;
    if (!swiper.scrollbar.isTouched) return;
    if (e.preventDefault) e.preventDefault();else e.returnValue = false;
    scrollbar.setDragPosition(e);
    $wrapperEl.transition(0);
    $el.transition(0);
    $dragEl.transition(0);
    swiper.emit('scrollbarDragMove', e);
  },
  onDragEnd: function onDragEnd(e) {
    var swiper = this;
    var params = swiper.params.scrollbar;
    var scrollbar = swiper.scrollbar,
        $wrapperEl = swiper.$wrapperEl;
    var $el = scrollbar.$el;
    if (!swiper.scrollbar.isTouched) return;
    swiper.scrollbar.isTouched = false;

    if (swiper.params.cssMode) {
      swiper.$wrapperEl.css('scroll-snap-type', '');
      $wrapperEl.transition('');
    }

    if (params.hide) {
      clearTimeout(swiper.scrollbar.dragTimeout);
      swiper.scrollbar.dragTimeout = nextTick(function () {
        $el.css('opacity', 0);
        $el.transition(400);
      }, 1000);
    }

    swiper.emit('scrollbarDragEnd', e);

    if (params.snapOnRelease) {
      swiper.slideToClosest();
    }
  },
  enableDraggable: function enableDraggable() {
    var swiper = this;
    if (!swiper.params.scrollbar.el) return;
    var document = getDocument();
    var scrollbar = swiper.scrollbar,
        touchEventsTouch = swiper.touchEventsTouch,
        touchEventsDesktop = swiper.touchEventsDesktop,
        params = swiper.params,
        support = swiper.support;
    var $el = scrollbar.$el;
    var target = $el[0];
    var activeListener = support.passiveListener && params.passiveListeners ? {
      passive: false,
      capture: false
    } : false;
    var passiveListener = support.passiveListener && params.passiveListeners ? {
      passive: true,
      capture: false
    } : false;
    if (!target) return;

    if (!support.touch) {
      target.addEventListener(touchEventsDesktop.start, swiper.scrollbar.onDragStart, activeListener);
      document.addEventListener(touchEventsDesktop.move, swiper.scrollbar.onDragMove, activeListener);
      document.addEventListener(touchEventsDesktop.end, swiper.scrollbar.onDragEnd, passiveListener);
    } else {
      target.addEventListener(touchEventsTouch.start, swiper.scrollbar.onDragStart, activeListener);
      target.addEventListener(touchEventsTouch.move, swiper.scrollbar.onDragMove, activeListener);
      target.addEventListener(touchEventsTouch.end, swiper.scrollbar.onDragEnd, passiveListener);
    }
  },
  disableDraggable: function disableDraggable() {
    var swiper = this;
    if (!swiper.params.scrollbar.el) return;
    var document = getDocument();
    var scrollbar = swiper.scrollbar,
        touchEventsTouch = swiper.touchEventsTouch,
        touchEventsDesktop = swiper.touchEventsDesktop,
        params = swiper.params,
        support = swiper.support;
    var $el = scrollbar.$el;
    var target = $el[0];
    var activeListener = support.passiveListener && params.passiveListeners ? {
      passive: false,
      capture: false
    } : false;
    var passiveListener = support.passiveListener && params.passiveListeners ? {
      passive: true,
      capture: false
    } : false;
    if (!target) return;

    if (!support.touch) {
      target.removeEventListener(touchEventsDesktop.start, swiper.scrollbar.onDragStart, activeListener);
      document.removeEventListener(touchEventsDesktop.move, swiper.scrollbar.onDragMove, activeListener);
      document.removeEventListener(touchEventsDesktop.end, swiper.scrollbar.onDragEnd, passiveListener);
    } else {
      target.removeEventListener(touchEventsTouch.start, swiper.scrollbar.onDragStart, activeListener);
      target.removeEventListener(touchEventsTouch.move, swiper.scrollbar.onDragMove, activeListener);
      target.removeEventListener(touchEventsTouch.end, swiper.scrollbar.onDragEnd, passiveListener);
    }
  },
  init: function init() {
    var swiper = this;
    if (!swiper.params.scrollbar.el) return;
    var scrollbar = swiper.scrollbar,
        $swiperEl = swiper.$el;
    var params = swiper.params.scrollbar;
    var $el = dom(params.el);

    if (swiper.params.uniqueNavElements && typeof params.el === 'string' && $el.length > 1 && $swiperEl.find(params.el).length === 1) {
      $el = $swiperEl.find(params.el);
    }

    var $dragEl = $el.find(".".concat(swiper.params.scrollbar.dragClass));

    if ($dragEl.length === 0) {
      $dragEl = dom("<div class=\"".concat(swiper.params.scrollbar.dragClass, "\"></div>"));
      $el.append($dragEl);
    }

    utils_extend(scrollbar, {
      $el: $el,
      el: $el[0],
      $dragEl: $dragEl,
      dragEl: $dragEl[0]
    });

    if (params.draggable) {
      scrollbar.enableDraggable();
    }
  },
  destroy: function destroy() {
    var swiper = this;
    swiper.scrollbar.disableDraggable();
  }
};
/* harmony default export */ const scrollbar = ({
  name: 'scrollbar',
  params: {
    scrollbar: {
      el: null,
      dragSize: 'auto',
      hide: false,
      draggable: false,
      snapOnRelease: true,
      lockClass: 'swiper-scrollbar-lock',
      dragClass: 'swiper-scrollbar-drag'
    }
  },
  create: function create() {
    var swiper = this;
    bindModuleMethods(swiper, {
      scrollbar: scrollbar_objectSpread({
        isTouched: false,
        timeout: null,
        dragTimeout: null
      }, Scrollbar)
    });
  },
  on: {
    init: function init(swiper) {
      swiper.scrollbar.init();
      swiper.scrollbar.updateSize();
      swiper.scrollbar.setTranslate();
    },
    update: function update(swiper) {
      swiper.scrollbar.updateSize();
    },
    resize: function resize(swiper) {
      swiper.scrollbar.updateSize();
    },
    observerUpdate: function observerUpdate(swiper) {
      swiper.scrollbar.updateSize();
    },
    setTranslate: function setTranslate(swiper) {
      swiper.scrollbar.setTranslate();
    },
    setTransition: function setTransition(swiper, duration) {
      swiper.scrollbar.setTransition(duration);
    },
    destroy: function destroy(swiper) {
      swiper.scrollbar.destroy();
    }
  }
});
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/parallax/parallax.js


function parallax_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function parallax_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? parallax_ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : parallax_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }



var Parallax = {
  setTransform: function setTransform(el, progress) {
    var swiper = this;
    var rtl = swiper.rtl;
    var $el = dom(el);
    var rtlFactor = rtl ? -1 : 1;
    var p = $el.attr('data-swiper-parallax') || '0';
    var x = $el.attr('data-swiper-parallax-x');
    var y = $el.attr('data-swiper-parallax-y');
    var scale = $el.attr('data-swiper-parallax-scale');
    var opacity = $el.attr('data-swiper-parallax-opacity');

    if (x || y) {
      x = x || '0';
      y = y || '0';
    } else if (swiper.isHorizontal()) {
      x = p;
      y = '0';
    } else {
      y = p;
      x = '0';
    }

    if (x.indexOf('%') >= 0) {
      x = "".concat(parseInt(x, 10) * progress * rtlFactor, "%");
    } else {
      x = "".concat(x * progress * rtlFactor, "px");
    }

    if (y.indexOf('%') >= 0) {
      y = "".concat(parseInt(y, 10) * progress, "%");
    } else {
      y = "".concat(y * progress, "px");
    }

    if (typeof opacity !== 'undefined' && opacity !== null) {
      var currentOpacity = opacity - (opacity - 1) * (1 - Math.abs(progress));
      $el[0].style.opacity = currentOpacity;
    }

    if (typeof scale === 'undefined' || scale === null) {
      $el.transform("translate3d(".concat(x, ", ").concat(y, ", 0px)"));
    } else {
      var currentScale = scale - (scale - 1) * (1 - Math.abs(progress));
      $el.transform("translate3d(".concat(x, ", ").concat(y, ", 0px) scale(").concat(currentScale, ")"));
    }
  },
  setTranslate: function setTranslate() {
    var swiper = this;
    var $el = swiper.$el,
        slides = swiper.slides,
        progress = swiper.progress,
        snapGrid = swiper.snapGrid;
    $el.children('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]').each(function (el) {
      swiper.parallax.setTransform(el, progress);
    });
    slides.each(function (slideEl, slideIndex) {
      var slideProgress = slideEl.progress;

      if (swiper.params.slidesPerGroup > 1 && swiper.params.slidesPerView !== 'auto') {
        slideProgress += Math.ceil(slideIndex / 2) - progress * (snapGrid.length - 1);
      }

      slideProgress = Math.min(Math.max(slideProgress, -1), 1);
      dom(slideEl).find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]').each(function (el) {
        swiper.parallax.setTransform(el, slideProgress);
      });
    });
  },
  setTransition: function setTransition() {
    var duration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.params.speed;
    var swiper = this;
    var $el = swiper.$el;
    $el.find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]').each(function (parallaxEl) {
      var $parallaxEl = dom(parallaxEl);
      var parallaxDuration = parseInt($parallaxEl.attr('data-swiper-parallax-duration'), 10) || duration;
      if (duration === 0) parallaxDuration = 0;
      $parallaxEl.transition(parallaxDuration);
    });
  }
};
/* harmony default export */ const parallax = ({
  name: 'parallax',
  params: {
    parallax: {
      enabled: false
    }
  },
  create: function create() {
    var swiper = this;
    bindModuleMethods(swiper, {
      parallax: parallax_objectSpread({}, Parallax)
    });
  },
  on: {
    beforeInit: function beforeInit(swiper) {
      if (!swiper.params.parallax.enabled) return;
      swiper.params.watchSlidesProgress = true;
      swiper.originalParams.watchSlidesProgress = true;
    },
    init: function init(swiper) {
      if (!swiper.params.parallax.enabled) return;
      swiper.parallax.setTranslate();
    },
    setTranslate: function setTranslate(swiper) {
      if (!swiper.params.parallax.enabled) return;
      swiper.parallax.setTranslate();
    },
    setTransition: function setTransition(swiper, duration) {
      if (!swiper.params.parallax.enabled) return;
      swiper.parallax.setTransition(duration);
    }
  }
});
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/pagination/pagination.js


function pagination_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function pagination_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? pagination_ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : pagination_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }



var Pagination = {
  update: function update() {
    // Render || Update Pagination bullets/items
    var swiper = this;
    var rtl = swiper.rtl;
    var params = swiper.params.pagination;
    if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) return;
    var slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
    var $el = swiper.pagination.$el; // Current/Total

    var current;
    var total = swiper.params.loop ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;

    if (swiper.params.loop) {
      current = Math.ceil((swiper.activeIndex - swiper.loopedSlides) / swiper.params.slidesPerGroup);

      if (current > slidesLength - 1 - swiper.loopedSlides * 2) {
        current -= slidesLength - swiper.loopedSlides * 2;
      }

      if (current > total - 1) current -= total;
      if (current < 0 && swiper.params.paginationType !== 'bullets') current = total + current;
    } else if (typeof swiper.snapIndex !== 'undefined') {
      current = swiper.snapIndex;
    } else {
      current = swiper.activeIndex || 0;
    } // Types


    if (params.type === 'bullets' && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {
      var bullets = swiper.pagination.bullets;
      var firstIndex;
      var lastIndex;
      var midIndex;

      if (params.dynamicBullets) {
        swiper.pagination.bulletSize = bullets.eq(0)[swiper.isHorizontal() ? 'outerWidth' : 'outerHeight'](true);
        $el.css(swiper.isHorizontal() ? 'width' : 'height', "".concat(swiper.pagination.bulletSize * (params.dynamicMainBullets + 4), "px"));

        if (params.dynamicMainBullets > 1 && swiper.previousIndex !== undefined) {
          swiper.pagination.dynamicBulletIndex += current - swiper.previousIndex;

          if (swiper.pagination.dynamicBulletIndex > params.dynamicMainBullets - 1) {
            swiper.pagination.dynamicBulletIndex = params.dynamicMainBullets - 1;
          } else if (swiper.pagination.dynamicBulletIndex < 0) {
            swiper.pagination.dynamicBulletIndex = 0;
          }
        }

        firstIndex = current - swiper.pagination.dynamicBulletIndex;
        lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);
        midIndex = (lastIndex + firstIndex) / 2;
      }

      bullets.removeClass("".concat(params.bulletActiveClass, " ").concat(params.bulletActiveClass, "-next ").concat(params.bulletActiveClass, "-next-next ").concat(params.bulletActiveClass, "-prev ").concat(params.bulletActiveClass, "-prev-prev ").concat(params.bulletActiveClass, "-main"));

      if ($el.length > 1) {
        bullets.each(function (bullet) {
          var $bullet = dom(bullet);
          var bulletIndex = $bullet.index();

          if (bulletIndex === current) {
            $bullet.addClass(params.bulletActiveClass);
          }

          if (params.dynamicBullets) {
            if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {
              $bullet.addClass("".concat(params.bulletActiveClass, "-main"));
            }

            if (bulletIndex === firstIndex) {
              $bullet.prev().addClass("".concat(params.bulletActiveClass, "-prev")).prev().addClass("".concat(params.bulletActiveClass, "-prev-prev"));
            }

            if (bulletIndex === lastIndex) {
              $bullet.next().addClass("".concat(params.bulletActiveClass, "-next")).next().addClass("".concat(params.bulletActiveClass, "-next-next"));
            }
          }
        });
      } else {
        var $bullet = bullets.eq(current);
        var bulletIndex = $bullet.index();
        $bullet.addClass(params.bulletActiveClass);

        if (params.dynamicBullets) {
          var $firstDisplayedBullet = bullets.eq(firstIndex);
          var $lastDisplayedBullet = bullets.eq(lastIndex);

          for (var i = firstIndex; i <= lastIndex; i += 1) {
            bullets.eq(i).addClass("".concat(params.bulletActiveClass, "-main"));
          }

          if (swiper.params.loop) {
            if (bulletIndex >= bullets.length - params.dynamicMainBullets) {
              for (var _i = params.dynamicMainBullets; _i >= 0; _i -= 1) {
                bullets.eq(bullets.length - _i).addClass("".concat(params.bulletActiveClass, "-main"));
              }

              bullets.eq(bullets.length - params.dynamicMainBullets - 1).addClass("".concat(params.bulletActiveClass, "-prev"));
            } else {
              $firstDisplayedBullet.prev().addClass("".concat(params.bulletActiveClass, "-prev")).prev().addClass("".concat(params.bulletActiveClass, "-prev-prev"));
              $lastDisplayedBullet.next().addClass("".concat(params.bulletActiveClass, "-next")).next().addClass("".concat(params.bulletActiveClass, "-next-next"));
            }
          } else {
            $firstDisplayedBullet.prev().addClass("".concat(params.bulletActiveClass, "-prev")).prev().addClass("".concat(params.bulletActiveClass, "-prev-prev"));
            $lastDisplayedBullet.next().addClass("".concat(params.bulletActiveClass, "-next")).next().addClass("".concat(params.bulletActiveClass, "-next-next"));
          }
        }
      }

      if (params.dynamicBullets) {
        var dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);
        var bulletsOffset = (swiper.pagination.bulletSize * dynamicBulletsLength - swiper.pagination.bulletSize) / 2 - midIndex * swiper.pagination.bulletSize;
        var offsetProp = rtl ? 'right' : 'left';
        bullets.css(swiper.isHorizontal() ? offsetProp : 'top', "".concat(bulletsOffset, "px"));
      }
    }

    if (params.type === 'fraction') {
      $el.find(classesToSelector(params.currentClass)).text(params.formatFractionCurrent(current + 1));
      $el.find(classesToSelector(params.totalClass)).text(params.formatFractionTotal(total));
    }

    if (params.type === 'progressbar') {
      var progressbarDirection;

      if (params.progressbarOpposite) {
        progressbarDirection = swiper.isHorizontal() ? 'vertical' : 'horizontal';
      } else {
        progressbarDirection = swiper.isHorizontal() ? 'horizontal' : 'vertical';
      }

      var scale = (current + 1) / total;
      var scaleX = 1;
      var scaleY = 1;

      if (progressbarDirection === 'horizontal') {
        scaleX = scale;
      } else {
        scaleY = scale;
      }

      $el.find(classesToSelector(params.progressbarFillClass)).transform("translate3d(0,0,0) scaleX(".concat(scaleX, ") scaleY(").concat(scaleY, ")")).transition(swiper.params.speed);
    }

    if (params.type === 'custom' && params.renderCustom) {
      $el.html(params.renderCustom(swiper, current + 1, total));
      swiper.emit('paginationRender', $el[0]);
    } else {
      swiper.emit('paginationUpdate', $el[0]);
    }

    $el[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
  },
  render: function render() {
    // Render Container
    var swiper = this;
    var params = swiper.params.pagination;
    if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) return;
    var slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
    var $el = swiper.pagination.$el;
    var paginationHTML = '';

    if (params.type === 'bullets') {
      var numberOfBullets = swiper.params.loop ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;

      if (swiper.params.freeMode && !swiper.params.loop && numberOfBullets > slidesLength) {
        numberOfBullets = slidesLength;
      }

      for (var i = 0; i < numberOfBullets; i += 1) {
        if (params.renderBullet) {
          paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);
        } else {
          paginationHTML += "<".concat(params.bulletElement, " class=\"").concat(params.bulletClass, "\"></").concat(params.bulletElement, ">");
        }
      }

      $el.html(paginationHTML);
      swiper.pagination.bullets = $el.find(classesToSelector(params.bulletClass));
    }

    if (params.type === 'fraction') {
      if (params.renderFraction) {
        paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);
      } else {
        paginationHTML = "<span class=\"".concat(params.currentClass, "\"></span>") + ' / ' + "<span class=\"".concat(params.totalClass, "\"></span>");
      }

      $el.html(paginationHTML);
    }

    if (params.type === 'progressbar') {
      if (params.renderProgressbar) {
        paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);
      } else {
        paginationHTML = "<span class=\"".concat(params.progressbarFillClass, "\"></span>");
      }

      $el.html(paginationHTML);
    }

    if (params.type !== 'custom') {
      swiper.emit('paginationRender', swiper.pagination.$el[0]);
    }
  },
  init: function init() {
    var swiper = this;
    var params = swiper.params.pagination;
    if (!params.el) return;
    var $el = dom(params.el);
    if ($el.length === 0) return;

    if (swiper.params.uniqueNavElements && typeof params.el === 'string' && $el.length > 1) {
      $el = swiper.$el.find(params.el);
    }

    if (params.type === 'bullets' && params.clickable) {
      $el.addClass(params.clickableClass);
    }

    $el.addClass(params.modifierClass + params.type);

    if (params.type === 'bullets' && params.dynamicBullets) {
      $el.addClass("".concat(params.modifierClass).concat(params.type, "-dynamic"));
      swiper.pagination.dynamicBulletIndex = 0;

      if (params.dynamicMainBullets < 1) {
        params.dynamicMainBullets = 1;
      }
    }

    if (params.type === 'progressbar' && params.progressbarOpposite) {
      $el.addClass(params.progressbarOppositeClass);
    }

    if (params.clickable) {
      $el.on('click', classesToSelector(params.bulletClass), function onClick(e) {
        e.preventDefault();
        var index = dom(this).index() * swiper.params.slidesPerGroup;
        if (swiper.params.loop) index += swiper.loopedSlides;
        swiper.slideTo(index);
      });
    }

    utils_extend(swiper.pagination, {
      $el: $el,
      el: $el[0]
    });
  },
  destroy: function destroy() {
    var swiper = this;
    var params = swiper.params.pagination;
    if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) return;
    var $el = swiper.pagination.$el;
    $el.removeClass(params.hiddenClass);
    $el.removeClass(params.modifierClass + params.type);
    if (swiper.pagination.bullets) swiper.pagination.bullets.removeClass(params.bulletActiveClass);

    if (params.clickable) {
      $el.off('click', classesToSelector(params.bulletClass));
    }
  }
};
/* harmony default export */ const pagination = ({
  name: 'pagination',
  params: {
    pagination: {
      el: null,
      bulletElement: 'span',
      clickable: false,
      hideOnClick: false,
      renderBullet: null,
      renderProgressbar: null,
      renderFraction: null,
      renderCustom: null,
      progressbarOpposite: false,
      type: 'bullets',
      // 'bullets' or 'progressbar' or 'fraction' or 'custom'
      dynamicBullets: false,
      dynamicMainBullets: 1,
      formatFractionCurrent: function formatFractionCurrent(number) {
        return number;
      },
      formatFractionTotal: function formatFractionTotal(number) {
        return number;
      },
      bulletClass: 'swiper-pagination-bullet',
      bulletActiveClass: 'swiper-pagination-bullet-active',
      modifierClass: 'swiper-pagination-',
      // NEW
      currentClass: 'swiper-pagination-current',
      totalClass: 'swiper-pagination-total',
      hiddenClass: 'swiper-pagination-hidden',
      progressbarFillClass: 'swiper-pagination-progressbar-fill',
      progressbarOppositeClass: 'swiper-pagination-progressbar-opposite',
      clickableClass: 'swiper-pagination-clickable',
      // NEW
      lockClass: 'swiper-pagination-lock'
    }
  },
  create: function create() {
    var swiper = this;
    bindModuleMethods(swiper, {
      pagination: pagination_objectSpread({
        dynamicBulletIndex: 0
      }, Pagination)
    });
  },
  on: {
    init: function init(swiper) {
      swiper.pagination.init();
      swiper.pagination.render();
      swiper.pagination.update();
    },
    activeIndexChange: function activeIndexChange(swiper) {
      if (swiper.params.loop) {
        swiper.pagination.update();
      } else if (typeof swiper.snapIndex === 'undefined') {
        swiper.pagination.update();
      }
    },
    snapIndexChange: function snapIndexChange(swiper) {
      if (!swiper.params.loop) {
        swiper.pagination.update();
      }
    },
    slidesLengthChange: function slidesLengthChange(swiper) {
      if (swiper.params.loop) {
        swiper.pagination.render();
        swiper.pagination.update();
      }
    },
    snapGridLengthChange: function snapGridLengthChange(swiper) {
      if (!swiper.params.loop) {
        swiper.pagination.render();
        swiper.pagination.update();
      }
    },
    destroy: function destroy(swiper) {
      swiper.pagination.destroy();
    },
    click: function click(swiper, e) {
      var targetEl = e.target;

      if (swiper.params.pagination.el && swiper.params.pagination.hideOnClick && swiper.pagination.$el.length > 0 && !dom(targetEl).hasClass(swiper.params.pagination.bulletClass)) {
        if (swiper.navigation && (swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl || swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl)) return;
        var isHidden = swiper.pagination.$el.hasClass(swiper.params.pagination.hiddenClass);

        if (isHidden === true) {
          swiper.emit('paginationShow');
        } else {
          swiper.emit('paginationHide');
        }

        swiper.pagination.$el.toggleClass(swiper.params.pagination.hiddenClass);
      }
    }
  }
});
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/navigation/navigation.js


function navigation_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function navigation_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? navigation_ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : navigation_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }



var Navigation = {
  toggleEl: function toggleEl($el, disabled) {
    $el[disabled ? 'addClass' : 'removeClass'](this.params.navigation.disabledClass);
    if ($el[0] && $el[0].tagName === 'BUTTON') $el[0].disabled = disabled;
  },
  update: function update() {
    // Update Navigation Buttons
    var swiper = this;
    var params = swiper.params.navigation;
    var toggleEl = swiper.navigation.toggleEl;
    if (swiper.params.loop) return;
    var _swiper$navigation = swiper.navigation,
        $nextEl = _swiper$navigation.$nextEl,
        $prevEl = _swiper$navigation.$prevEl;

    if ($prevEl && $prevEl.length > 0) {
      if (swiper.isBeginning) {
        toggleEl($prevEl, true);
      } else {
        toggleEl($prevEl, false);
      }

      $prevEl[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
    }

    if ($nextEl && $nextEl.length > 0) {
      if (swiper.isEnd) {
        toggleEl($nextEl, true);
      } else {
        toggleEl($nextEl, false);
      }

      $nextEl[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
    }
  },
  onPrevClick: function onPrevClick(e) {
    var swiper = this;
    e.preventDefault();
    if (swiper.isBeginning && !swiper.params.loop) return;
    swiper.slidePrev();
  },
  onNextClick: function onNextClick(e) {
    var swiper = this;
    e.preventDefault();
    if (swiper.isEnd && !swiper.params.loop) return;
    swiper.slideNext();
  },
  init: function init() {
    var swiper = this;
    var params = swiper.params.navigation;
    if (!(params.nextEl || params.prevEl)) return;
    var $nextEl;
    var $prevEl;

    if (params.nextEl) {
      $nextEl = dom(params.nextEl);

      if (swiper.params.uniqueNavElements && typeof params.nextEl === 'string' && $nextEl.length > 1 && swiper.$el.find(params.nextEl).length === 1) {
        $nextEl = swiper.$el.find(params.nextEl);
      }
    }

    if (params.prevEl) {
      $prevEl = dom(params.prevEl);

      if (swiper.params.uniqueNavElements && typeof params.prevEl === 'string' && $prevEl.length > 1 && swiper.$el.find(params.prevEl).length === 1) {
        $prevEl = swiper.$el.find(params.prevEl);
      }
    }

    if ($nextEl && $nextEl.length > 0) {
      $nextEl.on('click', swiper.navigation.onNextClick);
    }

    if ($prevEl && $prevEl.length > 0) {
      $prevEl.on('click', swiper.navigation.onPrevClick);
    }

    utils_extend(swiper.navigation, {
      $nextEl: $nextEl,
      nextEl: $nextEl && $nextEl[0],
      $prevEl: $prevEl,
      prevEl: $prevEl && $prevEl[0]
    });
  },
  destroy: function destroy() {
    var swiper = this;
    var _swiper$navigation2 = swiper.navigation,
        $nextEl = _swiper$navigation2.$nextEl,
        $prevEl = _swiper$navigation2.$prevEl;

    if ($nextEl && $nextEl.length) {
      $nextEl.off('click', swiper.navigation.onNextClick);
      $nextEl.removeClass(swiper.params.navigation.disabledClass);
    }

    if ($prevEl && $prevEl.length) {
      $prevEl.off('click', swiper.navigation.onPrevClick);
      $prevEl.removeClass(swiper.params.navigation.disabledClass);
    }
  }
};
/* harmony default export */ const navigation = ({
  name: 'navigation',
  params: {
    navigation: {
      nextEl: null,
      prevEl: null,
      hideOnClick: false,
      disabledClass: 'swiper-button-disabled',
      hiddenClass: 'swiper-button-hidden',
      lockClass: 'swiper-button-lock'
    }
  },
  create: function create() {
    var swiper = this;
    bindModuleMethods(swiper, {
      navigation: navigation_objectSpread({}, Navigation)
    });
  },
  on: {
    init: function init(swiper) {
      swiper.navigation.init();
      swiper.navigation.update();
    },
    toEdge: function toEdge(swiper) {
      swiper.navigation.update();
    },
    fromEdge: function fromEdge(swiper) {
      swiper.navigation.update();
    },
    destroy: function destroy(swiper) {
      swiper.navigation.destroy();
    },
    click: function click(swiper, e) {
      var _swiper$navigation3 = swiper.navigation,
          $nextEl = _swiper$navigation3.$nextEl,
          $prevEl = _swiper$navigation3.$prevEl;
      var targetEl = e.target;

      if (swiper.params.navigation.hideOnClick && !dom(targetEl).is($prevEl) && !dom(targetEl).is($nextEl)) {
        if (swiper.pagination && swiper.params.pagination && swiper.params.pagination.clickable && (swiper.pagination.el === targetEl || swiper.pagination.el.contains(targetEl))) return;
        var isHidden;

        if ($nextEl) {
          isHidden = $nextEl.hasClass(swiper.params.navigation.hiddenClass);
        } else if ($prevEl) {
          isHidden = $prevEl.hasClass(swiper.params.navigation.hiddenClass);
        }

        if (isHidden === true) {
          swiper.emit('navigationShow');
        } else {
          swiper.emit('navigationHide');
        }

        if ($nextEl) {
          $nextEl.toggleClass(swiper.params.navigation.hiddenClass);
        }

        if ($prevEl) {
          $prevEl.toggleClass(swiper.params.navigation.hiddenClass);
        }
      }
    }
  }
});
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/mousewheel/mousewheel.js




function isEventSupported() {
  var document = getDocument();
  var eventName = 'onwheel';
  var isSupported = (eventName in document);

  if (!isSupported) {
    var element = document.createElement('div');
    element.setAttribute(eventName, 'return;');
    isSupported = typeof element[eventName] === 'function';
  }

  if (!isSupported && document.implementation && document.implementation.hasFeature && // always returns true in newer browsers as per the standard.
  // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
  document.implementation.hasFeature('', '') !== true) {
    // This is the only way to test support for the `wheel` event in IE9+.
    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
  }

  return isSupported;
}

var Mousewheel = {
  lastScrollTime: now(),
  lastEventBeforeSnap: undefined,
  recentWheelEvents: [],
  event: function event() {
    var window = ssr_window_esm_getWindow();
    if (window.navigator.userAgent.indexOf('firefox') > -1) return 'DOMMouseScroll';
    return isEventSupported() ? 'wheel' : 'mousewheel';
  },
  normalize: function normalize(e) {
    // Reasonable defaults
    var PIXEL_STEP = 10;
    var LINE_HEIGHT = 40;
    var PAGE_HEIGHT = 800;
    var sX = 0;
    var sY = 0; // spinX, spinY

    var pX = 0;
    var pY = 0; // pixelX, pixelY
    // Legacy

    if ('detail' in e) {
      sY = e.detail;
    }

    if ('wheelDelta' in e) {
      sY = -e.wheelDelta / 120;
    }

    if ('wheelDeltaY' in e) {
      sY = -e.wheelDeltaY / 120;
    }

    if ('wheelDeltaX' in e) {
      sX = -e.wheelDeltaX / 120;
    } // side scrolling on FF with DOMMouseScroll


    if ('axis' in e && e.axis === e.HORIZONTAL_AXIS) {
      sX = sY;
      sY = 0;
    }

    pX = sX * PIXEL_STEP;
    pY = sY * PIXEL_STEP;

    if ('deltaY' in e) {
      pY = e.deltaY;
    }

    if ('deltaX' in e) {
      pX = e.deltaX;
    }

    if (e.shiftKey && !pX) {
      // if user scrolls with shift he wants horizontal scroll
      pX = pY;
      pY = 0;
    }

    if ((pX || pY) && e.deltaMode) {
      if (e.deltaMode === 1) {
        // delta in LINE units
        pX *= LINE_HEIGHT;
        pY *= LINE_HEIGHT;
      } else {
        // delta in PAGE units
        pX *= PAGE_HEIGHT;
        pY *= PAGE_HEIGHT;
      }
    } // Fall-back if spin cannot be determined


    if (pX && !sX) {
      sX = pX < 1 ? -1 : 1;
    }

    if (pY && !sY) {
      sY = pY < 1 ? -1 : 1;
    }

    return {
      spinX: sX,
      spinY: sY,
      pixelX: pX,
      pixelY: pY
    };
  },
  handleMouseEnter: function handleMouseEnter() {
    var swiper = this;
    swiper.mouseEntered = true;
  },
  handleMouseLeave: function handleMouseLeave() {
    var swiper = this;
    swiper.mouseEntered = false;
  },
  handle: function handle(event) {
    var e = event;
    var disableParentSwiper = true;
    var swiper = this;
    var params = swiper.params.mousewheel;

    if (swiper.params.cssMode) {
      e.preventDefault();
    }

    var target = swiper.$el;

    if (swiper.params.mousewheel.eventsTarget !== 'container') {
      target = dom(swiper.params.mousewheel.eventsTarget);
    }

    if (!swiper.mouseEntered && !target[0].contains(e.target) && !params.releaseOnEdges) return true;
    if (e.originalEvent) e = e.originalEvent; // jquery fix

    var delta = 0;
    var rtlFactor = swiper.rtlTranslate ? -1 : 1;
    var data = Mousewheel.normalize(e);

    if (params.forceToAxis) {
      if (swiper.isHorizontal()) {
        if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) delta = -data.pixelX * rtlFactor;else return true;
      } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) delta = -data.pixelY;else return true;
    } else {
      delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;
    }

    if (delta === 0) return true;
    if (params.invert) delta = -delta; // Get the scroll positions

    var positions = swiper.getTranslate() + delta * params.sensitivity;
    if (positions >= swiper.minTranslate()) positions = swiper.minTranslate();
    if (positions <= swiper.maxTranslate()) positions = swiper.maxTranslate(); // When loop is true:
    //     the disableParentSwiper will be true.
    // When loop is false:
    //     if the scroll positions is not on edge,
    //     then the disableParentSwiper will be true.
    //     if the scroll on edge positions,
    //     then the disableParentSwiper will be false.

    disableParentSwiper = swiper.params.loop ? true : !(positions === swiper.minTranslate() || positions === swiper.maxTranslate());
    if (disableParentSwiper && swiper.params.nested) e.stopPropagation();

    if (!swiper.params.freeMode) {
      // Register the new event in a variable which stores the relevant data
      var newEvent = {
        time: now(),
        delta: Math.abs(delta),
        direction: Math.sign(delta),
        raw: event
      }; // Keep the most recent events

      var recentWheelEvents = swiper.mousewheel.recentWheelEvents;

      if (recentWheelEvents.length >= 2) {
        recentWheelEvents.shift(); // only store the last N events
      }

      var prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;
      recentWheelEvents.push(newEvent); // If there is at least one previous recorded event:
      //   If direction has changed or
      //   if the scroll is quicker than the previous one:
      //     Animate the slider.
      // Else (this is the first time the wheel is moved):
      //     Animate the slider.

      if (prevEvent) {
        if (newEvent.direction !== prevEvent.direction || newEvent.delta > prevEvent.delta || newEvent.time > prevEvent.time + 150) {
          swiper.mousewheel.animateSlider(newEvent);
        }
      } else {
        swiper.mousewheel.animateSlider(newEvent);
      } // If it's time to release the scroll:
      //   Return now so you don't hit the preventDefault.


      if (swiper.mousewheel.releaseScroll(newEvent)) {
        return true;
      }
    } else {
      // Freemode or scrollContainer:
      // If we recently snapped after a momentum scroll, then ignore wheel events
      // to give time for the deceleration to finish. Stop ignoring after 500 msecs
      // or if it's a new scroll (larger delta or inverse sign as last event before
      // an end-of-momentum snap).
      var _newEvent = {
        time: now(),
        delta: Math.abs(delta),
        direction: Math.sign(delta)
      };
      var lastEventBeforeSnap = swiper.mousewheel.lastEventBeforeSnap;
      var ignoreWheelEvents = lastEventBeforeSnap && _newEvent.time < lastEventBeforeSnap.time + 500 && _newEvent.delta <= lastEventBeforeSnap.delta && _newEvent.direction === lastEventBeforeSnap.direction;

      if (!ignoreWheelEvents) {
        swiper.mousewheel.lastEventBeforeSnap = undefined;

        if (swiper.params.loop) {
          swiper.loopFix();
        }

        var position = swiper.getTranslate() + delta * params.sensitivity;
        var wasBeginning = swiper.isBeginning;
        var wasEnd = swiper.isEnd;
        if (position >= swiper.minTranslate()) position = swiper.minTranslate();
        if (position <= swiper.maxTranslate()) position = swiper.maxTranslate();
        swiper.setTransition(0);
        swiper.setTranslate(position);
        swiper.updateProgress();
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();

        if (!wasBeginning && swiper.isBeginning || !wasEnd && swiper.isEnd) {
          swiper.updateSlidesClasses();
        }

        if (swiper.params.freeModeSticky) {
          // When wheel scrolling starts with sticky (aka snap) enabled, then detect
          // the end of a momentum scroll by storing recent (N=15?) wheel events.
          // 1. do all N events have decreasing or same (absolute value) delta?
          // 2. did all N events arrive in the last M (M=500?) msecs?
          // 3. does the earliest event have an (absolute value) delta that's
          //    at least P (P=1?) larger than the most recent event's delta?
          // 4. does the latest event have a delta that's smaller than Q (Q=6?) pixels?
          // If 1-4 are "yes" then we're near the end of a momentum scroll deceleration.
          // Snap immediately and ignore remaining wheel events in this scroll.
          // See comment above for "remaining wheel events in this scroll" determination.
          // If 1-4 aren't satisfied, then wait to snap until 500ms after the last event.
          clearTimeout(swiper.mousewheel.timeout);
          swiper.mousewheel.timeout = undefined;
          var _recentWheelEvents = swiper.mousewheel.recentWheelEvents;

          if (_recentWheelEvents.length >= 15) {
            _recentWheelEvents.shift(); // only store the last N events

          }

          var _prevEvent = _recentWheelEvents.length ? _recentWheelEvents[_recentWheelEvents.length - 1] : undefined;

          var firstEvent = _recentWheelEvents[0];

          _recentWheelEvents.push(_newEvent);

          if (_prevEvent && (_newEvent.delta > _prevEvent.delta || _newEvent.direction !== _prevEvent.direction)) {
            // Increasing or reverse-sign delta means the user started scrolling again. Clear the wheel event log.
            _recentWheelEvents.splice(0);
          } else if (_recentWheelEvents.length >= 15 && _newEvent.time - firstEvent.time < 500 && firstEvent.delta - _newEvent.delta >= 1 && _newEvent.delta <= 6) {
            // We're at the end of the deceleration of a momentum scroll, so there's no need
            // to wait for more events. Snap ASAP on the next tick.
            // Also, because there's some remaining momentum we'll bias the snap in the
            // direction of the ongoing scroll because it's better UX for the scroll to snap
            // in the same direction as the scroll instead of reversing to snap.  Therefore,
            // if it's already scrolled more than 20% in the current direction, keep going.
            var snapToThreshold = delta > 0 ? 0.8 : 0.2;
            swiper.mousewheel.lastEventBeforeSnap = _newEvent;

            _recentWheelEvents.splice(0);

            swiper.mousewheel.timeout = nextTick(function () {
              swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);
            }, 0); // no delay; move on next tick
          }

          if (!swiper.mousewheel.timeout) {
            // if we get here, then we haven't detected the end of a momentum scroll, so
            // we'll consider a scroll "complete" when there haven't been any wheel events
            // for 500ms.
            swiper.mousewheel.timeout = nextTick(function () {
              var snapToThreshold = 0.5;
              swiper.mousewheel.lastEventBeforeSnap = _newEvent;

              _recentWheelEvents.splice(0);

              swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);
            }, 500);
          }
        } // Emit event


        if (!ignoreWheelEvents) swiper.emit('scroll', e); // Stop autoplay

        if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction) swiper.autoplay.stop(); // Return page scroll on edge positions

        if (position === swiper.minTranslate() || position === swiper.maxTranslate()) return true;
      }
    }

    if (e.preventDefault) e.preventDefault();else e.returnValue = false;
    return false;
  },
  animateSlider: function animateSlider(newEvent) {
    var swiper = this;
    var window = ssr_window_esm_getWindow();

    if (this.params.mousewheel.thresholdDelta && newEvent.delta < this.params.mousewheel.thresholdDelta) {
      // Prevent if delta of wheel scroll delta is below configured threshold
      return false;
    }

    if (this.params.mousewheel.thresholdTime && now() - swiper.mousewheel.lastScrollTime < this.params.mousewheel.thresholdTime) {
      // Prevent if time between scrolls is below configured threshold
      return false;
    } // If the movement is NOT big enough and
    // if the last time the user scrolled was too close to the current one (avoid continuously triggering the slider):
    //   Don't go any further (avoid insignificant scroll movement).


    if (newEvent.delta >= 6 && now() - swiper.mousewheel.lastScrollTime < 60) {
      // Return false as a default
      return true;
    } // If user is scrolling towards the end:
    //   If the slider hasn't hit the latest slide or
    //   if the slider is a loop and
    //   if the slider isn't moving right now:
    //     Go to next slide and
    //     emit a scroll event.
    // Else (the user is scrolling towards the beginning) and
    // if the slider hasn't hit the first slide or
    // if the slider is a loop and
    // if the slider isn't moving right now:
    //   Go to prev slide and
    //   emit a scroll event.


    if (newEvent.direction < 0) {
      if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {
        swiper.slideNext();
        swiper.emit('scroll', newEvent.raw);
      }
    } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {
      swiper.slidePrev();
      swiper.emit('scroll', newEvent.raw);
    } // If you got here is because an animation has been triggered so store the current time


    swiper.mousewheel.lastScrollTime = new window.Date().getTime(); // Return false as a default

    return false;
  },
  releaseScroll: function releaseScroll(newEvent) {
    var swiper = this;
    var params = swiper.params.mousewheel;

    if (newEvent.direction < 0) {
      if (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges) {
        // Return true to animate scroll on edges
        return true;
      }
    } else if (swiper.isBeginning && !swiper.params.loop && params.releaseOnEdges) {
      // Return true to animate scroll on edges
      return true;
    }

    return false;
  },
  enable: function enable() {
    var swiper = this;
    var event = Mousewheel.event();

    if (swiper.params.cssMode) {
      swiper.wrapperEl.removeEventListener(event, swiper.mousewheel.handle);
      return true;
    }

    if (!event) return false;
    if (swiper.mousewheel.enabled) return false;
    var target = swiper.$el;

    if (swiper.params.mousewheel.eventsTarget !== 'container') {
      target = dom(swiper.params.mousewheel.eventsTarget);
    }

    target.on('mouseenter', swiper.mousewheel.handleMouseEnter);
    target.on('mouseleave', swiper.mousewheel.handleMouseLeave);
    target.on(event, swiper.mousewheel.handle);
    swiper.mousewheel.enabled = true;
    return true;
  },
  disable: function disable() {
    var swiper = this;
    var event = Mousewheel.event();

    if (swiper.params.cssMode) {
      swiper.wrapperEl.addEventListener(event, swiper.mousewheel.handle);
      return true;
    }

    if (!event) return false;
    if (!swiper.mousewheel.enabled) return false;
    var target = swiper.$el;

    if (swiper.params.mousewheel.eventsTarget !== 'container') {
      target = dom(swiper.params.mousewheel.eventsTarget);
    }

    target.off(event, swiper.mousewheel.handle);
    swiper.mousewheel.enabled = false;
    return true;
  }
};
/* harmony default export */ const mousewheel = ({
  name: 'mousewheel',
  params: {
    mousewheel: {
      enabled: false,
      releaseOnEdges: false,
      invert: false,
      forceToAxis: false,
      sensitivity: 1,
      eventsTarget: 'container',
      thresholdDelta: null,
      thresholdTime: null
    }
  },
  create: function create() {
    var swiper = this;
    bindModuleMethods(swiper, {
      mousewheel: {
        enabled: false,
        lastScrollTime: now(),
        lastEventBeforeSnap: undefined,
        recentWheelEvents: [],
        enable: Mousewheel.enable,
        disable: Mousewheel.disable,
        handle: Mousewheel.handle,
        handleMouseEnter: Mousewheel.handleMouseEnter,
        handleMouseLeave: Mousewheel.handleMouseLeave,
        animateSlider: Mousewheel.animateSlider,
        releaseScroll: Mousewheel.releaseScroll
      }
    });
  },
  on: {
    init: function init(swiper) {
      if (!swiper.params.mousewheel.enabled && swiper.params.cssMode) {
        swiper.mousewheel.disable();
      }

      if (swiper.params.mousewheel.enabled) swiper.mousewheel.enable();
    },
    destroy: function destroy(swiper) {
      if (swiper.params.cssMode) {
        swiper.mousewheel.enable();
      }

      if (swiper.mousewheel.enabled) swiper.mousewheel.disable();
    }
  }
});
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/lazy/lazy.js


function lazy_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function lazy_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? lazy_ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : lazy_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }




var Lazy = {
  loadInSlide: function loadInSlide(index) {
    var loadInDuplicate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    var swiper = this;
    var params = swiper.params.lazy;
    if (typeof index === 'undefined') return;
    if (swiper.slides.length === 0) return;
    var isVirtual = swiper.virtual && swiper.params.virtual.enabled;
    var $slideEl = isVirtual ? swiper.$wrapperEl.children(".".concat(swiper.params.slideClass, "[data-swiper-slide-index=\"").concat(index, "\"]")) : swiper.slides.eq(index);
    var $images = $slideEl.find(".".concat(params.elementClass, ":not(.").concat(params.loadedClass, "):not(.").concat(params.loadingClass, ")"));

    if ($slideEl.hasClass(params.elementClass) && !$slideEl.hasClass(params.loadedClass) && !$slideEl.hasClass(params.loadingClass)) {
      $images.push($slideEl[0]);
    }

    if ($images.length === 0) return;
    $images.each(function (imageEl) {
      var $imageEl = dom(imageEl);
      $imageEl.addClass(params.loadingClass);
      var background = $imageEl.attr('data-background');
      var src = $imageEl.attr('data-src');
      var srcset = $imageEl.attr('data-srcset');
      var sizes = $imageEl.attr('data-sizes');
      var $pictureEl = $imageEl.parent('picture');
      swiper.loadImage($imageEl[0], src || background, srcset, sizes, false, function () {
        if (typeof swiper === 'undefined' || swiper === null || !swiper || swiper && !swiper.params || swiper.destroyed) return;

        if (background) {
          $imageEl.css('background-image', "url(\"".concat(background, "\")"));
          $imageEl.removeAttr('data-background');
        } else {
          if (srcset) {
            $imageEl.attr('srcset', srcset);
            $imageEl.removeAttr('data-srcset');
          }

          if (sizes) {
            $imageEl.attr('sizes', sizes);
            $imageEl.removeAttr('data-sizes');
          }

          if ($pictureEl.length) {
            $pictureEl.children('source').each(function (sourceEl) {
              var $source = dom(sourceEl);

              if ($source.attr('data-srcset')) {
                $source.attr('srcset', $source.attr('data-srcset'));
                $source.removeAttr('data-srcset');
              }
            });
          }

          if (src) {
            $imageEl.attr('src', src);
            $imageEl.removeAttr('data-src');
          }
        }

        $imageEl.addClass(params.loadedClass).removeClass(params.loadingClass);
        $slideEl.find(".".concat(params.preloaderClass)).remove();

        if (swiper.params.loop && loadInDuplicate) {
          var slideOriginalIndex = $slideEl.attr('data-swiper-slide-index');

          if ($slideEl.hasClass(swiper.params.slideDuplicateClass)) {
            var originalSlide = swiper.$wrapperEl.children("[data-swiper-slide-index=\"".concat(slideOriginalIndex, "\"]:not(.").concat(swiper.params.slideDuplicateClass, ")"));
            swiper.lazy.loadInSlide(originalSlide.index(), false);
          } else {
            var duplicatedSlide = swiper.$wrapperEl.children(".".concat(swiper.params.slideDuplicateClass, "[data-swiper-slide-index=\"").concat(slideOriginalIndex, "\"]"));
            swiper.lazy.loadInSlide(duplicatedSlide.index(), false);
          }
        }

        swiper.emit('lazyImageReady', $slideEl[0], $imageEl[0]);

        if (swiper.params.autoHeight) {
          swiper.updateAutoHeight();
        }
      });
      swiper.emit('lazyImageLoad', $slideEl[0], $imageEl[0]);
    });
  },
  load: function load() {
    var swiper = this;
    var $wrapperEl = swiper.$wrapperEl,
        swiperParams = swiper.params,
        slides = swiper.slides,
        activeIndex = swiper.activeIndex;
    var isVirtual = swiper.virtual && swiperParams.virtual.enabled;
    var params = swiperParams.lazy;
    var slidesPerView = swiperParams.slidesPerView;

    if (slidesPerView === 'auto') {
      slidesPerView = 0;
    }

    function slideExist(index) {
      if (isVirtual) {
        if ($wrapperEl.children(".".concat(swiperParams.slideClass, "[data-swiper-slide-index=\"").concat(index, "\"]")).length) {
          return true;
        }
      } else if (slides[index]) return true;

      return false;
    }

    function slideIndex(slideEl) {
      if (isVirtual) {
        return dom(slideEl).attr('data-swiper-slide-index');
      }

      return dom(slideEl).index();
    }

    if (!swiper.lazy.initialImageLoaded) swiper.lazy.initialImageLoaded = true;

    if (swiper.params.watchSlidesVisibility) {
      $wrapperEl.children(".".concat(swiperParams.slideVisibleClass)).each(function (slideEl) {
        var index = isVirtual ? dom(slideEl).attr('data-swiper-slide-index') : dom(slideEl).index();
        swiper.lazy.loadInSlide(index);
      });
    } else if (slidesPerView > 1) {
      for (var i = activeIndex; i < activeIndex + slidesPerView; i += 1) {
        if (slideExist(i)) swiper.lazy.loadInSlide(i);
      }
    } else {
      swiper.lazy.loadInSlide(activeIndex);
    }

    if (params.loadPrevNext) {
      if (slidesPerView > 1 || params.loadPrevNextAmount && params.loadPrevNextAmount > 1) {
        var amount = params.loadPrevNextAmount;
        var spv = slidesPerView;
        var maxIndex = Math.min(activeIndex + spv + Math.max(amount, spv), slides.length);
        var minIndex = Math.max(activeIndex - Math.max(spv, amount), 0); // Next Slides

        for (var _i = activeIndex + slidesPerView; _i < maxIndex; _i += 1) {
          if (slideExist(_i)) swiper.lazy.loadInSlide(_i);
        } // Prev Slides


        for (var _i2 = minIndex; _i2 < activeIndex; _i2 += 1) {
          if (slideExist(_i2)) swiper.lazy.loadInSlide(_i2);
        }
      } else {
        var nextSlide = $wrapperEl.children(".".concat(swiperParams.slideNextClass));
        if (nextSlide.length > 0) swiper.lazy.loadInSlide(slideIndex(nextSlide));
        var prevSlide = $wrapperEl.children(".".concat(swiperParams.slidePrevClass));
        if (prevSlide.length > 0) swiper.lazy.loadInSlide(slideIndex(prevSlide));
      }
    }
  },
  checkInViewOnLoad: function checkInViewOnLoad() {
    var window = ssr_window_esm_getWindow();
    var swiper = this;
    if (!swiper || swiper.destroyed) return;
    var $scrollElement = swiper.params.lazy.scrollingElement ? dom(swiper.params.lazy.scrollingElement) : dom(window);
    var isWindow = $scrollElement[0] === window;
    var scrollElementWidth = isWindow ? window.innerWidth : $scrollElement[0].offsetWidth;
    var scrollElementHeight = isWindow ? window.innerHeight : $scrollElement[0].offsetHeight;
    var swiperOffset = swiper.$el.offset();
    var rtl = swiper.rtlTranslate;
    var inView = false;
    if (rtl) swiperOffset.left -= swiper.$el[0].scrollLeft;
    var swiperCoord = [[swiperOffset.left, swiperOffset.top], [swiperOffset.left + swiper.width, swiperOffset.top], [swiperOffset.left, swiperOffset.top + swiper.height], [swiperOffset.left + swiper.width, swiperOffset.top + swiper.height]];

    for (var i = 0; i < swiperCoord.length; i += 1) {
      var point = swiperCoord[i];

      if (point[0] >= 0 && point[0] <= scrollElementWidth && point[1] >= 0 && point[1] <= scrollElementHeight) {
        if (point[0] === 0 && point[1] === 0) continue; // eslint-disable-line

        inView = true;
      }
    }

    if (inView) {
      swiper.lazy.load();
      $scrollElement.off('scroll', swiper.lazy.checkInViewOnLoad);
    } else if (!swiper.lazy.scrollHandlerAttached) {
      swiper.lazy.scrollHandlerAttached = true;
      $scrollElement.on('scroll', swiper.lazy.checkInViewOnLoad);
    }
  }
};
/* harmony default export */ const lazy = ({
  name: 'lazy',
  params: {
    lazy: {
      checkInView: false,
      enabled: false,
      loadPrevNext: false,
      loadPrevNextAmount: 1,
      loadOnTransitionStart: false,
      scrollingElement: '',
      elementClass: 'swiper-lazy',
      loadingClass: 'swiper-lazy-loading',
      loadedClass: 'swiper-lazy-loaded',
      preloaderClass: 'swiper-lazy-preloader'
    }
  },
  create: function create() {
    var swiper = this;
    bindModuleMethods(swiper, {
      lazy: lazy_objectSpread({
        initialImageLoaded: false
      }, Lazy)
    });
  },
  on: {
    beforeInit: function beforeInit(swiper) {
      if (swiper.params.lazy.enabled && swiper.params.preloadImages) {
        swiper.params.preloadImages = false;
      }
    },
    init: function init(swiper) {
      if (swiper.params.lazy.enabled && !swiper.params.loop && swiper.params.initialSlide === 0) {
        if (swiper.params.lazy.checkInView) {
          swiper.lazy.checkInViewOnLoad();
        } else {
          swiper.lazy.load();
        }
      }
    },
    scroll: function scroll(swiper) {
      if (swiper.params.freeMode && !swiper.params.freeModeSticky) {
        swiper.lazy.load();
      }
    },
    'scrollbarDragMove resize _freeModeNoMomentumRelease': function lazyLoad(swiper) {
      if (swiper.params.lazy.enabled) {
        swiper.lazy.load();
      }
    },
    transitionStart: function transitionStart(swiper) {
      if (swiper.params.lazy.enabled) {
        if (swiper.params.lazy.loadOnTransitionStart || !swiper.params.lazy.loadOnTransitionStart && !swiper.lazy.initialImageLoaded) {
          swiper.lazy.load();
        }
      }
    },
    transitionEnd: function transitionEnd(swiper) {
      if (swiper.params.lazy.enabled && !swiper.params.lazy.loadOnTransitionStart) {
        swiper.lazy.load();
      }
    },
    slideChange: function slideChange(swiper) {
      if (swiper.params.lazy.enabled && swiper.params.cssMode) {
        swiper.lazy.load();
      }
    }
  }
});
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/keyboard/keyboard.js


function keyboard_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function keyboard_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? keyboard_ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : keyboard_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }




var Keyboard = {
  handle: function handle(event) {
    var swiper = this;
    var window = ssr_window_esm_getWindow();
    var document = getDocument();
    var rtl = swiper.rtlTranslate;
    var e = event;
    if (e.originalEvent) e = e.originalEvent; // jquery fix

    var kc = e.keyCode || e.charCode;
    var pageUpDown = swiper.params.keyboard.pageUpDown;
    var isPageUp = pageUpDown && kc === 33;
    var isPageDown = pageUpDown && kc === 34;
    var isArrowLeft = kc === 37;
    var isArrowRight = kc === 39;
    var isArrowUp = kc === 38;
    var isArrowDown = kc === 40; // Directions locks

    if (!swiper.allowSlideNext && (swiper.isHorizontal() && isArrowRight || swiper.isVertical() && isArrowDown || isPageDown)) {
      return false;
    }

    if (!swiper.allowSlidePrev && (swiper.isHorizontal() && isArrowLeft || swiper.isVertical() && isArrowUp || isPageUp)) {
      return false;
    }

    if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {
      return undefined;
    }

    if (document.activeElement && document.activeElement.nodeName && (document.activeElement.nodeName.toLowerCase() === 'input' || document.activeElement.nodeName.toLowerCase() === 'textarea')) {
      return undefined;
    }

    if (swiper.params.keyboard.onlyInViewport && (isPageUp || isPageDown || isArrowLeft || isArrowRight || isArrowUp || isArrowDown)) {
      var inView = false; // Check that swiper should be inside of visible area of window

      if (swiper.$el.parents(".".concat(swiper.params.slideClass)).length > 0 && swiper.$el.parents(".".concat(swiper.params.slideActiveClass)).length === 0) {
        return undefined;
      }

      var $el = swiper.$el;
      var swiperWidth = $el[0].clientWidth;
      var swiperHeight = $el[0].clientHeight;
      var windowWidth = window.innerWidth;
      var windowHeight = window.innerHeight;
      var swiperOffset = swiper.$el.offset();
      if (rtl) swiperOffset.left -= swiper.$el[0].scrollLeft;
      var swiperCoord = [[swiperOffset.left, swiperOffset.top], [swiperOffset.left + swiperWidth, swiperOffset.top], [swiperOffset.left, swiperOffset.top + swiperHeight], [swiperOffset.left + swiperWidth, swiperOffset.top + swiperHeight]];

      for (var i = 0; i < swiperCoord.length; i += 1) {
        var point = swiperCoord[i];

        if (point[0] >= 0 && point[0] <= windowWidth && point[1] >= 0 && point[1] <= windowHeight) {
          if (point[0] === 0 && point[1] === 0) continue; // eslint-disable-line

          inView = true;
        }
      }

      if (!inView) return undefined;
    }

    if (swiper.isHorizontal()) {
      if (isPageUp || isPageDown || isArrowLeft || isArrowRight) {
        if (e.preventDefault) e.preventDefault();else e.returnValue = false;
      }

      if ((isPageDown || isArrowRight) && !rtl || (isPageUp || isArrowLeft) && rtl) swiper.slideNext();
      if ((isPageUp || isArrowLeft) && !rtl || (isPageDown || isArrowRight) && rtl) swiper.slidePrev();
    } else {
      if (isPageUp || isPageDown || isArrowUp || isArrowDown) {
        if (e.preventDefault) e.preventDefault();else e.returnValue = false;
      }

      if (isPageDown || isArrowDown) swiper.slideNext();
      if (isPageUp || isArrowUp) swiper.slidePrev();
    }

    swiper.emit('keyPress', kc);
    return undefined;
  },
  enable: function enable() {
    var swiper = this;
    var document = getDocument();
    if (swiper.keyboard.enabled) return;
    dom(document).on('keydown', swiper.keyboard.handle);
    swiper.keyboard.enabled = true;
  },
  disable: function disable() {
    var swiper = this;
    var document = getDocument();
    if (!swiper.keyboard.enabled) return;
    dom(document).off('keydown', swiper.keyboard.handle);
    swiper.keyboard.enabled = false;
  }
};
/* harmony default export */ const keyboard = ({
  name: 'keyboard',
  params: {
    keyboard: {
      enabled: false,
      onlyInViewport: true,
      pageUpDown: true
    }
  },
  create: function create() {
    var swiper = this;
    bindModuleMethods(swiper, {
      keyboard: keyboard_objectSpread({
        enabled: false
      }, Keyboard)
    });
  },
  on: {
    init: function init(swiper) {
      if (swiper.params.keyboard.enabled) {
        swiper.keyboard.enable();
      }
    },
    destroy: function destroy(swiper) {
      if (swiper.keyboard.enabled) {
        swiper.keyboard.disable();
      }
    }
  }
});
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/history/history.js


function history_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function history_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? history_ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : history_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }



var History = {
  init: function init() {
    var swiper = this;
    var window = ssr_window_esm_getWindow();
    if (!swiper.params.history) return;

    if (!window.history || !window.history.pushState) {
      swiper.params.history.enabled = false;
      swiper.params.hashNavigation.enabled = true;
      return;
    }

    var history = swiper.history;
    history.initialized = true;
    history.paths = History.getPathValues(swiper.params.url);
    if (!history.paths.key && !history.paths.value) return;
    history.scrollToSlide(0, history.paths.value, swiper.params.runCallbacksOnInit);

    if (!swiper.params.history.replaceState) {
      window.addEventListener('popstate', swiper.history.setHistoryPopState);
    }
  },
  destroy: function destroy() {
    var swiper = this;
    var window = ssr_window_esm_getWindow();

    if (!swiper.params.history.replaceState) {
      window.removeEventListener('popstate', swiper.history.setHistoryPopState);
    }
  },
  setHistoryPopState: function setHistoryPopState() {
    var swiper = this;
    swiper.history.paths = History.getPathValues(swiper.params.url);
    swiper.history.scrollToSlide(swiper.params.speed, swiper.history.paths.value, false);
  },
  getPathValues: function getPathValues(urlOverride) {
    var window = ssr_window_esm_getWindow();
    var location;

    if (urlOverride) {
      location = new URL(urlOverride);
    } else {
      location = window.location;
    }

    var pathArray = location.pathname.slice(1).split('/').filter(function (part) {
      return part !== '';
    });
    var total = pathArray.length;
    var key = pathArray[total - 2];
    var value = pathArray[total - 1];
    return {
      key: key,
      value: value
    };
  },
  setHistory: function setHistory(key, index) {
    var swiper = this;
    var window = ssr_window_esm_getWindow();
    if (!swiper.history.initialized || !swiper.params.history.enabled) return;
    var location;

    if (swiper.params.url) {
      location = new URL(swiper.params.url);
    } else {
      location = window.location;
    }

    var slide = swiper.slides.eq(index);
    var value = History.slugify(slide.attr('data-history'));

    if (swiper.params.history.root.length > 0) {
      var root = swiper.params.history.root;
      if (root[root.length - 1] === '/') root = root.slice(0, root.length - 1);
      value = "".concat(root, "/").concat(key, "/").concat(value);
    } else if (!location.pathname.includes(key)) {
      value = "".concat(key, "/").concat(value);
    }

    var currentState = window.history.state;

    if (currentState && currentState.value === value) {
      return;
    }

    if (swiper.params.history.replaceState) {
      window.history.replaceState({
        value: value
      }, null, value);
    } else {
      window.history.pushState({
        value: value
      }, null, value);
    }
  },
  slugify: function slugify(text) {
    return text.toString().replace(/\s+/g, '-').replace(/[^\w-]+/g, '').replace(/--+/g, '-').replace(/^-+/, '').replace(/-+$/, '');
  },
  scrollToSlide: function scrollToSlide(speed, value, runCallbacks) {
    var swiper = this;

    if (value) {
      for (var i = 0, length = swiper.slides.length; i < length; i += 1) {
        var slide = swiper.slides.eq(i);
        var slideHistory = History.slugify(slide.attr('data-history'));

        if (slideHistory === value && !slide.hasClass(swiper.params.slideDuplicateClass)) {
          var index = slide.index();
          swiper.slideTo(index, speed, runCallbacks);
        }
      }
    } else {
      swiper.slideTo(0, speed, runCallbacks);
    }
  }
};
/* harmony default export */ const history_history = ({
  name: 'history',
  params: {
    history: {
      enabled: false,
      root: '',
      replaceState: false,
      key: 'slides'
    }
  },
  create: function create() {
    var swiper = this;
    bindModuleMethods(swiper, {
      history: history_objectSpread({}, History)
    });
  },
  on: {
    init: function init(swiper) {
      if (swiper.params.history.enabled) {
        swiper.history.init();
      }
    },
    destroy: function destroy(swiper) {
      if (swiper.params.history.enabled) {
        swiper.history.destroy();
      }
    },
    'transitionEnd _freeModeNoMomentumRelease': function transitionEnd_freeModeNoMomentumRelease(swiper) {
      if (swiper.history.initialized) {
        swiper.history.setHistory(swiper.params.history.key, swiper.activeIndex);
      }
    },
    slideChange: function slideChange(swiper) {
      if (swiper.history.initialized && swiper.params.cssMode) {
        swiper.history.setHistory(swiper.params.history.key, swiper.activeIndex);
      }
    }
  }
});
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/hash-navigation/hash-navigation.js


function hash_navigation_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function hash_navigation_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? hash_navigation_ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : hash_navigation_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }




var HashNavigation = {
  onHashCange: function onHashCange() {
    var swiper = this;
    var document = getDocument();
    swiper.emit('hashChange');
    var newHash = document.location.hash.replace('#', '');
    var activeSlideHash = swiper.slides.eq(swiper.activeIndex).attr('data-hash');

    if (newHash !== activeSlideHash) {
      var newIndex = swiper.$wrapperEl.children(".".concat(swiper.params.slideClass, "[data-hash=\"").concat(newHash, "\"]")).index();
      if (typeof newIndex === 'undefined') return;
      swiper.slideTo(newIndex);
    }
  },
  setHash: function setHash() {
    var swiper = this;
    var window = ssr_window_esm_getWindow();
    var document = getDocument();
    if (!swiper.hashNavigation.initialized || !swiper.params.hashNavigation.enabled) return;

    if (swiper.params.hashNavigation.replaceState && window.history && window.history.replaceState) {
      window.history.replaceState(null, null, "#".concat(swiper.slides.eq(swiper.activeIndex).attr('data-hash')) || 0);
      swiper.emit('hashSet');
    } else {
      var slide = swiper.slides.eq(swiper.activeIndex);
      var hash = slide.attr('data-hash') || slide.attr('data-history');
      document.location.hash = hash || '';
      swiper.emit('hashSet');
    }
  },
  init: function init() {
    var swiper = this;
    var document = getDocument();
    var window = ssr_window_esm_getWindow();
    if (!swiper.params.hashNavigation.enabled || swiper.params.history && swiper.params.history.enabled) return;
    swiper.hashNavigation.initialized = true;
    var hash = document.location.hash.replace('#', '');

    if (hash) {
      var speed = 0;

      for (var i = 0, length = swiper.slides.length; i < length; i += 1) {
        var slide = swiper.slides.eq(i);
        var slideHash = slide.attr('data-hash') || slide.attr('data-history');

        if (slideHash === hash && !slide.hasClass(swiper.params.slideDuplicateClass)) {
          var index = slide.index();
          swiper.slideTo(index, speed, swiper.params.runCallbacksOnInit, true);
        }
      }
    }

    if (swiper.params.hashNavigation.watchState) {
      dom(window).on('hashchange', swiper.hashNavigation.onHashCange);
    }
  },
  destroy: function destroy() {
    var swiper = this;
    var window = ssr_window_esm_getWindow();

    if (swiper.params.hashNavigation.watchState) {
      dom(window).off('hashchange', swiper.hashNavigation.onHashCange);
    }
  }
};
/* harmony default export */ const hash_navigation = ({
  name: 'hash-navigation',
  params: {
    hashNavigation: {
      enabled: false,
      replaceState: false,
      watchState: false
    }
  },
  create: function create() {
    var swiper = this;
    bindModuleMethods(swiper, {
      hashNavigation: hash_navigation_objectSpread({
        initialized: false
      }, HashNavigation)
    });
  },
  on: {
    init: function init(swiper) {
      if (swiper.params.hashNavigation.enabled) {
        swiper.hashNavigation.init();
      }
    },
    destroy: function destroy(swiper) {
      if (swiper.params.hashNavigation.enabled) {
        swiper.hashNavigation.destroy();
      }
    },
    'transitionEnd _freeModeNoMomentumRelease': function transitionEnd_freeModeNoMomentumRelease(swiper) {
      if (swiper.hashNavigation.initialized) {
        swiper.hashNavigation.setHash();
      }
    },
    slideChange: function slideChange(swiper) {
      if (swiper.hashNavigation.initialized && swiper.params.cssMode) {
        swiper.hashNavigation.setHash();
      }
    }
  }
});
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/effect-flip/effect-flip.js


function effect_flip_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function effect_flip_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? effect_flip_ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : effect_flip_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }



var Flip = {
  setTranslate: function setTranslate() {
    var swiper = this;
    var slides = swiper.slides,
        rtl = swiper.rtlTranslate;

    for (var i = 0; i < slides.length; i += 1) {
      var $slideEl = slides.eq(i);
      var progress = $slideEl[0].progress;

      if (swiper.params.flipEffect.limitRotation) {
        progress = Math.max(Math.min($slideEl[0].progress, 1), -1);
      }

      var offset = $slideEl[0].swiperSlideOffset;
      var rotate = -180 * progress;
      var rotateY = rotate;
      var rotateX = 0;
      var tx = -offset;
      var ty = 0;

      if (!swiper.isHorizontal()) {
        ty = tx;
        tx = 0;
        rotateX = -rotateY;
        rotateY = 0;
      } else if (rtl) {
        rotateY = -rotateY;
      }

      $slideEl[0].style.zIndex = -Math.abs(Math.round(progress)) + slides.length;

      if (swiper.params.flipEffect.slideShadows) {
        // Set shadows
        var shadowBefore = swiper.isHorizontal() ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
        var shadowAfter = swiper.isHorizontal() ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');

        if (shadowBefore.length === 0) {
          shadowBefore = dom("<div class=\"swiper-slide-shadow-".concat(swiper.isHorizontal() ? 'left' : 'top', "\"></div>"));
          $slideEl.append(shadowBefore);
        }

        if (shadowAfter.length === 0) {
          shadowAfter = dom("<div class=\"swiper-slide-shadow-".concat(swiper.isHorizontal() ? 'right' : 'bottom', "\"></div>"));
          $slideEl.append(shadowAfter);
        }

        if (shadowBefore.length) shadowBefore[0].style.opacity = Math.max(-progress, 0);
        if (shadowAfter.length) shadowAfter[0].style.opacity = Math.max(progress, 0);
      }

      $slideEl.transform("translate3d(".concat(tx, "px, ").concat(ty, "px, 0px) rotateX(").concat(rotateX, "deg) rotateY(").concat(rotateY, "deg)"));
    }
  },
  setTransition: function setTransition(duration) {
    var swiper = this;
    var slides = swiper.slides,
        activeIndex = swiper.activeIndex,
        $wrapperEl = swiper.$wrapperEl;
    slides.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);

    if (swiper.params.virtualTranslate && duration !== 0) {
      var eventTriggered = false; // eslint-disable-next-line

      slides.eq(activeIndex).transitionEnd(function onTransitionEnd() {
        if (eventTriggered) return;
        if (!swiper || swiper.destroyed) return; // if (!$(this).hasClass(swiper.params.slideActiveClass)) return;

        eventTriggered = true;
        swiper.animating = false;
        var triggerEvents = ['webkitTransitionEnd', 'transitionend'];

        for (var i = 0; i < triggerEvents.length; i += 1) {
          $wrapperEl.trigger(triggerEvents[i]);
        }
      });
    }
  }
};
/* harmony default export */ const effect_flip = ({
  name: 'effect-flip',
  params: {
    flipEffect: {
      slideShadows: true,
      limitRotation: true
    }
  },
  create: function create() {
    var swiper = this;
    bindModuleMethods(swiper, {
      flipEffect: effect_flip_objectSpread({}, Flip)
    });
  },
  on: {
    beforeInit: function beforeInit(swiper) {
      if (swiper.params.effect !== 'flip') return;
      swiper.classNames.push("".concat(swiper.params.containerModifierClass, "flip"));
      swiper.classNames.push("".concat(swiper.params.containerModifierClass, "3d"));
      var overwriteParams = {
        slidesPerView: 1,
        slidesPerColumn: 1,
        slidesPerGroup: 1,
        watchSlidesProgress: true,
        spaceBetween: 0,
        virtualTranslate: true
      };
      utils_extend(swiper.params, overwriteParams);
      utils_extend(swiper.originalParams, overwriteParams);
    },
    setTranslate: function setTranslate(swiper) {
      if (swiper.params.effect !== 'flip') return;
      swiper.flipEffect.setTranslate();
    },
    setTransition: function setTransition(swiper, duration) {
      if (swiper.params.effect !== 'flip') return;
      swiper.flipEffect.setTransition(duration);
    }
  }
});
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/effect-fade/effect-fade.js


function effect_fade_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function effect_fade_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? effect_fade_ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : effect_fade_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }


var Fade = {
  setTranslate: function setTranslate() {
    var swiper = this;
    var slides = swiper.slides;

    for (var i = 0; i < slides.length; i += 1) {
      var $slideEl = swiper.slides.eq(i);
      var offset = $slideEl[0].swiperSlideOffset;
      var tx = -offset;
      if (!swiper.params.virtualTranslate) tx -= swiper.translate;
      var ty = 0;

      if (!swiper.isHorizontal()) {
        ty = tx;
        tx = 0;
      }

      var slideOpacity = swiper.params.fadeEffect.crossFade ? Math.max(1 - Math.abs($slideEl[0].progress), 0) : 1 + Math.min(Math.max($slideEl[0].progress, -1), 0);
      $slideEl.css({
        opacity: slideOpacity
      }).transform("translate3d(".concat(tx, "px, ").concat(ty, "px, 0px)"));
    }
  },
  setTransition: function setTransition(duration) {
    var swiper = this;
    var slides = swiper.slides,
        $wrapperEl = swiper.$wrapperEl;
    slides.transition(duration);

    if (swiper.params.virtualTranslate && duration !== 0) {
      var eventTriggered = false;
      slides.transitionEnd(function () {
        if (eventTriggered) return;
        if (!swiper || swiper.destroyed) return;
        eventTriggered = true;
        swiper.animating = false;
        var triggerEvents = ['webkitTransitionEnd', 'transitionend'];

        for (var i = 0; i < triggerEvents.length; i += 1) {
          $wrapperEl.trigger(triggerEvents[i]);
        }
      });
    }
  }
};
/* harmony default export */ const effect_fade = ({
  name: 'effect-fade',
  params: {
    fadeEffect: {
      crossFade: false
    }
  },
  create: function create() {
    var swiper = this;
    bindModuleMethods(swiper, {
      fadeEffect: effect_fade_objectSpread({}, Fade)
    });
  },
  on: {
    beforeInit: function beforeInit(swiper) {
      if (swiper.params.effect !== 'fade') return;
      swiper.classNames.push("".concat(swiper.params.containerModifierClass, "fade"));
      var overwriteParams = {
        slidesPerView: 1,
        slidesPerColumn: 1,
        slidesPerGroup: 1,
        watchSlidesProgress: true,
        spaceBetween: 0,
        virtualTranslate: true
      };
      utils_extend(swiper.params, overwriteParams);
      utils_extend(swiper.originalParams, overwriteParams);
    },
    setTranslate: function setTranslate(swiper) {
      if (swiper.params.effect !== 'fade') return;
      swiper.fadeEffect.setTranslate();
    },
    setTransition: function setTransition(swiper, duration) {
      if (swiper.params.effect !== 'fade') return;
      swiper.fadeEffect.setTransition(duration);
    }
  }
});
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/effect-cube/effect-cube.js


function effect_cube_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function effect_cube_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? effect_cube_ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : effect_cube_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }



var Cube = {
  setTranslate: function setTranslate() {
    var swiper = this;
    var $el = swiper.$el,
        $wrapperEl = swiper.$wrapperEl,
        slides = swiper.slides,
        swiperWidth = swiper.width,
        swiperHeight = swiper.height,
        rtl = swiper.rtlTranslate,
        swiperSize = swiper.size,
        UixBrowser = swiper.UixBrowser;
    var params = swiper.params.cubeEffect;
    var isHorizontal = swiper.isHorizontal();
    var isVirtual = swiper.virtual && swiper.params.virtual.enabled;
    var wrapperRotate = 0;
    var $cubeShadowEl;

    if (params.shadow) {
      if (isHorizontal) {
        $cubeShadowEl = $wrapperEl.find('.swiper-cube-shadow');

        if ($cubeShadowEl.length === 0) {
          $cubeShadowEl = dom('<div class="swiper-cube-shadow"></div>');
          $wrapperEl.append($cubeShadowEl);
        }

        $cubeShadowEl.css({
          height: "".concat(swiperWidth, "px")
        });
      } else {
        $cubeShadowEl = $el.find('.swiper-cube-shadow');

        if ($cubeShadowEl.length === 0) {
          $cubeShadowEl = dom('<div class="swiper-cube-shadow"></div>');
          $el.append($cubeShadowEl);
        }
      }
    }

    for (var i = 0; i < slides.length; i += 1) {
      var $slideEl = slides.eq(i);
      var slideIndex = i;

      if (isVirtual) {
        slideIndex = parseInt($slideEl.attr('data-swiper-slide-index'), 10);
      }

      var slideAngle = slideIndex * 90;
      var round = Math.floor(slideAngle / 360);

      if (rtl) {
        slideAngle = -slideAngle;
        round = Math.floor(-slideAngle / 360);
      }

      var progress = Math.max(Math.min($slideEl[0].progress, 1), -1);
      var tx = 0;
      var ty = 0;
      var tz = 0;

      if (slideIndex % 4 === 0) {
        tx = -round * 4 * swiperSize;
        tz = 0;
      } else if ((slideIndex - 1) % 4 === 0) {
        tx = 0;
        tz = -round * 4 * swiperSize;
      } else if ((slideIndex - 2) % 4 === 0) {
        tx = swiperSize + round * 4 * swiperSize;
        tz = swiperSize;
      } else if ((slideIndex - 3) % 4 === 0) {
        tx = -swiperSize;
        tz = 3 * swiperSize + swiperSize * 4 * round;
      }

      if (rtl) {
        tx = -tx;
      }

      if (!isHorizontal) {
        ty = tx;
        tx = 0;
      }

      var transform = "rotateX(".concat(isHorizontal ? 0 : -slideAngle, "deg) rotateY(").concat(isHorizontal ? slideAngle : 0, "deg) translate3d(").concat(tx, "px, ").concat(ty, "px, ").concat(tz, "px)");

      if (progress <= 1 && progress > -1) {
        wrapperRotate = slideIndex * 90 + progress * 90;
        if (rtl) wrapperRotate = -slideIndex * 90 - progress * 90;
      }

      $slideEl.transform(transform);

      if (params.slideShadows) {
        // Set shadows
        var shadowBefore = isHorizontal ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
        var shadowAfter = isHorizontal ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');

        if (shadowBefore.length === 0) {
          shadowBefore = dom("<div class=\"swiper-slide-shadow-".concat(isHorizontal ? 'left' : 'top', "\"></div>"));
          $slideEl.append(shadowBefore);
        }

        if (shadowAfter.length === 0) {
          shadowAfter = dom("<div class=\"swiper-slide-shadow-".concat(isHorizontal ? 'right' : 'bottom', "\"></div>"));
          $slideEl.append(shadowAfter);
        }

        if (shadowBefore.length) shadowBefore[0].style.opacity = Math.max(-progress, 0);
        if (shadowAfter.length) shadowAfter[0].style.opacity = Math.max(progress, 0);
      }
    }

    $wrapperEl.css({
      '-webkit-transform-origin': "50% 50% -".concat(swiperSize / 2, "px"),
      '-moz-transform-origin': "50% 50% -".concat(swiperSize / 2, "px"),
      '-ms-transform-origin': "50% 50% -".concat(swiperSize / 2, "px"),
      'transform-origin': "50% 50% -".concat(swiperSize / 2, "px")
    });

    if (params.shadow) {
      if (isHorizontal) {
        $cubeShadowEl.transform("translate3d(0px, ".concat(swiperWidth / 2 + params.shadowOffset, "px, ").concat(-swiperWidth / 2, "px) rotateX(90deg) rotateZ(0deg) scale(").concat(params.shadowScale, ")"));
      } else {
        var shadowAngle = Math.abs(wrapperRotate) - Math.floor(Math.abs(wrapperRotate) / 90) * 90;
        var multiplier = 1.5 - (Math.sin(shadowAngle * 2 * Math.PI / 360) / 2 + Math.cos(shadowAngle * 2 * Math.PI / 360) / 2);
        var scale1 = params.shadowScale;
        var scale2 = params.shadowScale / multiplier;
        var offset = params.shadowOffset;
        $cubeShadowEl.transform("scale3d(".concat(scale1, ", 1, ").concat(scale2, ") translate3d(0px, ").concat(swiperHeight / 2 + offset, "px, ").concat(-swiperHeight / 2 / scale2, "px) rotateX(-90deg)"));
      }
    }

    var zFactor = browser.isSafari || browser.isWebView ? -swiperSize / 2 : 0;
    $wrapperEl.transform("translate3d(0px,0,".concat(zFactor, "px) rotateX(").concat(swiper.isHorizontal() ? 0 : wrapperRotate, "deg) rotateY(").concat(swiper.isHorizontal() ? -wrapperRotate : 0, "deg)"));
  },
  setTransition: function setTransition(duration) {
    var swiper = this;
    var $el = swiper.$el,
        slides = swiper.slides;
    slides.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);

    if (swiper.params.cubeEffect.shadow && !swiper.isHorizontal()) {
      $el.find('.swiper-cube-shadow').transition(duration);
    }
  }
};
/* harmony default export */ const effect_cube = ({
  name: 'effect-cube',
  params: {
    cubeEffect: {
      slideShadows: true,
      shadow: true,
      shadowOffset: 20,
      shadowScale: 0.94
    }
  },
  create: function create() {
    var swiper = this;
    bindModuleMethods(swiper, {
      cubeEffect: effect_cube_objectSpread({}, Cube)
    });
  },
  on: {
    beforeInit: function beforeInit(swiper) {
      if (swiper.params.effect !== 'cube') return;
      swiper.classNames.push("".concat(swiper.params.containerModifierClass, "cube"));
      swiper.classNames.push("".concat(swiper.params.containerModifierClass, "3d"));
      var overwriteParams = {
        slidesPerView: 1,
        slidesPerColumn: 1,
        slidesPerGroup: 1,
        watchSlidesProgress: true,
        resistanceRatio: 0,
        spaceBetween: 0,
        centeredSlides: false,
        virtualTranslate: true
      };
      utils_extend(swiper.params, overwriteParams);
      utils_extend(swiper.originalParams, overwriteParams);
    },
    setTranslate: function setTranslate(swiper) {
      if (swiper.params.effect !== 'cube') return;
      swiper.cubeEffect.setTranslate();
    },
    setTransition: function setTransition(swiper, duration) {
      if (swiper.params.effect !== 'cube') return;
      swiper.cubeEffect.setTransition(duration);
    }
  }
});
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/effect-coverflow/effect-coverflow.js


function effect_coverflow_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function effect_coverflow_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? effect_coverflow_ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : effect_coverflow_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }



var Coverflow = {
  setTranslate: function setTranslate() {
    var swiper = this;
    var swiperWidth = swiper.width,
        swiperHeight = swiper.height,
        slides = swiper.slides,
        slidesSizesGrid = swiper.slidesSizesGrid;
    var params = swiper.params.coverflowEffect;
    var isHorizontal = swiper.isHorizontal();
    var transform = swiper.translate;
    var center = isHorizontal ? -transform + swiperWidth / 2 : -transform + swiperHeight / 2;
    var rotate = isHorizontal ? params.rotate : -params.rotate;
    var translate = params.depth; // Each slide offset from center

    for (var i = 0, length = slides.length; i < length; i += 1) {
      var $slideEl = slides.eq(i);
      var slideSize = slidesSizesGrid[i];
      var slideOffset = $slideEl[0].swiperSlideOffset;
      var offsetMultiplier = (center - slideOffset - slideSize / 2) / slideSize * params.modifier;
      var rotateY = isHorizontal ? rotate * offsetMultiplier : 0;
      var rotateX = isHorizontal ? 0 : rotate * offsetMultiplier; // var rotateZ = 0

      var translateZ = -translate * Math.abs(offsetMultiplier);
      var stretch = params.stretch; // Allow percentage to make a relative stretch for responsive sliders

      if (typeof stretch === 'string' && stretch.indexOf('%') !== -1) {
        stretch = parseFloat(params.stretch) / 100 * slideSize;
      }

      var translateY = isHorizontal ? 0 : stretch * offsetMultiplier;
      var translateX = isHorizontal ? stretch * offsetMultiplier : 0;
      var scale = 1 - (1 - params.scale) * Math.abs(offsetMultiplier); // Fix for ultra small values

      if (Math.abs(translateX) < 0.001) translateX = 0;
      if (Math.abs(translateY) < 0.001) translateY = 0;
      if (Math.abs(translateZ) < 0.001) translateZ = 0;
      if (Math.abs(rotateY) < 0.001) rotateY = 0;
      if (Math.abs(rotateX) < 0.001) rotateX = 0;
      if (Math.abs(scale) < 0.001) scale = 0;
      var slideTransform = "translate3d(".concat(translateX, "px,").concat(translateY, "px,").concat(translateZ, "px)  rotateX(").concat(rotateX, "deg) rotateY(").concat(rotateY, "deg) scale(").concat(scale, ")");
      $slideEl.transform(slideTransform);
      $slideEl[0].style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;

      if (params.slideShadows) {
        // Set shadows
        var $shadowBeforeEl = isHorizontal ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
        var $shadowAfterEl = isHorizontal ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');

        if ($shadowBeforeEl.length === 0) {
          $shadowBeforeEl = dom("<div class=\"swiper-slide-shadow-".concat(isHorizontal ? 'left' : 'top', "\"></div>"));
          $slideEl.append($shadowBeforeEl);
        }

        if ($shadowAfterEl.length === 0) {
          $shadowAfterEl = dom("<div class=\"swiper-slide-shadow-".concat(isHorizontal ? 'right' : 'bottom', "\"></div>"));
          $slideEl.append($shadowAfterEl);
        }

        if ($shadowBeforeEl.length) $shadowBeforeEl[0].style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0;
        if ($shadowAfterEl.length) $shadowAfterEl[0].style.opacity = -offsetMultiplier > 0 ? -offsetMultiplier : 0;
      }
    }
  },
  setTransition: function setTransition(duration) {
    var swiper = this;
    swiper.slides.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);
  }
};
/* harmony default export */ const effect_coverflow = ({
  name: 'effect-coverflow',
  params: {
    coverflowEffect: {
      rotate: 50,
      stretch: 0,
      depth: 100,
      scale: 1,
      modifier: 1,
      slideShadows: true
    }
  },
  create: function create() {
    var swiper = this;
    bindModuleMethods(swiper, {
      coverflowEffect: effect_coverflow_objectSpread({}, Coverflow)
    });
  },
  on: {
    beforeInit: function beforeInit(swiper) {
      if (swiper.params.effect !== 'coverflow') return;
      swiper.classNames.push("".concat(swiper.params.containerModifierClass, "coverflow"));
      swiper.classNames.push("".concat(swiper.params.containerModifierClass, "3d"));
      swiper.params.watchSlidesProgress = true;
      swiper.originalParams.watchSlidesProgress = true;
    },
    setTranslate: function setTranslate(swiper) {
      if (swiper.params.effect !== 'coverflow') return;
      swiper.coverflowEffect.setTranslate();
    },
    setTransition: function setTransition(swiper, duration) {
      if (swiper.params.effect !== 'coverflow') return;
      swiper.coverflowEffect.setTransition(duration);
    }
  }
});
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/controller/controller.js


function controller_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function controller_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? controller_ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : controller_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

/* eslint no-bitwise: ["error", { "allow": [">>"] }] */

var Controller = {
  LinearSpline: function LinearSpline(x, y) {
    var binarySearch = function search() {
      var maxIndex;
      var minIndex;
      var guess;
      return function (array, val) {
        minIndex = -1;
        maxIndex = array.length;

        while (maxIndex - minIndex > 1) {
          guess = maxIndex + minIndex >> 1;

          if (array[guess] <= val) {
            minIndex = guess;
          } else {
            maxIndex = guess;
          }
        }

        return maxIndex;
      };
    }();

    this.x = x;
    this.y = y;
    this.lastIndex = x.length - 1; // Given an x value (x2), return the expected y2 value:
    // (x1,y1) is the known point before given value,
    // (x3,y3) is the known point after given value.

    var i1;
    var i3;

    this.interpolate = function interpolate(x2) {
      if (!x2) return 0; // Get the indexes of x1 and x3 (the array indexes before and after given x2):

      i3 = binarySearch(this.x, x2);
      i1 = i3 - 1; // We have our indexes i1 & i3, so we can calculate already:
      // y2 := ((x2−x1) × (y3−y1)) ÷ (x3−x1) + y1

      return (x2 - this.x[i1]) * (this.y[i3] - this.y[i1]) / (this.x[i3] - this.x[i1]) + this.y[i1];
    };

    return this;
  },
  // xxx: for now i will just save one spline function to to
  getInterpolateFunction: function getInterpolateFunction(c) {
    var swiper = this;

    if (!swiper.controller.spline) {
      swiper.controller.spline = swiper.params.loop ? new Controller.LinearSpline(swiper.slidesGrid, c.slidesGrid) : new Controller.LinearSpline(swiper.snapGrid, c.snapGrid);
    }
  },
  setTranslate: function setTranslate(_setTranslate, byController) {
    var swiper = this;
    var controlled = swiper.controller.control;
    var multiplier;
    var controlledTranslate;
    var Swiper = swiper.constructor;

    function setControlledTranslate(c) {
      // this will create an Interpolate function based on the snapGrids
      // x is the Grid of the scrolled scroller and y will be the controlled scroller
      // it makes sense to create this only once and recall it for the interpolation
      // the function does a lot of value caching for performance
      var translate = swiper.rtlTranslate ? -swiper.translate : swiper.translate;

      if (swiper.params.controller.by === 'slide') {
        swiper.controller.getInterpolateFunction(c); // i am not sure why the values have to be multiplicated this way, tried to invert the snapGrid
        // but it did not work out

        controlledTranslate = -swiper.controller.spline.interpolate(-translate);
      }

      if (!controlledTranslate || swiper.params.controller.by === 'container') {
        multiplier = (c.maxTranslate() - c.minTranslate()) / (swiper.maxTranslate() - swiper.minTranslate());
        controlledTranslate = (translate - swiper.minTranslate()) * multiplier + c.minTranslate();
      }

      if (swiper.params.controller.inverse) {
        controlledTranslate = c.maxTranslate() - controlledTranslate;
      }

      c.updateProgress(controlledTranslate);
      c.setTranslate(controlledTranslate, swiper);
      c.updateActiveIndex();
      c.updateSlidesClasses();
    }

    if (Array.isArray(controlled)) {
      for (var i = 0; i < controlled.length; i += 1) {
        if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
          setControlledTranslate(controlled[i]);
        }
      }
    } else if (controlled instanceof Swiper && byController !== controlled) {
      setControlledTranslate(controlled);
    }
  },
  setTransition: function setTransition(duration, byController) {
    var swiper = this;
    var Swiper = swiper.constructor;
    var controlled = swiper.controller.control;
    var i;

    function setControlledTransition(c) {
      c.setTransition(duration, swiper);

      if (duration !== 0) {
        c.transitionStart();

        if (c.params.autoHeight) {
          nextTick(function () {
            c.updateAutoHeight();
          });
        }

        c.$wrapperEl.transitionEnd(function () {
          if (!controlled) return;

          if (c.params.loop && swiper.params.controller.by === 'slide') {
            c.loopFix();
          }

          c.transitionEnd();
        });
      }
    }

    if (Array.isArray(controlled)) {
      for (i = 0; i < controlled.length; i += 1) {
        if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
          setControlledTransition(controlled[i]);
        }
      }
    } else if (controlled instanceof Swiper && byController !== controlled) {
      setControlledTransition(controlled);
    }
  }
};
/* harmony default export */ const controller = ({
  name: 'controller',
  params: {
    controller: {
      control: undefined,
      inverse: false,
      by: 'slide' // or 'container'

    }
  },
  create: function create() {
    var swiper = this;
    bindModuleMethods(swiper, {
      controller: controller_objectSpread({
        control: swiper.params.controller.control
      }, Controller)
    });
  },
  on: {
    update: function update(swiper) {
      if (!swiper.controller.control) return;

      if (swiper.controller.spline) {
        swiper.controller.spline = undefined;
        delete swiper.controller.spline;
      }
    },
    resize: function resize(swiper) {
      if (!swiper.controller.control) return;

      if (swiper.controller.spline) {
        swiper.controller.spline = undefined;
        delete swiper.controller.spline;
      }
    },
    observerUpdate: function observerUpdate(swiper) {
      if (!swiper.controller.control) return;

      if (swiper.controller.spline) {
        swiper.controller.spline = undefined;
        delete swiper.controller.spline;
      }
    },
    setTranslate: function setTranslate(swiper, translate, byController) {
      if (!swiper.controller.control) return;
      swiper.controller.setTranslate(translate, byController);
    },
    setTransition: function setTransition(swiper, duration, byController) {
      if (!swiper.controller.control) return;
      swiper.controller.setTransition(duration, byController);
    }
  }
});
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/autoplay/autoplay.js


function autoplay_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function autoplay_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? autoplay_ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : autoplay_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

/* eslint no-underscore-dangle: "off" */


var Autoplay = {
  run: function run() {
    var swiper = this;
    var $activeSlideEl = swiper.slides.eq(swiper.activeIndex);
    var delay = swiper.params.autoplay.delay;

    if ($activeSlideEl.attr('data-swiper-autoplay')) {
      delay = $activeSlideEl.attr('data-swiper-autoplay') || swiper.params.autoplay.delay;
    }

    clearTimeout(swiper.autoplay.timeout);
    swiper.autoplay.timeout = nextTick(function () {
      var autoplayResult;

      if (swiper.params.autoplay.reverseDirection) {
        if (swiper.params.loop) {
          swiper.loopFix();
          autoplayResult = swiper.slidePrev(swiper.params.speed, true, true);
          swiper.emit('autoplay');
        } else if (!swiper.isBeginning) {
          autoplayResult = swiper.slidePrev(swiper.params.speed, true, true);
          swiper.emit('autoplay');
        } else if (!swiper.params.autoplay.stopOnLastSlide) {
          autoplayResult = swiper.slideTo(swiper.slides.length - 1, swiper.params.speed, true, true);
          swiper.emit('autoplay');
        } else {
          swiper.autoplay.stop();
        }
      } else if (swiper.params.loop) {
        swiper.loopFix();
        autoplayResult = swiper.slideNext(swiper.params.speed, true, true);
        swiper.emit('autoplay');
      } else if (!swiper.isEnd) {
        autoplayResult = swiper.slideNext(swiper.params.speed, true, true);
        swiper.emit('autoplay');
      } else if (!swiper.params.autoplay.stopOnLastSlide) {
        autoplayResult = swiper.slideTo(0, swiper.params.speed, true, true);
        swiper.emit('autoplay');
      } else {
        swiper.autoplay.stop();
      }

      if (swiper.params.cssMode && swiper.autoplay.running) swiper.autoplay.run();else if (autoplayResult === false) {
        swiper.autoplay.run();
      }
    }, delay);
  },
  start: function start() {
    var swiper = this;
    if (typeof swiper.autoplay.timeout !== 'undefined') return false;
    if (swiper.autoplay.running) return false;
    swiper.autoplay.running = true;
    swiper.emit('autoplayStart');
    swiper.autoplay.run();
    return true;
  },
  stop: function stop() {
    var swiper = this;
    if (!swiper.autoplay.running) return false;
    if (typeof swiper.autoplay.timeout === 'undefined') return false;

    if (swiper.autoplay.timeout) {
      clearTimeout(swiper.autoplay.timeout);
      swiper.autoplay.timeout = undefined;
    }

    swiper.autoplay.running = false;
    swiper.emit('autoplayStop');
    return true;
  },
  pause: function pause(speed) {
    var swiper = this;
    if (!swiper.autoplay.running) return;
    if (swiper.autoplay.paused) return;
    if (swiper.autoplay.timeout) clearTimeout(swiper.autoplay.timeout);
    swiper.autoplay.paused = true;

    if (speed === 0 || !swiper.params.autoplay.waitForTransition) {
      swiper.autoplay.paused = false;
      swiper.autoplay.run();
    } else {
      swiper.$wrapperEl[0].addEventListener('transitionend', swiper.autoplay.onTransitionEnd);
      swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.autoplay.onTransitionEnd);
    }
  },
  onVisibilityChange: function onVisibilityChange() {
    var swiper = this;
    var document = getDocument();

    if (document.visibilityState === 'hidden' && swiper.autoplay.running) {
      swiper.autoplay.pause();
    }

    if (document.visibilityState === 'visible' && swiper.autoplay.paused) {
      swiper.autoplay.run();
      swiper.autoplay.paused = false;
    }
  },
  onTransitionEnd: function onTransitionEnd(e) {
    var swiper = this;
    if (!swiper || swiper.destroyed || !swiper.$wrapperEl) return;
    if (e.target !== swiper.$wrapperEl[0]) return;
    swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.autoplay.onTransitionEnd);
    swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.autoplay.onTransitionEnd);
    swiper.autoplay.paused = false;

    if (!swiper.autoplay.running) {
      swiper.autoplay.stop();
    } else {
      swiper.autoplay.run();
    }
  }
};
/* harmony default export */ const autoplay = ({
  name: 'autoplay',
  params: {
    autoplay: {
      enabled: false,
      delay: 3000,
      waitForTransition: true,
      disableOnInteraction: true,
      stopOnLastSlide: false,
      reverseDirection: false
    }
  },
  create: function create() {
    var swiper = this;
    bindModuleMethods(swiper, {
      autoplay: autoplay_objectSpread(autoplay_objectSpread({}, Autoplay), {}, {
        running: false,
        paused: false
      })
    });
  },
  on: {
    init: function init(swiper) {
      if (swiper.params.autoplay.enabled) {
        swiper.autoplay.start();
        var document = getDocument();
        document.addEventListener('visibilitychange', swiper.autoplay.onVisibilityChange);
      }
    },
    beforeTransitionStart: function beforeTransitionStart(swiper, speed, internal) {
      if (swiper.autoplay.running) {
        if (internal || !swiper.params.autoplay.disableOnInteraction) {
          swiper.autoplay.pause(speed);
        } else {
          swiper.autoplay.stop();
        }
      }
    },
    sliderFirstMove: function sliderFirstMove(swiper) {
      if (swiper.autoplay.running) {
        if (swiper.params.autoplay.disableOnInteraction) {
          swiper.autoplay.stop();
        } else {
          swiper.autoplay.pause();
        }
      }
    },
    touchEnd: function touchEnd(swiper) {
      if (swiper.params.cssMode && swiper.autoplay.paused && !swiper.params.autoplay.disableOnInteraction) {
        swiper.autoplay.run();
      }
    },
    destroy: function destroy(swiper) {
      if (swiper.autoplay.running) {
        swiper.autoplay.stop();
      }

      var document = getDocument();
      document.removeEventListener('visibilitychange', swiper.autoplay.onVisibilityChange);
    }
  }
});
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/a11y/a11y.js


function a11y_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function a11y_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? a11y_ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : a11y_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }



var A11y = {
  getRandomNumber: function getRandomNumber() {
    var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 16;

    var randomChar = function randomChar() {
      return Math.round(16 * Math.random()).toString(16);
    };

    return 'x'.repeat(size).replace(/x/g, randomChar);
  },
  makeElFocusable: function makeElFocusable($el) {
    $el.attr('tabIndex', '0');
    return $el;
  },
  makeElNotFocusable: function makeElNotFocusable($el) {
    $el.attr('tabIndex', '-1');
    return $el;
  },
  addElRole: function addElRole($el, role) {
    $el.attr('role', role);
    return $el;
  },
  addElRoleDescription: function addElRoleDescription($el, description) {
    $el.attr('aria-roledescription', description);
    return $el;
  },
  addElControls: function addElControls($el, controls) {
    $el.attr('aria-controls', controls);
    return $el;
  },
  addElLabel: function addElLabel($el, label) {
    $el.attr('aria-label', label);
    return $el;
  },
  addElId: function addElId($el, id) {
    $el.attr('id', id);
    return $el;
  },
  addElLive: function addElLive($el, live) {
    $el.attr('aria-live', live);
    return $el;
  },
  disableEl: function disableEl($el) {
    $el.attr('aria-disabled', true);
    return $el;
  },
  enableEl: function enableEl($el) {
    $el.attr('aria-disabled', false);
    return $el;
  },
  onEnterOrSpaceKey: function onEnterOrSpaceKey(e) {
    if (e.keyCode !== 13 && e.keyCode !== 32) return;
    var swiper = this;
    var params = swiper.params.a11y;
    var $targetEl = dom(e.target);

    if (swiper.navigation && swiper.navigation.$nextEl && $targetEl.is(swiper.navigation.$nextEl)) {
      if (!(swiper.isEnd && !swiper.params.loop)) {
        swiper.slideNext();
      }

      if (swiper.isEnd) {
        swiper.a11y.notify(params.lastSlideMessage);
      } else {
        swiper.a11y.notify(params.nextSlideMessage);
      }
    }

    if (swiper.navigation && swiper.navigation.$prevEl && $targetEl.is(swiper.navigation.$prevEl)) {
      if (!(swiper.isBeginning && !swiper.params.loop)) {
        swiper.slidePrev();
      }

      if (swiper.isBeginning) {
        swiper.a11y.notify(params.firstSlideMessage);
      } else {
        swiper.a11y.notify(params.prevSlideMessage);
      }
    }

    if (swiper.pagination && $targetEl.is(classesToSelector(swiper.params.pagination.bulletClass))) {
      $targetEl[0].click();
    }
  },
  notify: function notify(message) {
    var swiper = this;
    var notification = swiper.a11y.liveRegion;
    if (notification.length === 0) return;
    notification.html('');
    notification.html(message);
  },
  updateNavigation: function updateNavigation() {
    var swiper = this;
    if (swiper.params.loop || !swiper.navigation) return;
    var _swiper$navigation = swiper.navigation,
        $nextEl = _swiper$navigation.$nextEl,
        $prevEl = _swiper$navigation.$prevEl;

    if ($prevEl && $prevEl.length > 0) {
      if (swiper.isBeginning) {
        swiper.a11y.disableEl($prevEl);
        swiper.a11y.makeElNotFocusable($prevEl);
      } else {
        swiper.a11y.enableEl($prevEl);
        swiper.a11y.makeElFocusable($prevEl);
      }
    }

    if ($nextEl && $nextEl.length > 0) {
      if (swiper.isEnd) {
        swiper.a11y.disableEl($nextEl);
        swiper.a11y.makeElNotFocusable($nextEl);
      } else {
        swiper.a11y.enableEl($nextEl);
        swiper.a11y.makeElFocusable($nextEl);
      }
    }
  },
  updatePagination: function updatePagination() {
    var swiper = this;
    var params = swiper.params.a11y;

    if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {
      swiper.pagination.bullets.each(function (bulletEl) {
        var $bulletEl = dom(bulletEl);
        swiper.a11y.makeElFocusable($bulletEl);

        if (!swiper.params.pagination.renderBullet) {
          swiper.a11y.addElRole($bulletEl, 'button');
          swiper.a11y.addElLabel($bulletEl, params.paginationBulletMessage.replace(/\{\{index\}\}/, $bulletEl.index() + 1));
        }
      });
    }
  },
  init: function init() {
    var swiper = this;
    var params = swiper.params.a11y;
    swiper.$el.append(swiper.a11y.liveRegion); // Container

    var $containerEl = swiper.$el;

    if (params.containerRoleDescriptionMessage) {
      swiper.a11y.addElRoleDescription($containerEl, params.containerRoleDescriptionMessage);
    }

    if (params.containerMessage) {
      swiper.a11y.addElLabel($containerEl, params.containerMessage);
    } // Wrapper


    var $wrapperEl = swiper.$wrapperEl;
    var wrapperId = $wrapperEl.attr('id') || "swiper-wrapper-".concat(swiper.a11y.getRandomNumber(16));
    var live;
    swiper.a11y.addElId($wrapperEl, wrapperId);

    if (swiper.params.autoplay && swiper.params.autoplay.enabled) {
      live = 'off';
    } else {
      live = 'polite';
    }

    swiper.a11y.addElLive($wrapperEl, live); // Slide

    if (params.itemRoleDescriptionMessage) {
      swiper.a11y.addElRoleDescription(dom(swiper.slides), params.itemRoleDescriptionMessage);
    }

    swiper.a11y.addElRole(dom(swiper.slides), params.slideRole);
    swiper.slides.each(function (slideEl) {
      var $slideEl = dom(slideEl);
      var ariaLabelMessage = params.slideLabelMessage.replace(/\{\{index\}\}/, $slideEl.index() + 1).replace(/\{\{slidesLength\}\}/, swiper.slides.length);
      swiper.a11y.addElLabel($slideEl, ariaLabelMessage);
    }); // Navigation

    var $nextEl;
    var $prevEl;

    if (swiper.navigation && swiper.navigation.$nextEl) {
      $nextEl = swiper.navigation.$nextEl;
    }

    if (swiper.navigation && swiper.navigation.$prevEl) {
      $prevEl = swiper.navigation.$prevEl;
    }

    if ($nextEl && $nextEl.length) {
      swiper.a11y.makeElFocusable($nextEl);

      if ($nextEl[0].tagName !== 'BUTTON') {
        swiper.a11y.addElRole($nextEl, 'button');
        $nextEl.on('keydown', swiper.a11y.onEnterOrSpaceKey);
      }

      swiper.a11y.addElLabel($nextEl, params.nextSlideMessage);
      swiper.a11y.addElControls($nextEl, wrapperId);
    }

    if ($prevEl && $prevEl.length) {
      swiper.a11y.makeElFocusable($prevEl);

      if ($prevEl[0].tagName !== 'BUTTON') {
        swiper.a11y.addElRole($prevEl, 'button');
        $prevEl.on('keydown', swiper.a11y.onEnterOrSpaceKey);
      }

      swiper.a11y.addElLabel($prevEl, params.prevSlideMessage);
      swiper.a11y.addElControls($prevEl, wrapperId);
    } // Pagination


    if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {
      swiper.pagination.$el.on('keydown', classesToSelector(swiper.params.pagination.bulletClass), swiper.a11y.onEnterOrSpaceKey);
    }
  },
  destroy: function destroy() {
    var swiper = this;
    if (swiper.a11y.liveRegion && swiper.a11y.liveRegion.length > 0) swiper.a11y.liveRegion.remove();
    var $nextEl;
    var $prevEl;

    if (swiper.navigation && swiper.navigation.$nextEl) {
      $nextEl = swiper.navigation.$nextEl;
    }

    if (swiper.navigation && swiper.navigation.$prevEl) {
      $prevEl = swiper.navigation.$prevEl;
    }

    if ($nextEl) {
      $nextEl.off('keydown', swiper.a11y.onEnterOrSpaceKey);
    }

    if ($prevEl) {
      $prevEl.off('keydown', swiper.a11y.onEnterOrSpaceKey);
    } // Pagination


    if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {
      swiper.pagination.$el.off('keydown', classesToSelector(swiper.params.pagination.bulletClass), swiper.a11y.onEnterOrSpaceKey);
    }
  }
};
/* harmony default export */ const a11y = ({
  name: 'a11y',
  params: {
    a11y: {
      enabled: true,
      notificationClass: 'swiper-notification',
      prevSlideMessage: 'Previous slide',
      nextSlideMessage: 'Next slide',
      firstSlideMessage: 'This is the first slide',
      lastSlideMessage: 'This is the last slide',
      paginationBulletMessage: 'Go to slide {{index}}',
      slideLabelMessage: '{{index}} / {{slidesLength}}',
      containerMessage: null,
      containerRoleDescriptionMessage: null,
      itemRoleDescriptionMessage: null,
      slideRole: 'group'
    }
  },
  create: function create() {
    var swiper = this;
    bindModuleMethods(swiper, {
      a11y: a11y_objectSpread(a11y_objectSpread({}, A11y), {}, {
        liveRegion: dom("<span class=\"".concat(swiper.params.a11y.notificationClass, "\" aria-live=\"assertive\" aria-atomic=\"true\"></span>"))
      })
    });
  },
  on: {
    afterInit: function afterInit(swiper) {
      if (!swiper.params.a11y.enabled) return;
      swiper.a11y.init();
      swiper.a11y.updateNavigation();
    },
    toEdge: function toEdge(swiper) {
      if (!swiper.params.a11y.enabled) return;
      swiper.a11y.updateNavigation();
    },
    fromEdge: function fromEdge(swiper) {
      if (!swiper.params.a11y.enabled) return;
      swiper.a11y.updateNavigation();
    },
    paginationUpdate: function paginationUpdate(swiper) {
      if (!swiper.params.a11y.enabled) return;
      swiper.a11y.updatePagination();
    },
    destroy: function destroy(swiper) {
      if (!swiper.params.a11y.enabled) return;
      swiper.a11y.destroy();
    }
  }
});
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/swiper.js
// Swiper Class
 //IMPORT_COMPONENTS




















var components = [virtual, keyboard, mousewheel, navigation, pagination, scrollbar, parallax, zoom, lazy, controller, a11y, history_history, hash_navigation, autoplay, effect_fade, effect_cube, effect_flip, effect_coverflow, thumbs];
core_class.use(components); //EXPORT

/* harmony default export */ const swiper = (core_class);
;// CONCATENATED MODULE: ./src/components/swiper/js/index.js





/* 
 *************************************
 * <!-- Swiper -->
 *************************************
 */
 //IMPORT_DEFAULT

 //IMPORT_COMPONENTS














 //


var SWIPER = function (module, $, window, document) {
  if (window.SWIPER === null) return false;
  module.SWIPER = module.SWIPER || {};
  module.SWIPER.version = '0.0.6';

  module.SWIPER.documentReady = function ($) {
    $('.uix-swiper').each(function () {
      var $el = $(this);
      var actived = $el.data('activated');

      if ((0,esm_typeof/* default */.Z)(actived) === ( true ? "undefined" : 0)) {
        //Synchronize multiple objects
        //------------------------------------------
        if ($el.find('#app-slider1').length > 0) {
          var swiper2 = new swiper('#app-slider2', {
            slidesPerView: 5,
            spaceBetween: 10,
            allowTouchMove: false
          });
          var swiper1 = new swiper('#app-slider1', {
            slidesPerView: 1,
            spaceBetween: 10,
            speed: 1000,
            pagination: {
              el: '.swiper-pagination',
              clickable: true,
              renderBullet: function renderBullet(index, className) {
                return '<span class="' + className + '">' + (index + 1) + '</span>';
              }
            },
            navigation: {
              nextEl: '.swiper-button-next',
              prevEl: '.swiper-button-prev'
            },
            breakpoints: {
              640: {
                slidesPerView: 2,
                spaceBetween: 20
              },
              768: {
                slidesPerView: 4,
                spaceBetween: 40
              },
              1024: {
                slidesPerView: 5,
                spaceBetween: 50
              }
            }
          }); //Sync swiper slider

          swiper1.on('slideChange', function () {
            var index = this.activeIndex;
            swiper2.slideTo(index, 1000, false);
          });
        } //Swiper custom slides transform effect (Parallax effect)
        //------------------------------------------


        if ($el.find('#app-slider3').length > 0) {
          var interleaveOffset = 0.5;
          var swiper3 = new swiper('#app-slider3', {
            slidesPerView: 1,
            spaceBetween: 0,
            loop: false,
            speed: 1000,
            grabCursor: false,
            watchSlidesProgress: true,
            mousewheelControl: false,
            keyboardControl: false,
            pagination: {
              el: '.swiper-pagination',
              clickable: true,
              renderBullet: function renderBullet(index, className) {
                return '<span class="' + className + '">' + (index + 1) + '</span>';
              }
            },
            navigation: {
              nextEl: '.swiper-button-next',
              prevEl: '.swiper-button-prev'
            },
            on: {
              progress: function progress(e) {
                var thisSwiper = this;

                for (var i = 0; i < thisSwiper.slides.length; i++) {
                  var slideProgress = thisSwiper.slides[i].progress;
                  var innerOffset = thisSwiper.width * interleaveOffset;
                  var innerTranslate = slideProgress * innerOffset;
                  thisSwiper.slides[i].querySelector(".slide-inner").style.transform = "translate3d(" + innerTranslate + "px, 0, 0)"; //console.log( e.passedParams );
                }
              },
              touchStart: function touchStart(e) {
                var passedParams = e.passedParams;
                var thisSwiper = this;

                for (var i = 0; i < thisSwiper.slides.length; i++) {
                  thisSwiper.slides[i].style.transition = "";
                }
              },
              setTransition: function setTransition(e) {
                var passedParams = e.passedParams;
                var thisSwiper = this;

                for (var i = 0; i < thisSwiper.slides.length; i++) {
                  thisSwiper.slides[i].style.transition = passedParams.speed + "ms";
                  thisSwiper.slides[i].querySelector(".slide-inner").style.transition = passedParams.speed + "ms";
                }
              }
            }
          }); //AutoPlay

          swiper3.autoplay.start(); //swiper3.autoplay.stop();			
        } //Swiper custom slides transform effect (Scale Effect without left/right swipe)
        //------------------------------------------


        if ($el.find('#app-slider4').length > 0) {
          var swiper4 = new swiper('#app-slider4', {
            slidesPerView: 1,
            spaceBetween: 0,
            loop: false,
            speed: 1000,
            grabCursor: false,
            watchSlidesProgress: true,
            mousewheelControl: false,
            keyboardControl: false,
            virtualTranslate: true,

            /* Required */
            pagination: {
              el: '.swiper-pagination',
              clickable: true,
              renderBullet: function renderBullet(index, className) {
                return '<span class="' + className + '">' + (index + 1) + '</span>';
              }
            },
            navigation: {
              nextEl: '.swiper-button-next',
              prevEl: '.swiper-button-prev'
            },
            on: {
              progress: function progress(translate) {
                var thisSwiper = this;

                for (var i = 0; i < thisSwiper.slides.length; i++) {
                  var slideProgress = thisSwiper.slides[i].progress;
                  console.log(translate.params);
                }
              },
              touchStart: function touchStart(translate) {
                var params = translate.params;
                var thisSwiper = this;
              },
              setTransition: function setTransition(translate) {
                var params = translate.params;
                var thisSwiper = this;
              },
              setTranslate: function setTranslate(translate) {
                var params = translate.params;
                var thisSwiper = this;
                /*
                A weird way to find this out but I've found no other.
                Checks if the progress on the active slide is 1 or -1 which happens when swiper navigates to next/previous slide on click and keybord navigation.
                If not then the slider is being dragged, so we get the right index by finding the startTranslate from touchEvents in array of transitions the swiper snaps to.
                The startTranslate doesn't exist on initial load so we use the initialSlide index instead.
                */

                var getActiveIndexBeforeTransitionStart = function getActiveIndexBeforeTransitionStart(curSwiper, curSlides) {
                  var isDragging = !Math.abs(curSlides[curSwiper.activeIndex].progress === 1);

                  if (isDragging) {
                    return curSwiper.slidesGrid.indexOf(-curSwiper.touchEventsData.startTranslate || curSwiper.params.initialSlide);
                  } else {
                    return curSwiper.activeIndex;
                  }
                };

                var getDirection = function getDirection(animationProgress) {
                  if (animationProgress === 0) {
                    return "NONE";
                  } else if (animationProgress > 0) {
                    return "NEXT";
                  } else {
                    return "BACK";
                  }
                };

                var durationInSeconds = params.speed / 1000; // convert slides object to plain array

                var slides = thisSwiper.slides; // get the index of the slide active before transition start (activeIndex changes halfway when dragging)

                var originIndex = getActiveIndexBeforeTransitionStart(thisSwiper, slides); // get information about animation progress from the active slide - the active slide's value is always -1 to 1.

                /* 
                every slide has a progress attribute equal to the "distance" from the current active index.
                */

                var animationProgress = slides[originIndex].progress; // you can then get the drag direction like so:

                var direction = getDirection(animationProgress); // console.log(direction);
                // do magic with each slide

                slides.map(function (perSlide, index) {
                  // to put the slides behind each other we have to set their CSS translate accordingly since by default they are arranged in line.
                  var offset = perSlide.swiperSlideOffset;
                  var x = -offset;
                  if (!thisSwiper.params.virtualTranslate) x -= thisSwiper.translate;
                  var y = 0;

                  if (!thisSwiper.isHorizontal()) {
                    y = x;
                    x = 0;
                  }

                  TweenMax.set(perSlide, {
                    x: x,
                    y: y
                  }); // do our animation stuff!

                  var clip = function clip(val, min, max) {
                    return Math.max(min, Math.min(val, max));
                  };

                  var ZOOM_FACTOR = 0.05;
                  var opacity = Math.max(1 - Math.abs(perSlide.progress), 0);
                  var clippedProgress = clip(perSlide.progress, -1, 1);
                  var scale = 1 - ZOOM_FACTOR * clippedProgress; // you can do your CSS animation instead of using tweening.

                  TweenMax.to(perSlide, durationInSeconds, {
                    scale: scale,
                    opacity: opacity
                  });
                });
              }
            }
          }); //AutoPlay

          swiper4.autoplay.start(); //swiper4.autoplay.stop();			
        } //Centered Slides
        //------------------------------------------	


        if ($el.find('#app-slider5').length > 0) {
          var swiper5 = new swiper('#app-slider5', {
            slidesPerView: 3,
            spaceBetween: 30,
            loop: true,
            speed: 1000,
            centeredSlides: true,
            pagination: {
              el: '.swiper-pagination',
              clickable: true,
              renderBullet: function renderBullet(index, className) {
                return '<span class="' + className + '">' + (index + 1) + '</span>';
              }
            },
            navigation: {
              nextEl: '.swiper-button-next',
              prevEl: '.swiper-button-prev'
            }
          });
        } //Display half on both sides
        //------------------------------------------		


        if ($el.find('#app-slider6').length > 0) {
          var swiper6 = new swiper('#app-slider6', {
            slidesPerView: 'auto',
            //Number of slides per view, and it must be "auto"!
            spaceBetween: 30,
            loop: true,
            speed: 1000,
            centeredSlides: true,
            //If true, then active slide will be centered, not always on the left side.
            pagination: {
              el: '.swiper-pagination',
              clickable: true,
              renderBullet: function renderBullet(index, className) {
                return '<span class="' + className + '">' + (index + 1) + '</span>';
              }
            },
            navigation: {
              nextEl: '.swiper-button-next',
              prevEl: '.swiper-button-prev'
            }
          });
        } //Custom Progress Bar
        //------------------------------------------


        if ($el.find('#app-slider7').length > 0) {
          var cusProgressBar = function cusProgressBar(speed, length, curIndex) {
            TweenMax.set('#app-slider7__progress', {
              width: 0,
              onComplete: function onComplete() {
                TweenMax.to('#app-slider7__progress', speed / 1000, {
                  width: '100%'
                });
              }
            });
            TweenMax.set('#app-slider7__progress2', {
              width: 100 / length * curIndex + '%',
              onComplete: function onComplete() {
                TweenMax.to('#app-slider7__progress2', speed / 1000, {
                  width: 100 / length * (curIndex + 1) + '%'
                });
              }
            });
          };

          var swiper7 = new swiper('#app-slider7', {
            slidesPerView: 1,
            spaceBetween: 0,
            loop: false,
            speed: 3500,
            grabCursor: false,
            watchSlidesProgress: true,
            mousewheelControl: false,
            keyboardControl: false,
            pagination: {
              el: '.swiper-pagination',
              clickable: true,
              renderBullet: function renderBullet(index, className) {
                return '<span class="' + className + '">' + (index + 1) + '</span>';
              }
            },
            navigation: {
              nextEl: '.swiper-button-next',
              prevEl: '.swiper-button-prev'
            },
            on: {
              init: function init(e) {
                var thisSwiper = this;
                console.log('current index: ' + thisSwiper.activeIndex);
                cusProgressBar(e.passedParams.speed, thisSwiper.slides.length, thisSwiper.activeIndex);
              },
              slideChange: function slideChange(e) {
                var thisSwiper = this;
                console.log('current index: ' + thisSwiper.activeIndex);
                cusProgressBar(e.passedParams.speed, thisSwiper.slides.length, thisSwiper.activeIndex);
              }
            }
          });
        } //Gallery with center thumbs automatically
        //------------------------------------------


        if ($el.find('#app-slider8').length > 0) {
          var swiper8 = new swiper('#app-slider8', {
            spaceBetween: 10,
            grabCursor: false,
            loop: true,
            loopedSlides: 4,
            autoplay: {
              delay: 5000
            },
            // other parameters
            on: {
              click: function click() {
                /* do something */
              }
            },
            keyboard: {
              enabled: true,
              onlyInViewport: false
            },
            autoHeight: true,
            pagination: {
              el: '.swiper-pagination',
              clickable: true,
              renderBullet: function renderBullet(index, className) {
                return '<span class="' + className + '">' + (index + 1) + '</span>';
              }
            },
            navigation: {
              nextEl: '.swiper-button-next',
              prevEl: '.swiper-button-prev'
            },
            speed: 1000
          });
          /* thumbs */

          var swiper8Thumbs = new swiper('#app-slider8-thumbs', {
            spaceBetween: 10,
            centeredSlides: true,
            slidesPerView: "auto",
            //If you use it with "auto" value and along with loop: true then you need to specify loopedSlides parameter with amount of slides to loop (duplicate)
            touchRatio: 0.4,
            slideToClickedSlide: true,
            loop: true,
            loopedSlides: 4,
            keyboard: {
              enabled: true,
              onlyInViewport: false
            },
            speed: 1000
          });
          /* set conteoller  */

          swiper8.controller.control = swiper8Thumbs;
          swiper8Thumbs.controller.control = swiper8;
        } //Gallery with manual triggers
        //------------------------------------------


        if ($el.find('#app-slider9').length > 0) {
          var swiper9BTN = function swiper9BTN(index, init) {
            var _btns = $('#app-slider9-triggers > div');

            _btns.removeClass('is-active');

            _btns.eq(index).addClass('is-active');

            if (!init) {
              swiper9.slideTo(index, 1000);
            }
          };

          var swiper9 = new swiper('#app-slider9', _defineProperty({
            spaceBetween: 10,
            grabCursor: false,
            autoplay: {
              delay: 5000
            },
            // other parameters
            on: {
              click: function click() {
                /* do something */
              }
            },
            keyboard: {
              enabled: true,
              onlyInViewport: false
            },
            autoHeight: true,
            pagination: {
              el: '.swiper-pagination',
              clickable: true,
              renderBullet: function renderBullet(index, className) {
                return '<span class="' + className + '">' + (index + 1) + '</span>';
              }
            },
            navigation: {
              nextEl: '.swiper-button-next',
              prevEl: '.swiper-button-prev'
            },
            speed: 1000
          }, "on", {
            init: function init(e) {
              var thisSwiper = this;
              swiper9BTN(thisSwiper.activeIndex, true);
            }
          })); //Sync swiper slider

          swiper9.on('slideChange', function () {
            var index = this.activeIndex;
            swiper9BTN(index, false);
          });
          $('#app-slider9-triggers > div').on('click', function () {
            swiper9BTN($(this).index(), false);
          });
        } //------------------------------------------
        //Prevents front-end javascripts that are activated in the background to repeat loading.


        $el.data('activated', 1);
      } //endif actived

    });
  };

  module.components.documentReady.push(module.SWIPER.documentReady);
  return /*#__PURE__*/_createClass(function SWIPER() {
    _classCallCheck(this, SWIPER);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/_third-party-plugins/THREE/esm/extensions/ShaderRuntime.custom.js
var defaultThreeUniforms = (/* unused pure expression or super */ null && (['normalMatrix', 'viewMatrix', 'projectionMatrix', 'position', 'normal', 'modelViewMatrix', 'uv', 'uv2', 'modelMatrix']));

function ShaderRuntime() {}

ShaderRuntime.prototype = {
  mainCamera: null,
  cubeCameras: {},
  reserved: {
    time: null,
    cameraPosition: null
  },
  umap: {
    "float": {
      type: 'f',
      value: 0
    },
    "int": {
      type: 'i',
      value: 0
    },
    vec2: {
      type: 'v2',
      value: function value() {
        return new THREE.Vector2();
      }
    },
    vec3: {
      type: 'v3',
      value: function value() {
        return new THREE.Vector3();
      }
    },
    vec4: {
      type: 'v4',
      value: function value() {
        return new THREE.Vector4();
      }
    },
    samplerCube: {
      type: 't'
    },
    sampler2D: {
      type: 't'
    }
  },
  getUmap: function getUmap(type) {
    var value = this.umap[type].value;
    return typeof value === 'function' ? value() : value;
  },
  load: function load(sourceOrSources, callback) {
    var _this = this;

    var sources = sourceOrSources,
        onlyOneSource = typeof sourceOrSources === 'string';

    if (onlyOneSource) {
      sources = [sourceOrSources];
    }

    var loadedShaders = new Array(sources.length),
        itemsLoaded = 0;

    var loadSource = function loadSource(index, source) {
      var loader = new THREE.FileLoader();
      loader.load(source, function (json) {
        var parsed;

        try {
          parsed = JSON.parse(json);
          delete parsed.id; // Errors if passed to rawshadermaterial :(
        } catch (e) {
          throw new Error('Could not parse shader' + source + '! Please verify the URL is correct.');
        }

        _this.add(parsed.name, parsed);

        loadedShaders[index] = parsed;

        if (++itemsLoaded === sources.length) {
          callback(onlyOneSource ? loadedShaders[0] : loadedShaders);
        }
      });
    };

    for (var x = 0; x < sources.length; x++) {
      loadSource(x, sources[x]);
    }
  },
  //Load json code directly
  loadJSON: function load(sourceOrSources, callback) {
    var _this = this;

    var sources = sourceOrSources,
        onlyOneSource = typeof sourceOrSources === 'string';

    if (onlyOneSource) {
      sources = [sourceOrSources];
    }

    var loadedShaders = new Array(sources.length),
        itemsLoaded = 0;

    var loadJSONCode = function loadJSONCode(index, source) {
      var parsed;
      parsed = source;
      delete parsed.id; // Errors if passed to rawshadermaterial :(

      _this.add(parsed.name, parsed);

      loadedShaders[index] = parsed;

      if (++itemsLoaded === sources.length) {
        callback(onlyOneSource ? loadedShaders[0] : loadedShaders);
      }
    };

    for (var x = 0; x < sources.length; x++) {
      loadJSONCode(x, sources[x]);
    }
  },
  registerCamera: function registerCamera(camera) {
    if (!(camera instanceof THREE.Camera)) {
      throw new Error('Cannot register a non-camera as a camera!');
    }

    this.mainCamera = camera;
  },
  registerCubeCamera: function registerCubeCamera(name, camera) {
    if (!camera.renderTarget) {
      throw new Error('Cannot register a non-camera as a camera!');
    }

    this.cubeCameras[name] = camera;
  },
  unregisterCamera: function unregisterCamera(name) {
    if (name in this.cubeCameras) {
      delete this.cubeCameras[name];
    } else if (name === this.mainCamera) {
      delete this.mainCamera;
    } else {
      throw new Error('You never registered camera ' + name);
    }
  },
  updateSource: function updateSource(identifier, config, findBy) {
    findBy = findBy || 'name';

    if (!this.shaderTypes[identifier]) {
      throw new Error('Runtime Error: Cannot update shader ' + identifier + ' because it has not been added.');
    }

    var newShaderData = this.add(identifier, config),
        shader,
        x;

    for (x = 0; shader = this.runningShaders[x++];) {
      if (shader[findBy] === identifier) {
        ShaderRuntime_custom_extend(shader.material, omit(newShaderData, 'id'));
        shader.material.needsUpdate = true;
      }
    }
  },
  renameShader: function renameShader(oldName, newName) {
    var x, shader;

    if (!(oldName in this.shaderTypes)) {
      throw new Error('Could not rename shader ' + oldName + ' to ' + newName + '. It does not exist.');
    }

    this.shaderTypes[newName] = this.shaderTypes[oldName];
    delete this.shaderTypes[oldName];

    for (x = 0; shader = this.runningShaders[x++];) {
      if (shader.name === oldName) {
        shader.name = newName;
      }
    }
  },
  get: function get(identifier) {
    var shaderType = this.shaderTypes[identifier];

    if (!shaderType.initted) {
      this.create(identifier);
    }

    return shaderType.material;
  },
  add: function add(shaderName, config) {
    var newData = clone(config),
        uniform;
    newData.fragmentShader = config.fragment;
    newData.vertexShader = config.vertex;
    delete newData.fragment;
    delete newData.vertex;

    for (var uniformName in newData.uniforms) {
      uniform = newData.uniforms[uniformName];

      if (uniform.value === null) {
        newData.uniforms[uniformName].value = this.getUmap(uniform.glslType);
      }
    }

    if (shaderName in this.shaderTypes) {
      // maybe not needed? too sleepy, need document
      ShaderRuntime_custom_extend(this.shaderTypes[shaderName], newData);
    } else {
      this.shaderTypes[shaderName] = newData;
    }

    return newData;
  },
  create: function create(identifier) {
    var shaderType = this.shaderTypes[identifier];
    var keys = Object.keys(shaderType); // Three's shadermaterial id is not assignable, so filter it out

    var withoutId = {};

    for (var i = 0; i < keys.length; i++) {
      if (keys[i] !== 'id') {
        withoutId[keys[i]] = shaderType[keys[i]];
      }
    }

    shaderType.material = new THREE.RawShaderMaterial(withoutId);
    this.runningShaders.push(shaderType);
    shaderType.init && shaderType.init(shaderType.material);
    shaderType.material.needsUpdate = true;
    shaderType.initted = true;
    return shaderType.material;
  },
  updateRuntime: function updateRuntime(identifier, data, findBy) {
    findBy = findBy || 'name';
    var shader, x, uniformName, uniform; // This loop does not appear to be a slowdown culprit

    for (x = 0; shader = this.runningShaders[x++];) {
      if (shader[findBy] === identifier) {
        for (uniformName in data.uniforms) {
          if (uniformName in this.reserved) {
            continue;
          }

          if (uniformName in shader.material.uniforms) {
            uniform = data.uniforms[uniformName]; // this is nasty, since the shader serializes
            // CubeCamera model to string. Maybe not update it at
            // all?

            if (uniform.type === 't' && typeof uniform.value === 'string') {
              uniform.value = this.cubeCameras[uniform.value].renderTarget;
            }

            shader.material.uniforms[uniformName].value = data.uniforms[uniformName].value;
          }
        }
      }
    }
  },
  // Update global shader uniform values
  updateShaders: function updateShaders(time, obj) {
    var shader, x;
    obj = obj || {};

    for (x = 0; shader = this.runningShaders[x++];) {
      for (var uniform in obj.uniforms) {
        if (uniform in shader.material.uniforms) {
          shader.material.uniforms[uniform].value = obj.uniforms[uniform];
        }
      }

      if ('cameraPosition' in shader.material.uniforms && this.mainCamera) {
        shader.material.uniforms.cameraPosition.value = this.mainCamera.position.clone();
      }

      if ('viewMatrix' in shader.material.uniforms && this.mainCamera) {
        shader.material.uniforms.viewMatrix.value = this.mainCamera.matrixWorldInverse;
      }

      if ('time' in shader.material.uniforms) {
        shader.material.uniforms.time.value = time;
      }
    }
  },
  shaderTypes: {},
  runningShaders: []
}; // Convenience methods so we don't have to include underscore

function ShaderRuntime_custom_extend() {
  var length = arguments.length,
      obj = arguments[0];

  if (length < 2) {
    return obj;
  }

  for (var index = 1; index < length; index++) {
    var source = arguments[index],
        keys = Object.keys(source || {}),
        l = keys.length;

    for (var i = 0; i < l; i++) {
      var key = keys[i];
      obj[key] = source[key];
    }
  }

  return obj;
}

function clone(obj) {
  return ShaderRuntime_custom_extend({}, obj);
}

function omit(obj) {
  var cloned = clone(obj),
      x,
      key;

  for (x = 0; key = (_ref = x++ + 1, _ref < 1 || arguments.length <= _ref ? undefined : arguments[_ref]);) {
    var _ref;

    delete cloned[key];
  }

  return cloned;
}

/* harmony default export */ const ShaderRuntime_custom = (ShaderRuntime);
;// CONCATENATED MODULE: ./src/components/simple-3D-background-three/js/index.js



/* 
 *************************************
 * <!-- 3D Background 1 with three.js -->
 *************************************
 */


var THREE_BACKGROUND_THREE = function (module, $, window, document) {
  if (window.THREE_BACKGROUND_THREE === null) return false;
  module.THREE_BACKGROUND_THREE = module.THREE_BACKGROUND_THREE || {};
  module.THREE_BACKGROUND_THREE.version = '0.0.5';

  module.THREE_BACKGROUND_THREE.documentReady = function ($) {
    //Prevent this module from loading in other pages
    if ($('#3D-background-three-canvas').length == 0 || !Modernizr.webgl) return false;
    var sceneSubjects = []; // Import objects and animations dynamically

    var MainStage = function () {
      var windowWidth = window.innerWidth,
          windowHeight = window.innerHeight;
      var rendererCanvasID = '3D-background-three-canvas'; // Generate one plane geometries mesh to scene
      //-------------------------------------	

      var camera,
          scene,
          light,
          renderer,
          displacementSprite,
          shaderSprite,
          clock = new THREE.Clock(); // controls

      var spriteAnim = false;
      var mouseX = 0,
          mouseY = 0,
          windowHalfX = windowWidth / 2,
          windowHalfY = windowHeight / 2;
      var targetX = 0.0,
          targetY = 0.0,
          angle = 0.0,
          height = 0.0,
          target = new THREE.Vector3(); // Load multiple ShaderFrog shaders

      var runtime = new ShaderRuntime_custom();
      runtime.load([$('#' + rendererCanvasID).data('shader-url')], function (shaders) {
        // Get the Three.js material you can assign to your objects
        var material = runtime.get(shaders[0].name);
        shaderSprite.material = material;
      });

      function init() {
        //camera
        camera = new THREE.PerspectiveCamera(60, windowWidth / windowHeight, 100, 2000000);
        camera.position.set(0, 100, 2000);
        runtime.registerCamera(camera); //Scene

        scene = new THREE.Scene(); //HemisphereLight

        scene.add(new THREE.AmbientLight(0x555555));
        light = new THREE.SpotLight(0xffffff, 1.5);
        light.position.set(0, 500, 2000);
        scene.add(light); //WebGL Renderer		

        renderer = new THREE.WebGLRenderer({
          canvas: document.getElementById(rendererCanvasID),
          //canvas
          alpha: true,
          antialias: true
        });
        renderer.setSize(windowWidth, windowHeight); //Add shader background

        var geometry = new THREE.SphereGeometry(5, 32, 32, 0, Math.PI * 2, 0, Math.PI * 2);
        shaderSprite = new THREE.Mesh(geometry);
        shaderSprite.scale.setScalar(10000);
        shaderSprite.renderDepth = 0;
        scene.add(shaderSprite); // Immediately use the texture for material creation

        var defaultMaterial = new THREE.MeshPhongMaterial({
          color: 0xffffff,
          flatShading: true,
          vertexColors: THREE.VertexColors
        });
        displacementSprite = new THREE.Mesh(generateGeometry('sphere', 200), defaultMaterial);
        scene.add(displacementSprite); // Fires when the window changes

        window.addEventListener('resize', onWindowResize, false);
        document.addEventListener('mousemove', onDocumentMouseMove, false);
        document.addEventListener('mousedown', onDocumentMouseDown, false);
        document.addEventListener('mouseup', onDocumentMouseUp, false);
      }

      function render() {
        requestAnimationFrame(render);
        var objVector = new THREE.Vector3(0, 0.2, 0.1),
            delta = clock.getDelta();

        if (!spriteAnim) {
          displacementSprite.rotation.x += delta * objVector.x;
          displacementSprite.rotation.y += delta * objVector.y;
          displacementSprite.rotation.z += delta * objVector.z;
        } //To set a background color.


        renderer.setClearColor(0x000000); //update shaders

        runtime.updateShaders(clock.getElapsedTime()); // update camera

        targetX = mouseX * .002;
        targetY = mouseY * .002;
        angle += 0.01 * (targetX - angle);
        height += 0.01 * (targetY - height);
        var x = -Math.sin(angle * 1.5) * 35;
        var z = Math.cos(angle * 1.5) * 35;
        var y = 130 * height + 0;
        camera.position.set(x, y, z);
        camera.lookAt(target); //push objects

        /*
        @Usage: 
             function CustomObj( scene ) {
                 const elements = new THREE...;
                scene.add( elements );
                 this.update = function( time ) {
                    elements.rotation.y = time*0.003;
                }
            }       
             sceneSubjects.push( new CustomObj( MainStage.getScene() ) );  
        */

        for (var i = 0; i < sceneSubjects.length; i++) {
          sceneSubjects[i].update(clock.getElapsedTime() * 1);
        } //render the scene to display our scene through the camera's eye.


        renderer.render(scene, camera);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function onDocumentMouseMove(event) {
        mouseX = event.clientX - windowHalfX;
        mouseY = event.clientY - windowHalfY;
      }

      function onDocumentMouseDown(event) {
        event.preventDefault();
        spriteAnim = true;
        mouseX = event.clientX - windowHalfX;
        mouseY = event.clientY - windowHalfY;
      }

      function onDocumentMouseUp(event) {
        event.preventDefault();
        spriteAnim = false;
        mouseX = event.clientX - windowHalfX;
        mouseY = event.clientY - windowHalfY;
      }
      /*
       * Batch generation of geometry
       *
       * @param  {String} objectType     - String of geometry type identifier.
       * @param  {Number} numObjects       - The total number of generated objects.
       * @return {Void}
       */


      function generateGeometry(objectType, numObjects) {
        var geometry = new THREE.Geometry();

        var applyVertexColors = function applyVertexColors(g, c) {
          g.faces.forEach(function (f) {
            var n = f instanceof THREE.Face3 ? 3 : 4;

            for (var j = 0; j < n; j++) {
              f.vertexColors[j] = c;
            }
          });
        };

        for (var i = 0; i < numObjects; i++) {
          var position = new THREE.Vector3();
          position.x = Math.random() * 10000 - 5000;
          position.y = Math.random() * 6000 - 3000;
          position.z = Math.random() * 8000 - 4000;
          var rotation = new THREE.Euler();
          rotation.x = Math.random() * 2 * Math.PI;
          rotation.y = Math.random() * 2 * Math.PI;
          rotation.z = Math.random() * 2 * Math.PI;
          var scale = new THREE.Vector3();
          scale.x = Math.random() * 200 + 100;
          var geom = void 0;
          var color = new THREE.Color();

          if (objectType == "cube") {
            geom = new THREE.BoxGeometry(1, 1, 1);
            scale.y = Math.random() * 200 + 100;
            scale.z = Math.random() * 200 + 100;
            color.setRGB(0, 0, Math.random() + 0.1);
          } else if (objectType == "sphere") {
            geom = new THREE.IcosahedronGeometry(1, 1);
            scale.y = scale.z = scale.x;
            color.setRGB(0.35, getRandomFloat(0.12, 0.3), 0.2);
          } else if (objectType == "poly") {
            geom = new THREE.CylinderGeometry(3, 6, 3, 5, 1);
            scale.y = Math.random() * 30;
            scale.z = Math.random() * 30;
            color.setRGB(Math.random() + 0.1, 0, 0);
          } // give the geom's vertices a random color, to be displayed


          applyVertexColors(geom, color);
          var object = new THREE.Mesh(geom);
          object.position.copy(position);
          object.rotation.copy(rotation);
          object.scale.copy(scale);
          object.updateMatrix();
          geometry.merge(object.geometry, object.matrix);
        }

        return geometry;
      } //Generate random number between two numbers


      function getRandomFloat(min, max) {
        return Math.random() * (max - min) + min;
      } // 
      //-------------------------------------	


      return {
        init: init,
        render: render,
        getRendererCanvasID: function getRendererCanvasID() {
          return rendererCanvasID;
        },
        getScene: function getScene() {
          return scene;
        },
        getCamera: function getCamera() {
          return camera;
        }
      };
    }();

    MainStage.init();
    MainStage.render();
  };

  module.components.documentReady.push(module.THREE_BACKGROUND_THREE.documentReady);
  return /*#__PURE__*/_createClass(function THREE_BACKGROUND_THREE() {
    _classCallCheck(this, THREE_BACKGROUND_THREE);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/simple-3D-background-three2/js/shader/fragment-custom.glsl
/* harmony default export */ const fragment_custom = ("#define GLSLIFY 1\nuniform float time;\n\nuniform sampler2D texture;\n\nvarying vec2 vUv;\n\nvoid main( void ) {\n\n    vec2 position = - 1.0 + 2.0 * vUv;\n\n    float a = atan( position.y, position.x );\n    float r = sqrt( dot( position, position ) );\n\n    vec2 uv;\n    uv.x = cos( a ) / r;\n    uv.y = sin( a ) / r;\n    uv /= 10.0;\n    uv += time * 0.05;\n\n    vec3 color = texture2D( texture, uv ).rgb;\n\n    gl_FragColor = vec4( color * r * 1.5, 1.0 );\n\n}");
;// CONCATENATED MODULE: ./src/components/simple-3D-background-three2/js/shader/vertex-custom.glsl
/* harmony default export */ const vertex_custom = ("#define GLSLIFY 1\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n    gl_Position = projectionMatrix * mvPosition;\n}");
;// CONCATENATED MODULE: ./src/components/simple-3D-background-three2/js/index.js



/* 
 *************************************
 * <!-- 3D Background 2 with three.js -->
 *************************************
 */



var THREE_BACKGROUND_THREE2 = function (module, $, window, document) {
  if (window.THREE_BACKGROUND_THREE2 === null) return false;
  module.THREE_BACKGROUND_THREE2 = module.THREE_BACKGROUND_THREE2 || {};
  module.THREE_BACKGROUND_THREE2.version = '0.0.4';

  module.THREE_BACKGROUND_THREE2.documentReady = function ($) {
    //Prevent this module from loading in other pages
    if ($('#3D-background-three-canvas2').length == 0 || !Modernizr.webgl) return false;
    var sceneSubjects = []; // Import objects and animations dynamically

    var MainStage = function () {
      var windowWidth = window.innerWidth,
          windowHeight = window.innerHeight;
      var rendererCanvasID = '3D-background-three-canvas2'; // Generate one plane geometries mesh to scene
      //-------------------------------------	

      var camera,
          scene,
          renderer,
          material,
          displacementSprite,
          clock = new THREE.Clock();
      var mouseVector = new THREE.Vector2();
      var mouseX = 0;
      var mouseY = 0;

      function init() {
        //camera
        camera = new THREE.PerspectiveCamera(50, windowWidth / windowHeight, .01, 1000);
        camera.position.set(0, 0, 1.8); //Scene

        scene = new THREE.Scene(); //WebGL Renderer	

        renderer = new THREE.WebGLRenderer({
          canvas: document.getElementById(rendererCanvasID),
          //canvas
          alpha: true,
          antialias: true
        });
        renderer.setSize(windowWidth, windowHeight); // Immediately use the texture for material creation

        material = new THREE.ShaderMaterial({
          uniforms: {
            "time": {
              value: 1.0
            },
            "texture": {
              value: new THREE.TextureLoader().load($('#' + rendererCanvasID).data('filter-texture'))
            }
          },
          fragmentShader: fragment_custom,
          vertexShader: vertex_custom
        }); //if use texture

        material.uniforms.texture.value.wrapS = THREE.RepeatWrapping;
        material.uniforms.texture.value.wrapT = THREE.RepeatWrapping;
        var geometry = new THREE.SphereGeometry(5, 50, 50, 0, Math.PI * 2, 0, Math.PI * 2);
        displacementSprite = new THREE.Mesh(geometry, material);
        scene.add(displacementSprite); // Fires when the window changes

        window.addEventListener('resize', onWindowResize, false);
        document.addEventListener('mousemove', onDocumentMouseMove, false);
      }

      function render() {
        requestAnimationFrame(render);
        var delta = clock.getDelta(); //To set a background color.

        renderer.setClearColor(0x000000);
        material.uniforms.time.value += delta * 5; //displacementSprite.rotation.y += delta * 0.5 * 1;
        //displacementSprite.rotation.x += delta * 0.5 * -1;
        //push objects

        /*
        @Usage: 
             function CustomObj( scene ) {
                 const elements = new THREE...;
                scene.add( elements );
                 this.update = function( time ) {
                    elements.rotation.y = time*0.003;
                }
            }       
             sceneSubjects.push( new CustomObj( MainStage.getScene() ) );  
        */

        for (var i = 0; i < sceneSubjects.length; i++) {
          sceneSubjects[i].update(clock.getElapsedTime() * 1);
        } //render the scene to display our scene through the camera's eye.


        renderer.render(scene, camera);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function onDocumentMouseMove(event) {
        var rect = renderer.domElement.getBoundingClientRect();
        displacementSprite.position.z = (event.clientX - rect.left) / rect.width * 4 - 1;
      }

      function avgArr(arr) {
        var total = arr.reduce(function (sum, b) {
          return sum + b;
        });
        return total / arr.length;
      }

      function maxArr(arr) {
        return arr.reduce(function (a, b) {
          return Math.max(a, b);
        });
      }

      function degToRad(degrees) {
        return degrees * Math.PI / 180;
      }

      function round(n, digits) {
        return Number(n.toFixed(digits));
      } // 
      //-------------------------------------	


      return {
        init: init,
        render: render,
        getRendererCanvasID: function getRendererCanvasID() {
          return rendererCanvasID;
        },
        getScene: function getScene() {
          return scene;
        },
        getCamera: function getCamera() {
          return camera;
        }
      };
    }();

    MainStage.init();
    MainStage.render();
  };

  module.components.documentReady.push(module.THREE_BACKGROUND_THREE2.documentReady);
  return /*#__PURE__*/_createClass(function THREE_BACKGROUND_THREE2() {
    _classCallCheck(this, THREE_BACKGROUND_THREE2);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/simple-3D-background-three3/js/index.js



/* 
 *************************************
 * <!-- 3D Background 3 with three.js -->
 *************************************
 */

var THREE_BACKGROUND_THREE3 = function (module, $, window, document) {
  if (window.THREE_BACKGROUND_THREE3 === null) return false;
  module.THREE_BACKGROUND_THREE3 = module.THREE_BACKGROUND_THREE3 || {};
  module.THREE_BACKGROUND_THREE3.version = '0.0.2';

  module.THREE_BACKGROUND_THREE3.documentReady = function ($) {
    //Prevent this module from loading in other pages
    if ($('#3D-background-three-canvas3').length == 0 || !Modernizr.webgl) return false;
    var sceneSubjects = []; // Import objects and animations dynamically

    var MainStage = function () {
      var windowWidth = window.innerWidth,
          windowHeight = window.innerHeight;
      var rendererCanvasID = '3D-background-three-canvas3'; // Generate one plane geometries mesh to scene
      //-------------------------------------	

      var camera,
          scene,
          renderer,
          displacementSprite,
          theta = 0;
      var mouseVector = new THREE.Vector2(),
          sphereTarget = new THREE.Euler(),
          xrad = THREE.Math.degToRad(30),
          yrad = THREE.Math.degToRad(10);

      function init() {
        //camera
        camera = new THREE.PerspectiveCamera(50, windowWidth / windowHeight, .01, 1000);
        camera.position.set(0, 0, 1.8); //Scene

        scene = new THREE.Scene(); //WebGL Renderer	

        renderer = new THREE.WebGLRenderer({
          canvas: document.getElementById(rendererCanvasID),
          //canvas
          alpha: true,
          antialias: true
        });
        renderer.setSize(windowWidth, windowHeight); // Immediately use the texture for material creation

        var sphereGeo = new THREE.SphereBufferGeometry(2, 12, 12);
        var sphereMat = new THREE.MeshBasicMaterial({
          color: 0x494949,
          wireframe: true
        });
        displacementSprite = new THREE.Mesh(sphereGeo, sphereMat);
        displacementSprite.position.y = -0.2;
        scene.add(displacementSprite); // Fires when the window changes

        window.addEventListener('resize', onWindowResize, false);
        document.addEventListener('mousemove', onDocumentMouseMove, false);
      }

      function render() {
        requestAnimationFrame(render);
        theta += 0.1; //To set a background color.

        renderer.setClearColor(0x000000);
        lerp(displacementSprite.rotation, 'x', sphereTarget.x);
        lerp(displacementSprite.rotation, 'y', sphereTarget.y); //push objects

        /*
        @Usage: 
             function CustomObj( scene ) {
                 const elements = new THREE...;
                scene.add( elements );
                 this.update = function( time ) {
                    elements.rotation.y = time*0.003;
                }
            }       
             sceneSubjects.push( new CustomObj( MainStage.getScene() ) );  
        */

        for (var i = 0; i < sceneSubjects.length; i++) {
          sceneSubjects[i].update(clock.getElapsedTime() * 1);
        } //render the scene to display our scene through the camera's eye.


        renderer.render(scene, camera);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function onDocumentMouseMove(event) {
        // NDC -1 to 1
        var rect = renderer.domElement.getBoundingClientRect();
        mouseVector.x = (event.clientX - rect.left) / rect.width * 2 - 1;
        mouseVector.y = (event.clientY - rect.top) / rect.height * -2 + 1;
        sphereTarget.y = mouseVector.x * xrad;
        sphereTarget.x = -mouseVector.y * yrad;
      } //Calculate the interpolation of two vectors


      function lerp(object, prop, destination) {
        if (object && object[prop] !== destination) {
          object[prop] += (destination - object[prop]) * 0.1;

          if (Math.abs(destination - object[prop]) < 0.001) {
            object[prop] = destination;
          }
        }
      } // 
      //-------------------------------------	


      return {
        init: init,
        render: render,
        getRendererCanvasID: function getRendererCanvasID() {
          return rendererCanvasID;
        },
        getScene: function getScene() {
          return scene;
        },
        getCamera: function getCamera() {
          return camera;
        }
      };
    }();

    MainStage.init();
    MainStage.render();
  };

  module.components.documentReady.push(module.THREE_BACKGROUND_THREE3.documentReady);
  return /*#__PURE__*/_createClass(function THREE_BACKGROUND_THREE3() {
    _classCallCheck(this, THREE_BACKGROUND_THREE3);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/simple-3D-background/js/index.js




/* 
 *************************************
 * <!-- 3D Background -->
 *************************************
 */


var THREE_BACKGROUND = function (module, $, window, document) {
  if (window.THREE_BACKGROUND === null) return false;
  module.THREE_BACKGROUND = module.THREE_BACKGROUND || {};
  module.THREE_BACKGROUND.version = '0.0.4';

  module.THREE_BACKGROUND.documentReady = function ($) {
    //grab each 3dAnimate element and pass it into the animate function along with the config data
    $('[data-3d-animate]').each(function (index, element) {
      var dataConfig = $(element).data('3d-animate');

      if ((0,esm_typeof/* default */.Z)(dataConfig) === ( true ? "undefined" : 0)) {
        dataConfig = false;
      }

      if (dataConfig) {
        element.removeEventListener('mousemove', handleMove);
        element.removeEventListener('touchmove', handleMove);
        element.addEventListener('mousemove', handleMove);
        element.addEventListener('touchmove', handleMove); //

        element.removeEventListener('mouseleave', handleMoveEnd);
        element.removeEventListener('touchend', handleMoveEnd);
        element.addEventListener('mouseleave', handleMoveEnd);
        element.addEventListener('touchend', handleMoveEnd); //pass arguments to addEventListener listener

        element.obj = element;
        element.itemsTotal = element.children.length;
        element.config = dataConfig;
      }
    });

    function handleMove(e) {
      var el = e.currentTarget.obj;
      var itemsTotal = e.currentTarget.itemsTotal;
      var offsetRes = e.currentTarget.config.offset;
      var w = el.clientWidth; //including: padding

      var h = el.clientHeight; //including: padding

      var base = 0; //Base offset value.

      var multiple = 0; //The power of target number.

      if (offsetRes) {
        if (itemsTotal === 1) {
          base = Math.pow(offsetRes[0], offsetRes[1]);
        } else {
          base = offsetRes[0];
          multiple = offsetRes[1];
        }
      }

      var mouseX, mouseY, offsetX, offsetY;
      var touches = e.touches; //get the absolute position of a mouse
      //!!! Important: If you do not use window.pageXOffset or window.pageYOffset, 
      //              the mouse coordinates are relative to the parent element

      if (touches && touches.length) {
        mouseX = touches[0].clientX + window.pageXOffset;
        mouseY = touches[0].clientY + window.pageYOffset;
      } else {
        mouseX = e.clientX + window.pageXOffset;
        mouseY = e.clientY + window.pageYOffset;
      } //Find mouse position relative to element
      //!!! Important: Using `el.offsetTop` or `el.offsetLeft` is relative, the value may be 0


      offsetX = mouseX - $(el).offset().left;
      offsetY = mouseY - $(el).offset().top; //console.log('mouseX: ', mouseX, ' mouseY: ', mouseY, 'el.offsetLeft: ', $(el).offset().left, ' el.offsetTop: ', $(el).offset().top );

      if (itemsTotal === 1) {
        /*
        ////////////////////////////////////////////////////////////
        ////////////////////////  Only One   ///////////////////////
        ////////////////////////////////////////////////////////////
        */
        // function to run matrix3D effect on block
        var targetX = mousePosition(offsetX, w, base),
            targetY = mousePosition(offsetY, h, base);
        el.style.transform = "rotateX(".concat(targetY, "deg) rotateY(").concat(targetX, "deg)");
      } else {
        /*
        ////////////////////////////////////////////////////////////
        ////////////////////  Multiple Images   ////////////////////
        ////////////////////////////////////////////////////////////
        */
        // function to run matrix3D effect on block
        var _targetX = offsetX / w,
            _targetY = offsetY / h;

        var $items = el.children;
        Array.prototype.forEach.call($items, function (node, index) {
          var x = _targetX * (base * Math.pow(multiple, index)),
              y = _targetY * (base * Math.pow(multiple, index)),
              z = 0,
              deg = _targetY * (180 / Math.PI),
              rotateDeg = deg - 35;

          node.style.transform = "translate(".concat(x, "px ,").concat(y, "px) rotate3d( -1, 1, 0, ").concat(rotateDeg, "deg )");
        });
      }
    }

    function handleMoveEnd(e) {
      var el = e.currentTarget.obj;
      var itemsTotal = e.currentTarget.itemsTotal;
      var resetRes = e.currentTarget.config.reset;

      if (resetRes) {
        if (itemsTotal === 1) {
          /*
          ////////////////////////////////////////////////////////////
          ////////////////////////  Only One   ///////////////////////
          ////////////////////////////////////////////////////////////
          */
          el.style.transform = "rotateX(0deg) rotateY(0deg)";
        } else {
          /*
          ////////////////////////////////////////////////////////////
          ////////////////////  Multiple Images   ////////////////////
          ////////////////////////////////////////////////////////////
          */
          var $items = el.children;
          Array.prototype.forEach.call($items, function (node, index) {
            node.style.transform = "translate(0,0) rotate3d( -1, 1, 0, 0deg )";
          });
        }
      }
    } // make some calculations for mouse position


    function mousePosition(mousePos, dimension, base) {
      return Math.floor(mousePos / dimension * (base * 2)) - base;
    }
  };

  module.components.documentReady.push(module.THREE_BACKGROUND.documentReady);
  return /*#__PURE__*/_createClass(function THREE_BACKGROUND() {
    _classCallCheck(this, THREE_BACKGROUND);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/simple-3D-carousel/js/index.js




/* 
 *************************************
 * <!-- 3D Carousel -->
 *************************************
 */


var THREE_CAROUSEL = function (module, $, window, document) {
  if (window.THREE_CAROUSEL === null) return false;
  module.THREE_CAROUSEL = module.THREE_CAROUSEL || {};
  module.THREE_CAROUSEL.version = '0.0.2';

  module.THREE_CAROUSEL.documentReady = function ($) {
    $('.uix-3d-carousel').each(function () {
      var $this = $(this);
      var $wrapper = $this.find('> ul'),
          $items = $wrapper.find('> li'),
          itemCount = $items.length;
      var dataTiming = $this.data('timing'),
          dataPrevBtn = $this.data('prev-btn'),
          dataNextBtn = $this.data('next-btn'),
          dataDraggable = $this.data('draggable'),
          autoSwap = null,
          items = [],
          startItem = 1,
          position = 0,
          leftpos = itemCount,
          resetCount = itemCount;
      if ((0,esm_typeof/* default */.Z)(dataTiming) === ( true ? "undefined" : 0)) dataTiming = 5000;
      if ((0,esm_typeof/* default */.Z)(dataPrevBtn) === ( true ? "undefined" : 0)) dataPrevBtn = ".my-carousel-3d-prev";
      if ((0,esm_typeof/* default */.Z)(dataNextBtn) === ( true ? "undefined" : 0)) dataNextBtn = ".my-carousel-3d-next";
      if ((0,esm_typeof/* default */.Z)(dataDraggable) === ( true ? "undefined" : 0)) dataDraggable = false; //Avoid problems caused by insufficient quantity
      //-------------------------------------		

      if (itemCount == 3) {
        var $clone3 = $items.eq(1).clone();
        $items.last().after($clone3);
      }

      if (itemCount == 2) {
        var $clone2_1 = $items.eq(0).clone(),
            $clone2_2 = $items.eq(1).clone();
        $items.last().after([$clone2_1, $clone2_2]);
      }

      if (itemCount == 1) {
        var $clone1_1 = $items.eq(0).clone(),
            $clone1_2 = $items.eq(0).clone(),
            $clone1_3 = $items.eq(0).clone();
        $items.last().after([$clone1_1, $clone1_2, $clone1_3]);
      } //New objects of items and wrapper


      $wrapper = $this.find('> ul');
      $items = $wrapper.find('> li');
      itemCount = $items.length;
      leftpos = itemCount;
      resetCount = itemCount; //Adding an index to an element makes it easy to query
      //-------------------------------------	

      $items.each(function (index) {
        items[index] = $(this).text();
        $(this).attr('id', index + 1);
      }); //Pause slideshow and reinstantiate on mouseout
      //-------------------------------------	

      $wrapper.on('mouseenter', function () {
        clearInterval(autoSwap);
      }).on('mouseleave', function () {
        autoSwap = setInterval(itemUpdates, dataTiming);
      }); //Initialize the default effect
      //-------------------------------------	

      itemUpdates('clockwise'); //The matched click events for the element.
      //-------------------------------------	

      $(dataPrevBtn).on('click', function (e) {
        e.preventDefault();
        itemUpdates('clockwise');
        return false;
      });
      $(dataNextBtn).on('click', function (e) {
        e.preventDefault();
        itemUpdates('counter-clockwise');
        return false;
      });
      $items.on('click', function (e) {
        e.preventDefault();

        if ($(this).attr('class') == 'uix-3d-carousel__item uix-3d-carousel__item--left-pos') {
          itemUpdates('counter-clockwise');
        } else {
          itemUpdates('clockwise');
        }
      }); //Drag and Drop
      //-------------------------------------	

      var $dragDropTrigger = $wrapper;
      var hammerProps = {};

      if (!dataDraggable) {
        hammerProps = {
          inputClass: Hammer.TouchInput
        };
      } //Mouse event
      //Hammer.js pan event only for touch devices and not for desktop computer Click+Drag


      var direction;
      var dragDropElement = $dragDropTrigger[0],
          dragDropMC = new Hammer(dragDropElement, hammerProps); // let the pan gesture support all directions.
      // this will block the vertical scrolling on a touch-device while on the element

      dragDropMC.get('pan').set({
        direction: Hammer.DIRECTION_ALL
      });
      dragDropMC.on('press panright panleft', function (ev) {
        //Set the direction in here
        direction = ev.type;
      });
      dragDropMC.on('panend', function (ev) {
        //Use the direction in here
        //You know the pan has ended
        //and you know which action they were taking
        if (direction == 'panleft') {
          itemUpdates('clockwise');
        }

        if (direction == 'panright') {
          itemUpdates('counter-clockwise');
        }
      });
      /*
       * Swap Between Images
       *
       * @param  {String} action           - Direction of movement, optional: clockwise, counter-clockwise
       * @return {Void}
       */

      function itemUpdates(action) {
        var direction = action; //moving carousel backwards

        if (direction == 'counter-clockwise') {
          var leftitem = parseFloat($wrapper.find('> li.uix-3d-carousel__item--left-pos').attr('id') - 1);

          if (leftitem == 0) {
            leftitem = itemCount;
          }

          $wrapper.find('> li.uix-3d-carousel__item--right-pos').removeClass('uix-3d-carousel__item--right-pos').addClass('uix-3d-carousel__item--back-pos');
          $wrapper.find('> li.uix-3d-carousel__item--main-pos').removeClass('uix-3d-carousel__item--main-pos').addClass('uix-3d-carousel__item--right-pos');
          $wrapper.find('> li.uix-3d-carousel__item--left-pos').removeClass('uix-3d-carousel__item--left-pos').addClass('uix-3d-carousel__item--main-pos');
          $wrapper.find('> li#' + leftitem + '').removeClass('uix-3d-carousel__item--back-pos').addClass('uix-3d-carousel__item--left-pos');
          startItem--;

          if (startItem < 1) {
            startItem = itemCount;
          }
        } //moving carousel forward


        if (direction == 'clockwise' || direction == '' || direction == null) {
          var carousel3DPos = function carousel3DPos(dir) {
            if (dir != 'leftposition') {
              //increment image list id
              position++; //if final result is greater than image count, reset position.

              if (startItem + position > resetCount) {
                position = 1 - startItem;
              }
            } //setting the left positioned item


            if (dir == 'leftposition') {
              //left positioned image should always be one left than main positioned image.
              position = startItem - 1; //reset last image in list to left position if first image is in main position

              if (position < 1) {
                position = itemCount;
              }
            }

            return position;
          };

          $wrapper.find('> li#' + startItem + '').removeClass('uix-3d-carousel__item--main-pos').addClass('uix-3d-carousel__item--left-pos');
          $wrapper.find('> li#' + (startItem + carousel3DPos()) + '').removeClass('uix-3d-carousel__item--right-pos').addClass('uix-3d-carousel__item--main-pos');
          $wrapper.find('> li#' + (startItem + carousel3DPos()) + '').removeClass('uix-3d-carousel__item--back-pos').addClass('uix-3d-carousel__item--right-pos');
          $wrapper.find('> li#' + carousel3DPos('leftposition') + '').removeClass('uix-3d-carousel__item--left-pos').addClass('uix-3d-carousel__item--back-pos');
          startItem++;
          position = 0;

          if (startItem > itemCount) {
            startItem = 1;
          }
        }
      }
    });
  };

  module.components.documentReady.push(module.THREE_CAROUSEL.documentReady);
  return /*#__PURE__*/_createClass(function THREE_CAROUSEL() {
    _classCallCheck(this, THREE_CAROUSEL);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/_third-party-plugins/THREE/esm/controls/OrbitControls.js
/**
 * @author qiao / https://github.com/qiao
 * @author mrdoob / http://mrdoob.com
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author erich666 / http://erichaines.com
 */
// This set of controls performs orbiting, dollying (zooming), and panning.
// Unlike TrackballControls, it maintains the "up" direction object.up (+Y by default).
//
//    Orbit - left mouse / touch: one-finger move
//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish
//    Pan - right mouse, or arrow keys / touch: two-finger move
THREE.OrbitControls = function (object, domElement) {
  this.object = object;
  this.domElement = domElement !== undefined ? domElement : document; // Set to false to disable this control

  this.enabled = true; // "target" sets the location of focus, where the object orbits around

  this.target = new THREE.Vector3(); // How far you can dolly in and out ( PerspectiveCamera only )

  this.minDistance = 0;
  this.maxDistance = Infinity; // How far you can zoom in and out ( OrthographicCamera only )

  this.minZoom = 0;
  this.maxZoom = Infinity; // How far you can orbit vertically, upper and lower limits.
  // Range is 0 to Math.PI radians.

  this.minPolarAngle = 0; // radians

  this.maxPolarAngle = Math.PI; // radians
  // How far you can orbit horizontally, upper and lower limits.
  // If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].

  this.minAzimuthAngle = -Infinity; // radians

  this.maxAzimuthAngle = Infinity; // radians
  // Set to true to enable damping (inertia)
  // If damping is enabled, you must call controls.update() in your animation loop

  this.enableDamping = false;
  this.dampingFactor = 0.25; // This option actually enables dollying in and out; left as "zoom" for backwards compatibility.
  // Set to false to disable zooming

  this.enableZoom = true;
  this.zoomSpeed = 1.0; // Set to false to disable rotating

  this.enableRotate = true;
  this.rotateSpeed = 1.0; // Set to false to disable panning

  this.enablePan = true;
  this.panSpeed = 1.0;
  this.screenSpacePanning = false; // if true, pan in screen-space

  this.keyPanSpeed = 7.0; // pixels moved per arrow key push
  // Set to true to automatically rotate around the target
  // If auto-rotate is enabled, you must call controls.update() in your animation loop

  this.autoRotate = false;
  this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60
  // Set to false to disable use of the keys

  this.enableKeys = true; // The four arrow keys

  this.keys = {
    LEFT: 37,
    UP: 38,
    RIGHT: 39,
    BOTTOM: 40
  }; // Mouse buttons

  this.mouseButtons = {
    ORBIT: THREE.MOUSE.LEFT,
    ZOOM: THREE.MOUSE.MIDDLE,
    PAN: THREE.MOUSE.RIGHT
  }; // for reset

  this.target0 = this.target.clone();
  this.position0 = this.object.position.clone();
  this.zoom0 = this.object.zoom; //
  // public methods
  //

  this.getPolarAngle = function () {
    return spherical.phi;
  };

  this.getAzimuthalAngle = function () {
    return spherical.theta;
  };

  this.saveState = function () {
    scope.target0.copy(scope.target);
    scope.position0.copy(scope.object.position);
    scope.zoom0 = scope.object.zoom;
  };

  this.reset = function () {
    scope.target.copy(scope.target0);
    scope.object.position.copy(scope.position0);
    scope.object.zoom = scope.zoom0;
    scope.object.updateProjectionMatrix();
    scope.dispatchEvent(changeEvent);
    scope.update();
    state = STATE.NONE;
  }; // this method is exposed, but perhaps it would be better if we can make it private...


  this.update = function () {
    var offset = new THREE.Vector3(); // so camera.up is the orbit axis

    var quat = new THREE.Quaternion().setFromUnitVectors(object.up, new THREE.Vector3(0, 1, 0));
    var quatInverse = quat.clone().inverse();
    var lastPosition = new THREE.Vector3();
    var lastQuaternion = new THREE.Quaternion();
    return function update() {
      var position = scope.object.position;
      offset.copy(position).sub(scope.target); // rotate offset to "y-axis-is-up" space

      offset.applyQuaternion(quat); // angle from z-axis around y-axis

      spherical.setFromVector3(offset);

      if (scope.autoRotate && state === STATE.NONE) {
        rotateLeft(getAutoRotationAngle());
      }

      spherical.theta += sphericalDelta.theta;
      spherical.phi += sphericalDelta.phi; // restrict theta to be between desired limits

      spherical.theta = Math.max(scope.minAzimuthAngle, Math.min(scope.maxAzimuthAngle, spherical.theta)); // restrict phi to be between desired limits

      spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi));
      spherical.makeSafe();
      spherical.radius *= scale; // restrict radius to be between desired limits

      spherical.radius = Math.max(scope.minDistance, Math.min(scope.maxDistance, spherical.radius)); // move target to panned location

      scope.target.add(panOffset);
      offset.setFromSpherical(spherical); // rotate offset back to "camera-up-vector-is-up" space

      offset.applyQuaternion(quatInverse);
      position.copy(scope.target).add(offset);
      scope.object.lookAt(scope.target);

      if (scope.enableDamping === true) {
        sphericalDelta.theta *= 1 - scope.dampingFactor;
        sphericalDelta.phi *= 1 - scope.dampingFactor;
        panOffset.multiplyScalar(1 - scope.dampingFactor);
      } else {
        sphericalDelta.set(0, 0, 0);
        panOffset.set(0, 0, 0);
      }

      scale = 1; // update condition is:
      // min(camera displacement, camera rotation in radians)^2 > EPS
      // using small-angle approximation cos(x/2) = 1 - x^2 / 8

      if (zoomChanged || lastPosition.distanceToSquared(scope.object.position) > EPS || 8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS) {
        scope.dispatchEvent(changeEvent);
        lastPosition.copy(scope.object.position);
        lastQuaternion.copy(scope.object.quaternion);
        zoomChanged = false;
        return true;
      }

      return false;
    };
  }();

  this.dispose = function () {
    scope.domElement.removeEventListener('contextmenu', onContextMenu, false);
    scope.domElement.removeEventListener('mousedown', onMouseDown, false);
    scope.domElement.removeEventListener('wheel', onMouseWheel, false);
    scope.domElement.removeEventListener('touchstart', onTouchStart, false);
    scope.domElement.removeEventListener('touchend', onTouchEnd, false);
    scope.domElement.removeEventListener('touchmove', onTouchMove, false);
    document.removeEventListener('mousemove', onMouseMove, false);
    document.removeEventListener('mouseup', onMouseUp, false);
    window.removeEventListener('keydown', onKeyDown, false); //scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?
  }; //
  // internals
  //


  var scope = this;
  var changeEvent = {
    type: 'change'
  };
  var startEvent = {
    type: 'start'
  };
  var endEvent = {
    type: 'end'
  };
  var STATE = {
    NONE: -1,
    ROTATE: 0,
    DOLLY: 1,
    PAN: 2,
    TOUCH_ROTATE: 3,
    TOUCH_DOLLY_PAN: 4
  };
  var state = STATE.NONE;
  var EPS = 0.000001; // current position in spherical coordinates

  var spherical = new THREE.Spherical();
  var sphericalDelta = new THREE.Spherical();
  var scale = 1;
  var panOffset = new THREE.Vector3();
  var zoomChanged = false;
  var rotateStart = new THREE.Vector2();
  var rotateEnd = new THREE.Vector2();
  var rotateDelta = new THREE.Vector2();
  var panStart = new THREE.Vector2();
  var panEnd = new THREE.Vector2();
  var panDelta = new THREE.Vector2();
  var dollyStart = new THREE.Vector2();
  var dollyEnd = new THREE.Vector2();
  var dollyDelta = new THREE.Vector2();

  function getAutoRotationAngle() {
    return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;
  }

  function getZoomScale() {
    return Math.pow(0.95, scope.zoomSpeed);
  }

  function rotateLeft(angle) {
    sphericalDelta.theta -= angle;
  }

  function rotateUp(angle) {
    sphericalDelta.phi -= angle;
  }

  var panLeft = function () {
    var v = new THREE.Vector3();
    return function panLeft(distance, objectMatrix) {
      v.setFromMatrixColumn(objectMatrix, 0); // get X column of objectMatrix

      v.multiplyScalar(-distance);
      panOffset.add(v);
    };
  }();

  var panUp = function () {
    var v = new THREE.Vector3();
    return function panUp(distance, objectMatrix) {
      if (scope.screenSpacePanning === true) {
        v.setFromMatrixColumn(objectMatrix, 1);
      } else {
        v.setFromMatrixColumn(objectMatrix, 0);
        v.crossVectors(scope.object.up, v);
      }

      v.multiplyScalar(distance);
      panOffset.add(v);
    };
  }(); // deltaX and deltaY are in pixels; right and down are positive


  var pan = function () {
    var offset = new THREE.Vector3();
    return function pan(deltaX, deltaY) {
      var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

      if (scope.object.isPerspectiveCamera) {
        // perspective
        var position = scope.object.position;
        offset.copy(position).sub(scope.target);
        var targetDistance = offset.length(); // half of the fov is center to top of screen

        targetDistance *= Math.tan(scope.object.fov / 2 * Math.PI / 180.0); // we use only clientHeight here so aspect ratio does not distort speed

        panLeft(2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix);
        panUp(2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix);
      } else if (scope.object.isOrthographicCamera) {
        // orthographic
        panLeft(deltaX * (scope.object.right - scope.object.left) / scope.object.zoom / element.clientWidth, scope.object.matrix);
        panUp(deltaY * (scope.object.top - scope.object.bottom) / scope.object.zoom / element.clientHeight, scope.object.matrix);
      } else {
        // camera neither orthographic nor perspective
        console.warn('WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.');
        scope.enablePan = false;
      }
    };
  }();

  function dollyIn(dollyScale) {
    if (scope.object.isPerspectiveCamera) {
      scale /= dollyScale;
    } else if (scope.object.isOrthographicCamera) {
      scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom * dollyScale));
      scope.object.updateProjectionMatrix();
      zoomChanged = true;
    } else {
      console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');
      scope.enableZoom = false;
    }
  }

  function dollyOut(dollyScale) {
    if (scope.object.isPerspectiveCamera) {
      scale *= dollyScale;
    } else if (scope.object.isOrthographicCamera) {
      scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / dollyScale));
      scope.object.updateProjectionMatrix();
      zoomChanged = true;
    } else {
      console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');
      scope.enableZoom = false;
    }
  } //
  // event callbacks - update the object state
  //


  function handleMouseDownRotate(event) {
    //console.log( 'handleMouseDownRotate' );
    rotateStart.set(event.clientX, event.clientY);
  }

  function handleMouseDownDolly(event) {
    //console.log( 'handleMouseDownDolly' );
    dollyStart.set(event.clientX, event.clientY);
  }

  function handleMouseDownPan(event) {
    //console.log( 'handleMouseDownPan' );
    panStart.set(event.clientX, event.clientY);
  }

  function handleMouseMoveRotate(event) {
    //console.log( 'handleMouseMoveRotate' );
    rotateEnd.set(event.clientX, event.clientY);
    rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
    var element = scope.domElement === document ? scope.domElement.body : scope.domElement; // rotating across whole screen goes 360 degrees around

    rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth); // rotating up and down along whole screen attempts to go 360, but limited to 180

    rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);
    rotateStart.copy(rotateEnd);
    scope.update();
  }

  function handleMouseMoveDolly(event) {
    //console.log( 'handleMouseMoveDolly' );
    dollyEnd.set(event.clientX, event.clientY);
    dollyDelta.subVectors(dollyEnd, dollyStart);

    if (dollyDelta.y > 0) {
      dollyIn(getZoomScale());
    } else if (dollyDelta.y < 0) {
      dollyOut(getZoomScale());
    }

    dollyStart.copy(dollyEnd);
    scope.update();
  }

  function handleMouseMovePan(event) {
    //console.log( 'handleMouseMovePan' );
    panEnd.set(event.clientX, event.clientY);
    panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
    pan(panDelta.x, panDelta.y);
    panStart.copy(panEnd);
    scope.update();
  }

  function handleMouseUp(event) {// console.log( 'handleMouseUp' );
  }

  function handleMouseWheel(event) {
    // console.log( 'handleMouseWheel' );
    if (event.deltaY < 0) {
      dollyOut(getZoomScale());
    } else if (event.deltaY > 0) {
      dollyIn(getZoomScale());
    }

    scope.update();
  }

  function handleKeyDown(event) {
    //console.log( 'handleKeyDown' );
    switch (event.keyCode) {
      case scope.keys.UP:
        pan(0, scope.keyPanSpeed);
        scope.update();
        break;

      case scope.keys.BOTTOM:
        pan(0, -scope.keyPanSpeed);
        scope.update();
        break;

      case scope.keys.LEFT:
        pan(scope.keyPanSpeed, 0);
        scope.update();
        break;

      case scope.keys.RIGHT:
        pan(-scope.keyPanSpeed, 0);
        scope.update();
        break;
    }
  }

  function handleTouchStartRotate(event) {
    //console.log( 'handleTouchStartRotate' );
    rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);
  }

  function handleTouchStartDollyPan(event) {
    //console.log( 'handleTouchStartDollyPan' );
    if (scope.enableZoom) {
      var dx = event.touches[0].pageX - event.touches[1].pageX;
      var dy = event.touches[0].pageY - event.touches[1].pageY;
      var distance = Math.sqrt(dx * dx + dy * dy);
      dollyStart.set(0, distance);
    }

    if (scope.enablePan) {
      var x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);
      var y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);
      panStart.set(x, y);
    }
  }

  function handleTouchMoveRotate(event) {
    //console.log( 'handleTouchMoveRotate' );
    rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);
    rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
    var element = scope.domElement === document ? scope.domElement.body : scope.domElement; // rotating across whole screen goes 360 degrees around

    rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth); // rotating up and down along whole screen attempts to go 360, but limited to 180

    rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);
    rotateStart.copy(rotateEnd);
    scope.update();
  }

  function handleTouchMoveDollyPan(event) {
    //console.log( 'handleTouchMoveDollyPan' );
    if (scope.enableZoom) {
      var dx = event.touches[0].pageX - event.touches[1].pageX;
      var dy = event.touches[0].pageY - event.touches[1].pageY;
      var distance = Math.sqrt(dx * dx + dy * dy);
      dollyEnd.set(0, distance);
      dollyDelta.set(0, Math.pow(dollyEnd.y / dollyStart.y, scope.zoomSpeed));
      dollyIn(dollyDelta.y);
      dollyStart.copy(dollyEnd);
    }

    if (scope.enablePan) {
      var x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);
      var y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);
      panEnd.set(x, y);
      panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
      pan(panDelta.x, panDelta.y);
      panStart.copy(panEnd);
    }

    scope.update();
  }

  function handleTouchEnd(event) {//console.log( 'handleTouchEnd' );
  } //
  // event handlers - FSM: listen for events and reset state
  //


  function onMouseDown(event) {
    if (scope.enabled === false) return;
    event.preventDefault();

    switch (event.button) {
      case scope.mouseButtons.ORBIT:
        if (scope.enableRotate === false) return;
        handleMouseDownRotate(event);
        state = STATE.ROTATE;
        break;

      case scope.mouseButtons.ZOOM:
        if (scope.enableZoom === false) return;
        handleMouseDownDolly(event);
        state = STATE.DOLLY;
        break;

      case scope.mouseButtons.PAN:
        if (scope.enablePan === false) return;
        handleMouseDownPan(event);
        state = STATE.PAN;
        break;
    }

    if (state !== STATE.NONE) {
      document.addEventListener('mousemove', onMouseMove, false);
      document.addEventListener('mouseup', onMouseUp, false);
      scope.dispatchEvent(startEvent);
    }
  }

  function onMouseMove(event) {
    if (scope.enabled === false) return;
    event.preventDefault();

    switch (state) {
      case STATE.ROTATE:
        if (scope.enableRotate === false) return;
        handleMouseMoveRotate(event);
        break;

      case STATE.DOLLY:
        if (scope.enableZoom === false) return;
        handleMouseMoveDolly(event);
        break;

      case STATE.PAN:
        if (scope.enablePan === false) return;
        handleMouseMovePan(event);
        break;
    }
  }

  function onMouseUp(event) {
    if (scope.enabled === false) return;
    handleMouseUp(event);
    document.removeEventListener('mousemove', onMouseMove, false);
    document.removeEventListener('mouseup', onMouseUp, false);
    scope.dispatchEvent(endEvent);
    state = STATE.NONE;
  }

  function onMouseWheel(event) {
    if (scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE && state !== STATE.ROTATE) return;
    event.preventDefault();
    event.stopPropagation();
    scope.dispatchEvent(startEvent);
    handleMouseWheel(event);
    scope.dispatchEvent(endEvent);
  }

  function onKeyDown(event) {
    if (scope.enabled === false || scope.enableKeys === false || scope.enablePan === false) return;
    handleKeyDown(event);
  }

  function onTouchStart(event) {
    if (scope.enabled === false) return;
    event.preventDefault();

    switch (event.touches.length) {
      case 1:
        // one-fingered touch: rotate
        if (scope.enableRotate === false) return;
        handleTouchStartRotate(event);
        state = STATE.TOUCH_ROTATE;
        break;

      case 2:
        // two-fingered touch: dolly-pan
        if (scope.enableZoom === false && scope.enablePan === false) return;
        handleTouchStartDollyPan(event);
        state = STATE.TOUCH_DOLLY_PAN;
        break;

      default:
        state = STATE.NONE;
    }

    if (state !== STATE.NONE) {
      scope.dispatchEvent(startEvent);
    }
  }

  function onTouchMove(event) {
    if (scope.enabled === false) return;
    event.preventDefault();
    event.stopPropagation();

    switch (event.touches.length) {
      case 1:
        // one-fingered touch: rotate
        if (scope.enableRotate === false) return;
        if (state !== STATE.TOUCH_ROTATE) return; // is this needed?

        handleTouchMoveRotate(event);
        break;

      case 2:
        // two-fingered touch: dolly-pan
        if (scope.enableZoom === false && scope.enablePan === false) return;
        if (state !== STATE.TOUCH_DOLLY_PAN) return; // is this needed?

        handleTouchMoveDollyPan(event);
        break;

      default:
        state = STATE.NONE;
    }
  }

  function onTouchEnd(event) {
    if (scope.enabled === false) return;
    handleTouchEnd(event);
    scope.dispatchEvent(endEvent);
    state = STATE.NONE;
  }

  function onContextMenu(event) {
    if (scope.enabled === false) return;
    event.preventDefault();
  } //


  scope.domElement.addEventListener('contextmenu', onContextMenu, false);
  scope.domElement.addEventListener('mousedown', onMouseDown, false);
  scope.domElement.addEventListener('wheel', onMouseWheel, false);
  scope.domElement.addEventListener('touchstart', onTouchStart, false);
  scope.domElement.addEventListener('touchend', onTouchEnd, false);
  scope.domElement.addEventListener('touchmove', onTouchMove, false);
  window.addEventListener('keydown', onKeyDown, false); // force an update at start

  this.update();
};

THREE.OrbitControls.prototype = Object.create(THREE.EventDispatcher.prototype);
THREE.OrbitControls.prototype.constructor = THREE.OrbitControls;
Object.defineProperties(THREE.OrbitControls.prototype, {
  center: {
    get: function get() {
      console.warn('THREE.OrbitControls: .center has been renamed to .target');
      return this.target;
    }
  },
  // backward compatibility
  noZoom: {
    get: function get() {
      console.warn('THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.');
      return !this.enableZoom;
    },
    set: function set(value) {
      console.warn('THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.');
      this.enableZoom = !value;
    }
  },
  noRotate: {
    get: function get() {
      console.warn('THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.');
      return !this.enableRotate;
    },
    set: function set(value) {
      console.warn('THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.');
      this.enableRotate = !value;
    }
  },
  noPan: {
    get: function get() {
      console.warn('THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.');
      return !this.enablePan;
    },
    set: function set(value) {
      console.warn('THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.');
      this.enablePan = !value;
    }
  },
  noKeys: {
    get: function get() {
      console.warn('THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.');
      return !this.enableKeys;
    },
    set: function set(value) {
      console.warn('THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.');
      this.enableKeys = !value;
    }
  },
  staticMoving: {
    get: function get() {
      console.warn('THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.');
      return !this.enableDamping;
    },
    set: function set(value) {
      console.warn('THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.');
      this.enableDamping = !value;
    }
  },
  dynamicDampingFactor: {
    get: function get() {
      console.warn('THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.');
      return this.dampingFactor;
    },
    set: function set(value) {
      console.warn('THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.');
      this.dampingFactor = value;
    }
  }
});
/* harmony default export */ const OrbitControls = (THREE.OrbitControls);
;// CONCATENATED MODULE: ./src/components/simple-3D-gallery/js/index.js




/* 
 *************************************
 * <!-- 3D Gallery with three.js -->
 *************************************
 */


var THREE_GALLERY = function (module, $, window, document) {
  if (window.THREE_GALLERY === null) return false;
  module.THREE_GALLERY = module.THREE_GALLERY || {};
  module.THREE_GALLERY.version = '0.0.5';

  module.THREE_GALLERY.documentReady = function ($) {
    //Prevent this module from loading in other pages
    if ($('#3D-gallery-three-canvas').length == 0 || !Modernizr.webgl) return false;
    var sceneSubjects = []; // Import objects and animations dynamically

    var MainStage = function () {
      var windowWidth = window.innerWidth,
          windowHeight = window.innerHeight;
      var rendererCanvasID = '3D-gallery-three-canvas'; // Generate one plane geometries mesh to scene
      //-------------------------------------	

      var camera,
          controls,
          scene,
          light,
          renderer,
          displacementSprite,
          theta = 0;
      var offsetWidth = 1400,
          offsetHeight = 933,
          allImages = [],
          imgTotal,
          imagesLoaded = false; // we will keep track of the scroll

      var scrollValue = 0;
      var lastScrollValue = 0;

      function init() {
        //camera
        camera = new THREE.PerspectiveCamera(75, windowWidth / windowHeight, 1, 10000);
        camera.position.set(0, 0, 1000); //controls

        controls = new THREE.OrbitControls(camera);
        controls.autoRotate = false;
        controls.autoRotateSpeed = 0.5;
        controls.rotateSpeed = 0.5;
        controls.zoomSpeed = 1.2;
        controls.panSpeed = 0.8;
        controls.enableZoom = false;
        controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled

        controls.dampingFactor = 0.25;
        controls.screenSpacePanning = false;
        controls.minDistance = 100;
        controls.maxDistance = 500;
        controls.maxPolarAngle = Math.PI / 2;
        controls.target.set(30, 167, 81);
        controls.update(); //Scene

        scene = new THREE.Scene(); //HemisphereLight

        scene.add(new THREE.AmbientLight(0x555555));
        light = new THREE.SpotLight(0xffffff, 1.5);
        light.position.set(0, 500, 2000);
        scene.add(light); //WebGL Renderer	

        renderer = new THREE.WebGLRenderer({
          canvas: document.getElementById(rendererCanvasID),
          //canvas
          alpha: true,
          antialias: true
        });
        renderer.setSize(windowWidth, windowHeight); // Immediately use the texture for material creation
        // Create a texture loader so we can load our image file

        var imgs = ['https://placekitten.com/2100/2100', 'https://placekitten.com/2200/2200', 'https://placekitten.com/2300/2300', 'https://placekitten.com/2400/2400', 'https://placekitten.com/2500/2500', 'https://placekitten.com/2000/2000', 'https://placekitten.com/1600/1600', 'https://placekitten.com/1650/1650', 'https://placekitten.com/1670/1670', 'https://placekitten.com/1680/1680', 'https://placekitten.com/1700/1700']; //A loader for loading all images from array.

        var loader = new THREE.TextureLoader();
        loader.crossOrigin = 'anonymous'; //Preload

        imgTotal = imgs.length;
        var gap = 100,
            circumference = (offsetWidth + gap) * imgTotal,
            //get circumference from all images width
        galleryRadius = circumference / (Math.PI * 2),
            // C = 2πr = Math.PI * 2 * radius
        eachItemAngleToRad = Math.PI * 2 / imgTotal; // 360° = 2π = Math.PI * 2

        if (camera.position.length() > galleryRadius) {
          camera.position.set(0, 0, 0);
        } //Load images


        imgs.forEach(function (element, index) {
          loadImage(loader, element, index, offsetWidth, offsetHeight, imgTotal, eachItemAngleToRad, galleryRadius, $('#3D-gallery-three-canvas__loader'));
        }); // Add function to the window that should be resized

        var debounceFuncWindow = UixDebounce(windowUpdate, 50);
        window.removeEventListener('resize', debounceFuncWindow);
        window.addEventListener('resize', debounceFuncWindow); // Add function to the element that should be used as the scrollable area.

        var throttleFunc = UixThrottle(scrollUpdate, 5);
        window.removeEventListener('scroll', throttleFunc);
        window.removeEventListener('touchmove', throttleFunc);
        window.addEventListener('scroll', throttleFunc);
        window.addEventListener('touchmove', throttleFunc);
        throttleFunc();
      }

      function render() {
        requestAnimationFrame(render);
        theta += 0.1; //To set a background color.

        renderer.setClearColor(0x000000); // listen to scroll to update

        var delta = scrollValue - lastScrollValue; // threshold

        if (delta > 60) {
          delta = 60;
        } else if (delta < -60) {
          delta = -60;
        }

        camera.position.x = camera.position.x + delta; //check all images loaded

        if ((0,esm_typeof/* default */.Z)(allImages) != ( true ? "undefined" : 0)) {
          if (!imagesLoaded && allImages.length === imgTotal) {
            allImages.forEach(function (element) {
              scene.add(element);
            });
            imagesLoaded = true;
          }
        } //update camera and controls


        controls.update(); //push objects

        /*
        @Usage: 
             function CustomObj( scene ) {
                 const elements = new THREE...;
                scene.add( elements );
                 this.update = function( time ) {
                    elements.rotation.y = time*0.003;
                }
            }       
             sceneSubjects.push( new CustomObj( MainStage.getScene() ) );  
        */

        for (var i = 0; i < sceneSubjects.length; i++) {
          sceneSubjects[i].update(clock.getElapsedTime() * 1);
        } //render the scene to display our scene through the camera's eye.


        renderer.render(scene, camera);
      }

      function windowUpdate() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function scrollUpdate() {
        lastScrollValue = scrollValue;
        scrollValue = window.pageYOffset;
        console.log('lastScrollValue: ' + lastScrollValue + ', scrollValue: ' + scrollValue);
      }
      /*
       * Load Image
       *
       * @param  {Element} imgLoader       - A loader for loading all images from array.
       * @param  {String} src             - URL of image.
       * @param  {Number} index           - Index of image.
       * @param  {Number} w               - The width of an image, in pixels. 
       * @param  {Number} h               - The height of an image, in pixels. 
       * @param  {Number} total           - Total number of preload images.
       * @param  {Number} itemRadAngle    - An equal radian angle of a sphere for each element.
       * @param  {Number} radius          - Radius length of the sphere (circumference).
       * @param  {Element|String} loading         - Progress bar display control.
       * @return {Void}
       */


      function loadImage(imgLoader, src, index, w, h, total, itemRadAngle, radius, loading) {
        // load a resource
        imgLoader.load( // resource URL
        src, // onLoad callback
        function (texture) {
          // in this example we create the material when the texture is loaded
          var material = new THREE.MeshBasicMaterial({
            map: texture
          });
          var geometry = new THREE.PlaneGeometry(w, h);
          var mesh = new THREE.Mesh(geometry, material); //LinearFilter, which takes the four closest texels and bilinearly interpolates among them. 

          mesh.minFilter = THREE.LinearFilter;
          mesh.overdraw = true; //Calculate the position of the image 
          //X axis: a = sinA * c = Math.sin( rad ) * radius
          //Z axis: b = cosA * c = Math.cos( rad ) * radius

          mesh.rotation.y = -index * itemRadAngle;
          mesh.position.set(radius * Math.sin(index * itemRadAngle), 0, -radius * Math.cos(index * itemRadAngle));
          allImages.push(mesh); //loading

          TweenMax.to(loading, 0.5, {
            width: Math.round(100 * allImages.length / total) + '%',
            onComplete: function onComplete() {
              if ($(this.target).width() >= windowWidth - 50) {
                TweenMax.to(this.target, 0.5, {
                  alpha: 0
                });
              }
            }
          });
        }, // onProgress callback currently not supported
        undefined, // onError callback
        function (err) {
          console.error('An error happened.');
        });
      } // 
      //-------------------------------------	


      return {
        init: init,
        render: render,
        getRendererCanvasID: function getRendererCanvasID() {
          return rendererCanvasID;
        },
        getScene: function getScene() {
          return scene;
        },
        getCamera: function getCamera() {
          return camera;
        }
      };
    }();

    MainStage.init();
    MainStage.render();
  };

  module.components.documentReady.push(module.THREE_GALLERY.documentReady);
  return /*#__PURE__*/_createClass(function THREE_GALLERY() {
    _classCallCheck(this, THREE_GALLERY);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/simple-3D-image-transition/js/shader/fragment-custom.glsl
/* harmony default export */ const shader_fragment_custom = ("#define GLSLIFY 1\nvarying vec2 vUv;\n\nuniform sampler2D texture;\nuniform sampler2D texture2;\nuniform sampler2D disp;\n\n// uniform float time;\n// uniform float _rot;\nuniform float dispFactor;\nuniform float effectFactor;\n\n// vec2 rotate(vec2 v, float a) {\n//  float s = sin(a);\n//  float c = cos(a);\n//  mat2 m = mat2(c, -s, s, c);\n//  return m * v;\n// }\n\nvoid main() {\n\n    vec2 uv = vUv;\n\n    // uv -= 0.5;\n    // vec2 rotUV = rotate(uv, _rot);\n    // uv += 0.5;\n\n    vec4 disp = texture2D(disp, uv);\n\n    vec2 distortedPosition = vec2(uv.x + dispFactor * (disp.r*effectFactor), uv.y);\n    vec2 distortedPosition2 = vec2(uv.x - (1.0 - dispFactor) * (disp.r*effectFactor), uv.y);\n\n    vec4 _texture = texture2D(texture, distortedPosition);\n    vec4 _texture2 = texture2D(texture2, distortedPosition2);\n\n    vec4 finalTexture = mix(_texture, _texture2, dispFactor);\n\n    gl_FragColor = finalTexture;\n    // gl_FragColor = disp;\n}");
;// CONCATENATED MODULE: ./src/components/simple-3D-image-transition/js/shader/vertex-custom.glsl
/* harmony default export */ const shader_vertex_custom = ("#define GLSLIFY 1\nvarying vec2 vUv;\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}");
;// CONCATENATED MODULE: ./src/components/simple-3D-image-transition/js/index.js



/* 
 *************************************
 * <!-- 3D Image Transition with three.js -->
 *************************************
 */




var THREE_IMAGE_TRANSITION = function (module, $, window, document) {
  if (window.THREE_IMAGE_TRANSITION === null) return false;
  module.THREE_IMAGE_TRANSITION = module.THREE_IMAGE_TRANSITION || {};
  module.THREE_IMAGE_TRANSITION.version = '0.0.3';

  module.THREE_IMAGE_TRANSITION.documentReady = function ($) {
    //Prevent this module from loading in other pages
    if ($('#3D-imagetransition-three-canvas').length == 0 || !Modernizr.webgl) return false;
    var sceneSubjects = []; // Import objects and animations dynamically

    var MainStage = function () {
      var windowWidth = window.innerWidth,
          windowHeight = window.innerHeight;
      var rendererCanvasID = '3D-imagetransition-three-canvas'; // Generate one plane geometries mesh to scene
      //-------------------------------------	

      var camera,
          controls,
          scene,
          light,
          renderer,
          displacementSprite,
          theta = 0;
      var filterMaterial,
          offsetWidth = $('#' + rendererCanvasID).parent().width(),
          offsetHeight = $('#' + rendererCanvasID).parent().width() * (550 / 1400);

      function init() {
        //camera
        camera = new THREE.PerspectiveCamera(75, windowWidth / windowHeight, 1, 10000);
        camera.position.set(0, 0, 1000); //controls

        controls = new THREE.OrbitControls(camera);
        controls.autoRotate = false;
        controls.autoRotateSpeed = 0.5;
        controls.rotateSpeed = 0.5;
        controls.zoomSpeed = 1.2;
        controls.panSpeed = 0.8;
        controls.enableZoom = false;
        controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled

        controls.dampingFactor = 0.25;
        controls.screenSpacePanning = false;
        controls.minDistance = 100;
        controls.maxDistance = 500;
        controls.maxPolarAngle = Math.PI / 2;
        controls.target.set(30, 167, 81);
        controls.update(); //Scene

        scene = new THREE.Scene(); //HemisphereLight

        scene.add(new THREE.AmbientLight(0x555555));
        light = new THREE.SpotLight(0xffffff, 1.5);
        light.position.set(0, 500, 2000);
        scene.add(light); //WebGL Renderer	

        renderer = new THREE.WebGLRenderer({
          canvas: document.getElementById(rendererCanvasID),
          //canvas
          alpha: true,
          antialias: true
        });
        renderer.setSize(offsetWidth, offsetHeight); // Immediately use the texture for material creation
        // Create a texture loader so we can load our image file

        var imgs = ['https://placekitten.com/1400/550', 'https://placekitten.com/1410/550'];
        var loader = new THREE.TextureLoader();
        loader.crossOrigin = 'anonymous';
        var texture1 = loader.load(imgs[0]),
            texture2 = loader.load(imgs[1]),
            intensity = 1,
            dispImage = $('#' + rendererCanvasID).data('filter-texture'),
            //Load displacement image
        disp = loader.load(dispImage);
        disp.wrapS = disp.wrapT = THREE.RepeatWrapping;
        texture1.magFilter = texture2.magFilter = THREE.LinearFilter;
        texture1.minFilter = texture2.minFilter = THREE.LinearFilter;
        texture1.anisotropy = renderer.capabilities.getMaxAnisotropy();
        texture2.anisotropy = renderer.capabilities.getMaxAnisotropy();
        var geometry = new THREE.PlaneBufferGeometry(offsetWidth, offsetHeight, 1);
        filterMaterial = new THREE.ShaderMaterial({
          uniforms: {
            effectFactor: {
              type: "f",
              value: intensity
            },
            dispFactor: {
              type: "f",
              value: 0.0
            },
            texture: {
              type: "t",
              value: texture1
            },
            texture2: {
              type: "t",
              value: texture2
            },
            disp: {
              type: "t",
              value: disp
            }
          },
          vertexShader: shader_vertex_custom,
          fragmentShader: shader_fragment_custom,
          transparent: true,
          opacity: 1.0
        });
        displacementSprite = new THREE.Mesh(geometry, filterMaterial);
        displacementSprite.position.set(0, 0, 0);
        scene.add(displacementSprite); // Fires when the window changes

        window.addEventListener('resize', onWindowResize, false); // When the mouse moves, call the given function

        document.getElementById(rendererCanvasID).addEventListener('mouseenter', onDocumentMouseEnter, false);
        document.getElementById(rendererCanvasID).addEventListener('mouseleave', onDocumentMouseLeave, false);
      }

      function render() {
        requestAnimationFrame(render);
        theta += 0.1; //To set a background color.
        //renderer.setClearColor( 0x000000 );	
        //update camera and controls

        controls.update(); //push objects

        /*
        @Usage: 
             function CustomObj( scene ) {
                 const elements = new THREE...;
                scene.add( elements );
                 this.update = function( time ) {
                    elements.rotation.y = time*0.003;
                }
            }       
             sceneSubjects.push( new CustomObj( MainStage.getScene() ) );  
        */

        for (var i = 0; i < sceneSubjects.length; i++) {
          sceneSubjects[i].update(clock.getElapsedTime() * 1);
        } //render the scene to display our scene through the camera's eye.


        renderer.render(scene, camera);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function onDocumentMouseEnter(event) {
        TweenMax.to(filterMaterial.uniforms.dispFactor, 1.5, {
          value: 1,
          ease: Expo.easeOut
        });
      }

      function onDocumentMouseLeave(event) {
        TweenMax.to(filterMaterial.uniforms.dispFactor, 1, {
          value: 0,
          ease: Expo.easeOut
        });
      } // 
      //-------------------------------------	


      return {
        init: init,
        render: render,
        getRendererCanvasID: function getRendererCanvasID() {
          return rendererCanvasID;
        },
        getScene: function getScene() {
          return scene;
        },
        getCamera: function getCamera() {
          return camera;
        }
      };
    }();

    MainStage.init();
    MainStage.render();
  };

  module.components.documentReady.push(module.THREE_IMAGE_TRANSITION.documentReady);
  return /*#__PURE__*/_createClass(function THREE_IMAGE_TRANSITION() {
    _classCallCheck(this, THREE_IMAGE_TRANSITION);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/_third-party-plugins/THREE/esm/loaders/GLTFLoader.js
/**
 * @author Rich Tibbett / https://github.com/richtr
 * @author mrdoob / http://mrdoob.com/
 * @author Tony Parisi / http://www.tonyparisi.com/
 * @author Takahiro / https://github.com/takahirox
 * @author Don McCurdy / https://www.donmccurdy.com
 */
THREE.GLTFLoader = function () {
  function GLTFLoader(manager) {
    this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;
    this.dracoLoader = null;
  }

  GLTFLoader.prototype = {
    constructor: GLTFLoader,
    crossOrigin: 'Anonymous',
    load: function load(url, onLoad, onProgress, onError) {
      var scope = this;
      var path = this.path !== undefined ? this.path : THREE.LoaderUtils.extractUrlBase(url);
      var loader = new THREE.FileLoader(scope.manager);
      loader.setResponseType('arraybuffer');
      loader.load(url, function (data) {
        try {
          scope.parse(data, path, onLoad, onError);
        } catch (e) {
          if (onError !== undefined) {
            onError(e);
          } else {
            throw e;
          }
        }
      }, onProgress, onError);
    },
    setCrossOrigin: function setCrossOrigin(value) {
      this.crossOrigin = value;
      return this;
    },
    setPath: function setPath(value) {
      this.path = value;
      return this;
    },
    setDRACOLoader: function setDRACOLoader(dracoLoader) {
      this.dracoLoader = dracoLoader;
      return this;
    },
    parse: function parse(data, path, onLoad, onError) {
      var content;
      var extensions = {};

      if (typeof data === 'string') {
        content = data;
      } else {
        var magic = THREE.LoaderUtils.decodeText(new Uint8Array(data, 0, 4));

        if (magic === BINARY_EXTENSION_HEADER_MAGIC) {
          try {
            extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);
          } catch (error) {
            if (onError) onError(error);
            return;
          }

          content = extensions[EXTENSIONS.KHR_BINARY_GLTF].content;
        } else {
          content = THREE.LoaderUtils.decodeText(new Uint8Array(data));
        }
      }

      var json = JSON.parse(content);

      if (json.asset === undefined || json.asset.version[0] < 2) {
        if (onError) onError(new Error('THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported. Use LegacyGLTFLoader instead.'));
        return;
      }

      if (json.extensionsUsed) {
        for (var i = 0; i < json.extensionsUsed.length; ++i) {
          var extensionName = json.extensionsUsed[i];
          var extensionsRequired = json.extensionsRequired || [];

          switch (extensionName) {
            case EXTENSIONS.KHR_LIGHTS:
              extensions[extensionName] = new GLTFLightsExtension(json);
              break;

            case EXTENSIONS.KHR_MATERIALS_UNLIT:
              extensions[extensionName] = new GLTFMaterialsUnlitExtension(json);
              break;

            case EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
              extensions[extensionName] = new GLTFMaterialsPbrSpecularGlossinessExtension();
              break;

            case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:
              extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader);
              break;

            case EXTENSIONS.MSFT_TEXTURE_DDS:
              extensions[EXTENSIONS.MSFT_TEXTURE_DDS] = new GLTFTextureDDSExtension();
              break;

            default:
              if (extensionsRequired.indexOf(extensionName) >= 0) {
                console.warn('THREE.GLTFLoader: Unknown extension "' + extensionName + '".');
              }

          }
        }
      }

      var parser = new GLTFParser(json, extensions, {
        path: path || this.path || '',
        crossOrigin: this.crossOrigin,
        manager: this.manager
      });
      parser.parse(function (scene, scenes, cameras, animations, json) {
        var glTF = {
          scene: scene,
          scenes: scenes,
          cameras: cameras,
          animations: animations,
          asset: json.asset,
          parser: parser,
          userData: {}
        };
        addUnknownExtensionsToUserData(extensions, glTF, json);
        onLoad(glTF);
      }, onError);
    }
  };
  /* GLTFREGISTRY */

  function GLTFRegistry() {
    var objects = {};
    return {
      get: function get(key) {
        return objects[key];
      },
      add: function add(key, object) {
        objects[key] = object;
      },
      remove: function remove(key) {
        delete objects[key];
      },
      removeAll: function removeAll() {
        objects = {};
      }
    };
  }
  /*********************************/

  /********** EXTENSIONS ***********/

  /*********************************/


  var EXTENSIONS = {
    KHR_BINARY_GLTF: 'KHR_binary_glTF',
    KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',
    KHR_LIGHTS: 'KHR_lights',
    KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: 'KHR_materials_pbrSpecularGlossiness',
    KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',
    MSFT_TEXTURE_DDS: 'MSFT_texture_dds'
  };
  /**
   * DDS Texture Extension
   *
   * Specification: 
   * https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/MSFT_texture_dds
   * 
   */

  function GLTFTextureDDSExtension() {
    if (!THREE.DDSLoader) {
      throw new Error('THREE.GLTFLoader: Attempting to load .dds texture without importing THREE.DDSLoader');
    }

    this.name = EXTENSIONS.MSFT_TEXTURE_DDS;
    this.ddsLoader = new THREE.DDSLoader();
  }
  /**
   * Lights Extension
   *
   * Specification: PENDING
   */


  function GLTFLightsExtension(json) {
    this.name = EXTENSIONS.KHR_LIGHTS;
    this.lights = {};
    var extension = json.extensions && json.extensions[EXTENSIONS.KHR_LIGHTS] || {};
    var lights = extension.lights || {};

    for (var lightId in lights) {
      var light = lights[lightId];
      var lightNode;
      var color = new THREE.Color().fromArray(light.color);

      switch (light.type) {
        case 'directional':
          lightNode = new THREE.DirectionalLight(color);
          lightNode.target.position.set(0, 0, 1);
          lightNode.add(lightNode.target);
          break;

        case 'point':
          lightNode = new THREE.PointLight(color);
          break;

        case 'spot':
          lightNode = new THREE.SpotLight(color); // Handle spotlight properties.

          light.spot = light.spot || {};
          light.spot.innerConeAngle = light.spot.innerConeAngle !== undefined ? light.spot.innerConeAngle : 0;
          light.spot.outerConeAngle = light.spot.outerConeAngle !== undefined ? light.spot.outerConeAngle : Math.PI / 4.0;
          lightNode.angle = light.spot.outerConeAngle;
          lightNode.penumbra = 1.0 - light.spot.innerConeAngle / light.spot.outerConeAngle;
          lightNode.target.position.set(0, 0, 1);
          lightNode.add(lightNode.target);
          break;

        case 'ambient':
          lightNode = new THREE.AmbientLight(color);
          break;
      }

      if (lightNode) {
        lightNode.decay = 2;

        if (light.intensity !== undefined) {
          lightNode.intensity = light.intensity;
        }

        lightNode.name = light.name || 'light_' + lightId;
        this.lights[lightId] = lightNode;
      }
    }
  }
  /**
   * Unlit Materials Extension (pending)
   *
   * PR: https://github.com/KhronosGroup/glTF/pull/1163
   */


  function GLTFMaterialsUnlitExtension(json) {
    this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;
  }

  GLTFMaterialsUnlitExtension.prototype.getMaterialType = function (material) {
    return THREE.MeshBasicMaterial;
  };

  GLTFMaterialsUnlitExtension.prototype.extendParams = function (materialParams, material, parser) {
    var pending = [];
    materialParams.color = new THREE.Color(1.0, 1.0, 1.0);
    materialParams.opacity = 1.0;
    var metallicRoughness = material.pbrMetallicRoughness;

    if (metallicRoughness) {
      if (Array.isArray(metallicRoughness.baseColorFactor)) {
        var array = metallicRoughness.baseColorFactor;
        materialParams.color.fromArray(array);
        materialParams.opacity = array[3];
      }

      if (metallicRoughness.baseColorTexture !== undefined) {
        pending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture.index));
      }
    }

    return Promise.all(pending);
  };
  /* BINARY EXTENSION */


  var BINARY_EXTENSION_BUFFER_NAME = 'binary_glTF';
  var BINARY_EXTENSION_HEADER_MAGIC = 'glTF';
  var BINARY_EXTENSION_HEADER_LENGTH = 12;
  var BINARY_EXTENSION_CHUNK_TYPES = {
    JSON: 0x4E4F534A,
    BIN: 0x004E4942
  };

  function GLTFBinaryExtension(data) {
    this.name = EXTENSIONS.KHR_BINARY_GLTF;
    this.content = null;
    this.body = null;
    var headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);
    this.header = {
      magic: THREE.LoaderUtils.decodeText(new Uint8Array(data.slice(0, 4))),
      version: headerView.getUint32(4, true),
      length: headerView.getUint32(8, true)
    };

    if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {
      throw new Error('THREE.GLTFLoader: Unsupported glTF-Binary header.');
    } else if (this.header.version < 2.0) {
      throw new Error('THREE.GLTFLoader: Legacy binary file detected. Use LegacyGLTFLoader instead.');
    }

    var chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);
    var chunkIndex = 0;

    while (chunkIndex < chunkView.byteLength) {
      var chunkLength = chunkView.getUint32(chunkIndex, true);
      chunkIndex += 4;
      var chunkType = chunkView.getUint32(chunkIndex, true);
      chunkIndex += 4;

      if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {
        var contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);
        this.content = THREE.LoaderUtils.decodeText(contentArray);
      } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {
        var byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;
        this.body = data.slice(byteOffset, byteOffset + chunkLength);
      } // Clients must ignore chunks with unknown types.


      chunkIndex += chunkLength;
    }

    if (this.content === null) {
      throw new Error('THREE.GLTFLoader: JSON content not found.');
    }
  }
  /**
   * DRACO Mesh Compression Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/pull/874
   */


  function GLTFDracoMeshCompressionExtension(json, dracoLoader) {
    if (!dracoLoader) {
      throw new Error('THREE.GLTFLoader: No DRACOLoader instance provided.');
    }

    this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;
    this.json = json;
    this.dracoLoader = dracoLoader;
  }

  GLTFDracoMeshCompressionExtension.prototype.decodePrimitive = function (primitive, parser) {
    var json = this.json;
    var dracoLoader = this.dracoLoader;
    var bufferViewIndex = primitive.extensions[this.name].bufferView;
    var gltfAttributeMap = primitive.extensions[this.name].attributes;
    var threeAttributeMap = {};
    var attributeNormalizedMap = {};
    var attributeTypeMap = {};

    for (var attributeName in gltfAttributeMap) {
      if (!(attributeName in ATTRIBUTES)) continue;
      threeAttributeMap[ATTRIBUTES[attributeName]] = gltfAttributeMap[attributeName];
    }

    for (attributeName in primitive.attributes) {
      if (ATTRIBUTES[attributeName] !== undefined && gltfAttributeMap[attributeName] !== undefined) {
        var accessorDef = json.accessors[primitive.attributes[attributeName]];
        var componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
        attributeTypeMap[ATTRIBUTES[attributeName]] = componentType;
        attributeNormalizedMap[ATTRIBUTES[attributeName]] = accessorDef.normalized === true;
      }
    }

    return parser.getDependency('bufferView', bufferViewIndex).then(function (bufferView) {
      return new Promise(function (resolve) {
        dracoLoader.decodeDracoFile(bufferView, function (geometry) {
          for (var attributeName in geometry.attributes) {
            var attribute = geometry.attributes[attributeName];
            var normalized = attributeNormalizedMap[attributeName];
            if (normalized !== undefined) attribute.normalized = normalized;
          }

          resolve(geometry);
        }, threeAttributeMap, attributeTypeMap);
      });
    });
  };
  /**
   * Specular-Glossiness Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness
   */


  function GLTFMaterialsPbrSpecularGlossinessExtension() {
    return {
      name: EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,
      specularGlossinessParams: ['color', 'map', 'lightMap', 'lightMapIntensity', 'aoMap', 'aoMapIntensity', 'emissive', 'emissiveIntensity', 'emissiveMap', 'bumpMap', 'bumpScale', 'normalMap', 'displacementMap', 'displacementScale', 'displacementBias', 'specularMap', 'specular', 'glossinessMap', 'glossiness', 'alphaMap', 'envMap', 'envMapIntensity', 'refractionRatio'],
      getMaterialType: function getMaterialType() {
        return THREE.ShaderMaterial;
      },
      extendParams: function extendParams(params, material, parser) {
        var pbrSpecularGlossiness = material.extensions[this.name];
        var shader = THREE.ShaderLib['standard'];
        var uniforms = THREE.UniformsUtils.clone(shader.uniforms);
        var specularMapParsFragmentChunk = ['#ifdef USE_SPECULARMAP', '	uniform sampler2D specularMap;', '#endif'].join('\n');
        var glossinessMapParsFragmentChunk = ['#ifdef USE_GLOSSINESSMAP', '	uniform sampler2D glossinessMap;', '#endif'].join('\n');
        var specularMapFragmentChunk = ['vec3 specularFactor = specular;', '#ifdef USE_SPECULARMAP', '	vec4 texelSpecular = texture2D( specularMap, vUv );', '	texelSpecular = sRGBToLinear( texelSpecular );', '	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture', '	specularFactor *= texelSpecular.rgb;', '#endif'].join('\n');
        var glossinessMapFragmentChunk = ['float glossinessFactor = glossiness;', '#ifdef USE_GLOSSINESSMAP', '	vec4 texelGlossiness = texture2D( glossinessMap, vUv );', '	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture', '	glossinessFactor *= texelGlossiness.a;', '#endif'].join('\n');
        var lightPhysicalFragmentChunk = ['PhysicalMaterial material;', 'material.diffuseColor = diffuseColor.rgb;', 'material.specularRoughness = clamp( 1.0 - glossinessFactor, 0.04, 1.0 );', 'material.specularColor = specularFactor.rgb;'].join('\n');
        var fragmentShader = shader.fragmentShader.replace('uniform float roughness;', 'uniform vec3 specular;').replace('uniform float metalness;', 'uniform float glossiness;').replace('#include <roughnessmap_pars_fragment>', specularMapParsFragmentChunk).replace('#include <metalnessmap_pars_fragment>', glossinessMapParsFragmentChunk).replace('#include <roughnessmap_fragment>', specularMapFragmentChunk).replace('#include <metalnessmap_fragment>', glossinessMapFragmentChunk).replace('#include <lights_physical_fragment>', lightPhysicalFragmentChunk);
        delete uniforms.roughness;
        delete uniforms.metalness;
        delete uniforms.roughnessMap;
        delete uniforms.metalnessMap;
        uniforms.specular = {
          value: new THREE.Color().setHex(0x111111)
        };
        uniforms.glossiness = {
          value: 0.5
        };
        uniforms.specularMap = {
          value: null
        };
        uniforms.glossinessMap = {
          value: null
        };
        params.vertexShader = shader.vertexShader;
        params.fragmentShader = fragmentShader;
        params.uniforms = uniforms;
        params.defines = {
          'STANDARD': ''
        };
        params.color = new THREE.Color(1.0, 1.0, 1.0);
        params.opacity = 1.0;
        var pending = [];

        if (Array.isArray(pbrSpecularGlossiness.diffuseFactor)) {
          var array = pbrSpecularGlossiness.diffuseFactor;
          params.color.fromArray(array);
          params.opacity = array[3];
        }

        if (pbrSpecularGlossiness.diffuseTexture !== undefined) {
          pending.push(parser.assignTexture(params, 'map', pbrSpecularGlossiness.diffuseTexture.index));
        }

        params.emissive = new THREE.Color(0.0, 0.0, 0.0);
        params.glossiness = pbrSpecularGlossiness.glossinessFactor !== undefined ? pbrSpecularGlossiness.glossinessFactor : 1.0;
        params.specular = new THREE.Color(1.0, 1.0, 1.0);

        if (Array.isArray(pbrSpecularGlossiness.specularFactor)) {
          params.specular.fromArray(pbrSpecularGlossiness.specularFactor);
        }

        if (pbrSpecularGlossiness.specularGlossinessTexture !== undefined) {
          var specGlossIndex = pbrSpecularGlossiness.specularGlossinessTexture.index;
          pending.push(parser.assignTexture(params, 'glossinessMap', specGlossIndex));
          pending.push(parser.assignTexture(params, 'specularMap', specGlossIndex));
        }

        return Promise.all(pending);
      },
      createMaterial: function createMaterial(params) {
        // setup material properties based on MeshStandardMaterial for Specular-Glossiness
        var material = new THREE.ShaderMaterial({
          defines: params.defines,
          vertexShader: params.vertexShader,
          fragmentShader: params.fragmentShader,
          uniforms: params.uniforms,
          fog: true,
          lights: true,
          opacity: params.opacity,
          transparent: params.transparent
        });
        material.isGLTFSpecularGlossinessMaterial = true;
        material.color = params.color;
        material.map = params.map === undefined ? null : params.map;
        material.lightMap = null;
        material.lightMapIntensity = 1.0;
        material.aoMap = params.aoMap === undefined ? null : params.aoMap;
        material.aoMapIntensity = 1.0;
        material.emissive = params.emissive;
        material.emissiveIntensity = 1.0;
        material.emissiveMap = params.emissiveMap === undefined ? null : params.emissiveMap;
        material.bumpMap = params.bumpMap === undefined ? null : params.bumpMap;
        material.bumpScale = 1;
        material.normalMap = params.normalMap === undefined ? null : params.normalMap;
        if (params.normalScale) material.normalScale = params.normalScale;
        material.displacementMap = null;
        material.displacementScale = 1;
        material.displacementBias = 0;
        material.specularMap = params.specularMap === undefined ? null : params.specularMap;
        material.specular = params.specular;
        material.glossinessMap = params.glossinessMap === undefined ? null : params.glossinessMap;
        material.glossiness = params.glossiness;
        material.alphaMap = null;
        material.envMap = params.envMap === undefined ? null : params.envMap;
        material.envMapIntensity = 1.0;
        material.refractionRatio = 0.98;
        material.extensions.derivatives = true;
        return material;
      },

      /**
       * Clones a GLTFSpecularGlossinessMaterial instance. The ShaderMaterial.copy() method can
       * copy only properties it knows about or inherits, and misses many properties that would
       * normally be defined by MeshStandardMaterial.
       *
       * This method allows GLTFSpecularGlossinessMaterials to be cloned in the process of
       * loading a glTF model, but cloning later (e.g. by the user) would require these changes
       * AND also updating `.onBeforeRender` on the parent mesh.
       *
       * @param  {THREE.ShaderMaterial} source
       * @return {THREE.ShaderMaterial}
       */
      cloneMaterial: function cloneMaterial(source) {
        var target = source.clone();
        target.isGLTFSpecularGlossinessMaterial = true;
        var params = this.specularGlossinessParams;

        for (var i = 0, il = params.length; i < il; i++) {
          target[params[i]] = source[params[i]];
        }

        return target;
      },
      // Here's based on refreshUniformsCommon() and refreshUniformsStandard() in WebGLRenderer.
      refreshUniforms: function refreshUniforms(renderer, scene, camera, geometry, material, group) {
        if (material.isGLTFSpecularGlossinessMaterial !== true) {
          return;
        }

        var uniforms = material.uniforms;
        var defines = material.defines;
        uniforms.opacity.value = material.opacity;
        uniforms.diffuse.value.copy(material.color);
        uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
        uniforms.map.value = material.map;
        uniforms.specularMap.value = material.specularMap;
        uniforms.alphaMap.value = material.alphaMap;
        uniforms.lightMap.value = material.lightMap;
        uniforms.lightMapIntensity.value = material.lightMapIntensity;
        uniforms.aoMap.value = material.aoMap;
        uniforms.aoMapIntensity.value = material.aoMapIntensity; // uv repeat and offset setting priorities
        // 1. color map
        // 2. specular map
        // 3. normal map
        // 4. bump map
        // 5. alpha map
        // 6. emissive map

        var uvScaleMap;

        if (material.map) {
          uvScaleMap = material.map;
        } else if (material.specularMap) {
          uvScaleMap = material.specularMap;
        } else if (material.displacementMap) {
          uvScaleMap = material.displacementMap;
        } else if (material.normalMap) {
          uvScaleMap = material.normalMap;
        } else if (material.bumpMap) {
          uvScaleMap = material.bumpMap;
        } else if (material.glossinessMap) {
          uvScaleMap = material.glossinessMap;
        } else if (material.alphaMap) {
          uvScaleMap = material.alphaMap;
        } else if (material.emissiveMap) {
          uvScaleMap = material.emissiveMap;
        }

        if (uvScaleMap !== undefined) {
          // backwards compatibility
          if (uvScaleMap.isWebGLRenderTarget) {
            uvScaleMap = uvScaleMap.texture;
          }

          var offset;
          var repeat;

          if (uvScaleMap.matrix !== undefined) {
            // > r88.
            if (uvScaleMap.matrixAutoUpdate === true) {
              offset = uvScaleMap.offset;
              repeat = uvScaleMap.repeat;
              var rotation = uvScaleMap.rotation;
              var center = uvScaleMap.center;
              uvScaleMap.matrix.setUvTransform(offset.x, offset.y, repeat.x, repeat.y, rotation, center.x, center.y);
            }

            uniforms.uvTransform.value.copy(uvScaleMap.matrix);
          } else {
            // <= r87. Remove when reasonable.
            offset = uvScaleMap.offset;
            repeat = uvScaleMap.repeat;
            uniforms.offsetRepeat.value.set(offset.x, offset.y, repeat.x, repeat.y);
          }
        }

        uniforms.envMap.value = material.envMap;
        uniforms.envMapIntensity.value = material.envMapIntensity;
        uniforms.flipEnvMap.value = material.envMap && material.envMap.isCubeTexture ? -1 : 1;
        uniforms.refractionRatio.value = material.refractionRatio;
        uniforms.specular.value.copy(material.specular);
        uniforms.glossiness.value = material.glossiness;
        uniforms.glossinessMap.value = material.glossinessMap;
        uniforms.emissiveMap.value = material.emissiveMap;
        uniforms.bumpMap.value = material.bumpMap;
        uniforms.normalMap.value = material.normalMap;
        uniforms.displacementMap.value = material.displacementMap;
        uniforms.displacementScale.value = material.displacementScale;
        uniforms.displacementBias.value = material.displacementBias;

        if (uniforms.glossinessMap.value !== null && defines.USE_GLOSSINESSMAP === undefined) {
          defines.USE_GLOSSINESSMAP = ''; // set USE_ROUGHNESSMAP to enable vUv

          defines.USE_ROUGHNESSMAP = '';
        }

        if (uniforms.glossinessMap.value === null && defines.USE_GLOSSINESSMAP !== undefined) {
          delete defines.USE_GLOSSINESSMAP;
          delete defines.USE_ROUGHNESSMAP;
        }
      }
    };
  }
  /*********************************/

  /********** INTERPOLATION ********/

  /*********************************/
  // Spline Interpolation
  // Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation


  function GLTFCubicSplineInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    THREE.Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
  }

  ;
  GLTFCubicSplineInterpolant.prototype = Object.create(THREE.Interpolant.prototype);
  GLTFCubicSplineInterpolant.prototype.constructor = GLTFCubicSplineInterpolant;

  GLTFCubicSplineInterpolant.prototype.interpolate_ = function (i1, t0, t, t1) {
    var result = this.resultBuffer;
    var values = this.sampleValues;
    var stride = this.valueSize;
    var stride2 = stride * 2;
    var stride3 = stride * 3;
    var td = t1 - t0;
    var p = (t - t0) / td;
    var pp = p * p;
    var ppp = pp * p;
    var offset1 = i1 * stride3;
    var offset0 = offset1 - stride3;
    var s0 = 2 * ppp - 3 * pp + 1;
    var s1 = ppp - 2 * pp + p;
    var s2 = -2 * ppp + 3 * pp;
    var s3 = ppp - pp; // Layout of keyframe output values for CUBICSPLINE animations:
    //   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]

    for (var i = 0; i !== stride; i++) {
      var p0 = values[offset0 + i + stride]; // splineVertex_k

      var m0 = values[offset0 + i + stride2] * td; // outTangent_k * (t_k+1 - t_k)

      var p1 = values[offset1 + i + stride]; // splineVertex_k+1

      var m1 = values[offset1 + i] * td; // inTangent_k+1 * (t_k+1 - t_k)

      result[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;
    }

    return result;
  };
  /*********************************/

  /********** INTERNALS ************/

  /*********************************/

  /* CONSTANTS */


  var WEBGL_CONSTANTS = {
    FLOAT: 5126,
    //FLOAT_MAT2: 35674,
    FLOAT_MAT3: 35675,
    FLOAT_MAT4: 35676,
    FLOAT_VEC2: 35664,
    FLOAT_VEC3: 35665,
    FLOAT_VEC4: 35666,
    LINEAR: 9729,
    REPEAT: 10497,
    SAMPLER_2D: 35678,
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6,
    UNSIGNED_BYTE: 5121,
    UNSIGNED_SHORT: 5123
  };
  var WEBGL_TYPE = {
    5126: Number,
    //35674: THREE.Matrix2,
    35675: THREE.Matrix3,
    35676: THREE.Matrix4,
    35664: THREE.Vector2,
    35665: THREE.Vector3,
    35666: THREE.Vector4,
    35678: THREE.Texture
  };
  var WEBGL_COMPONENT_TYPES = {
    5120: Int8Array,
    5121: Uint8Array,
    5122: Int16Array,
    5123: Uint16Array,
    5125: Uint32Array,
    5126: Float32Array
  };
  var WEBGL_FILTERS = {
    9728: THREE.NearestFilter,
    9729: THREE.LinearFilter,
    9984: THREE.NearestMipMapNearestFilter,
    9985: THREE.LinearMipMapNearestFilter,
    9986: THREE.NearestMipMapLinearFilter,
    9987: THREE.LinearMipMapLinearFilter
  };
  var WEBGL_WRAPPINGS = {
    33071: THREE.ClampToEdgeWrapping,
    33648: THREE.MirroredRepeatWrapping,
    10497: THREE.RepeatWrapping
  };
  var WEBGL_TEXTURE_FORMATS = {
    6406: THREE.AlphaFormat,
    6407: THREE.RGBFormat,
    6408: THREE.RGBAFormat,
    6409: THREE.LuminanceFormat,
    6410: THREE.LuminanceAlphaFormat
  };
  var WEBGL_TEXTURE_DATATYPES = {
    5121: THREE.UnsignedByteType,
    32819: THREE.UnsignedShort4444Type,
    32820: THREE.UnsignedShort5551Type,
    33635: THREE.UnsignedShort565Type
  };
  var WEBGL_SIDES = {
    1028: THREE.BackSide,
    // Culling front
    1029: THREE.FrontSide // Culling back
    //1032: THREE.NoSide   // Culling front and back, what to do?

  };
  var WEBGL_DEPTH_FUNCS = {
    512: THREE.NeverDepth,
    513: THREE.LessDepth,
    514: THREE.EqualDepth,
    515: THREE.LessEqualDepth,
    516: THREE.GreaterEqualDepth,
    517: THREE.NotEqualDepth,
    518: THREE.GreaterEqualDepth,
    519: THREE.AlwaysDepth
  };
  var WEBGL_BLEND_EQUATIONS = {
    32774: THREE.AddEquation,
    32778: THREE.SubtractEquation,
    32779: THREE.ReverseSubtractEquation
  };
  var WEBGL_BLEND_FUNCS = {
    0: THREE.ZeroFactor,
    1: THREE.OneFactor,
    768: THREE.SrcColorFactor,
    769: THREE.OneMinusSrcColorFactor,
    770: THREE.SrcAlphaFactor,
    771: THREE.OneMinusSrcAlphaFactor,
    772: THREE.DstAlphaFactor,
    773: THREE.OneMinusDstAlphaFactor,
    774: THREE.DstColorFactor,
    775: THREE.OneMinusDstColorFactor,
    776: THREE.SrcAlphaSaturateFactor // The followings are not supported by Three.js yet
    //32769: CONSTANT_COLOR,
    //32770: ONE_MINUS_CONSTANT_COLOR,
    //32771: CONSTANT_ALPHA,
    //32772: ONE_MINUS_CONSTANT_COLOR

  };
  var WEBGL_TYPE_SIZES = {
    'SCALAR': 1,
    'VEC2': 2,
    'VEC3': 3,
    'VEC4': 4,
    'MAT2': 4,
    'MAT3': 9,
    'MAT4': 16
  };
  var ATTRIBUTES = {
    POSITION: 'position',
    NORMAL: 'normal',
    TEXCOORD_0: 'uv',
    TEXCOORD0: 'uv',
    // deprecated
    TEXCOORD: 'uv',
    // deprecated
    TEXCOORD_1: 'uv2',
    COLOR_0: 'color',
    COLOR0: 'color',
    // deprecated
    COLOR: 'color',
    // deprecated
    WEIGHTS_0: 'skinWeight',
    WEIGHT: 'skinWeight',
    // deprecated
    JOINTS_0: 'skinIndex',
    JOINT: 'skinIndex' // deprecated

  };
  var PATH_PROPERTIES = {
    scale: 'scale',
    translation: 'position',
    rotation: 'quaternion',
    weights: 'morphTargetInfluences'
  };
  var INTERPOLATION = {
    CUBICSPLINE: THREE.InterpolateSmooth,
    // We use custom interpolation GLTFCubicSplineInterpolation for CUBICSPLINE.
    // KeyframeTrack.optimize() can't handle glTF Cubic Spline output values layout,
    // using THREE.InterpolateSmooth for KeyframeTrack instantiation to prevent optimization.
    // See KeyframeTrack.optimize() for the detail.
    LINEAR: THREE.InterpolateLinear,
    STEP: THREE.InterpolateDiscrete
  };
  var STATES_ENABLES = {
    2884: 'CULL_FACE',
    2929: 'DEPTH_TEST',
    3042: 'BLEND',
    3089: 'SCISSOR_TEST',
    32823: 'POLYGON_OFFSET_FILL',
    32926: 'SAMPLE_ALPHA_TO_COVERAGE'
  };
  var ALPHA_MODES = {
    OPAQUE: 'OPAQUE',
    MASK: 'MASK',
    BLEND: 'BLEND'
  };
  /* UTILITY FUNCTIONS */

  function resolveURL(url, path) {
    // Invalid URL
    if (typeof url !== 'string' || url === '') return ''; // Absolute URL http://,https://,//

    if (/^(https?:)?\/\//i.test(url)) return url; // Data URI

    if (/^data:.*,.*$/i.test(url)) return url; // Blob URL

    if (/^blob:.*$/i.test(url)) return url; // Relative URL

    return path + url;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material
   */


  function createDefaultMaterial() {
    return new THREE.MeshStandardMaterial({
      color: 0xFFFFFF,
      emissive: 0x000000,
      metalness: 1,
      roughness: 1,
      transparent: false,
      depthTest: true,
      side: THREE.FrontSide
    });
  }

  function addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {
    // Add unknown glTF extensions to an object's userData.
    for (var name in objectDef.extensions) {
      if (knownExtensions[name] === undefined) {
        object.userData.gltfExtensions = object.userData.gltfExtensions || {};
        object.userData.gltfExtensions[name] = objectDef.extensions[name];
      }
    }
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets
   *
   * @param {THREE.Geometry} geometry
   * @param {Array<GLTF.Target>} targets
   * @param {Array<THREE.BufferAttribute>} accessors
   */


  function addMorphTargets(geometry, targets, accessors) {
    var hasMorphPosition = false;
    var hasMorphNormal = false;

    for (var i = 0, il = targets.length; i < il; i++) {
      var target = targets[i];
      if (target.POSITION !== undefined) hasMorphPosition = true;
      if (target.NORMAL !== undefined) hasMorphNormal = true;
      if (hasMorphPosition && hasMorphNormal) break;
    }

    if (!hasMorphPosition && !hasMorphNormal) return;
    var morphPositions = [];
    var morphNormals = [];

    for (var i = 0, il = targets.length; i < il; i++) {
      var target = targets[i];
      var attributeName = 'morphTarget' + i;

      if (hasMorphPosition) {
        // Three.js morph position is absolute value. The formula is
        //   basePosition
        //     + weight0 * ( morphPosition0 - basePosition )
        //     + weight1 * ( morphPosition1 - basePosition )
        //     ...
        // while the glTF one is relative
        //   basePosition
        //     + weight0 * glTFmorphPosition0
        //     + weight1 * glTFmorphPosition1
        //     ...
        // then we need to convert from relative to absolute here.
        if (target.POSITION !== undefined) {
          // Cloning not to pollute original accessor
          var positionAttribute = cloneBufferAttribute(accessors[target.POSITION]);
          positionAttribute.name = attributeName;
          var position = geometry.attributes.position;

          for (var j = 0, jl = positionAttribute.count; j < jl; j++) {
            positionAttribute.setXYZ(j, positionAttribute.getX(j) + position.getX(j), positionAttribute.getY(j) + position.getY(j), positionAttribute.getZ(j) + position.getZ(j));
          }
        } else {
          positionAttribute = geometry.attributes.position;
        }

        morphPositions.push(positionAttribute);
      }

      if (hasMorphNormal) {
        // see target.POSITION's comment
        var normalAttribute;

        if (target.NORMAL !== undefined) {
          var normalAttribute = cloneBufferAttribute(accessors[target.NORMAL]);
          normalAttribute.name = attributeName;
          var normal = geometry.attributes.normal;

          for (var j = 0, jl = normalAttribute.count; j < jl; j++) {
            normalAttribute.setXYZ(j, normalAttribute.getX(j) + normal.getX(j), normalAttribute.getY(j) + normal.getY(j), normalAttribute.getZ(j) + normal.getZ(j));
          }
        } else {
          normalAttribute = geometry.attributes.normal;
        }

        morphNormals.push(normalAttribute);
      }
    }

    if (hasMorphPosition) geometry.morphAttributes.position = morphPositions;
    if (hasMorphNormal) geometry.morphAttributes.normal = morphNormals;
  }
  /**
   * @param {THREE.Mesh} mesh
   * @param {GLTF.Mesh} meshDef
   */


  function updateMorphTargets(mesh, meshDef) {
    mesh.updateMorphTargets();

    if (meshDef.weights !== undefined) {
      for (var i = 0, il = meshDef.weights.length; i < il; i++) {
        mesh.morphTargetInfluences[i] = meshDef.weights[i];
      }
    } // .extras has user-defined data, so check that .extras.targetNames is an array.


    if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {
      var targetNames = meshDef.extras.targetNames;

      if (mesh.morphTargetInfluences.length === targetNames.length) {
        mesh.morphTargetDictionary = {};

        for (var i = 0, il = targetNames.length; i < il; i++) {
          mesh.morphTargetDictionary[targetNames[i]] = i;
        }
      } else {
        console.warn('THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.');
      }
    }
  }

  function isPrimitiveEqual(a, b) {
    if (a.indices !== b.indices) {
      return false;
    }

    return isObjectEqual(a.attributes, b.attributes);
  }

  function isObjectEqual(a, b) {
    if (Object.keys(a).length !== Object.keys(b).length) return false;

    for (var key in a) {
      if (a[key] !== b[key]) return false;
    }

    return true;
  }

  function isArrayEqual(a, b) {
    if (a.length !== b.length) return false;

    for (var i = 0, il = a.length; i < il; i++) {
      if (a[i] !== b[i]) return false;
    }

    return true;
  }

  function getCachedGeometry(cache, newPrimitive) {
    for (var i = 0, il = cache.length; i < il; i++) {
      var cached = cache[i];
      if (isPrimitiveEqual(cached.primitive, newPrimitive)) return cached.promise;
    }

    return null;
  }

  function getCachedCombinedGeometry(cache, geometries) {
    for (var i = 0, il = cache.length; i < il; i++) {
      var cached = cache[i];
      if (isArrayEqual(geometries, cached.baseGeometries)) return cached.geometry;
    }

    return null;
  }

  function getCachedMultiPassGeometry(cache, geometry, primitives) {
    for (var i = 0, il = cache.length; i < il; i++) {
      var cached = cache[i];
      if (geometry === cached.baseGeometry && isArrayEqual(primitives, cached.primitives)) return cached.geometry;
    }

    return null;
  }

  function cloneBufferAttribute(attribute) {
    if (attribute.isInterleavedBufferAttribute) {
      var count = attribute.count;
      var itemSize = attribute.itemSize;
      var array = attribute.array.slice(0, count * itemSize);

      for (var i = 0; i < count; ++i) {
        array[i] = attribute.getX(i);
        if (itemSize >= 2) array[i + 1] = attribute.getY(i);
        if (itemSize >= 3) array[i + 2] = attribute.getZ(i);
        if (itemSize >= 4) array[i + 3] = attribute.getW(i);
      }

      return new THREE.BufferAttribute(array, itemSize, attribute.normalized);
    }

    return attribute.clone();
  }
  /**
   * Checks if we can build a single Mesh with MultiMaterial from multiple primitives.
   * Returns true if all primitives use the same attributes/morphAttributes/mode
   * and also have index. Otherwise returns false.
   *
   * @param {Array<GLTF.Primitive>} primitives
   * @return {Boolean}
   */


  function isMultiPassGeometry(primitives) {
    if (primitives.length < 2) return false;
    var primitive0 = primitives[0];
    var targets0 = primitive0.targets || [];
    if (primitive0.indices === undefined) return false;

    for (var i = 1, il = primitives.length; i < il; i++) {
      var primitive = primitives[i];
      if (primitive0.mode !== primitive.mode) return false;
      if (primitive.indices === undefined) return false;
      if (!isObjectEqual(primitive0.attributes, primitive.attributes)) return false;
      var targets = primitive.targets || [];
      if (targets0.length !== targets.length) return false;

      for (var j = 0, jl = targets0.length; j < jl; j++) {
        if (!isObjectEqual(targets0[j], targets[j])) return false;
      }
    }

    return true;
  }
  /* GLTF PARSER */


  function GLTFParser(json, extensions, options) {
    this.json = json || {};
    this.extensions = extensions || {};
    this.options = options || {}; // loader object cache

    this.cache = new GLTFRegistry(); // BufferGeometry caching

    this.primitiveCache = [];
    this.multiplePrimitivesCache = [];
    this.multiPassGeometryCache = [];
    this.textureLoader = new THREE.TextureLoader(this.options.manager);
    this.textureLoader.setCrossOrigin(this.options.crossOrigin);
    this.fileLoader = new THREE.FileLoader(this.options.manager);
    this.fileLoader.setResponseType('arraybuffer');
  }

  GLTFParser.prototype.parse = function (onLoad, onError) {
    var json = this.json; // Clear the loader cache

    this.cache.removeAll(); // Mark the special nodes/meshes in json for efficient parse

    this.markDefs(); // Fire the callback on complete

    this.getMultiDependencies(['scene', 'animation', 'camera']).then(function (dependencies) {
      var scenes = dependencies.scenes || [];
      var scene = scenes[json.scene || 0];
      var animations = dependencies.animations || [];
      var cameras = dependencies.cameras || [];
      onLoad(scene, scenes, cameras, animations, json);
    })["catch"](onError);
  };
  /**
   * Marks the special nodes/meshes in json for efficient parse.
   */


  GLTFParser.prototype.markDefs = function () {
    var nodeDefs = this.json.nodes || [];
    var skinDefs = this.json.skins || [];
    var meshDefs = this.json.meshes || [];
    var meshReferences = {};
    var meshUses = {}; // Nothing in the node definition indicates whether it is a Bone or an
    // Object3D. Use the skins' joint references to mark bones.

    for (var skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {
      var joints = skinDefs[skinIndex].joints;

      for (var i = 0, il = joints.length; i < il; i++) {
        nodeDefs[joints[i]].isBone = true;
      }
    } // Meshes can (and should) be reused by multiple nodes in a glTF asset. To
    // avoid having more than one THREE.Mesh with the same name, count
    // references and rename instances below.
    //
    // Example: CesiumMilkTruck sample model reuses "Wheel" meshes.


    for (var nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {
      var nodeDef = nodeDefs[nodeIndex];

      if (nodeDef.mesh !== undefined) {
        if (meshReferences[nodeDef.mesh] === undefined) {
          meshReferences[nodeDef.mesh] = meshUses[nodeDef.mesh] = 0;
        }

        meshReferences[nodeDef.mesh]++; // Nothing in the mesh definition indicates whether it is
        // a SkinnedMesh or Mesh. Use the node's mesh reference
        // to mark SkinnedMesh if node has skin.

        if (nodeDef.skin !== undefined) {
          meshDefs[nodeDef.mesh].isSkinnedMesh = true;
        }
      }
    }

    this.json.meshReferences = meshReferences;
    this.json.meshUses = meshUses;
  };
  /**
   * Requests the specified dependency asynchronously, with caching.
   * @param {String} type
   * @param {Number} index
   * @return {Promise<Object>}
   */


  GLTFParser.prototype.getDependency = function (type, index) {
    var cacheKey = type + ':' + index;
    var dependency = this.cache.get(cacheKey);

    if (!dependency) {
      switch (type) {
        case 'scene':
          dependency = this.loadScene(index);
          break;

        case 'node':
          dependency = this.loadNode(index);
          break;

        case 'mesh':
          dependency = this.loadMesh(index);
          break;

        case 'accessor':
          dependency = this.loadAccessor(index);
          break;

        case 'bufferView':
          dependency = this.loadBufferView(index);
          break;

        case 'buffer':
          dependency = this.loadBuffer(index);
          break;

        case 'material':
          dependency = this.loadMaterial(index);
          break;

        case 'texture':
          dependency = this.loadTexture(index);
          break;

        case 'skin':
          dependency = this.loadSkin(index);
          break;

        case 'animation':
          dependency = this.loadAnimation(index);
          break;

        case 'camera':
          dependency = this.loadCamera(index);
          break;

        default:
          throw new Error('Unknown type: ' + type);
      }

      this.cache.add(cacheKey, dependency);
    }

    return dependency;
  };
  /**
   * Requests all dependencies of the specified type asynchronously, with caching.
   * @param {String} type
   * @return {Promise<Array<Object>>}
   */


  GLTFParser.prototype.getDependencies = function (type) {
    var dependencies = this.cache.get(type);

    if (!dependencies) {
      var parser = this;
      var defs = this.json[type + (type === 'mesh' ? 'es' : 's')] || [];
      dependencies = Promise.all(defs.map(function (def, index) {
        return parser.getDependency(type, index);
      }));
      this.cache.add(type, dependencies);
    }

    return dependencies;
  };
  /**
   * Requests all multiple dependencies of the specified types asynchronously, with caching.
   * @param {Array<string>} types
   * @return {Promise<Object<Array<Object>>>}
   */


  GLTFParser.prototype.getMultiDependencies = function (types) {
    var results = {};
    var pendings = [];

    for (var i = 0, il = types.length; i < il; i++) {
      var type = types[i];
      var value = this.getDependencies(type);
      value = value.then(function (key, value) {
        results[key] = value;
      }.bind(this, type + (type === 'mesh' ? 'es' : 's')));
      pendings.push(value);
    }

    return Promise.all(pendings).then(function () {
      return results;
    });
  };
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {Number} bufferIndex
   * @return {Promise<ArrayBuffer>}
   */


  GLTFParser.prototype.loadBuffer = function (bufferIndex) {
    var bufferDef = this.json.buffers[bufferIndex];
    var loader = this.fileLoader;

    if (bufferDef.type && bufferDef.type !== 'arraybuffer') {
      throw new Error('THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.');
    } // If present, GLB container is required to be the first buffer.


    if (bufferDef.uri === undefined && bufferIndex === 0) {
      return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);
    }

    var options = this.options;
    return new Promise(function (resolve, reject) {
      loader.load(resolveURL(bufferDef.uri, options.path), resolve, undefined, function () {
        reject(new Error('THREE.GLTFLoader: Failed to load buffer "' + bufferDef.uri + '".'));
      });
    });
  };
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {Number} bufferViewIndex
   * @return {Promise<ArrayBuffer>}
   */


  GLTFParser.prototype.loadBufferView = function (bufferViewIndex) {
    var bufferViewDef = this.json.bufferViews[bufferViewIndex];
    return this.getDependency('buffer', bufferViewDef.buffer).then(function (buffer) {
      var byteLength = bufferViewDef.byteLength || 0;
      var byteOffset = bufferViewDef.byteOffset || 0;
      return buffer.slice(byteOffset, byteOffset + byteLength);
    });
  };
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
   * @param {Number} accessorIndex
   * @return {Promise<THREE.BufferAttribute|THREE.InterleavedBufferAttribute>}
   */


  GLTFParser.prototype.loadAccessor = function (accessorIndex) {
    var parser = this;
    var json = this.json;
    var accessorDef = this.json.accessors[accessorIndex];

    if (accessorDef.bufferView === undefined && accessorDef.sparse === undefined) {
      // Ignore empty accessors, which may be used to declare runtime
      // information about attributes coming from another source (e.g. Draco
      // compression extension).
      return null;
    }

    var pendingBufferViews = [];

    if (accessorDef.bufferView !== undefined) {
      pendingBufferViews.push(this.getDependency('bufferView', accessorDef.bufferView));
    } else {
      pendingBufferViews.push(null);
    }

    if (accessorDef.sparse !== undefined) {
      pendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.indices.bufferView));
      pendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.values.bufferView));
    }

    return Promise.all(pendingBufferViews).then(function (bufferViews) {
      var bufferView = bufferViews[0];
      var itemSize = WEBGL_TYPE_SIZES[accessorDef.type];
      var TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType]; // For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.

      var elementBytes = TypedArray.BYTES_PER_ELEMENT;
      var itemBytes = elementBytes * itemSize;
      var byteOffset = accessorDef.byteOffset || 0;
      var byteStride = json.bufferViews[accessorDef.bufferView].byteStride;
      var normalized = accessorDef.normalized === true;
      var array, bufferAttribute; // The buffer is not interleaved if the stride is the item size in bytes.

      if (byteStride && byteStride !== itemBytes) {
        var ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType;
        var ib = parser.cache.get(ibCacheKey);

        if (!ib) {
          // Use the full buffer if it's interleaved.
          array = new TypedArray(bufferView); // Integer parameters to IB/IBA are in array elements, not bytes.

          ib = new THREE.InterleavedBuffer(array, byteStride / elementBytes);
          parser.cache.add(ibCacheKey, ib);
        }

        bufferAttribute = new THREE.InterleavedBufferAttribute(ib, itemSize, byteOffset / elementBytes, normalized);
      } else {
        if (bufferView === null) {
          array = new TypedArray(accessorDef.count * itemSize);
        } else {
          array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);
        }

        bufferAttribute = new THREE.BufferAttribute(array, itemSize, normalized);
      } // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors


      if (accessorDef.sparse !== undefined) {
        var itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;
        var TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];
        var byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;
        var byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;
        var sparseIndices = new TypedArrayIndices(bufferViews[1], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices);
        var sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);

        if (bufferView !== null) {
          // Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.
          bufferAttribute.setArray(bufferAttribute.array.slice());
        }

        for (var i = 0, il = sparseIndices.length; i < il; i++) {
          var index = sparseIndices[i];
          bufferAttribute.setX(index, sparseValues[i * itemSize]);
          if (itemSize >= 2) bufferAttribute.setY(index, sparseValues[i * itemSize + 1]);
          if (itemSize >= 3) bufferAttribute.setZ(index, sparseValues[i * itemSize + 2]);
          if (itemSize >= 4) bufferAttribute.setW(index, sparseValues[i * itemSize + 3]);
          if (itemSize >= 5) throw new Error('THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.');
        }
      }

      return bufferAttribute;
    });
  };
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
   * @param {Number} textureIndex
   * @return {Promise<THREE.Texture>}
   */


  GLTFParser.prototype.loadTexture = function (textureIndex) {
    var parser = this;
    var json = this.json;
    var options = this.options;
    var textureLoader = this.textureLoader;
    var URL = window.URL || window.webkitURL;
    var textureDef = json.textures[textureIndex];
    var textureExtensions = textureDef.extensions || {};
    var source;

    if (textureExtensions[EXTENSIONS.MSFT_TEXTURE_DDS]) {
      source = json.images[textureExtensions[EXTENSIONS.MSFT_TEXTURE_DDS].source];
    } else {
      source = json.images[textureDef.source];
    }

    var sourceURI = source.uri;
    var isObjectURL = false;

    if (source.bufferView !== undefined) {
      // Load binary image data from bufferView, if provided.
      sourceURI = parser.getDependency('bufferView', source.bufferView).then(function (bufferView) {
        isObjectURL = true;
        var blob = new Blob([bufferView], {
          type: source.mimeType
        });
        sourceURI = URL.createObjectURL(blob);
        return sourceURI;
      });
    }

    return Promise.resolve(sourceURI).then(function (sourceURI) {
      // Load Texture resource.
      var loader = THREE.Loader.Handlers.get(sourceURI);

      if (!loader) {
        loader = textureExtensions[EXTENSIONS.MSFT_TEXTURE_DDS] ? parser.extensions[EXTENSIONS.MSFT_TEXTURE_DDS].ddsLoader : textureLoader;
      }

      return new Promise(function (resolve, reject) {
        loader.load(resolveURL(sourceURI, options.path), resolve, undefined, reject);
      });
    }).then(function (texture) {
      // Clean up resources and configure Texture.
      if (isObjectURL === true) {
        URL.revokeObjectURL(sourceURI);
      }

      texture.flipY = false;
      if (textureDef.name !== undefined) texture.name = textureDef.name; // .format of dds texture is set in DDSLoader

      if (!textureExtensions[EXTENSIONS.MSFT_TEXTURE_DDS]) {
        texture.format = textureDef.format !== undefined ? WEBGL_TEXTURE_FORMATS[textureDef.format] : THREE.RGBAFormat;
      }

      if (textureDef.internalFormat !== undefined && texture.format !== WEBGL_TEXTURE_FORMATS[textureDef.internalFormat]) {
        console.warn('THREE.GLTFLoader: Three.js does not support texture internalFormat which is different from texture format. ' + 'internalFormat will be forced to be the same value as format.');
      }

      texture.type = textureDef.type !== undefined ? WEBGL_TEXTURE_DATATYPES[textureDef.type] : THREE.UnsignedByteType;
      var samplers = json.samplers || {};
      var sampler = samplers[textureDef.sampler] || {};
      texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || THREE.LinearFilter;
      texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || THREE.LinearMipMapLinearFilter;
      texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || THREE.RepeatWrapping;
      texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || THREE.RepeatWrapping;
      return texture;
    });
  };
  /**
   * Asynchronously assigns a texture to the given material parameters.
   * @param {Object} materialParams
   * @param {String} textureName
   * @param {Number} textureIndex
   * @return {Promise}
   */


  GLTFParser.prototype.assignTexture = function (materialParams, textureName, textureIndex) {
    return this.getDependency('texture', textureIndex).then(function (texture) {
      materialParams[textureName] = texture;
    });
  };
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
   * @param {Number} materialIndex
   * @return {Promise<THREE.Material>}
   */


  GLTFParser.prototype.loadMaterial = function (materialIndex) {
    var parser = this;
    var json = this.json;
    var extensions = this.extensions;
    var materialDef = this.json.materials[materialIndex];
    var materialType;
    var materialParams = {};
    var materialExtensions = materialDef.extensions || {};
    var pending = [];

    if (materialExtensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
      var sgExtension = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
      materialType = sgExtension.getMaterialType(materialDef);
      pending.push(sgExtension.extendParams(materialParams, materialDef, parser));
    } else if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {
      var kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];
      materialType = kmuExtension.getMaterialType(materialDef);
      pending.push(kmuExtension.extendParams(materialParams, materialDef, parser));
    } else {
      // Specification:
      // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material
      materialType = THREE.MeshStandardMaterial;
      var metallicRoughness = materialDef.pbrMetallicRoughness || {};
      materialParams.color = new THREE.Color(1.0, 1.0, 1.0);
      materialParams.opacity = 1.0;

      if (Array.isArray(metallicRoughness.baseColorFactor)) {
        var array = metallicRoughness.baseColorFactor;
        materialParams.color.fromArray(array);
        materialParams.opacity = array[3];
      }

      if (metallicRoughness.baseColorTexture !== undefined) {
        pending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture.index));
      }

      materialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;
      materialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;

      if (metallicRoughness.metallicRoughnessTexture !== undefined) {
        var textureIndex = metallicRoughness.metallicRoughnessTexture.index;
        pending.push(parser.assignTexture(materialParams, 'metalnessMap', textureIndex));
        pending.push(parser.assignTexture(materialParams, 'roughnessMap', textureIndex));
      }
    }

    if (materialDef.doubleSided === true) {
      materialParams.side = THREE.DoubleSide;
    }

    var alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;

    if (alphaMode === ALPHA_MODES.BLEND) {
      materialParams.transparent = true;
    } else {
      materialParams.transparent = false;

      if (alphaMode === ALPHA_MODES.MASK) {
        materialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;
      }
    }

    if (materialDef.normalTexture !== undefined && materialType !== THREE.MeshBasicMaterial) {
      pending.push(parser.assignTexture(materialParams, 'normalMap', materialDef.normalTexture.index));
      materialParams.normalScale = new THREE.Vector2(1, 1);

      if (materialDef.normalTexture.scale !== undefined) {
        materialParams.normalScale.set(materialDef.normalTexture.scale, materialDef.normalTexture.scale);
      }
    }

    if (materialDef.occlusionTexture !== undefined && materialType !== THREE.MeshBasicMaterial) {
      pending.push(parser.assignTexture(materialParams, 'aoMap', materialDef.occlusionTexture.index));

      if (materialDef.occlusionTexture.strength !== undefined) {
        materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;
      }
    }

    if (materialDef.emissiveFactor !== undefined && materialType !== THREE.MeshBasicMaterial) {
      materialParams.emissive = new THREE.Color().fromArray(materialDef.emissiveFactor);
    }

    if (materialDef.emissiveTexture !== undefined && materialType !== THREE.MeshBasicMaterial) {
      pending.push(parser.assignTexture(materialParams, 'emissiveMap', materialDef.emissiveTexture.index));
    }

    return Promise.all(pending).then(function () {
      var material;

      if (materialType === THREE.ShaderMaterial) {
        material = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(materialParams);
      } else {
        material = new materialType(materialParams);
      }

      if (materialDef.name !== undefined) material.name = materialDef.name; // Normal map textures use OpenGL conventions:
      // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#materialnormaltexture

      if (material.normalScale) {
        material.normalScale.y = -material.normalScale.y;
      } // baseColorTexture, emissiveTexture, and specularGlossinessTexture use sRGB encoding.


      if (material.map) material.map.encoding = THREE.sRGBEncoding;
      if (material.emissiveMap) material.emissiveMap.encoding = THREE.sRGBEncoding;
      if (material.specularMap) material.specularMap.encoding = THREE.sRGBEncoding;
      if (materialDef.extras) material.userData = materialDef.extras;
      if (materialDef.extensions) addUnknownExtensionsToUserData(extensions, material, materialDef);
      return material;
    });
  };
  /**
   * @param  {THREE.BufferGeometry} geometry
   * @param  {GLTF.Primitive} primitiveDef
   * @param  {Array<THREE.BufferAttribute>} accessors
   */


  function addPrimitiveAttributes(geometry, primitiveDef, accessors) {
    var attributes = primitiveDef.attributes;

    for (var gltfAttributeName in attributes) {
      var threeAttributeName = ATTRIBUTES[gltfAttributeName];
      var bufferAttribute = accessors[attributes[gltfAttributeName]]; // Skip attributes already provided by e.g. Draco extension.

      if (!threeAttributeName) continue;
      if (threeAttributeName in geometry.attributes) continue;
      geometry.setAttribute(threeAttributeName, bufferAttribute);
    }

    if (primitiveDef.indices !== undefined && !geometry.index) {
      geometry.setIndex(accessors[primitiveDef.indices]);
    }

    if (primitiveDef.targets !== undefined) {
      addMorphTargets(geometry, primitiveDef.targets, accessors);
    }

    if (primitiveDef.extras !== undefined) {
      geometry.userData = primitiveDef.extras;
    }
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
   *
   * Creates BufferGeometries from primitives.
   * If we can build a single BufferGeometry with .groups from multiple primitives, returns one BufferGeometry.
   * Otherwise, returns BufferGeometries without .groups as many as primitives.
   *
   * @param {Array<Object>} primitives
   * @return {Promise<Array<THREE.BufferGeometry>>}
   */


  GLTFParser.prototype.loadGeometries = function (primitives) {
    var parser = this;
    var extensions = this.extensions;
    var cache = this.primitiveCache;
    var isMultiPass = isMultiPassGeometry(primitives);
    var originalPrimitives;

    if (isMultiPass) {
      originalPrimitives = primitives; // save original primitives and use later
      // We build a single BufferGeometry with .groups from multiple primitives
      // because all primitives share the same attributes/morph/mode and have indices.

      primitives = [primitives[0]]; // Sets .groups and combined indices to a geometry later in this method.
    }

    return this.getDependencies('accessor').then(function (accessors) {
      var pending = [];

      for (var i = 0, il = primitives.length; i < il; i++) {
        var primitive = primitives[i]; // See if we've already created this geometry

        var cached = getCachedGeometry(cache, primitive);

        if (cached) {
          // Use the cached geometry if it exists
          pending.push(cached);
        } else if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {
          // Use DRACO geometry if available
          var geometryPromise = extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive, parser).then(function (geometry) {
            addPrimitiveAttributes(geometry, primitive, accessors);
            return geometry;
          });
          cache.push({
            primitive: primitive,
            promise: geometryPromise
          });
          pending.push(geometryPromise);
        } else {
          // Otherwise create a new geometry
          var geometry = new THREE.BufferGeometry();
          addPrimitiveAttributes(geometry, primitive, accessors);
          var geometryPromise = Promise.resolve(geometry); // Cache this geometry

          cache.push({
            primitive: primitive,
            promise: geometryPromise
          });
          pending.push(geometryPromise);
        }
      }

      return Promise.all(pending).then(function (geometries) {
        if (isMultiPass) {
          var baseGeometry = geometries[0]; // See if we've already created this combined geometry

          var cache = parser.multiPassGeometryCache;
          var cached = getCachedMultiPassGeometry(cache, baseGeometry, originalPrimitives);
          if (cached !== null) return [cached.geometry]; // Cloning geometry because of index override.
          // Attributes can be reused so cloning by myself here.

          var geometry = new THREE.BufferGeometry();
          geometry.name = baseGeometry.name;
          geometry.userData = baseGeometry.userData;

          for (var key in baseGeometry.attributes) {
            geometry.setAttribute(key, baseGeometry.attributes[key]);
          }

          for (var key in baseGeometry.morphAttributes) {
            geometry.morphAttributes[key] = baseGeometry.morphAttributes[key];
          }

          var indices = [];
          var offset = 0;

          for (var i = 0, il = originalPrimitives.length; i < il; i++) {
            var accessor = accessors[originalPrimitives[i].indices];

            for (var j = 0, jl = accessor.count; j < jl; j++) {
              indices.push(accessor.array[j]);
            }

            geometry.addGroup(offset, accessor.count, i);
            offset += accessor.count;
          }

          geometry.setIndex(indices);
          cache.push({
            geometry: geometry,
            baseGeometry: baseGeometry,
            primitives: originalPrimitives
          });
          return [geometry];
        } else if (geometries.length > 1 && THREE.BufferGeometryUtils !== undefined) {
          // Tries to merge geometries with BufferGeometryUtils if possible
          for (var i = 1, il = primitives.length; i < il; i++) {
            // can't merge if draw mode is different
            if (primitives[0].mode !== primitives[i].mode) return geometries;
          } // See if we've already created this combined geometry


          var cache = parser.multiplePrimitivesCache;
          var cached = getCachedCombinedGeometry(cache, geometries);

          if (cached) {
            if (cached.geometry !== null) return [cached.geometry];
          } else {
            var geometry = THREE.BufferGeometryUtils.mergeBufferGeometries(geometries, true);
            cache.push({
              geometry: geometry,
              baseGeometries: geometries
            });
            if (geometry !== null) return [geometry];
          }
        }

        return geometries;
      });
    });
  };
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
   * @param {Number} meshIndex
   * @return {Promise<THREE.Group|THREE.Mesh|THREE.SkinnedMesh>}
   */


  GLTFParser.prototype.loadMesh = function (meshIndex) {
    var scope = this;
    var json = this.json;
    var extensions = this.extensions;
    var meshDef = this.json.meshes[meshIndex];
    return this.getMultiDependencies(['accessor', 'material']).then(function (dependencies) {
      var primitives = meshDef.primitives;
      var originalMaterials = [];

      for (var i = 0, il = primitives.length; i < il; i++) {
        originalMaterials[i] = primitives[i].material === undefined ? createDefaultMaterial() : dependencies.materials[primitives[i].material];
      }

      return scope.loadGeometries(primitives).then(function (geometries) {
        var isMultiMaterial = geometries.length === 1 && geometries[0].groups.length > 0;
        var meshes = [];

        for (var i = 0, il = geometries.length; i < il; i++) {
          var geometry = geometries[i];
          var primitive = primitives[i]; // 1. create Mesh

          var mesh;
          var material = isMultiMaterial ? originalMaterials : originalMaterials[i];

          if (primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === undefined) {
            // .isSkinnedMesh isn't in glTF spec. See .markDefs()
            mesh = meshDef.isSkinnedMesh === true ? new THREE.SkinnedMesh(geometry, material) : new THREE.Mesh(geometry, material);

            if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {
              mesh.drawMode = THREE.TriangleStripDrawMode;
            } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {
              mesh.drawMode = THREE.TriangleFanDrawMode;
            }
          } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {
            mesh = new THREE.LineSegments(geometry, material);
          } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {
            mesh = new THREE.Line(geometry, material);
          } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {
            mesh = new THREE.LineLoop(geometry, material);
          } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {
            mesh = new THREE.Points(geometry, material);
          } else {
            throw new Error('THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode);
          }

          if (Object.keys(mesh.geometry.morphAttributes).length > 0) {
            updateMorphTargets(mesh, meshDef);
          }

          mesh.name = meshDef.name || 'mesh_' + meshIndex;
          if (geometries.length > 1) mesh.name += '_' + i;
          if (meshDef.extras !== undefined) mesh.userData = meshDef.extras;
          meshes.push(mesh); // 2. update Material depending on Mesh and BufferGeometry

          var materials = isMultiMaterial ? mesh.material : [mesh.material];
          var useVertexColors = geometry.attributes.color !== undefined;
          var useFlatShading = geometry.attributes.normal === undefined;
          var useSkinning = mesh.isSkinnedMesh === true;
          var useMorphTargets = Object.keys(geometry.morphAttributes).length > 0;
          var useMorphNormals = useMorphTargets && geometry.morphAttributes.normal !== undefined;

          for (var j = 0, jl = materials.length; j < jl; j++) {
            var material = materials[j];

            if (mesh.isPoints) {
              var cacheKey = 'PointsMaterial:' + material.uuid;
              var pointsMaterial = scope.cache.get(cacheKey);

              if (!pointsMaterial) {
                pointsMaterial = new THREE.PointsMaterial();
                THREE.Material.prototype.copy.call(pointsMaterial, material);
                pointsMaterial.color.copy(material.color);
                pointsMaterial.map = material.map;
                pointsMaterial.lights = false; // PointsMaterial doesn't support lights yet

                scope.cache.add(cacheKey, pointsMaterial);
              }

              material = pointsMaterial;
            } else if (mesh.isLine) {
              var cacheKey = 'LineBasicMaterial:' + material.uuid;
              var lineMaterial = scope.cache.get(cacheKey);

              if (!lineMaterial) {
                lineMaterial = new THREE.LineBasicMaterial();
                THREE.Material.prototype.copy.call(lineMaterial, material);
                lineMaterial.color.copy(material.color);
                lineMaterial.lights = false; // LineBasicMaterial doesn't support lights yet

                scope.cache.add(cacheKey, lineMaterial);
              }

              material = lineMaterial;
            } // Clone the material if it will be modified


            if (useVertexColors || useFlatShading || useSkinning || useMorphTargets) {
              var cacheKey = 'ClonedMaterial:' + material.uuid + ':';
              if (material.isGLTFSpecularGlossinessMaterial) cacheKey += 'specular-glossiness:';
              if (useSkinning) cacheKey += 'skinning:';
              if (useVertexColors) cacheKey += 'vertex-colors:';
              if (useFlatShading) cacheKey += 'flat-shading:';
              if (useMorphTargets) cacheKey += 'morph-targets:';
              if (useMorphNormals) cacheKey += 'morph-normals:';
              var cachedMaterial = scope.cache.get(cacheKey);

              if (!cachedMaterial) {
                cachedMaterial = material.isGLTFSpecularGlossinessMaterial ? extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].cloneMaterial(material) : material.clone();
                if (useSkinning) cachedMaterial.skinning = true;
                if (useVertexColors) cachedMaterial.vertexColors = THREE.VertexColors;
                if (useFlatShading) cachedMaterial.flatShading = true;
                if (useMorphTargets) cachedMaterial.morphTargets = true;
                if (useMorphNormals) cachedMaterial.morphNormals = true;
                scope.cache.add(cacheKey, cachedMaterial);
              }

              material = cachedMaterial;
            }

            materials[j] = material; // workarounds for mesh and geometry

            if (material.aoMap && geometry.attributes.uv2 === undefined && geometry.attributes.uv !== undefined) {
              console.log('THREE.GLTFLoader: Duplicating UVs to support aoMap.');
              geometry.setAttribute('uv2', new THREE.BufferAttribute(geometry.attributes.uv.array, 2));
            }

            if (material.isGLTFSpecularGlossinessMaterial) {
              // for GLTFSpecularGlossinessMaterial(ShaderMaterial) uniforms runtime update
              mesh.onBeforeRender = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].refreshUniforms;
            }
          }

          mesh.material = isMultiMaterial ? materials : materials[0];
        }

        if (meshes.length === 1) {
          return meshes[0];
        }

        var group = new THREE.Group();

        for (var i = 0, il = meshes.length; i < il; i++) {
          group.add(meshes[i]);
        }

        return group;
      });
    });
  };
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
   * @param {Number} cameraIndex
   * @return {Promise<THREE.Camera>}
   */


  GLTFParser.prototype.loadCamera = function (cameraIndex) {
    var camera;
    var cameraDef = this.json.cameras[cameraIndex];
    var params = cameraDef[cameraDef.type];

    if (!params) {
      console.warn('THREE.GLTFLoader: Missing camera parameters.');
      return;
    }

    if (cameraDef.type === 'perspective') {
      camera = new THREE.PerspectiveCamera(THREE.Math.radToDeg(params.yfov), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6);
    } else if (cameraDef.type === 'orthographic') {
      camera = new THREE.OrthographicCamera(params.xmag / -2, params.xmag / 2, params.ymag / 2, params.ymag / -2, params.znear, params.zfar);
    }

    if (cameraDef.name !== undefined) camera.name = cameraDef.name;
    if (cameraDef.extras) camera.userData = cameraDef.extras;
    return Promise.resolve(camera);
  };
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
   * @param {Number} skinIndex
   * @return {Promise<Object>}
   */


  GLTFParser.prototype.loadSkin = function (skinIndex) {
    var skinDef = this.json.skins[skinIndex];
    var skinEntry = {
      joints: skinDef.joints
    };

    if (skinDef.inverseBindMatrices === undefined) {
      return Promise.resolve(skinEntry);
    }

    return this.getDependency('accessor', skinDef.inverseBindMatrices).then(function (accessor) {
      skinEntry.inverseBindMatrices = accessor;
      return skinEntry;
    });
  };
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
   * @param {Number} animationIndex
   * @return {Promise<THREE.AnimationClip>}
   */


  GLTFParser.prototype.loadAnimation = function (animationIndex) {
    var json = this.json;
    var animationDef = this.json.animations[animationIndex];
    return this.getMultiDependencies(['accessor', 'node']).then(function (dependencies) {
      var tracks = [];

      for (var i = 0, il = animationDef.channels.length; i < il; i++) {
        var channel = animationDef.channels[i];
        var sampler = animationDef.samplers[channel.sampler];

        if (sampler) {
          var target = channel.target;
          var name = target.node !== undefined ? target.node : target.id; // NOTE: target.id is deprecated.

          var input = animationDef.parameters !== undefined ? animationDef.parameters[sampler.input] : sampler.input;
          var output = animationDef.parameters !== undefined ? animationDef.parameters[sampler.output] : sampler.output;
          var inputAccessor = dependencies.accessors[input];
          var outputAccessor = dependencies.accessors[output];
          var node = dependencies.nodes[name];

          if (node) {
            node.updateMatrix();
            node.matrixAutoUpdate = true;
            var TypedKeyframeTrack;

            switch (PATH_PROPERTIES[target.path]) {
              case PATH_PROPERTIES.weights:
                TypedKeyframeTrack = THREE.NumberKeyframeTrack;
                break;

              case PATH_PROPERTIES.rotation:
                TypedKeyframeTrack = THREE.QuaternionKeyframeTrack;
                break;

              case PATH_PROPERTIES.position:
              case PATH_PROPERTIES.scale:
              default:
                TypedKeyframeTrack = THREE.VectorKeyframeTrack;
                break;
            }

            var targetName = node.name ? node.name : node.uuid;
            var interpolation = sampler.interpolation !== undefined ? INTERPOLATION[sampler.interpolation] : THREE.InterpolateLinear;
            var targetNames = [];

            if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {
              // node can be THREE.Group here but
              // PATH_PROPERTIES.weights(morphTargetInfluences) should be
              // the property of a mesh object under group.
              node.traverse(function (object) {
                if (object.isMesh === true && object.morphTargetInfluences) {
                  targetNames.push(object.name ? object.name : object.uuid);
                }
              });
            } else {
              targetNames.push(targetName);
            } // KeyframeTrack.optimize() will modify given 'times' and 'values'
            // buffers before creating a truncated copy to keep. Because buffers may
            // be reused by other tracks, make copies here.


            for (var j = 0, jl = targetNames.length; j < jl; j++) {
              var track = new TypedKeyframeTrack(targetNames[j] + '.' + PATH_PROPERTIES[target.path], THREE.AnimationUtils.arraySlice(inputAccessor.array, 0), THREE.AnimationUtils.arraySlice(outputAccessor.array, 0), interpolation); // Here is the trick to enable custom interpolation.
              // Overrides .createInterpolant in a factory method which creates custom interpolation.

              if (sampler.interpolation === 'CUBICSPLINE') {
                track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {
                  // A CUBICSPLINE keyframe in glTF has three output values for each input value,
                  // representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()
                  // must be divided by three to get the interpolant's sampleSize argument.
                  return new GLTFCubicSplineInterpolant(this.times, this.values, this.getValueSize() / 3, result);
                }; // Workaround, provide an alternate way to know if the interpolant type is cubis spline to track.
                // track.getInterpolation() doesn't return valid value for custom interpolant.


                track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;
              }

              tracks.push(track);
            }
          }
        }
      }

      var name = animationDef.name !== undefined ? animationDef.name : 'animation_' + animationIndex;
      return new THREE.AnimationClip(name, undefined, tracks);
    });
  };
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
   * @param {Number} nodeIndex
   * @return {Promise<THREE.Object3D>}
   */


  GLTFParser.prototype.loadNode = function (nodeIndex) {
    var json = this.json;
    var extensions = this.extensions;
    var meshReferences = this.json.meshReferences;
    var meshUses = this.json.meshUses;
    var nodeDef = this.json.nodes[nodeIndex];
    return this.getMultiDependencies(['mesh', 'skin', 'camera', 'light']).then(function (dependencies) {
      var node; // .isBone isn't in glTF spec. See .markDefs

      if (nodeDef.isBone === true) {
        node = new THREE.Bone();
      } else if (nodeDef.mesh !== undefined) {
        var mesh = dependencies.meshes[nodeDef.mesh];
        node = mesh.clone(); // for Specular-Glossiness

        if (mesh.isGroup === true) {
          for (var i = 0, il = mesh.children.length; i < il; i++) {
            var child = mesh.children[i];

            if (child.material && child.material.isGLTFSpecularGlossinessMaterial === true) {
              node.children[i].onBeforeRender = child.onBeforeRender;
            }
          }
        } else {
          if (mesh.material && mesh.material.isGLTFSpecularGlossinessMaterial === true) {
            node.onBeforeRender = mesh.onBeforeRender;
          }
        }

        if (meshReferences[nodeDef.mesh] > 1) {
          node.name += '_instance_' + meshUses[nodeDef.mesh]++;
        }
      } else if (nodeDef.camera !== undefined) {
        node = dependencies.cameras[nodeDef.camera];
      } else if (nodeDef.extensions && nodeDef.extensions[EXTENSIONS.KHR_LIGHTS] && nodeDef.extensions[EXTENSIONS.KHR_LIGHTS].light !== undefined) {
        var lights = extensions[EXTENSIONS.KHR_LIGHTS].lights;
        node = lights[nodeDef.extensions[EXTENSIONS.KHR_LIGHTS].light];
      } else {
        node = new THREE.Object3D();
      }

      if (nodeDef.name !== undefined) {
        node.name = THREE.PropertyBinding.sanitizeNodeName(nodeDef.name);
      }

      if (nodeDef.extras) node.userData = nodeDef.extras;
      if (nodeDef.extensions) addUnknownExtensionsToUserData(extensions, node, nodeDef);

      if (nodeDef.matrix !== undefined) {
        var matrix = new THREE.Matrix4();
        matrix.fromArray(nodeDef.matrix);
        node.applyMatrix4(matrix);
      } else {
        if (nodeDef.translation !== undefined) {
          node.position.fromArray(nodeDef.translation);
        }

        if (nodeDef.rotation !== undefined) {
          node.quaternion.fromArray(nodeDef.rotation);
        }

        if (nodeDef.scale !== undefined) {
          node.scale.fromArray(nodeDef.scale);
        }
      }

      return node;
    });
  };
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
   * @param {Number} sceneIndex
   * @return {Promise<THREE.Scene>}
   */


  GLTFParser.prototype.loadScene = function () {
    // scene node hierachy builder
    function buildNodeHierachy(nodeId, parentObject, json, allNodes, skins) {
      var node = allNodes[nodeId];
      var nodeDef = json.nodes[nodeId]; // build skeleton here as well

      if (nodeDef.skin !== undefined) {
        var meshes = node.isGroup === true ? node.children : [node];

        for (var i = 0, il = meshes.length; i < il; i++) {
          var mesh = meshes[i];
          var skinEntry = skins[nodeDef.skin];
          var bones = [];
          var boneInverses = [];

          for (var j = 0, jl = skinEntry.joints.length; j < jl; j++) {
            var jointId = skinEntry.joints[j];
            var jointNode = allNodes[jointId];

            if (jointNode) {
              bones.push(jointNode);
              var mat = new THREE.Matrix4();

              if (skinEntry.inverseBindMatrices !== undefined) {
                mat.fromArray(skinEntry.inverseBindMatrices.array, j * 16);
              }

              boneInverses.push(mat);
            } else {
              console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', jointId);
            }
          }

          mesh.bind(new THREE.Skeleton(bones, boneInverses), mesh.matrixWorld);
        }
      } // build node hierachy


      parentObject.add(node);

      if (nodeDef.children) {
        var children = nodeDef.children;

        for (var i = 0, il = children.length; i < il; i++) {
          var child = children[i];
          buildNodeHierachy(child, node, json, allNodes, skins);
        }
      }
    }

    return function loadScene(sceneIndex) {
      var json = this.json;
      var extensions = this.extensions;
      var sceneDef = this.json.scenes[sceneIndex];
      return this.getMultiDependencies(['node', 'skin']).then(function (dependencies) {
        var scene = new THREE.Scene();
        if (sceneDef.name !== undefined) scene.name = sceneDef.name;
        if (sceneDef.extras) scene.userData = sceneDef.extras;
        if (sceneDef.extensions) addUnknownExtensionsToUserData(extensions, scene, sceneDef);
        var nodeIds = sceneDef.nodes || [];

        for (var i = 0, il = nodeIds.length; i < il; i++) {
          buildNodeHierachy(nodeIds[i], scene, json, dependencies.nodes, dependencies.skins);
        } // Ambient lighting, if present, is always attached to the scene root.


        if (sceneDef.extensions && sceneDef.extensions[EXTENSIONS.KHR_LIGHTS] && sceneDef.extensions[EXTENSIONS.KHR_LIGHTS].light !== undefined) {
          var lights = extensions[EXTENSIONS.KHR_LIGHTS].lights;
          scene.add(lights[sceneDef.extensions[EXTENSIONS.KHR_LIGHTS].light]);
        }

        return scene;
      });
    };
  }();

  return GLTFLoader;
}();

/* harmony default export */ const GLTFLoader = (THREE.GLTFLoader);
;// CONCATENATED MODULE: ./src/components/simple-3D-model/js/index.js




/* 
 *************************************
 * <!-- 3D Model -->
 *************************************
 */


var THREE_MODEL = function (module, $, window, document) {
  if (window.THREE_MODEL === null) return false;
  module.THREE_MODEL = module.THREE_MODEL || {};
  module.THREE_MODEL.version = '0.0.5';

  module.THREE_MODEL.documentReady = function ($) {
    //Prevent this module from loading in other pages
    if ($('#3D-model-canvas').length == 0 || !Modernizr.webgl) return false;
    var sceneSubjects = []; // Import objects and animations dynamically

    var MainStage = function () {
      var windowWidth = window.innerWidth,
          windowHeight = window.innerHeight;
      var rendererCanvasID = '3D-model-canvas'; // Generate one plane geometries mesh to scene
      //-------------------------------------	

      var camera,
          scene,
          lights = [],
          renderer,
          displacementSprite,
          theta = 0;
      var mixerGLTF;
      var radius = 600;
      var prevTime = Date.now();

      function init() {
        //=================
        //camera
        camera = new THREE.PerspectiveCamera(45, windowWidth / windowHeight, 1, 10000);
        camera.position.set(0, 0, 100);
        camera.target = new THREE.Vector3(0, 150, 0); //=================
        //Scene

        scene = new THREE.Scene(); //=================
        //Lights

        lights[0] = new THREE.PointLight(0xffffff, 1, 0);
        lights[1] = new THREE.PointLight(0xffffff, 1, 0);
        lights[2] = new THREE.DirectionalLight(0xffffff);
        lights[0].position.set(0, 200, 0);
        lights[1].position.set(100, 200, 100);
        lights[2].position.set(120, 200, 0);
        lights[2].intensity = 0.6;
        scene.add(lights[0]);
        scene.add(lights[1]);
        scene.add(lights[2]); //=================
        //WebGL Renderer	

        renderer = new THREE.WebGLRenderer({
          canvas: document.getElementById(rendererCanvasID),
          //canvas
          alpha: true,
          antialias: true
        });
        renderer.setSize(windowWidth, windowHeight); //=================

        displacementSprite = new THREE.Object3D();
        var manager = new THREE.LoadingManager();

        manager.onProgress = function (item, loaded, total) {
          console.log(item, loaded, total);
        };

        var textureURL = (0,esm_typeof/* default */.Z)($('#' + rendererCanvasID).data('texture-src')) != ( true ? "undefined" : 0) ? $('#' + rendererCanvasID).data('texture-src') : templateUrl + '/assets/models/gltf/project.jpg';
        var objURL = (0,esm_typeof/* default */.Z)($('#' + rendererCanvasID).data('model-src')) != ( true ? "undefined" : 0) ? $('#' + rendererCanvasID).data('model-src') : templateUrl + '/assets/models/gltf/project.glb';

        var textureLoader = new THREE.TextureLoader(manager),
            texture = textureLoader.load(textureURL),
            onProgress = function onProgress(xhr) {
          if (xhr.lengthComputable) {
            var percentComplete = xhr.loaded / xhr.total * 100;
            console.log(Math.round(percentComplete, 2) + '% downloaded');
          }
        },
            onError = function onError(xhr) {};

        var loader = new THREE.GLTFLoader(manager);
        loader.crossOrigin = 'anonymous';
        loader.load(objURL, function (object) {
          var gltfMesh = object.scene.children[0];
          object.scene.children[0].traverse(function (child) {
            if (child instanceof THREE.Mesh) {
              console.log(child);
              child.material.emissive = new THREE.Color(0xff6600); // -> color

              child.material.normalMap = texture; // -> map

              child.material.shadowSide = THREE.DoubleSide; // -> side

              child.material.wireframe = false; // -> wireframe

              child.material.emissiveIntensity = 0.5; // -> shininess
              //Excluding objects from fog

              child.material.fog = false; // -> fog
              // set castShadow to object

              child.castShadow = true;
            }
          });
          /*
          If you can not use `object.scene.children[ 0 ]`, use the following code:
          
          	const gltfMesh = object.scene;
          object.scene.traverse( function( child ) {            
             if ( ( child instanceof THREE.Mesh ) ) { 
          				child.material = new THREE.MeshPhongMaterial( {
          							color: 0xdddddd,
          							shininess: 80,
          							wireframe: true,
          							map: mainSceneImgTexture,
          							side: THREE.DoubleSide,
          							fog : false //Excluding objects from fog
          						} );
          			// set castShadow to object
          		child.castShadow = true;
          		}
          });
          	
          */

          displacementSprite.add(gltfMesh);
          displacementSprite.scale.set(1.2, 1.2, 1.2);
          displacementSprite.position.y = 100;
          scene.add(displacementSprite); // set the original position

          displacementSprite.origPos = {
            x: displacementSprite.position.x,
            y: displacementSprite.position.y,
            z: displacementSprite.position.z,
            rx: displacementSprite.rotation.x,
            ry: displacementSprite.rotation.y,
            rz: displacementSprite.rotation.z
          }; // set animation

          mixerGLTF = new THREE.AnimationMixer(displacementSprite);
          console.log(mixerGLTF);
          object.animations.forEach(function (el) {
            var thisAction = mixerGLTF.clipAction(el);
            thisAction.setDuration(1);

            if (thisAction.time === 0) {
              thisAction.time = thisAction.getClip().duration;
            } //console.log( 'thisAction.time: ' + thisAction.time );


            console.log(thisAction);
            thisAction.paused = false; //thisAction.timeScale = -1; //Reverse Keyframe animation

            thisAction.play();
          });
        }, onProgress, onError); //=================
        // Fires when the window changes

        window.addEventListener('resize', onWindowResize, false);
      }

      function render() {
        requestAnimationFrame(render);
        theta += 0.1;
        camera.position.x = radius * Math.sin(getRadian(theta));
        camera.position.z = radius * Math.cos(getRadian(theta));
        camera.lookAt(camera.target);

        if (mixerGLTF) {
          var time = Date.now();
          mixerGLTF.update((time - prevTime) * 0.001);
          prevTime = time; //
          //const delta  clock.getDelta();
          //mixerGLTF.update( delta );
        } //To set a background color.
        //renderer.setClearColor( 0x000000 );	
        //push objects

        /*
        @Usage: 
             function CustomObj( scene ) {
                 const elements = new THREE...;
                scene.add( elements );
                 this.update = function( time ) {
                    elements.rotation.y = time*0.003;
                }
            }       
             sceneSubjects.push( new CustomObj( MainStage.getScene() ) );  
        */


        for (var i = 0; i < sceneSubjects.length; i++) {
          sceneSubjects[i].update(clock.getElapsedTime() * 1);
        } //render the scene to display our scene through the camera's eye.


        renderer.render(scene, camera);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }
      /*
       * Returns the radian degree .
       *
       * @return {Number} deg - Value of degree.
       * @return {Number}
       * @usage: 
          
          rad = Math.PI / 180 * 30 ;
       */


      function getRadian(deg) {
        return deg * Math.PI / 180;
      } // 
      //-------------------------------------	


      return {
        init: init,
        render: render,
        getRendererCanvasID: function getRendererCanvasID() {
          return rendererCanvasID;
        },
        getScene: function getScene() {
          return scene;
        },
        getCamera: function getCamera() {
          return camera;
        }
      };
    }();

    MainStage.init();
    MainStage.render();
  };

  module.components.documentReady.push(module.THREE_MODEL.documentReady);
  return /*#__PURE__*/_createClass(function THREE_MODEL() {
    _classCallCheck(this, THREE_MODEL);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/_third-party-plugins/THREE/esm/renderers/CSS3DRenderer.js
/**
 * Based on http://www.emagix.net/academic/mscs-project/item/camera-sync-with-css3-and-webgl-threejs
 * @author mrdoob / http://mrdoob.com/
 * @author yomotsu / https://yomotsu.net/
 */
THREE.CSS3DObject = function (element) {
  THREE.Object3D.call(this);
  this.element = element;
  this.element.style.position = 'absolute';
  this.addEventListener('removed', function () {
    if (this.element.parentNode !== null) {
      this.element.parentNode.removeChild(this.element);
    }
  });
};

THREE.CSS3DObject.prototype = Object.create(THREE.Object3D.prototype);
THREE.CSS3DObject.prototype.constructor = THREE.CSS3DObject;

THREE.CSS3DSprite = function (element) {
  THREE.CSS3DObject.call(this, element);
};

THREE.CSS3DSprite.prototype = Object.create(THREE.CSS3DObject.prototype);
THREE.CSS3DSprite.prototype.constructor = THREE.CSS3DSprite; //

THREE.CSS3DRenderer = function () {
  console.log('THREE.CSS3DRenderer', THREE.REVISION);

  var _width, _height;

  var _widthHalf, _heightHalf;

  var matrix = new THREE.Matrix4();
  var cache = {
    camera: {
      fov: 0,
      style: ''
    },
    objects: new WeakMap()
  };
  var domElement = document.createElement('div');
  domElement.style.overflow = 'hidden';
  this.domElement = domElement;
  var cameraElement = document.createElement('div');
  cameraElement.style.WebkitTransformStyle = 'preserve-3d';
  cameraElement.style.transformStyle = 'preserve-3d';
  domElement.appendChild(cameraElement);
  var isIE = /Trident/i.test(navigator.userAgent);

  this.getSize = function () {
    return {
      width: _width,
      height: _height
    };
  };

  this.setSize = function (width, height) {
    _width = width;
    _height = height;
    _widthHalf = _width / 2;
    _heightHalf = _height / 2;
    domElement.style.width = width + 'px';
    domElement.style.height = height + 'px';
    cameraElement.style.width = width + 'px';
    cameraElement.style.height = height + 'px';
  };

  function epsilon(value) {
    return Math.abs(value) < 1e-10 ? 0 : value;
  }

  function getCameraCSSMatrix(matrix) {
    var elements = matrix.elements;
    return 'matrix3d(' + epsilon(elements[0]) + ',' + epsilon(-elements[1]) + ',' + epsilon(elements[2]) + ',' + epsilon(elements[3]) + ',' + epsilon(elements[4]) + ',' + epsilon(-elements[5]) + ',' + epsilon(elements[6]) + ',' + epsilon(elements[7]) + ',' + epsilon(elements[8]) + ',' + epsilon(-elements[9]) + ',' + epsilon(elements[10]) + ',' + epsilon(elements[11]) + ',' + epsilon(elements[12]) + ',' + epsilon(-elements[13]) + ',' + epsilon(elements[14]) + ',' + epsilon(elements[15]) + ')';
  }

  function getObjectCSSMatrix(matrix, cameraCSSMatrix) {
    var elements = matrix.elements;
    var matrix3d = 'matrix3d(' + epsilon(elements[0]) + ',' + epsilon(elements[1]) + ',' + epsilon(elements[2]) + ',' + epsilon(elements[3]) + ',' + epsilon(-elements[4]) + ',' + epsilon(-elements[5]) + ',' + epsilon(-elements[6]) + ',' + epsilon(-elements[7]) + ',' + epsilon(elements[8]) + ',' + epsilon(elements[9]) + ',' + epsilon(elements[10]) + ',' + epsilon(elements[11]) + ',' + epsilon(elements[12]) + ',' + epsilon(elements[13]) + ',' + epsilon(elements[14]) + ',' + epsilon(elements[15]) + ')';

    if (isIE) {
      return 'translate(-50%,-50%)' + 'translate(' + _widthHalf + 'px,' + _heightHalf + 'px)' + cameraCSSMatrix + matrix3d;
    }

    return 'translate(-50%,-50%)' + matrix3d;
  }

  function renderObject(object, camera, cameraCSSMatrix) {
    if (object instanceof THREE.CSS3DObject) {
      var style;

      if (object instanceof THREE.CSS3DSprite) {
        // http://swiftcoder.wordpress.com/2008/11/25/constructing-a-billboard-matrix/
        matrix.copy(camera.matrixWorldInverse);
        matrix.transpose();
        matrix.copyPosition(object.matrixWorld);
        matrix.scale(object.scale);
        matrix.elements[3] = 0;
        matrix.elements[7] = 0;
        matrix.elements[11] = 0;
        matrix.elements[15] = 1;
        style = getObjectCSSMatrix(matrix, cameraCSSMatrix);
      } else {
        style = getObjectCSSMatrix(object.matrixWorld, cameraCSSMatrix);
      }

      var element = object.element;
      var cachedStyle = cache.objects.get(object);

      if (cachedStyle === undefined || cachedStyle !== style) {
        element.style.WebkitTransform = style;
        element.style.transform = style;
        var objectData = {
          style: style
        };

        if (isIE) {
          objectData.distanceToCameraSquared = getDistanceToSquared(camera, object);
        }

        cache.objects.set(object, objectData);
      }

      if (element.parentNode !== cameraElement) {
        cameraElement.appendChild(element);
      }
    }

    for (var i = 0, l = object.children.length; i < l; i++) {
      renderObject(object.children[i], camera, cameraCSSMatrix);
    }
  }

  var getDistanceToSquared = function () {
    var a = new THREE.Vector3();
    var b = new THREE.Vector3();
    return function (object1, object2) {
      a.setFromMatrixPosition(object1.matrixWorld);
      b.setFromMatrixPosition(object2.matrixWorld);
      return a.distanceToSquared(b);
    };
  }();

  function filterAndFlatten(scene) {
    var result = [];
    scene.traverse(function (object) {
      if (object instanceof THREE.CSS3DObject) result.push(object);
    });
    return result;
  }

  function zOrder(scene) {
    var sorted = filterAndFlatten(scene).sort(function (a, b) {
      var distanceA = cache.objects.get(a).distanceToCameraSquared;
      var distanceB = cache.objects.get(b).distanceToCameraSquared;
      return distanceA - distanceB;
    });
    var zMax = sorted.length;

    for (var i = 0, l = sorted.length; i < l; i++) {
      sorted[i].element.style.zIndex = zMax - i;
    }
  }

  this.render = function (scene, camera) {
    var fov = camera.projectionMatrix.elements[5] * _heightHalf;

    if (cache.camera.fov !== fov) {
      if (camera.isPerspectiveCamera) {
        domElement.style.WebkitPerspective = fov + 'px';
        domElement.style.perspective = fov + 'px';
      }

      cache.camera.fov = fov;
    }

    scene.updateMatrixWorld();
    if (camera.parent === null) camera.updateMatrixWorld();
    var cameraCSSMatrix = camera.isOrthographicCamera ? 'scale(' + fov + ')' + getCameraCSSMatrix(camera.matrixWorldInverse) : 'translateZ(' + fov + 'px)' + getCameraCSSMatrix(camera.matrixWorldInverse);
    var style = cameraCSSMatrix + 'translate(' + _widthHalf + 'px,' + _heightHalf + 'px)';

    if (cache.camera.style !== style && !isIE) {
      cameraElement.style.WebkitTransform = style;
      cameraElement.style.transform = style;
      cache.camera.style = style;
    }

    renderObject(scene, camera, cameraCSSMatrix);

    if (isIE) {
      // IE10 and 11 does not support 'preserve-3d'.
      // Thus, z-order in 3D will not work.
      // We have to calc z-order manually and set CSS z-index for IE.
      // FYI: z-index can't handle object intersection
      zOrder(scene);
    }
  };
};

/* harmony default export */ const CSS3DRenderer = (THREE.CSS3DObject);
;// CONCATENATED MODULE: ./src/components/simple-3D-pages/js/index.js



/* 
 *************************************
 * <!-- 3D Pages -->
 *************************************
 */

/**
 * module.THREE_PAGES
 * 
 * @requires ./examples/assets/js/min/three.min.js
 * @requires ./src/plugins/THREE
 */



var THREE_PAGES = function (module, $, window, document) {
  if (window.THREE_PAGES === null) return false;
  module.THREE_PAGES = module.THREE_PAGES || {};
  module.THREE_PAGES.version = '0.0.2';

  module.THREE_PAGES.documentReady = function ($) {
    //Prevent this module from loading in other pages
    if ($('#3D-renderer').length == 0 || !Modernizr.webgl) return false;
    var sceneSubjects = []; // Import objects and animations dynamically

    var MainStage = function () {
      var windowWidth = window.innerWidth,
          windowHeight = window.innerHeight;
      var viewRenderer = '3D-renderer'; // Generate one plane geometries mesh to scene
      //-------------------------------------	

      var camera,
          controls,
          scene,
          light,
          renderer,
          clock = new THREE.Clock();

      function init() {
        //camera
        camera = new THREE.PerspectiveCamera(45, windowWidth / windowHeight, 1, 10000);
        camera.position.set(0, 0, -1000); //controls

        controls = new THREE.OrbitControls(camera);
        controls.rotateSpeed = 0.5;
        controls.zoomSpeed = 1.2;
        controls.panSpeed = 0.8;
        controls.enableZoom = true;
        controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled

        controls.dampingFactor = 0.25;
        controls.screenSpacePanning = false;
        controls.minDistance = 1000;
        controls.maxDistance = 1500;
        controls.maxPolarAngle = Math.PI / 2; //Scene

        scene = new THREE.Scene(); //HemisphereLight

        light = new THREE.HemisphereLight(0xffbf67, 0x15c6ff);
        scene.add(light); //WebGL Renderer

        renderer = new THREE.WebGLRenderer({
          alpha: true,
          antialias: true
        });
        renderer.setClearColor(0xffffff, 0);
        renderer.setSize(windowWidth - 50, windowHeight - 50);
        renderer.domElement.style.zIndex = 5;
        document.getElementById(viewRenderer).appendChild(renderer.domElement); //Add HTML elements to scene

        var target = $('#html3D-view').clone(),
            pages = target.find('.html3D-view-content');
        pages.each(function () {
          var el = new THREE.CSS3DObject($.parseHTML($(this)[0].outerHTML)[0]);
          el.position.x = $(this).data('position-x') || 0;
          el.position.y = $(this).data('position-y') || 0;
          el.position.z = $(this).data('position-z') || 0;
          el.rotation.x = $(this).data('rotation-x') || 0;
          el.rotation.y = $(this).data('rotation-y') || 3.14159265358979;
          el.rotation.z = $(this).data('rotation-z') || 0;
          scene.add(el);
        }); //CSS3D Renderer

        renderer = new THREE.CSS3DRenderer();
        renderer.setSize(windowWidth, windowHeight);
        renderer.domElement.style.position = 'absolute';
        renderer.domElement.style.top = 0;
        document.getElementById(viewRenderer).appendChild(renderer.domElement); // Fires when the window changes

        window.addEventListener('resize', onWindowResize, false);
      }

      function render() {
        requestAnimationFrame(render);
        var delta = clock.getDelta(); //update camera and controls

        controls.update(); //push objects

        /*
        @Usage: 
             function CustomObj( scene ) {
                 const elements = new THREE...;
                scene.add( elements );
                 this.update = function( time ) {
                    elements.rotation.y = time*0.003;
                }
            }       
             sceneSubjects.push( new CustomObj( MainStage.getScene() ) );  
        */

        for (var i = 0; i < sceneSubjects.length; i++) {
          sceneSubjects[i].update(clock.getElapsedTime() * 1);
        } //render the scene to display our scene through the camera's eye.


        renderer.render(scene, camera);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      } // 
      //-------------------------------------	


      return {
        init: init,
        render: render,
        getRendererCanvasID: function getRendererCanvasID() {
          return rendererCanvasID;
        },
        getScene: function getScene() {
          return scene;
        },
        getCamera: function getCamera() {
          return camera;
        }
      };
    }();

    MainStage.init();
    MainStage.render();
  };

  module.components.documentReady.push(module.THREE_PAGES.documentReady);
  return /*#__PURE__*/_createClass(function THREE_PAGES() {
    _classCallCheck(this, THREE_PAGES);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/simple-3D-particle-effect/js/index.js




/* 
 *************************************
 * <!-- 3D Particle Effect -->
 *************************************
 */

/**
 * module.THREE_PARTICLE
 * 
 * @requires ./examples/assets/js/min/three.min.js
 * @requires ./src/plugins/THREE
 */

var THREE_PARTICLE = function (module, $, window, document) {
  if (window.THREE_PARTICLE === null) return false;
  module.THREE_PARTICLE = module.THREE_PARTICLE || {};
  module.THREE_PARTICLE.version = '0.0.6';

  module.THREE_PARTICLE.documentReady = function ($) {
    //Prevent this module from loading in other pages
    if ($('#3D-particle-effect-canvas').length == 0 || !Modernizr.webgl) return false;
    var sceneSubjects = []; // Import objects and animations dynamically

    var MainStage = function () {
      var windowWidth = window.innerWidth,
          windowHeight = window.innerHeight;
      var rendererCanvasID = '3D-particle-effect-canvas';
      var renderer,
          texture,
          scene,
          camera,
          particles,
          imagedata,
          clock = new THREE.Clock(),
          mouseX = 0,
          mouseY = 0,
          isMouseDown = true,
          lastMousePos = {
        x: 0,
        y: 0
      },
          windowHalfX = windowWidth / 2,
          windowHalfY = windowHeight / 2; //background

      var backgroundBg = 0xCE3A3E;
      var backgroundPlane = 0xDE510E; // Light from scene ready

      var sceneForLightPlane, sceneForSpotLight, sceneForAmbientLight; // camera data

      var fieldOfView, aspectRatio, nearPlane, farPlane;
      var dist, vFOV, visibleHeight, visibleWidth;
      var xLimit, yLimit;
      var maxTargetZ = 200; //particle rotation

      var particleRotation;
      var centerVector = new THREE.Vector3(0, 0, 0);
      var previousTime = 0;

      function init() {
        //==================================
        //==================================
        //camera
        fieldOfView = 60;
        aspectRatio = windowWidth / windowHeight;
        nearPlane = 1; // the camera won't "see" any object placed in front of this plane

        farPlane = 10000; // the camera wont't see any object placed further than this plane 

        camera = new THREE.PerspectiveCamera(fieldOfView, aspectRatio, nearPlane, farPlane);
        camera.position.set(0, 65, -500);
        camera.lookAt(centerVector); // convert the field of view to radians

        var ang = fieldOfView / 2 * Math.PI / 180; // calculate the max y position seen by the camera related to the maxTargetZ position, I start by calculating the y limit because fielOfView is a vertical field of view. I then calculate the x Limit

        yLimit = (camera.position.z + maxTargetZ) * Math.tan(ang); // this is a formula I found, don't ask me why it works, it just does :) 
        // Calculate the max x position seen by the camera related to the y Limit position

        xLimit = yLimit * camera.aspect; // Fit plane to screen

        dist = 1000;
        vFOV = THREE.Math.degToRad(camera.fov); // convert vertical fov to radians

        visibleHeight = 2 * Math.tan(vFOV / 2) * dist; // visible height

        visibleWidth = visibleHeight * camera.aspect; // visible width   
        //console.log( 'visibleWidth:' + visibleWidth + ', visibleHeight: ' + visibleHeight + ', xLimit: ' + xLimit + ', yLimit: ' + yLimit );
        //==================================
        //==================================
        //Scene

        scene = new THREE.Scene();
        scene.fog = new THREE.Fog(backgroundBg, 0.0025, 650); // Used to cover the light plane
        //==================================
        //==================================
        //Light from scene ready
        // Light plane  

        sceneForLightPlane = new THREE.Mesh(new THREE.CircleGeometry(1000, 32), new THREE.MeshPhongMaterial({
          emissive: backgroundPlane,
          side: THREE.DoubleSide
        }));
        sceneForLightPlane.receiveShadow = true;
        sceneForLightPlane.position.set(0, -101, 5);
        sceneForLightPlane.rotation.x = getRadian(-95);
        scene.add(sceneForLightPlane); // Spot Light

        var spotLightColor = 0xffffff,
            spotLightIntensity = 2,
            spotLightDistance = 1200,
            spotLightAngle = getRadian(50),
            spotLightPenumbra = 1,
            spotLightDecay = 1;
        sceneForSpotLight = new THREE.SpotLight(spotLightColor, spotLightIntensity, spotLightDistance, spotLightAngle, spotLightPenumbra, spotLightDecay);
        sceneForSpotLight.position.set(5, 320, 5); // Setting the y-axis bond angle is critical

        sceneForSpotLight.castShadow = true;
        sceneForSpotLight.shadow.mapSize.width = 1024;
        sceneForSpotLight.shadow.mapSize.height = 1024;
        sceneForSpotLight.shadow.camera.near = 0.5;
        sceneForSpotLight.shadow.camera.far = 31;
        scene.add(sceneForSpotLight); //console.log( sceneForSpotLight );

        /*
        const spotLightHelper = new THREE.SpotLightHelper( sceneForSpotLight );
        scene.add( spotLightHelper );   
        */
        // Ambient Light

        sceneForAmbientLight = new THREE.AmbientLight(0xffffff, 0.08);
        scene.add(sceneForAmbientLight); //==================================
        //==================================
        //WebGL Renderer		

        renderer = new THREE.WebGLRenderer({
          canvas: document.getElementById(rendererCanvasID),
          //canvas
          alpha: true,
          antialias: true
        });
        renderer.setSize(windowWidth, windowHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; // instantiate a loader

        var loader = new THREE.TextureLoader(); // load a resource

        loader.load( // resource URL
        $('#' + rendererCanvasID).data('img-src'), // onLoad callback
        function (texture) {
          // in this example we create the material when the texture is loaded
          // Get data from an image
          imagedata = getImageData(texture.image); // Immediately use the texture for material creation

          var geometry = new THREE.Geometry();
          var material = new THREE.PointsMaterial({
            size: 3,
            color: 0xffffff,
            sizeAttenuation: false,
            fog: false //Excluding objects from fog

          });

          for (var y = 0, y2 = imagedata.height; y < y2; y += 2) {
            for (var x = 0, x2 = imagedata.width; x < x2; x += 2) {
              if (imagedata.data[x * 4 + y * 4 * imagedata.width + 3] > 128) {
                // The array of vertices holds the position of every vertex in the model.
                var vertex = new THREE.Vector3();
                vertex.x = Math.random() * 1000 - 500;
                vertex.y = Math.random() * 1000 - 500;
                vertex.z = -Math.random() * 500;
                vertex.destination = {
                  x: x - imagedata.width / 2,
                  y: -y + imagedata.height / 2,
                  z: 0
                };
                vertex.speed = Math.random() / 200 + 0.015;
                geometry.vertices.push(vertex);
              }
            }
          }

          particles = new THREE.Points(geometry, material);
          scene.add(particles);
          particles.scale.setScalar(0.7);
          particles.position.y = 50;
          particles.position.z = 70;
          particles.rotation.y = getRadian(180); // set castShadow to object

          particles.castShadow = true;
        }, // onProgress callback currently not supported
        undefined, // onError callback
        function (err) {
          console.error('An error happened.');
        }); // add particle rotation

        particleRotation = new THREE.Object3D();
        scene.add(particleRotation);
        var geometryPR = new THREE.TetrahedronGeometry(2, 0),
            materialPR = new THREE.MeshPhongMaterial({
          color: 0xffffff,
          emissive: 0xffffff,
          shininess: 80,
          flatShading: true
        });

        for (var i = 0; i < 750; i++) {
          var mesh = new THREE.Mesh(geometryPR, materialPR);
          mesh.position.set(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize();
          mesh.position.multiplyScalar(90 + Math.random() * 700);
          mesh.rotation.set(Math.random() * 2, Math.random() * 2, Math.random() * 2);
          particleRotation.add(mesh); // set castShadow to object

          mesh.castShadow = true;
        } //----


        document.addEventListener('mousemove', onDocumentMouseMove, false);
        document.addEventListener('touchstart', onDocumentTouchStart, UixBrowser.supportsPassive ? {
          passive: true
        } : false);
        document.addEventListener('touchmove', onDocumentTouchMove, UixBrowser.supportsPassive ? {
          passive: true
        } : false);
        document.addEventListener('mousedown', onDocumentMouseDown, false);
        document.addEventListener('mouseup', onDocumentMouseUp, false); // Fires when the window changes

        window.addEventListener('resize', onWindowResize, false);
      }

      function render() {
        requestAnimationFrame(render);
        var delta = clock.getDelta(),
            thickness = 40; //---
        // 
        // To set a background color.

        renderer.setClearColor(backgroundBg); //---
        // 
        //Need to add judgment to avoid Cannot read property 'geometry' of undefined

        if ((0,esm_typeof/* default */.Z)(particles) != ( true ? "undefined" : 0)) {
          var particle;

          for (var i = 0, j = particles.geometry.vertices.length; i < j; i++) {
            particle = particles.geometry.vertices[i];
            particle.x += (particle.destination.x - particle.x) * particle.speed;
            particle.y += (particle.destination.y - particle.y) * particle.speed;
            particle.z += (particle.destination.z - particle.z) * particle.speed;
          }

          if (delta - previousTime > thickness) {
            var index = Math.floor(Math.random() * particles.geometry.vertices.length);
            var particle1 = particles.geometry.vertices[index];
            var particle2 = particles.geometry.vertices[particles.geometry.vertices.length - index];
            TweenMax.to(particle, Math.random() * 2 + 1, {
              x: particle2.x,
              y: particle2.y,
              ease: Power2.easeInOut
            });
            TweenMax.to(particle2, Math.random() * 2 + 1, {
              x: particle1.x,
              y: particle1.y,
              ease: Power2.easeInOut
            });
            previousTime = delta;
          }

          particles.geometry.verticesNeedUpdate = true;
        }

        if (!isMouseDown) {
          camera.position.x += (0 - camera.position.x) * 0.06;
          camera.position.y += (0 - camera.position.y) * 0.06;
        }

        camera.position.x += (mouseX - camera.position.x) * 0.09;
        camera.position.y += (-mouseY - camera.position.y) * 0.09;
        if (camera.position.y < -60) camera.position.y = -60;
        camera.lookAt(centerVector); //particle rotation

        particleRotation.rotation.x += 0.0000;
        particleRotation.rotation.y -= 0.0040; //---
        // 
        //push objects

        /*
        @Usage: 
             function CustomObj( scene ) {
                 const elements = new THREE...;
                scene.add( elements );
                 this.update = function( time ) {
                    elements.rotation.y = time*0.003;
                }
            }       
             sceneSubjects.push( new CustomObj( MainStage.getScene() ) );  
        */

        for (var _i = 0; _i < sceneSubjects.length; _i++) {
          sceneSubjects[_i].update(clock.getElapsedTime() * 1);
        } //---
        // 
        //render the scene to display our scene through the camera's eye.


        renderer.render(scene, camera);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function onDocumentMouseMove(event) {
        mouseX = event.clientX - windowHalfX;
        mouseY = event.clientY - windowHalfY;

        if (isMouseDown) {
          camera.position.x += (event.clientX - lastMousePos.x) / 100;
          camera.position.y -= (event.clientY - lastMousePos.y) / 100;
          camera.lookAt(centerVector);
          lastMousePos = {
            x: event.clientX,
            y: event.clientY
          };
        }
      }

      function onDocumentTouchStart(event) {
        if (event.touches.length == 1) {
          event.preventDefault();
          mouseX = event.touches[0].pageX - windowHalfX;
          mouseY = event.touches[0].pageY - windowHalfY;
        }
      }

      function onDocumentTouchMove(event) {
        if (event.touches.length == 1) {
          event.preventDefault();
          mouseX = event.touches[0].pageX - windowHalfX;
          mouseY = event.touches[0].pageY - windowHalfY;
        }
      }

      function onDocumentMouseUp() {
        isMouseDown = false;
      }

      function onDocumentMouseDown(event) {
        isMouseDown = true;
        lastMousePos = {
          x: event.clientX,
          y: event.clientY
        };
      }
      /*
       * Get Image Data when Draw Image To Canvas
       *
       * @param  {!Element} image         - Overridden with a record type holding data, width and height.
       * @return {Object}                 - The image data via JSON.
       */


      function getImageData(image) {
        var canvas = document.createElement('canvas');
        canvas.width = image.width;
        canvas.height = image.height;
        var ctx = canvas.getContext('2d');
        ctx.drawImage(image, 0, 0);
        return ctx.getImageData(0, 0, image.width, image.height);
      }
      /*
       * Get Object Coordinate, Width and Height From Screen
       * Note: No data may be acquired without delay !!
       *
      * @param  {THREE.Mesh} obj                           - Mesh object.
       * @param  {THREE.PerspectiveCamera} camera           - Mesh object.
      * @param  {Number} rendererWidth                     - Width of renderer.
       * @param  {Number} rendererHeight                    - Height of renderer.
       * @param  {String} type                              - Build type.
       * @return {JSON}
       */

      /* @usage: 
         const screenPos = nestedObjectToScreenXYZAndWH( displacementSprite , camera, renderer.domElement.width, renderer.domElement.height );
        */


      function nestedObjectToScreenXYZAndWH(obj, camera, rendererWidth, rendererHeight) {
        var vector = new THREE.Vector3();
        vector.setFromMatrixPosition(obj.matrixWorld);
        var widthHalf = rendererWidth / 2;
        var heightHalf = rendererHeight / 2;
        var aspect = rendererHeight / rendererWidth;
        vector.project(camera);
        vector.x = vector.x * widthHalf + widthHalf;
        vector.y = -(vector.y * heightHalf) + heightHalf; //compute bounding box after

        var boxInfo = new THREE.Box3().setFromObject(obj).getSize(new THREE.Vector3()); //Change it to fit the width and height of the stage based on the current value

        var ratioFixedNum = 7; //correction

        return {
          position: vector,
          width: (boxInfo.x * ratioFixedNum * aspect).toFixed(2),
          height: (boxInfo.y * ratioFixedNum * aspect).toFixed(2)
        };
      }
      /*
       * Generate random number between two numbers
       *
       * @return {Number}
       */


      function getRandomFloat(min, max) {
        return Math.random() * (max - min) + min;
      }
      /*
       * Returns the degree from radian.
       *
       * @return {Number} rad - Value of radian.
       * @return {Number}
       * @usage: 
       
         angle = rad / ( Math.PI / 180 )  = rad * ( 180/Math.PI );
       */


      function getDegree(rad) {
        return rad / Math.PI * 180;
      }
      /*
       * Returns the radian degree .
       *
       * @return {Number} deg - Value of degree.
       * @return {Number}
       * @usage: 
          
          rad = Math.PI / 180 * 30 ;
       */


      function getRadian(deg) {
        return deg * Math.PI / 180;
      }
      /*
       * Convert three.js scene rotation to polar coordinates
       *
       * @return {Number} deg - Value of degree.
       * @return {Number}
       * @usage: 
       
          x = r * cos（θ）
          y = r * sin（θ）  
       */


      function getPolarCoord(x, y, z) {
        var nx = Math.cos(x) * Math.cos(y) * z,
            nz = Math.cos(x) * Math.sin(y) * z,
            ny = Math.sin(x) * z;
        return new THREE.Vector3(nx, ny, nz);
      } // 
      //-------------------------------------	


      return {
        init: init,
        render: render,
        getRendererCanvasID: function getRendererCanvasID() {
          return rendererCanvasID;
        },
        getScene: function getScene() {
          return scene;
        },
        getCamera: function getCamera() {
          return camera;
        }
      };
    }();

    MainStage.init();
    MainStage.render();
  };

  module.components.documentReady.push(module.THREE_PARTICLE.documentReady);
  return /*#__PURE__*/_createClass(function THREE_PARTICLE() {
    _classCallCheck(this, THREE_PARTICLE);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/simple-3D-sphere-three/js/index.js



/* 
 *************************************
 * <!-- 3D Sphere Rotation -->
 *************************************
 */

/**
 * module.THREE_SPHERE_THREE
 * 
 * @requires ./examples/assets/js/min/three.min.js
 * @requires ./src/plugins/THREE
 */


var THREE_SPHERE_THREE = function (module, $, window, document) {
  if (window.THREE_SPHERE_THREE === null) return false;
  module.THREE_SPHERE_THREE = module.THREE_SPHERE_THREE || {};
  module.THREE_SPHERE_THREE.version = '0.0.2';

  module.THREE_SPHERE_THREE.documentReady = function ($) {
    //Prevent this module from loading in other pages
    if ($('#3D-sphere-three-canvas').length == 0 || !Modernizr.webgl) return false;
    var sceneSubjects = []; // Import objects and animations dynamically

    var MainStage = function () {
      var windowWidth = window.innerWidth,
          windowHeight = window.innerHeight;
      var rendererCanvasID = '3D-sphere-three-canvas'; // Generate one plane geometries mesh to scene
      //-------------------------------------	

      var camera, controls, scene, light, renderer, displacementSprite;

      function init() {
        // camera
        camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 1, 100);
        camera.position.set(0, -46, 18); // controls

        controls = new THREE.OrbitControls(camera);
        controls.minDistance = 10;
        controls.maxDistance = 50; //Scene

        scene = new THREE.Scene(); //HemisphereLight

        scene.add(new THREE.AmbientLight(0x555555));
        light = new THREE.SpotLight(0xffffff, 1.5);
        light.position.set(0, 500, 2000);
        scene.add(light); //WebGL Renderer		

        renderer = new THREE.WebGLRenderer({
          canvas: document.getElementById(rendererCanvasID),
          //canvas
          alpha: true,
          antialias: true
        });
        renderer.setSize(windowWidth, windowHeight); // axes
        //scene.add( new THREE.AxisHelper( 20 ) );
        // geometry

        var geometry = new THREE.SphereGeometry(3, 32, 32); // material, we create the material when the texture is loaded

        var loader = new THREE.TextureLoader();
        loader.crossOrigin = 'anonymous';
        var texture = loader.load('https://placekitten.com/1650/1650'),
            material = new THREE.MeshBasicMaterial({
          map: texture
        }); // parent

        displacementSprite = new THREE.Object3D();
        scene.add(displacementSprite); // pivots

        var pivot1 = new THREE.Object3D(),
            pivot2 = new THREE.Object3D(),
            pivot3 = new THREE.Object3D();
        pivot1.rotation.z = 0;
        pivot2.rotation.z = 2 * Math.PI / 3;
        pivot3.rotation.z = 4 * Math.PI / 3;
        displacementSprite.add(pivot1);
        displacementSprite.add(pivot2);
        displacementSprite.add(pivot3); // mesh

        var mesh1 = new THREE.Mesh(geometry, material),
            mesh2 = new THREE.Mesh(geometry, material),
            mesh3 = new THREE.Mesh(geometry, material);
        mesh1.position.y = 5;
        mesh2.position.y = 15;
        mesh3.position.y = 25;
        pivot1.add(mesh1);
        pivot2.add(mesh2);
        pivot3.add(mesh3); // Fires when the window changes

        window.addEventListener('resize', onWindowResize, false);
      }

      function render() {
        requestAnimationFrame(render);
        displacementSprite.rotation.z += 0.01; //update camera and controls

        controls.update(); //push objects

        /*
        @Usage: 
             function CustomObj( scene ) {
                 const elements = new THREE...;
                scene.add( elements );
                 this.update = function( time ) {
                    elements.rotation.y = time*0.003;
                }
            }       
             sceneSubjects.push( new CustomObj( MainStage.getScene() ) );  
        */

        for (var i = 0; i < sceneSubjects.length; i++) {
          sceneSubjects[i].update(clock.getElapsedTime() * 1);
        } //render the scene to display our scene through the camera's eye.


        renderer.render(scene, camera);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      } // 
      //-------------------------------------	


      return {
        init: init,
        render: render,
        getRendererCanvasID: function getRendererCanvasID() {
          return rendererCanvasID;
        },
        getScene: function getScene() {
          return scene;
        },
        getCamera: function getCamera() {
          return camera;
        }
      };
    }();

    MainStage.init();
    MainStage.render();
  };

  module.components.documentReady.push(module.THREE_SPHERE_THREE.documentReady);
  return /*#__PURE__*/_createClass(function THREE_SPHERE_THREE() {
    _classCallCheck(this, THREE_SPHERE_THREE);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/simple-3D-obj-anim-interaction/js/index.js



/* 
 *************************************
 * <!-- 3D Object Anim When Click -->
 *************************************
 */


var THREE_OBJ_ANIM_INTERACTION = function (module, $, window, document) {
  if (window.THREE_OBJ_ANIM_INTERACTION === null) return false;
  module.THREE_OBJ_ANIM_INTERACTION = module.THREE_OBJ_ANIM_INTERACTION || {};
  module.THREE_OBJ_ANIM_INTERACTION.version = '0.0.3';

  module.THREE_OBJ_ANIM_INTERACTION.documentReady = function ($) {
    //Prevent this module from loading in other pages
    if ($('#3D-object-buttonevent-canvas').length == 0 || !Modernizr.webgl) return false;
    var sceneSubjects = []; // Import objects and animations dynamically

    var MainStage = function () {
      var windowWidth = window.innerWidth,
          windowHeight = window.innerHeight;
      var rendererCanvasID = '3D-object-buttonevent-canvas';
      var renderer, scene, controls, camera, targetObj, parent, material, segLength;
      var radius = 3,
          height = 6,
          segments = 200; //segments must be even

      function init() {
        // Create a camera, which defines where we're looking at.		
        renderer = new THREE.WebGLRenderer({
          canvas: document.getElementById(rendererCanvasID),
          //canvas
          alpha: true,
          antialias: true
        });
        renderer.setSize(windowWidth, windowHeight); //Scene

        scene = new THREE.Scene(); //camera

        camera = new THREE.PerspectiveCamera(70, windowWidth / windowHeight, 1, 100);
        camera.position.set(1, 1, 22); //controls

        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.addEventListener('change', function () {
          renderer.render(scene, camera);
        }, false);
        controls.enableZoom = false;
        controls.enablePan = false; // Immediately use the texture for material creation

        material = new THREE.MeshPhongMaterial({
          color: 0xEB6D35,
          specular: 0xEB6D35,
          shininess: 15,
          flatShading: THREE.FlatShading,
          side: THREE.DoubleSide,
          transparent: true,
          opacity: .8
        }); //HemisphereLight

        var light1 = new THREE.DirectionalLight(0xffffff);
        light1.position.set(-5, 10, 10);
        var light2 = new THREE.PointLight(0xffffff, .7, 0);
        light2.position.set(5, 5, -5);
        scene.add(light1, light2); //put the target object inside a parent object so the manipulation is easier

        parent = new THREE.Object3D();
        addObject();
        parent.position.set(-radius, height / 2, 0);
        parent.rotation.y = Math.PI;
        scene.add(parent);
        renderer.render(scene, camera);
      }

      function addObject() {
        var geo = new THREE.Geometry();
        segLength = Math.PI * 2 * radius / segments;
        geo.vertices.push(new THREE.Vector3(0, height / 2, 0));
        geo.vertices.push(new THREE.Vector3(0, -height / 2, 0));

        for (var i = 0; i < Math.floor(segments / 2); i++) {
          geo.vertices.push(new THREE.Vector3(0, height / 2, segLength * i));
          geo.vertices.push(new THREE.Vector3(0, -height / 2, segLength * i));
          geo.vertices.push(new THREE.Vector3(0, height / 2, -segLength * i));
          geo.vertices.push(new THREE.Vector3(0, -height / 2, -segLength * i));
        }

        geo.faces.push(new THREE.Face3(0, 1, 2));
        geo.faces.push(new THREE.Face3(1, 2, 3));
        geo.faces.push(new THREE.Face3(0, 1, 4));
        geo.faces.push(new THREE.Face3(1, 4, 5));

        for (var _i = 1; _i < Math.floor(segments / 2); _i++) {
          geo.faces.push(new THREE.Face3(2 + (_i - 1) * 4, 3 + (_i - 1) * 4, 6 + (_i - 1) * 4));
          geo.faces.push(new THREE.Face3(3 + (_i - 1) * 4, 6 + (_i - 1) * 4, 7 + (_i - 1) * 4));
          geo.faces.push(new THREE.Face3(4 + (_i - 1) * 4, 5 + (_i - 1) * 4, 8 + (_i - 1) * 4));
          geo.faces.push(new THREE.Face3(5 + (_i - 1) * 4, 8 + (_i - 1) * 4, 9 + (_i - 1) * 4));
        }

        targetObj = new THREE.Mesh(geo, material);
        parent.add(targetObj);
      }

      function render() {
        requestAnimationFrame(render); //upodate object

        targetObj.geometry.verticesNeedUpdate = true; //update camera and controls

        controls.update(); //push objects

        /*
        @Usage: 
             function CustomObj( scene ) {
                 const elements = new THREE...;
                scene.add( elements );
                 this.update = function( time ) {
                    elements.rotation.y = time*0.003;
                }
            }       
             sceneSubjects.push( new CustomObj( MainStage.getScene() ) );  
        */

        for (var i = 0; i < sceneSubjects.length; i++) {
          sceneSubjects[i].update(clock.getElapsedTime() * 1);
        } //render the scene to display our scene through the camera's eye.


        renderer.render(scene, camera);
      }

      $('#3D-object-button1').on('click', function (e) {
        e.preventDefault();
        var theta = 55,
            x = camera.position.x,
            z = camera.position.z,
            moveX = x * Math.cos(theta) - z * Math.sin(theta),
            moveZ = z * Math.cos(theta) + x * Math.sin(theta);
        TweenMax.to(camera.position, 1.5, {
          x: moveX,
          z: moveZ,
          ease: Power0.easeNone,
          onUpdate: function onUpdate() {}
        });
      });
      $('#3D-object-button2').on('click', function (e) {
        e.preventDefault(); //1. tween the first segment of each side

        var w = targetObj.geometry.vertices;
        w[2].x = w[3].x = w[4].x = w[5].x = -Math.sin(0) * segLength;
        w[2].z = w[3].z = Math.cos(0) * segLength;
        w[4].z = w[5].z = -Math.cos(0) * segLength; //2. rest of the vertex can now refer to the fourth previous vertex, their reference in the algorithm

        for (var i = 6; i < w.length; i++) {
          //which segment from the origin the vertex belongs to
          var vIndex = i,
              segIndex = Math.floor((vIndex + 2) / 4),
              negate = vIndex / 4 === Math.floor(vIndex / 4) || (vIndex - 1) / 4 === Math.floor((vIndex - 1) / 4) ? -1 : 1;
          var tx = w[vIndex - 4].x - Math.sin(vIndex * (negate * (2 * segIndex - 1))) * segLength * negate;
          var tz = w[vIndex - 4].z + Math.cos(vIndex * (negate * (2 * segIndex - 1))) * segLength * negate;
          TweenMax.to(w[vIndex], 1.5, {
            x: tx,
            z: tz,
            ease: Power0.easeNone,
            onUpdate: function onUpdate() {}
          });
        }
      });
      $('#3D-object-button3').on('click', function (e) {
        e.preventDefault();
        var scaleTo = Math.floor(Math.random() * Math.floor(3));
        TweenMax.to(targetObj.scale, 1.5, {
          x: scaleTo,
          y: scaleTo,
          z: scaleTo,
          ease: Power0.easeNone,
          onUpdate: function onUpdate() {}
        });
      }); // 
      //-------------------------------------	

      return {
        init: init,
        render: render,
        getRendererCanvasID: function getRendererCanvasID() {
          return rendererCanvasID;
        },
        getScene: function getScene() {
          return scene;
        },
        getCamera: function getCamera() {
          return camera;
        }
      };
    }();

    MainStage.init();
    MainStage.render();
  };

  module.components.documentReady.push(module.THREE_OBJ_ANIM_INTERACTION.documentReady);
  return /*#__PURE__*/_createClass(function THREE_OBJ_ANIM_INTERACTION() {
    _classCallCheck(this, THREE_OBJ_ANIM_INTERACTION);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/simple-3D-mouse-interaction/js/index.js



/* 
 *************************************
 * <!-- 3D Mouse Interaction with three.js -->
 *************************************
 */


var THREE_MOUSE_INTERACTION = function (module, $, window, document) {
  if (window.THREE_MOUSE_INTERACTION === null) return false;
  module.THREE_MOUSE_INTERACTION = module.THREE_MOUSE_INTERACTION || {};
  module.THREE_MOUSE_INTERACTION.version = '0.0.4';

  module.THREE_MOUSE_INTERACTION.documentReady = function ($) {
    //Prevent this module from loading in other pages
    if ($('#3D-mouseinteraction-three-canvas').length == 0 || !Modernizr.webgl) return false;
    var sceneSubjects = []; // Import objects and animations dynamically

    var MainStage = function () {
      var windowWidth = window.innerWidth,
          windowHeight = window.innerHeight;
      var rendererCanvasID = '3D-mouseinteraction-three-canvas'; // Generate one plane geometries mesh to scene
      //-------------------------------------	

      var camera,
          controls,
          scene,
          light,
          renderer,
          displacementSprite,
          radius = 100,
          theta = 0,
          clickEnabled = false;
      var mouseVector = new THREE.Vector2();
      var raycaster,
          intersects,
          INTERSECTED,
          nucleus,
          atoms = [];

      function init() {
        //=================
        //camera
        camera = new THREE.PerspectiveCamera(75, windowWidth / windowHeight, 1, 10000);
        camera.position.set(0, 0, 1300); //=================
        //controls

        controls = new THREE.OrbitControls(camera);
        controls.autoRotate = false;
        controls.autoRotateSpeed = 0.5;
        controls.rotateSpeed = 0.5;
        controls.zoomSpeed = 1.2;
        controls.panSpeed = 0.8;
        controls.enableZoom = true;
        controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled

        controls.dampingFactor = 0.25;
        controls.screenSpacePanning = false;
        controls.minDistance = 100;
        controls.maxDistance = 500;
        controls.maxPolarAngle = Math.PI / 2;
        controls.target.set(30, 167, 81);
        controls.update(); //=================
        //Scene

        scene = new THREE.Scene(); //=================
        //HemisphereLight

        scene.add(new THREE.AmbientLight(0x555555));
        light = new THREE.SpotLight(0xffffff, 1.5);
        light.position.set(0, 500, 2000);
        scene.add(light); //=================
        //WebGL Renderer	

        renderer = new THREE.WebGLRenderer({
          canvas: document.getElementById(rendererCanvasID),
          //canvas
          alpha: true,
          antialias: true
        });
        renderer.setSize(windowWidth, windowHeight); //=================
        // Immediately use the texture for material creation

        generateGeometry('poly', 15); //=================
        // Fires when the window changes

        window.addEventListener('resize', onWindowResize, false); //=================
        // When the mouse moves, call the given function

        raycaster = new THREE.Raycaster();
        document.addEventListener('mousemove', onDocumentMouseMove, false);
        document.getElementById(rendererCanvasID).addEventListener('click', onDocumentMouseDown, false);
        document.addEventListener('mouseup', onDocumentMouseUp, false);
      }

      function render() {
        requestAnimationFrame(render);
        theta += 0.1; //To set a background color.

        renderer.setClearColor(0x000000); //++++++++++++++++++++++++++++++++++++++
        //++++++++++++++++++++++++++++++++++++++
        //Mouse interactions

        raycaster.setFromCamera(mouseVector, camera);
        intersects = raycaster.intersectObjects(atoms); //intersects = raycaster.intersectObjects( scene.children );

        if (intersects.length > 0) {
          if (INTERSECTED != intersects[0].object) {
            // restore previous intersection object (if it exists) to its original color
            if (INTERSECTED) INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex);
            INTERSECTED = intersects[0].object;
            INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
            INTERSECTED.material.emissive.setHex(0xff0000);
          }
        } else {
          // restore previous intersection object (if it exists) to its original color
          if (INTERSECTED) INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex); //by setting current intersection object to "nothing"

          INTERSECTED = null;
        } //update camera and controls


        controls.update(); //push objects

        /*
        @Usage: 
             function CustomObj( scene ) {
                 const elements = new THREE...;
                scene.add( elements );
                 this.update = function( time ) {
                    elements.rotation.y = time*0.003;
                }
            }       
             sceneSubjects.push( new CustomObj( MainStage.getScene() ) );  
        */

        for (var i = 0; i < sceneSubjects.length; i++) {
          sceneSubjects[i].update(clock.getElapsedTime() * 1);
        } //render the scene to display our scene through the camera's eye.


        renderer.render(scene, camera);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function onDocumentMouseMove(event) {
        event.preventDefault();
        mouseVector.x = event.clientX / window.innerWidth * 2 - 1;
        mouseVector.y = -(event.clientY / window.innerHeight) * 2 + 1;
      }

      function onDocumentMouseDown(event) {
        event.preventDefault();
        mouseVector.x = event.clientX / window.innerWidth * 2 - 1;
        mouseVector.y = -(event.clientY / window.innerHeight) * 2 + 1;
        clickEnabled = true; //++++++++++++++++++++++++++++++++++++++
        //++++++++++++++++++++++++++++++++++++++
        //Mouse interactions

        raycaster.setFromCamera(mouseVector, camera);
        intersects = raycaster.intersectObjects(atoms); //intersects = raycaster.intersectObjects( scene.children );

        if (intersects.length > 0 && intersects[0].object.name.indexOf('nucleus') >= 0) {
          var _obj = intersects[0].object;
          console.log(_obj.name); //---Change object size
          //				if ( typeof intersects[ 0 ] != typeof undefined ) {
          //					const obj = intersects[ 0 ].object;
          //
          //
          //					TweenMax.to( obj.scale, 1, {
          //						x: '+=' + ( 200 - obj.scale.x ) * 0.05,
          //						y: '+=' + ( 200 - obj.scale.y ) * 0.05,
          //						z: '+=' + ( 200 - obj.scale.z ) * 0.05
          //					});	
          //
          //
          //					obj.updateMatrix();	
          //	
          //				}
          //---Change object position

          var targetAtomPos = _obj.position;
          console.log(targetAtomPos); // targetAtomPos.tween.pause();

          var destinationPos = targetAtomPos.clone();
          TweenMax.to(controls.target, 2, {
            x: destinationPos.x,
            y: destinationPos.y,
            z: destinationPos.z
          });
          TweenMax.to(camera.position, 2, {
            x: destinationPos.x,
            y: destinationPos.y,
            z: destinationPos.z + 100,
            onUpdate: function onUpdate() {
              camera.up.set(0, 1, 0);
              camera.updateProjectionMatrix();
            },
            onComplete: function onComplete() {
              // get object new coordinates
              var screenData = nestedObjectToScreenXYZAndWH(_obj, camera, renderer.domElement.width, renderer.domElement.height);
              console.log("Current object coordinates: {x: ".concat(screenData.position.x, ", y: ").concat(screenData.position.y, ", z: ").concat(screenData.position.z, " }"));
            }
          });
        } else {
          //Change object position
          TweenMax.to(controls.target, 2, {
            x: 0,
            y: 0,
            z: 0,
            onComplete: function onComplete() {
              TweenMax.resumeAll();
            }
          });
        }
      }

      function onDocumentMouseUp(event) {
        event.preventDefault();
        mouseVector.x = event.clientX / window.innerWidth * 2 - 1;
        mouseVector.y = -(event.clientY / window.innerHeight) * 2 + 1;
        theta = 0;
        clickEnabled = false;
      }
      /*
       * Batch generation of geometry
       *
       * @param  {String} objectType     - String of geometry type identifier.
       * @param  {Number} numObjects       - The total number of generated objects.
       * @return {Void}
       */


      function generateGeometry(objectType, numObjects) {
        //set color
        var applyVertexColors = function applyVertexColors(g, c) {
          g.faces.forEach(function (f) {
            var n = f instanceof THREE.Face3 ? 3 : 4;

            for (var j = 0; j < n; j++) {
              f.vertexColors[j] = c;
            }
          });
        };

        for (var i = 0; i < numObjects; i++) {
          var geometry = void 0;

          if (objectType == "cube") {
            geometry = new THREE.BoxGeometry(1, 1, 1);
          } else if (objectType == "sphere") {
            geometry = new THREE.IcosahedronGeometry(1, 1);
          } else if (objectType == "poly") {
            geometry = new THREE.CylinderGeometry(3, 6, 3, 5, 1);
          }

          var position = new THREE.Vector3();
          position.x = Math.random() * 500;
          position.y = Math.random() * 400;
          position.z = Math.random() * 300;
          var rotation = new THREE.Euler();
          rotation.x = Math.random() * 2 * Math.PI;
          rotation.y = Math.random() * 2 * Math.PI;
          rotation.z = Math.random() * 2 * Math.PI;
          var scale = new THREE.Vector3(); // give the geom's vertices a random color, to be displayed

          var color = new THREE.Color();
          color.setRGB(Math.random(), Math.random(), Math.random());
          applyVertexColors(geometry, color); // Immediately use the texture for material creation

          var defaultMaterial = new THREE.MeshPhongMaterial({
            color: 0xffffff,
            flatShading: true,
            vertexColors: THREE.VertexColors
          });
          displacementSprite = new THREE.Mesh(geometry, defaultMaterial);
          displacementSprite.name = 'nucleus-' + i;
          displacementSprite.position.x = Math.random() * 800 - 400;
          displacementSprite.position.y = Math.random() * 800 - 400;
          displacementSprite.position.z = Math.random() * 800 - 400;
          displacementSprite.rotation.x = Math.random() * 2 * Math.PI;
          displacementSprite.rotation.y = Math.random() * 2 * Math.PI;
          displacementSprite.rotation.z = Math.random() * 2 * Math.PI;
          displacementSprite.scale.x = Math.random() + 5;
          displacementSprite.scale.y = Math.random() + 5;
          displacementSprite.scale.z = Math.random() + 5;
          scene.add(displacementSprite);
          atoms.push(displacementSprite);
        }
      }
      /*
       * Get Object Coordinate, Width and Height From Screen
       * Note: No data may be acquired without delay !!
       *
      * @param  {THREE.Mesh} obj                           - Mesh object.
       * @param  {THREE.PerspectiveCamera} camera           - Mesh object.
      * @param  {Number} rendererWidth                     - Width of renderer.
       * @param  {Number} rendererHeight                    - Height of renderer.
       * @param  {String} type                              - Build type.
       * @return {JSON}
       */

      /* @usage: 
         const screenPos = nestedObjectToScreenXYZAndWH( displacementSprite , camera, renderer.domElement.width, renderer.domElement.height );
        */


      function nestedObjectToScreenXYZAndWH(obj, camera, rendererWidth, rendererHeight) {
        var vector = new THREE.Vector3();
        vector.setFromMatrixPosition(obj.matrixWorld);
        var widthHalf = rendererWidth / 2;
        var heightHalf = rendererHeight / 2;
        var aspect = rendererHeight / rendererWidth;
        vector.project(camera);
        vector.x = vector.x * widthHalf + widthHalf;
        vector.y = -(vector.y * heightHalf) + heightHalf; //compute bounding box after

        var boxInfo = new THREE.Box3().setFromObject(obj).getSize(new THREE.Vector3()); //Change it to fit the width and height of the stage based on the current value

        var ratioFixedNum = 7; //correction

        return {
          position: vector,
          width: (boxInfo.x * ratioFixedNum * aspect).toFixed(2),
          height: (boxInfo.y * ratioFixedNum * aspect).toFixed(2)
        };
      }
      /*
       * Generate random number between two numbers
       *
       * @return {Number}
       */


      function getRandomFloat(min, max) {
        return Math.random() * (max - min) + min;
      }
      /*
       * Returns the degree from radian.
       *
       * @return {Number} rad - Value of radian.
       * @return {Number}
       * @usage: 
       
         angle = rad / ( Math.PI / 180 )  = rad * ( 180/Math.PI );
       */


      function getDegree(rad) {
        return rad / Math.PI * 180;
      }
      /*
       * Returns the radian degree .
       *
       * @return {Number} deg - Value of degree.
       * @return {Number}
       * @usage: 
          
          rad = Math.PI / 180 * 30 ;
       */


      function getRadian(deg) {
        return deg * Math.PI / 180;
      }
      /*
       * Convert three.js scene rotation to polar coordinates
       *
       * @return {Number} deg - Value of degree.
       * @return {Number}
       * @usage: 
       
          x = r * cos（θ）
          y = r * sin（θ）  
       */


      function getPolarCoord(x, y, z) {
        var nx = Math.cos(x) * Math.cos(y) * z,
            nz = Math.cos(x) * Math.sin(y) * z,
            ny = Math.sin(x) * z;
        return new THREE.Vector3(nx, ny, nz);
      } // 
      //-------------------------------------	


      return {
        init: init,
        render: render,
        getRendererCanvasID: function getRendererCanvasID() {
          return rendererCanvasID;
        },
        getScene: function getScene() {
          return scene;
        },
        getCamera: function getCamera() {
          return camera;
        }
      };
    }();

    MainStage.init();
    MainStage.render();
  };

  module.components.documentReady.push(module.THREE_MOUSE_INTERACTION.documentReady);
  return /*#__PURE__*/_createClass(function THREE_MOUSE_INTERACTION() {
    _classCallCheck(this, THREE_MOUSE_INTERACTION);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/simple-3D-mouse-interaction2/js/index.js



/* 
 *************************************
 * <!-- 3D Mouse Interaction with three.js -->
 *************************************
 */

var THREE_MOUSE_INTERACTION2 = function (module, $, window, document) {
  if (window.THREE_MOUSE_INTERACTION2 === null) return false;
  module.THREE_MOUSE_INTERACTION2 = module.THREE_MOUSE_INTERACTION2 || {};
  module.THREE_MOUSE_INTERACTION2.version = '0.0.5';

  module.THREE_MOUSE_INTERACTION2.documentReady = function ($) {
    //Prevent this module from loading in other pages
    if ($('#3D-mouseinteraction2-three-canvas').length == 0 || !Modernizr.webgl) return false;
    var sceneSubjects = []; // Import objects and animations dynamically

    var MainStage = function () {
      var windowWidth = window.innerWidth,
          windowHeight = window.innerHeight;
      var rendererCanvasID = '3D-mouseinteraction2-three-canvas'; // Generate one plane geometries mesh to scene
      //-------------------------------------	

      var camera,
          scene,
          light,
          renderer,
          displacementSprite,
          theta = 0,
          clickEnabled = false; // controls

      var scroller = new CameraScroller({
        direction: "y"
      }); // mouse

      var mouseVector = new THREE.Vector2();
      var raycaster,
          intersects,
          INTERSECTED,
          nucleus,
          atoms = [];

      function init() {
        //camera
        camera = new THREE.PerspectiveCamera(70, windowWidth / windowHeight, 1, 50000);
        camera.position.set(0, 0, 20000); //Scene

        scene = new THREE.Scene(); //HemisphereLight

        scene.add(new THREE.AmbientLight(0x555555));
        light = new THREE.SpotLight(0xffffff, 1.5);
        light.position.set(0, 500, 2000);
        scene.add(light); //WebGL Renderer		

        renderer = new THREE.WebGLRenderer({
          canvas: document.getElementById(rendererCanvasID),
          //canvas
          alpha: true,
          antialias: true
        });
        renderer.setSize(windowWidth, windowHeight);
        scroller.init(renderer.domElement); // Immediately use the texture for material creation

        generateGeometry(500); // Fires when the window changes

        window.addEventListener('resize', onWindowResize, false); // When the mouse moves, call the given function

        raycaster = new THREE.Raycaster();
        document.addEventListener('mousemove', onDocumentMouseMove, false);
        document.getElementById(rendererCanvasID).addEventListener('click', onDocumentMouseDown, false);
        document.addEventListener('mouseup', onDocumentMouseUp, false);
      }

      function render() {
        requestAnimationFrame(render); //To set a background color.

        renderer.setClearColor(0x000000); //update controls

        camera.position.y = scroller.getScrollPosY() * 10000; //Mouse interactions

        raycaster.setFromCamera(mouseVector, camera);
        intersects = raycaster.intersectObjects(atoms); //intersects = raycaster.intersectObjects( scene.children );

        if (intersects.length > 0) {
          if (INTERSECTED != intersects[0].object) {
            // restore previous intersection object (if it exists) to its original color
            if (INTERSECTED) INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex);
            INTERSECTED = intersects[0].object;
            INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
            INTERSECTED.material.emissive.setHex(0xff0000);
          }
        } else {
          // restore previous intersection object (if it exists) to its original color
          if (INTERSECTED) INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex); //by setting current intersection object to "nothing"

          INTERSECTED = null;
        } //push objects

        /*
        @Usage: 
             function CustomObj( scene ) {
                 const elements = new THREE...;
                scene.add( elements );
                 this.update = function( time ) {
                    elements.rotation.y = time*0.003;
                }
            }       
             sceneSubjects.push( new CustomObj( MainStage.getScene() ) );  
        */


        for (var i = 0; i < sceneSubjects.length; i++) {
          sceneSubjects[i].update(clock.getElapsedTime() * 1);
        } //render the scene to display our scene through the camera's eye.


        renderer.render(scene, camera);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function onDocumentMouseMove(event) {
        event.preventDefault();
        mouseVector.x = event.clientX / window.innerWidth * 2 - 1;
        mouseVector.y = -(event.clientY / window.innerHeight) * 2 + 1;
      }

      function onDocumentMouseDown(event) {
        event.preventDefault();
        mouseVector.x = event.clientX / window.innerWidth * 2 - 1;
        mouseVector.y = -(event.clientY / window.innerHeight) * 2 + 1;
        clickEnabled = true; //Mouse interactions

        raycaster.setFromCamera(mouseVector, camera);
        intersects = raycaster.intersectObjects(atoms); //intersects = raycaster.intersectObjects( scene.children );

        if (intersects.length > 0 && intersects[0].object.name.indexOf('nucleus') >= 0) {
          var _obj = intersects[0].object;
          var targetAtomPos = _obj.position;
          console.log(targetAtomPos); // targetAtomPos.tween.pause();

          var destinationPos = targetAtomPos.clone(); // jump to new position
          // y movement via scroller object
          // x and z movement via TWEEN

          scroller.targetPosition = _obj.position.y / 10000;
          var targetPos = {
            x: _obj.position.x,
            y: _obj.position.y,
            z: _obj.position.z + 1100
          };
          TweenMax.to(targetPos, 2, {
            x: destinationPos.x,
            y: destinationPos.y,
            z: destinationPos.z
          });
          TweenMax.to(camera.position, 2, {
            x: destinationPos.x,
            y: destinationPos.y,
            z: destinationPos.z + 1000,
            onUpdate: function onUpdate() {
              camera.up.set(0, 1, 0);
              camera.updateProjectionMatrix();
            },
            onComplete: function onComplete() {
              // get object new coordinates
              var screenData = nestedObjectToScreenXYZAndWH(_obj, camera, renderer.domElement.width, renderer.domElement.height);
              console.log("Current object coordinates: {x: ".concat(screenData.position.x, ", y: ").concat(screenData.position.y, ", z: ").concat(screenData.position.z, " }"));
            }
          });
        } else {
          //restore scroller position
          scroller.targetPosition = 0; //restore camera position

          TweenMax.to(camera.position, 2, {
            x: 0,
            y: 0,
            z: 20000,
            onComplete: function onComplete() {
              TweenMax.resumeAll();
            }
          });
        }
      }

      function onDocumentMouseUp(event) {
        event.preventDefault();
        mouseVector.x = event.clientX / window.innerWidth * 2 - 1;
        mouseVector.y = -(event.clientY / window.innerHeight) * 2 + 1;
        theta = 0;
        clickEnabled = false;
      }
      /*
       * Batch generation of geometry
       *
       * @param  {Number} numObjects       - The total number of generated objects.
       * @return {Void}
       */


      function generateGeometry(numObjects) {
        var geometry = new THREE.Geometry();

        var applyVertexColors = function applyVertexColors(g, c) {
          g.faces.forEach(function (f) {
            var n = f instanceof THREE.Face3 ? 3 : 4;

            for (var j = 0; j < n; j++) {
              f.vertexColors[j] = c;
            }
          });
        };

        for (var i = 0; i < numObjects; i++) {
          var geom = void 0;
          var color = new THREE.Color();
          var position = new THREE.Vector3();
          position.x = -9000 + i % 10 * 2000;
          position.y = -9000 + Math.floor(i % 100 / 10) * 2000;
          position.z = -1000 + Math.floor(i / 100) * 2000;
          var rotation = new THREE.Euler();
          rotation.x = 0;
          rotation.y = 0;
          rotation.z = 0;
          var scale = new THREE.Vector3();
          scale.x = 1200;
          scale.y = 600;
          scale.z = 200;
          geom = new THREE.BoxGeometry(1, 1, 1);
          color.setRGB(0, 0, Math.random() + 0.1); // give the geom's vertices a random color, to be displayed

          applyVertexColors(geom, color); // Immediately use the texture for material creation

          var defaultMaterial = new THREE.MeshPhongMaterial({
            color: 0xffffff,
            flatShading: true,
            vertexColors: THREE.VertexColors
          });
          displacementSprite = new THREE.Mesh(geom, defaultMaterial);
          scene.add(displacementSprite);
          var object = new THREE.Mesh(geom);
          displacementSprite.name = 'nucleus-' + i;
          displacementSprite.position.copy(position);
          displacementSprite.rotation.copy(rotation);
          displacementSprite.scale.copy(scale);
          displacementSprite.updateMatrix();
          scene.add(displacementSprite);
          atoms.push(displacementSprite);
        }
      }
      /*
       * CameraSroller
       * Scrolls the camera vertically (up/down) by mouse, scrollwhell and touch
       * including a velocity based animation
       */


      function CameraScroller(options) {
        this.targetPosition = 0;
        this.targetPositionOnMouseDown = 0;
        this.mouseY = 0;
        this.mouseYOnMouseDown = 0;
        this.scrollPosY = 0;
        this.domElem = undefined;

        this.init = function (domEl) {
          this.domElem = domEl;
          this.domElem.addEventListener('mousedown', this.onDocumentMouseDown, false);
          this.domElem.addEventListener('touchstart', this.onDocumentTouchStart, UixBrowser.supportsPassive ? {
            passive: true
          } : false);
          this.domElem.addEventListener('touchmove', this.onDocumentTouchMove, UixBrowser.supportsPassive ? {
            passive: true
          } : false);
          this.domElem.addEventListener('wheel', this.onDocumentMousewheel, UixBrowser.supportsPassive ? {
            passive: true
          } : false);
        };

        this.onDocumentMouseDown = function (event) {
          event.preventDefault();
          this.domElem.addEventListener('mousemove', this.onDocumentMouseMove, false);
          this.domElem.addEventListener('mouseup', this.onDocumentMouseUp, false);
          this.domElem.addEventListener('mouseout', this.onDocumentMouseOut, false);
          this.mouseYOnMouseDown = event.clientY;
          this.targetPositionOnMouseDown = this.targetPosition;
        }.bind(this);

        this.onDocumentMouseMove = function (event) {
          this.mouseY = event.clientY;
          this.targetPosition = this.targetPositionOnMouseDown + (this.mouseY - this.mouseYOnMouseDown) * 0.02;
        }.bind(this);

        this.onDocumentMouseUp = function (event) {
          this.domElem.removeEventListener('mousemove', this.onDocumentMouseMove, false);
          this.domElem.removeEventListener('mouseup', this.onDocumentMouseUp, false);
          this.domElem.removeEventListener('mouseout', this.onDocumentMouseOut, false);
        }.bind(this);

        this.onDocumentMouseOut = function (event) {
          this.domElem.removeEventListener('mousemove', this.onDocumentMouseMove, false);
          this.domElem.removeEventListener('mouseup', this.onDocumentMouseUp, false);
          this.domElem.removeEventListener('mouseout', this.onDocumentMouseOut, false);
        }.bind(this);

        this.onDocumentTouchStart = function (event) {
          if (event.touches.length == 1) {
            event.preventDefault();
            this.mouseYOnMouseDown = event.touches[0].pageY;
            this.targetPositionOnMouseDown = this.targetPosition;
          }
        }.bind(this);

        this.onDocumentTouchMove = function (event) {
          if (event.touches.length == 1) {
            event.preventDefault();
            this.mouseY = event.touches[0].pageY;
            this.targetPosition = this.targetPositionOnMouseDown + (this.mouseY - this.mouseYOnMouseDown) * 0.02;
          }
        }.bind(this);

        this.onDocumentMousewheel = function (event) {
          this.targetPosition = this.targetPosition + event.wheelDeltaY * 0.005;
        }.bind(this);

        this.getScrollPosY = function () {
          this.scrollPosY = this.scrollPosY + (this.targetPosition - this.scrollPosY) * 0.05; // 0.05=long scroll delay, 0.15=short delay

          return this.scrollPosY;
        }.bind(this);
      }
      /*
       * Get Object Coordinate, Width and Height From Screen
       * Note: No data may be acquired without delay !!
       *
      * @param  {THREE.Mesh} obj                           - Mesh object.
       * @param  {THREE.PerspectiveCamera} camera           - Mesh object.
      * @param  {Number} rendererWidth                     - Width of renderer.
       * @param  {Number} rendererHeight                    - Height of renderer.
       * @param  {String} type                              - Build type.
       * @return {JSON}
       */

      /* @usage: 
         const screenPos = nestedObjectToScreenXYZAndWH( displacementSprite , camera, renderer.domElement.width, renderer.domElement.height );
        */


      function nestedObjectToScreenXYZAndWH(obj, camera, rendererWidth, rendererHeight) {
        var vector = new THREE.Vector3();
        vector.setFromMatrixPosition(obj.matrixWorld);
        var widthHalf = rendererWidth / 2;
        var heightHalf = rendererHeight / 2;
        var aspect = rendererHeight / rendererWidth;
        vector.project(camera);
        vector.x = vector.x * widthHalf + widthHalf;
        vector.y = -(vector.y * heightHalf) + heightHalf; //compute bounding box after

        var boxInfo = new THREE.Box3().setFromObject(obj).getSize(new THREE.Vector3()); //Change it to fit the width and height of the stage based on the current value

        var ratioFixedNum = 7; //correction

        return {
          position: vector,
          width: (boxInfo.x * ratioFixedNum * aspect).toFixed(2),
          height: (boxInfo.y * ratioFixedNum * aspect).toFixed(2)
        };
      }
      /*
       * Generate random number between two numbers
       *
       * @return {Number}
       */


      function getRandomFloat(min, max) {
        return Math.random() * (max - min) + min;
      }
      /*
       * Returns the degree from radian.
       *
       * @return {Number} rad - Value of radian.
       * @return {Number}
       * @usage: 
       
         angle = rad / ( Math.PI / 180 )  = rad * ( 180/Math.PI );
       */


      function getDegree(rad) {
        return rad / Math.PI * 180;
      }
      /*
       * Returns the radian degree .
       *
       * @return {Number} deg - Value of degree.
       * @return {Number}
       * @usage: 
          
          rad = Math.PI / 180 * 30 ;
       */


      function getRadian(deg) {
        return deg * Math.PI / 180;
      }
      /*
       * Convert three.js scene rotation to polar coordinates
       *
       * @return {Number} deg - Value of degree.
       * @return {Number}
       * @usage: 
       
          x = r * cos（θ）
          y = r * sin（θ）  
       */


      function getPolarCoord(x, y, z) {
        var nx = Math.cos(x) * Math.cos(y) * z,
            nz = Math.cos(x) * Math.sin(y) * z,
            ny = Math.sin(x) * z;
        return new THREE.Vector3(nx, ny, nz);
      } // 
      //-------------------------------------	


      return {
        init: init,
        render: render,
        getRendererCanvasID: function getRendererCanvasID() {
          return rendererCanvasID;
        },
        getScene: function getScene() {
          return scene;
        },
        getCamera: function getCamera() {
          return camera;
        }
      };
    }();

    MainStage.init();
    MainStage.render();
  };

  module.components.documentReady.push(module.THREE_MOUSE_INTERACTION2.documentReady);
  return /*#__PURE__*/_createClass(function THREE_MOUSE_INTERACTION2() {
    _classCallCheck(this, THREE_MOUSE_INTERACTION2);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/_third-party-plugins/THREE/esm/modifiers/ExplodeModifier.js
/**
 * Make all faces use unique vertices
 * so that each face can be separated from others
 *
 * @author alteredq / http://alteredqualia.com/
 */
THREE.ExplodeModifier = function () {};

THREE.ExplodeModifier.prototype.modify = function (geometry) {
  var vertices = [];

  for (var i = 0, il = geometry.faces.length; i < il; i++) {
    var n = vertices.length;
    var face = geometry.faces[i];
    var a = face.a;
    var b = face.b;
    var c = face.c;
    var va = geometry.vertices[a];
    var vb = geometry.vertices[b];
    var vc = geometry.vertices[c];
    vertices.push(va.clone());
    vertices.push(vb.clone());
    vertices.push(vc.clone());
    face.a = n;
    face.b = n + 1;
    face.c = n + 2;
  }

  geometry.vertices = vertices;
};

/* harmony default export */ const ExplodeModifier = (THREE.ExplodeModifier);
;// CONCATENATED MODULE: ./src/components/simple-3D-shatter-slider/js/index.js




/* 
 *************************************
 * <!-- 3D Shatter Slider -->
 *************************************
 */

/**
 * module.THREE_SHATTER_SLIDER
 * 
 * @requires ./examples/assets/js/min/three.min.js
 * @requires ./src/plugins/THREE
 */




var THREE_SHATTER_SLIDER = function (module, $, window, document) {
  if (window.THREE_SHATTER_SLIDER === null) return false;
  module.THREE_SHATTER_SLIDER = module.THREE_SHATTER_SLIDER || {};
  module.THREE_SHATTER_SLIDER.version = '0.1.0';

  module.THREE_SHATTER_SLIDER.documentReady = function ($) {
    //Prevent this module from loading in other pages
    if ($('.uix-3d-slider--shatter').length == 0 || !Modernizr.webgl) return false;
    var sceneSubjects = []; // Import objects and animations dynamically

    var MainStage = function () {
      var windowWidth = window.innerWidth,
          windowHeight = window.innerHeight;
      var $sliderWrapper = $('.uix-3d-slider--shatter'),
          //Basic webGL renderers 
      renderLoaderID = 'uix-3d-slider--shatter__loader',
          rendererOuterID = 'uix-3d-slider--shatter__canvas-container',
          rendererCanvasID = 'uix-3d-slider--shatter__canvas';
      var animSpeed = 1000; // Generate one plane geometries mesh to scene
      //-------------------------------------	

      var camera,
          controls,
          scene,
          light,
          renderer,
          material,
          displacementSprite,
          theta = 0;
      var offsetWidth = 475,
          //Set the display width of the objects in the Stage
      offsetHeight = 375,
          //Set the display height of the objects in the Stage
      allSources = [],
          objTotal,
          objLoaded = false;
      var sources = [];
      var isAnimating = false; // constants

      var activeSlider = 0;

      function wrapperInit() {
        $sliderWrapper.each(function () {
          var $this = $(this);
          var $items = $this.find('.uix-3d-slider--shatter__item'),
              $first = $items.first(),
              itemsTotal = $items.length,
              activated = $this.data('activated');

          if ((0,esm_typeof/* default */.Z)(activated) === ( true ? "undefined" : 0) || activated === 0) {
            //Get parameter configuration from the data-* attribute of HTML
            var dataControlsPagination = $this.data('controls-pagination'),
                dataControlsArrows = $this.data('controls-arrows'),
                dataFilterTexture = $this.data('filter-texture'),
                dataDraggable = $this.data('draggable'),
                dataDraggableCursor = $this.data('draggable-cursor'),
                dataSpeed = $this.data('speed'),
                dataCountTotal = $this.data('count-total'),
                dataCountCur = $this.data('count-now');
            if ((0,esm_typeof/* default */.Z)(dataControlsPagination) === ( true ? "undefined" : 0)) dataControlsPagination = '.uix-3d-slider--shatter__pagination';
            if ((0,esm_typeof/* default */.Z)(dataControlsArrows) === ( true ? "undefined" : 0) || dataControlsArrows == false) dataControlsArrows = '.uix-3d-slider--shatter__arrows';
            if ((0,esm_typeof/* default */.Z)(dataLoop) === ( true ? "undefined" : 0)) dataLoop = false;
            if ((0,esm_typeof/* default */.Z)(dataFilterTexture) === ( true ? "undefined" : 0) || !dataFilterTexture || dataFilterTexture == '') dataFilterTexture = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
            if ((0,esm_typeof/* default */.Z)(dataDraggable) === ( true ? "undefined" : 0)) dataDraggable = false;
            if ((0,esm_typeof/* default */.Z)(dataDraggableCursor) === ( true ? "undefined" : 0)) dataDraggableCursor = 'move'; //Autoplay parameters

            var dataAuto = $this.data('auto'),
                dataTiming = $this.data('timing'),
                dataLoop = $this.data('loop');
            if ((0,esm_typeof/* default */.Z)(dataAuto) === ( true ? "undefined" : 0)) dataAuto = false;
            if ((0,esm_typeof/* default */.Z)(dataTiming) === ( true ? "undefined" : 0)) dataTiming = 10000;
            if ((0,esm_typeof/* default */.Z)(dataLoop) === ( true ? "undefined" : 0)) dataLoop = false; //Autoplay times

            var playTimes; //A function called "timer" once every second (like a digital watch).

            $this[0].animatedSlides; //If arrows does not exist on the page, it will be added by default, 
            //and the drag and drop function will be activated.

            if ($(dataControlsArrows).length == 0) {
              $('body').prepend('<div style="display:none;" class="uix-3d-slider--shatter__arrows ' + dataControlsArrows.replace('#', '').replace('.', '') + '"><a href="#" class="uix-3d-slider--shatter__arrows--prev"></a><a href="#" class="uix-3d-slider--shatter__arrows--next"></a></div>');
            } //Prevent bubbling


            if (itemsTotal == 1) {
              $(dataControlsPagination).hide();
              $(dataControlsArrows).hide();
            } //Initialize the controlers classes
            //-------------------------------------	


            $(dataControlsPagination).find('ul > li').first().addClass('is-active'); //Initialize the wrapper width and height
            //-------------------------------------	

            $this.css('height', windowHeight + 'px'); //Load slides to canvas
            //-------------------------------------	

            if ($('#' + rendererCanvasID).length == 0) {
              $this.prepend('<div id="' + rendererOuterID + '" class="uix-3d-slider--shatter__canvas-container"><canvas id="' + rendererCanvasID + '"></canvas></div>');
            } //Get the animation speed
            //-------------------------------------	


            if ((0,esm_typeof/* default */.Z)(dataSpeed) != ( true ? "undefined" : 0) && dataSpeed != false) {
              animSpeed = dataSpeed;
            } //Initialize the first item container
            //-------------------------------------		


            $items.addClass('next');
            $first.addClass('is-active'); //Add identifiers for the first and last items
            //-------------------------------------		

            $items.last().addClass('last');
            $items.first().addClass('first'); //Get all images and videos
            //-------------------------------------		

            $items.each(function () {
              var _item = $(this);

              if (_item.find('video').length > 0) {
                //Returns the dimensions (intrinsic height and width ) of the video
                var video = document.getElementById(_item.find('video').attr('id'));

                var videoURL = _item.find('source:first').attr('src');

                if ((0,esm_typeof/* default */.Z)(videoURL) === ( true ? "undefined" : 0)) videoURL = _item.attr('src');

                if ((0,esm_typeof/* default */.Z)(videoURL) != ( true ? "undefined" : 0)) {
                  sources.push({
                    "url": videoURL,
                    "id": _item.find('video').attr('id'),
                    "type": 'video'
                  });
                }
              } else {
                var imgURL = _item.find('img').attr('src');

                if ((0,esm_typeof/* default */.Z)(imgURL) != ( true ? "undefined" : 0)) {
                  sources.push({
                    "url": imgURL,
                    "id": 'img-' + UixGUID.create(),
                    "type": 'img'
                  });
                }
              }
            }); //Pagination dots 
            //-------------------------------------	

            var _dot = '',
                _dotActive = '';
            _dot += '<ul>';

            for (var i = 0; i < itemsTotal; i++) {
              _dotActive = i == 0 ? 'class="is-active"' : '';
              _dot += '<li ' + _dotActive + ' data-index="' + i + '"><a href="javascript:"></a></li>';
            }

            _dot += '</ul>';
            if ($(dataControlsPagination).html() == '') $(dataControlsPagination).html(_dot); //Fire the slider transtion with buttons

            $(dataControlsPagination).find('ul > li').off('click').on('click', function (e) {
              e.preventDefault(); //Prevent buttons' events from firing multiple times

              var $btn = $(this);
              if ($btn.attr('aria-disabled') == 'true') return false;
              $(dataControlsPagination).find('ul > li').attr('aria-disabled', 'true');
              $(dataControlsPagination).find('ul > li').delay(animSpeed).queue(function (next) {
                $(dataControlsPagination).find('ul > li').attr('aria-disabled', 'false');
                next();
              }); //

              var slideCurId = $(dataControlsPagination).find('ul > li.is-active').index(),
                  slideNextId = $(this).index(); //Determine the direction

              var curDir = 'prev';

              if ($(this).attr('data-index') > slideCurId) {
                curDir = 'next';
              } //Transition Between Slides


              sliderUpdates(slideCurId, slideNextId, curDir, dataCountTotal, dataCountCur, dataControlsPagination, dataControlsArrows, dataLoop); //Pause the auto play event

              clearInterval($this[0].animatedSlides);
            }); //Next/Prev buttons
            //-------------------------------------		

            var _prev = $(dataControlsArrows).find('.uix-3d-slider--shatter__arrows--prev'),
                _next = $(dataControlsArrows).find('.uix-3d-slider--shatter__arrows--next');

            $(dataControlsArrows).find('a').attr('href', 'javascript:');
            $(dataControlsArrows).find('a').removeClass('is-disabled');

            if (!dataLoop) {
              _prev.addClass('is-disabled');
            }

            _prev.off('click').on('click', function (e) {
              e.preventDefault(); //Prevent buttons' events from firing multiple times

              if ($(this).attr('aria-disabled') == 'true') return false;
              $(this).attr('aria-disabled', 'true');
              $(this).delay(animSpeed).queue(function (next) {
                $(this).attr('aria-disabled', 'false');
                next();
              }); //

              var slideCurId = $items.filter('.is-active').index(),
                  slideNextId = parseFloat($items.filter('.is-active').index()) - 1; //Transition Between Slides

              sliderUpdates(slideCurId, slideNextId, 'prev', dataCountTotal, dataCountCur, dataControlsPagination, dataControlsArrows, dataLoop); //Pause the auto play event

              clearInterval($this[0].animatedSlides);
            });

            _next.off('click').on('click', function (e) {
              e.preventDefault(); //Prevent buttons' events from firing multiple times

              if ($(this).attr('aria-disabled') == 'true') return false;
              $(this).attr('aria-disabled', 'true');
              $(this).delay(animSpeed).queue(function (next) {
                $(this).attr('aria-disabled', 'false');
                next();
              }); //

              var slideCurId = $items.filter('.is-active').index(),
                  slideNextId = parseFloat($items.filter('.is-active').index()) + 1; //Transition Between Slides

              sliderUpdates(slideCurId, slideNextId, 'next', dataCountTotal, dataCountCur, dataControlsPagination, dataControlsArrows, dataLoop); //Pause the auto play event

              clearInterval($this[0].animatedSlides);
            }); //Autoplay Slider
            //-------------------------------------		


            if (dataAuto && !isNaN(parseFloat(dataTiming)) && isFinite(dataTiming)) {
              sliderAutoPlay(playTimes, dataTiming, dataLoop, $this, dataCountTotal, dataCountCur, dataControlsPagination, dataControlsArrows);

              var autoplayEnter = function autoplayEnter() {
                clearInterval($this[0].animatedSlides);
              };

              var autoplayLeave = function autoplayLeave() {
                sliderAutoPlay(playTimes, dataTiming, dataLoop, $this, dataCountTotal, dataCountCur, dataControlsPagination, dataControlsArrows);
              }; // Do not use the `off()` method, otherwise it will cause the second mouseenter to be invalid


              $this.on('mouseenter', autoplayEnter);
              $this.on('mouseleave', autoplayLeave); // To determine if it is a touch screen.

              if (Modernizr.touchevents) {
                $this.on('pointerenter', autoplayEnter);
                $this.on('pointerleave', autoplayLeave);
              }
            } //Prevents front-end javascripts that are activated with AJAX to repeat loading.


            $this.data('activated', 1);
          } //endif activated

        }); // end each				
      }

      function init() {
        //Core 3D stage begin
        //-------------------------------------		
        //camera
        camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 10, 2500); // FlyCamera // FlyControls

        camera.movementSpeed = 100.0;
        camera.rollSpeed = 0.5;
        camera.position.y = 60;
        camera.position.z = 500; //Scene

        scene = new THREE.Scene(); //HemisphereLight

        scene.add(new THREE.AmbientLight(0x555555));
        light = new THREE.SpotLight(0xffffff, 1.5);
        light.position.set(0, 0, 2000);
        scene.add(light); //WebGL Renderer	
        // create a render and set the size

        renderer = new THREE.WebGLRenderer({
          canvas: document.getElementById(rendererCanvasID),
          //canvas
          alpha: true,
          antialias: true
        });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight); //controls

        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.autoRotate = false;
        controls.autoRotateSpeed = 0.5;
        controls.rotateSpeed = 0.5;
        controls.zoomSpeed = 1.2;
        controls.panSpeed = 0.8;
        controls.enableZoom = false;
        controls.target.set(0, 0, 0);
        controls.update(); //A loader for loading all images from array.

        var loader = new THREE.TextureLoader();
        loader.crossOrigin = 'anonymous'; //Preload

        objTotal = sources.length;
        sources.forEach(function (element, index) {
          if (element.type == 'img') {
            loader.load( // resource URL
            element.url, // onLoad callback
            function (texture) {
              loadSource(texture, index, offsetWidth, offsetHeight, objTotal, $('#' + renderLoaderID));
            }, // onProgress callback currently not supported
            undefined, // onError callback
            function (err) {
              console.error('An error happened.');
            });
          } else {
            var texture = new THREE.VideoTexture(document.getElementById(element.id));
            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter;
            texture.format = THREE.RGBFormat; // pause the video

            texture.image.autoplay = true;
            texture.image.loop = true;
            texture.image.currentTime = 0;
            texture.image.muted = false;
            texture.image.pause();
            loadSource(texture, index, offsetWidth, offsetHeight, objTotal, $('#' + renderLoaderID));
          }
        }); // Fires when the window changes

        window.addEventListener('resize', onWindowResize, false);
      }

      function render() {
        requestAnimationFrame(render);
        theta += 0.1; //To set a background color.
        //renderer.setClearColor( 0x000000 );	
        //Animating Three.js vertices

        allSources.forEach(function (element, index) {
          element.geometry.verticesNeedUpdate = true;
        }); //check all images loaded

        if ((0,esm_typeof/* default */.Z)(allSources) != ( true ? "undefined" : 0)) {
          if (!objLoaded && allSources.length === objTotal) {
            allSources.forEach(function (element, index) {
              scene.add(element); //if the first object is video and play it

              if (index == 0) {
                var videoObCur = element.material.map.image;

                if (videoObCur.localName == 'video') {
                  videoObCur.autoplay = true;
                  videoObCur.currentTime = 0;
                  videoObCur.muted = true;
                  videoObCur.play();
                }
              } //initialize all objects


              if (index > 0) {
                var fragment = element.geometry.vertices;

                for (var i = 0; i < fragment.length; i++) {
                  var pos = new THREE.Vector3();

                  var _final = Math.random();

                  pos.x = Math.random();
                  pos.y = Math.random() * (50 * i);
                  pos.z = Math.random() * -300;
                  fragment[i].x = pos.x;
                  fragment[i].y = pos.y;
                  fragment[i].z = pos.z;
                }
              }

              console.log(element);
            });
            objLoaded = true;
          }
        } //update camera and controls


        controls.update(); //push objects

        /*
        @Usage: 
             function CustomObj( scene ) {
                 const elements = new THREE...;
                scene.add( elements );
                 this.update = function( time ) {
                    elements.rotation.y = time*0.003;
                }
            }       
             sceneSubjects.push( new CustomObj( MainStage.getScene() ) );  
        */

        for (var i = 0; i < sceneSubjects.length; i++) {
          sceneSubjects[i].update(clock.getElapsedTime() * 1);
        } //render the scene to display our scene through the camera's eye.


        renderer.render(scene, camera);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }
      /*
       * Load Source
       *
       * @param  {Three.MeshBasicMaterial.map} texture         - Returns a new texture object which can directly be used for material creation.
       * @param  {Number} index           - Index of image or video.
       * @param  {Number} w               - The width of an image or video, in pixels. 
       * @param  {Number} h               - The height of an image or video, in pixels. 
       * @param  {Number} total           - Total number of preload images or video.
       * @param  {Element|String} loading         - Progress bar display control.
       * @return {Void}
       */


      function loadSource(texture, index, w, h, total, loading) {
        var imgW = w,
            imgH = h; // Immediately use the texture for material creation
        // Create a texture loader so we can load our image file

        material = new THREE.MeshBasicMaterial({
          map: texture
        });
        var geometryExplode = new THREE.BoxGeometry(imgW, imgH, 13),
            displacementSprite = new THREE.Mesh(geometryExplode, material);
        displacementSprite.minFilter = THREE.LinearFilter;
        displacementSprite.overdraw = true;
        displacementSprite.position.set(0, 0, 0);
        geometryExplode.center(); // Shattering Images

        var explodeModifier = new THREE.ExplodeModifier();
        explodeModifier.modify(geometryExplode); // add some additional vars to the
        // fragments to ensure we can do physics
        // and so on

        for (var i = 0; i < geometryExplode.vertices.length; i++) {
          var fragment = geometryExplode.vertices[i];
          fragment.origPos = {
            x: fragment.x,
            y: fragment.y,
            z: fragment.z
          };
        }

        allSources.push(displacementSprite); //loading

        TweenMax.to(loading, 0.5, {
          width: Math.round(100 * allSources.length / total) + '%',
          onComplete: function onComplete() {
            if ($(this.target).width() >= windowWidth - 50) {
              TweenMax.to(this.target, 0.5, {
                alpha: 0
              });
            }
          }
        });
      }
      /*
      * Trigger slider autoplay
      *
      * @param  {Function} playTimes            - Number of times.
      * @param  {Number} timing                 - Autoplay interval.
      * @param  {Boolean} loop                  - Gives the slider a seamless infinite loop.
      * @param  {Element} slider                 - Selector of the slider .
      * @param  {String} countTotalID           - Total number ID or class of counter.
      * @param  {String} countCurID             - Current number ID or class of counter.
      * @param  {String} paginationID           - Navigation ID for paging control of each slide.
      * @param  {String} arrowsID               - Previous/Next arrow navigation ID.
      * @return {Void}                          - The constructor.
      */


      function sliderAutoPlay(playTimes, timing, loop, slider, countTotalID, countCurID, paginationID, arrowsID) {
        var items = slider.find('.uix-3d-slider--shatter__item'),
            total = items.length;
        slider[0].animatedSlides = setInterval(function () {
          playTimes = parseFloat(items.filter('.is-active').index());
          playTimes++;

          if (!loop) {
            if (playTimes < total && playTimes >= 0) {
              var slideCurId = items.filter('.is-active').index(),
                  slideNextId = playTimes;
              sliderUpdates(slideCurId, slideNextId, 'next', countTotalID, countCurID, paginationID, arrowsID, loop);
            }
          } else {
            if (playTimes == total) playTimes = 0;
            if (playTimes < 0) playTimes = total - 1;

            var _slideCurId = items.filter('.is-active').index(),
                _slideNextId = playTimes; //Prevent problems with styles when switching in positive order


            if (playTimes == 0) {
              sliderUpdates(_slideCurId, _slideNextId, 'prev', countTotalID, countCurID, paginationID, arrowsID, loop);
            } else {
              sliderUpdates(_slideCurId, _slideNextId, 'next', countTotalID, countCurID, paginationID, arrowsID, loop);
            }
          }
        }, timing);
      }
      /*
       *  Transition Between Slides
       *
       * @param  {Number} slideCurId             - Index of current slider.
       * @param  {Number} slideNextId            - Index of next slider.
       * @param  {String} dir                    - Switching direction indicator.	 
                * @param  {String} countTotalID           - Total number ID or class of counter.
                * @param  {String} countCurID             - Current number ID or class of counter.
                * @param  {String} paginationID           - Navigation ID for paging control of each slide.
                * @param  {String} arrowsID               - Previous/Next arrow navigation ID.
                * @param  {Boolean} loop                  - Gives the slider a seamless infinite loop.
       * @return {Void}
       */


      function sliderUpdates(slideCurId, slideNextId, dir, countTotalID, countCurID, paginationID, arrowsID, loop) {
        var $items = $sliderWrapper.find('.uix-3d-slider--shatter__item'),
            total = $items.length; //Prevent bubbling

        if (total == 1) {
          $(paginationID).hide();
          $(arrowsID).hide();
          return false;
        }

        if (!isAnimating) {
          isAnimating = true; //Transition Interception
          //-------------------------------------

          if (loop) {
            if (slideCurId > total - 1) slideCurId = 0;
            if (slideCurId < 0) slideCurId = total - 1; //--

            if (slideNextId < 0) slideNextId = total - 1;
            if (slideNextId > total - 1) slideNextId = 0;
          } else {
            if (slideCurId > total - 1) slideCurId = total - 1;
            if (slideCurId < 0) slideCurId = 0; //--

            if (slideNextId < 0) slideNextId = 0;
            if (slideNextId > total - 1) slideNextId = total - 1;
          } //Get previous and next index of item
          //-------------------------------------


          var $current = $sliderWrapper.find('.uix-3d-slider--shatter__item').eq(slideCurId);
          var $next = $sliderWrapper.find('.uix-3d-slider--shatter__item').eq(slideNextId);
          console.log('Current: ' + slideCurId + ' | Next: ' + slideNextId); //Determine the direction and add class to switching direction indicator.
          //-------------------------------------

          var dirIndicatorClass = '';
          if (dir == 'prev') dirIndicatorClass = 'prev';
          if (dir == 'next') dirIndicatorClass = 'next'; //Add transition class to each item
          //-------------------------------------	

          $items.removeClass('is-active leave prev next').addClass(dirIndicatorClass);
          $current.addClass('leave');
          $next.addClass('is-active'); //Add transition class to Controls Pagination
          //-------------------------------------

          $(paginationID).find('ul > li').removeClass('is-active leave prev next').addClass(dirIndicatorClass);
          $(paginationID).find('ul > li').eq(slideCurId).addClass('leave');
          $(paginationID).find('ul > li').eq(slideNextId).addClass('is-active'); //Add transition class to Arrows
          //-------------------------------------		

          if (!loop) {
            $(arrowsID).find('a').removeClass('is-disabled');
            if (slideNextId == total - 1) $(arrowsID).find('.uix-3d-slider--shatter__arrows--next').addClass('is-disabled');
            if (slideNextId == 0) $(arrowsID).find('.uix-3d-slider--shatter__arrows--prev').addClass('is-disabled');
          } //Display counter
          //-------------------------------------


          $(countTotalID).text(total);
          $(countCurID).text(parseFloat(slideCurId) + 1); //Pause all videos
          //-------------------------------------
          // pause all videos

          allSources.forEach(function (element, index) {
            var videoOb = element.material.map.image;

            if (videoOb.localName == 'video') {
              videoOb.autoplay = false;
              videoOb.currentTime = 0;
              videoOb.muted = true;
              videoOb.pause();
            }
          }); //Fire the next object
          //-------------------------------------

          activeSlider = slideNextId;

          if ((0,esm_typeof/* default */.Z)(allSources[slideNextId]) != ( true ? "undefined" : 0)) {
            var fragment = allSources[slideNextId].geometry.vertices;

            for (var i = 0; i < fragment.length; i++) {
              TweenMax.to(fragment[i], 2, {
                x: fragment[i].origPos.x,
                y: fragment[i].origPos.y,
                z: fragment[i].origPos.z,
                ease: "Expo.easeInOut"
              });
            }
          } // play the video


          var videoObCur = allSources[slideNextId].material.map.image;

          if (videoObCur.localName == 'video') {
            videoObCur.autoplay = true;
            videoObCur.currentTime = 0;
            videoObCur.muted = false;
            videoObCur.play();
          } //Fire the current object
          //-------------------------------------


          if ((0,esm_typeof/* default */.Z)(allSources[slideCurId]) != ( true ? "undefined" : 0)) {
            var _fragment = allSources[slideCurId].geometry.vertices;

            for (var _i = 0; _i < _fragment.length; _i++) {
              var pos = new THREE.Vector3();

              var _final2 = Math.random();

              pos.x = Math.random();
              pos.y = Math.random() * (50 * _i);
              pos.z = Math.random() * -300;
              TweenMax.to(_fragment[_i], 2, {
                x: pos.x,
                y: pos.y,
                z: pos.z,
                ease: "Expo.easeInOut",
                onComplete: function onComplete() {
                  //reset the trigger
                  isAnimating = false;
                }
              });
            }
          }
        } // end isAnimating

      } // 
      //-------------------------------------	


      return {
        init: init,
        render: render,
        wrapperInit: wrapperInit,
        getRendererCanvasID: function getRendererCanvasID() {
          return rendererCanvasID;
        },
        getScene: function getScene() {
          return scene;
        },
        getCamera: function getCamera() {
          return camera;
        }
      };
    }();

    MainStage.wrapperInit();
    MainStage.init();
    MainStage.render();
  };

  module.components.documentReady.push(module.THREE_SHATTER_SLIDER.documentReady);
  return /*#__PURE__*/_createClass(function THREE_SHATTER_SLIDER() {
    _classCallCheck(this, THREE_SHATTER_SLIDER);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/simple-3D-explosive-particle-slider/js/index.js




/* 
 *************************************
 * <!-- 3D Explosive Particle Slider -->
 *************************************
 */



var THREE_EXP_PARTICLE_SLIDER = function (module, $, window, document) {
  if (window.THREE_EXP_PARTICLE_SLIDER === null) return false;
  module.THREE_EXP_PARTICLE_SLIDER = module.THREE_EXP_PARTICLE_SLIDER || {};
  module.THREE_EXP_PARTICLE_SLIDER.version = '0.1.0';

  module.THREE_EXP_PARTICLE_SLIDER.documentReady = function ($) {
    //Prevent this module from loading in other pages
    if ($('.uix-3d-slider--expParticle').length == 0 || !Modernizr.webgl) return false;
    var sceneSubjects = []; // Import objects and animations dynamically

    var MainStage = function () {
      var windowWidth = window.innerWidth,
          windowHeight = window.innerHeight;
      var $sliderWrapper = $('.uix-3d-slider--expParticle'),
          //Basic webGL renderers 
      renderLoaderID = 'uix-3d-slider--expParticle__loader',
          rendererOuterID = 'uix-3d-slider--expParticle__canvas-container',
          rendererCanvasID = 'uix-3d-slider--expParticle__canvas';
      var animSpeed = 1000; // Generate one plane geometries mesh to scene
      //-------------------------------------	

      var camera,
          controls,
          scene,
          light,
          renderer,
          material,
          displacementSprite,
          clock = new THREE.Clock();
      var offsetWidth = 475,
          //Set the display width of the objects in the Stage
      offsetHeight = 375,
          //Set the display height of the objects in the Stage
      allSources = [],
          objTotal,
          objLoaded = false;
      var sources = [];
      var isAnimating = false; // constants

      var activeSlider = 0;
      var cube_count,
          meshes = [],
          materials = [],
          xgrid = 25,
          ygrid = 15;

      function wrapperInit() {
        $sliderWrapper.each(function () {
          var $this = $(this);
          var $items = $this.find('.uix-3d-slider--expParticle__item'),
              $first = $items.first(),
              itemsTotal = $items.length,
              activated = $this.data('activated');

          if ((0,esm_typeof/* default */.Z)(activated) === ( true ? "undefined" : 0) || activated === 0) {
            //Get parameter configuration from the data-* attribute of HTML
            var dataControlsPagination = $this.data('controls-pagination'),
                dataControlsArrows = $this.data('controls-arrows'),
                dataFilterTexture = $this.data('filter-texture'),
                dataDraggable = $this.data('draggable'),
                dataDraggableCursor = $this.data('draggable-cursor'),
                dataSpeed = $this.data('speed'),
                dataCountTotal = $this.data('count-total'),
                dataCountCur = $this.data('count-now');
            if ((0,esm_typeof/* default */.Z)(dataControlsPagination) === ( true ? "undefined" : 0)) dataControlsPagination = '.uix-3d-slider--expParticle__pagination';
            if ((0,esm_typeof/* default */.Z)(dataControlsArrows) === ( true ? "undefined" : 0) || dataControlsArrows == false) dataControlsArrows = '.uix-3d-slider--expParticle__arrows';
            if ((0,esm_typeof/* default */.Z)(dataFilterTexture) === ( true ? "undefined" : 0) || !dataFilterTexture || dataFilterTexture == '') dataFilterTexture = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
            if ((0,esm_typeof/* default */.Z)(dataDraggable) === ( true ? "undefined" : 0)) dataDraggable = false;
            if ((0,esm_typeof/* default */.Z)(dataDraggableCursor) === ( true ? "undefined" : 0)) dataDraggableCursor = 'move';
            if ((0,esm_typeof/* default */.Z)(dataCountTotal) === ( true ? "undefined" : 0)) dataCountTotal = 'p.count em.count';
            if ((0,esm_typeof/* default */.Z)(dataCountCur) === ( true ? "undefined" : 0)) dataCountCur = 'p.count em.current'; //Autoplay parameters

            var dataAuto = $this.data('auto'),
                dataTiming = $this.data('timing'),
                dataLoop = $this.data('loop');
            if ((0,esm_typeof/* default */.Z)(dataAuto) === ( true ? "undefined" : 0)) dataAuto = false;
            if ((0,esm_typeof/* default */.Z)(dataTiming) === ( true ? "undefined" : 0)) dataTiming = 10000;
            if ((0,esm_typeof/* default */.Z)(dataLoop) === ( true ? "undefined" : 0)) dataLoop = false; //Autoplay times

            var playTimes; //A function called "timer" once every second (like a digital watch).

            $this[0].animatedSlides; //If arrows does not exist on the page, it will be added by default, 
            //and the drag and drop function will be activated.

            if ($(dataControlsArrows).length == 0) {
              $('body').prepend('<div style="display:none;" class="uix-3d-slider--expParticle__arrows ' + dataControlsArrows.replace('#', '').replace('.', '') + '"><a href="#" class="uix-3d-slider--expParticle__arrows--prev"></a><a href="#" class="uix-3d-slider--expParticle__arrows--next"></a></div>');
            } //Prevent bubbling


            if (itemsTotal == 1) {
              $(dataControlsPagination).hide();
              $(dataControlsArrows).hide();
            } //Initialize the controlers classes
            //-------------------------------------	


            $(dataControlsPagination).find('ul > li').first().addClass('is-active'); //Initialize the wrapper width and height
            //-------------------------------------	

            $this.css('height', windowHeight + 'px'); //Load slides to canvas
            //-------------------------------------	

            if ($('#' + rendererCanvasID).length == 0) {
              $this.prepend('<div id="' + rendererOuterID + '" class="uix-3d-slider--expParticle__canvas-container"><canvas id="' + rendererCanvasID + '"></canvas></div>');
            } //Get the animation speed
            //-------------------------------------	


            if ((0,esm_typeof/* default */.Z)(dataSpeed) != ( true ? "undefined" : 0) && dataSpeed != false) {
              animSpeed = dataSpeed;
            } //Initialize the first item container
            //-------------------------------------		


            $items.addClass('next');
            $first.addClass('is-active'); //Add identifiers for the first and last items
            //-------------------------------------		

            $items.last().addClass('last');
            $items.first().addClass('first'); //Get all images and videos
            //-------------------------------------		

            $items.each(function () {
              var _item = $(this);

              if (_item.find('video').length > 0) {
                //Returns the dimensions (intrinsic height and width ) of the video
                var video = document.getElementById(_item.find('video').attr('id'));

                var videoURL = _item.find('source:first').attr('src');

                if ((0,esm_typeof/* default */.Z)(videoURL) === ( true ? "undefined" : 0)) videoURL = _item.attr('src');

                if ((0,esm_typeof/* default */.Z)(videoURL) != ( true ? "undefined" : 0)) {
                  sources.push({
                    "url": videoURL,
                    "id": _item.find('video').attr('id'),
                    "type": 'video'
                  });
                }
              } else {
                var imgURL = _item.find('img').attr('src');

                if ((0,esm_typeof/* default */.Z)(imgURL) != ( true ? "undefined" : 0)) {
                  sources.push({
                    "url": imgURL,
                    "id": 'img-' + UixGUID.create(),
                    "type": 'img'
                  });
                }
              }
            }); //Pagination dots 
            //-------------------------------------	

            var _dot = '',
                _dotActive = '';
            _dot += '<ul>';

            for (var i = 0; i < itemsTotal; i++) {
              _dotActive = i == 0 ? 'class="is-active"' : '';
              _dot += '<li ' + _dotActive + ' data-index="' + i + '"><a href="javascript:"></a></li>';
            }

            _dot += '</ul>';
            if ($(dataControlsPagination).html() == '') $(dataControlsPagination).html(_dot); //Fire the slider transtion with buttons

            $(dataControlsPagination).find('ul > li').off('click').on('click', function (e) {
              e.preventDefault(); //Prevent buttons' events from firing multiple times

              var $btn = $(this);
              if ($btn.attr('aria-disabled') == 'true') return false;
              $(dataControlsPagination).find('ul > li').attr('aria-disabled', 'true');
              $(dataControlsPagination).find('ul > li').delay(animSpeed).queue(function (next) {
                $(dataControlsPagination).find('ul > li').attr('aria-disabled', 'false');
                next();
              }); //

              var slideCurId = $(dataControlsPagination).find('ul > li.is-active').index(),
                  slideNextId = $(this).index(); //Determine the direction

              var curDir = 'prev';

              if ($(this).attr('data-index') > slideCurId) {
                curDir = 'next';
              } //Transition Between Slides


              sliderUpdates(slideCurId, slideNextId, curDir, dataCountTotal, dataCountCur, dataControlsPagination, dataControlsArrows, dataLoop); //Pause the auto play event

              clearInterval($this[0].animatedSlides);
            }); //Next/Prev buttons
            //-------------------------------------		

            var _prev = $(dataControlsArrows).find('.uix-3d-slider--expParticle__arrows--prev'),
                _next = $(dataControlsArrows).find('.uix-3d-slider--expParticle__arrows--next');

            $(dataControlsArrows).find('a').attr('href', 'javascript:');
            $(dataControlsArrows).find('a').removeClass('is-disabled');

            if (!dataLoop) {
              _prev.addClass('is-disabled');
            }

            _prev.off('click').on('click', function (e) {
              e.preventDefault(); //Prevent buttons' events from firing multiple times

              if ($(this).attr('aria-disabled') == 'true') return false;
              $(this).attr('aria-disabled', 'true');
              $(this).delay(animSpeed).queue(function (next) {
                $(this).attr('aria-disabled', 'false');
                next();
              }); //

              var slideCurId = $items.filter('.is-active').index(),
                  slideNextId = parseFloat($items.filter('.is-active').index()) - 1; //Transition Between Slides

              sliderUpdates(slideCurId, slideNextId, 'prev', dataCountTotal, dataCountCur, dataControlsPagination, dataControlsArrows, dataLoop); //Pause the auto play event

              clearInterval($this[0].animatedSlides);
            });

            _next.off('click').on('click', function (e) {
              e.preventDefault(); //Prevent buttons' events from firing multiple times

              if ($(this).attr('aria-disabled') == 'true') return false;
              $(this).attr('aria-disabled', 'true');
              $(this).delay(animSpeed).queue(function (next) {
                $(this).attr('aria-disabled', 'false');
                next();
              }); //

              var slideCurId = $items.filter('.is-active').index(),
                  slideNextId = parseFloat($items.filter('.is-active').index()) + 1; //Transition Between Slides

              sliderUpdates(slideCurId, slideNextId, 'next', dataCountTotal, dataCountCur, dataControlsPagination, dataControlsArrows, dataLoop); //Pause the auto play event

              clearInterval($this[0].animatedSlides);
            }); //Autoplay Slider
            //-------------------------------------		


            if (dataAuto && !isNaN(parseFloat(dataTiming)) && isFinite(dataTiming)) {
              sliderAutoPlay(playTimes, dataTiming, dataLoop, $this, dataCountTotal, dataCountCur, dataControlsPagination, dataControlsArrows);

              var autoplayEnter = function autoplayEnter() {
                clearInterval($this[0].animatedSlides);
              };

              var autoplayLeave = function autoplayLeave() {
                sliderAutoPlay(playTimes, dataTiming, dataLoop, $this, dataCountTotal, dataCountCur, dataControlsPagination, dataControlsArrows);
              }; // Do not use the `off()` method, otherwise it will cause the second mouseenter to be invalid


              $this.on('mouseenter', autoplayEnter);
              $this.on('mouseleave', autoplayLeave); // To determine if it is a touch screen.

              if (Modernizr.touchevents) {
                $this.on('pointerenter', autoplayEnter);
                $this.on('pointerleave', autoplayLeave);
              }
            } //Prevents front-end javascripts that are activated with AJAX to repeat loading.


            $this.data('activated', 1);
          } //endif activated

        }); // end each				
      }

      function init() {
        //Core 3D stage begin
        //-------------------------------------		
        //camera
        camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 10, 2500); // FlyCamera // FlyControls

        camera.movementSpeed = 100.0;
        camera.rollSpeed = 0.5;
        camera.position.y = 60;
        camera.position.z = 500; //Scene

        scene = new THREE.Scene(); //HemisphereLight

        scene.add(new THREE.AmbientLight(0x555555));
        light = new THREE.SpotLight(0xffffff, 1.5);
        light.position.set(0, 0, 2000);
        scene.add(light); //WebGL Renderer	
        // create a render and set the size

        renderer = new THREE.WebGLRenderer({
          canvas: document.getElementById(rendererCanvasID),
          //canvas
          alpha: true,
          antialias: true
        });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight); //controls

        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.autoRotate = false;
        controls.autoRotateSpeed = 0.5;
        controls.rotateSpeed = 0.5;
        controls.zoomSpeed = 1.2;
        controls.panSpeed = 0.8;
        controls.enableZoom = false;
        controls.target.set(0, 0, 0);
        controls.update(); //A loader for loading all images from array.

        var loader = new THREE.TextureLoader();
        loader.crossOrigin = 'anonymous'; //Preload

        objTotal = sources.length;
        sources.forEach(function (element, index) {
          if (element.type == 'img') {
            loader.load( // resource URL
            element.url, // onLoad callback
            function (texture) {
              loadSource(texture, index, offsetWidth, offsetHeight, objTotal, $('#' + renderLoaderID));
            }, // onProgress callback currently not supported
            undefined, // onError callback
            function (err) {
              console.error('An error happened.');
            });
          } else {
            var texture = new THREE.VideoTexture(document.getElementById(element.id));
            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter;
            texture.format = THREE.RGBFormat; // pause the video

            texture.image.autoplay = true;
            texture.image.loop = true;
            texture.image.currentTime = 0;
            texture.image.muted = true;
            texture.image.play();
            loadSource(texture, index, offsetWidth, offsetHeight, objTotal, $('#' + renderLoaderID));
          }
        }); // Fires when the window changes

        window.addEventListener('resize', onWindowResize, false);
      }

      function render() {
        requestAnimationFrame(render);
        var elapsed = clock.getElapsedTime(); //To set a background color.
        //renderer.setClearColor( 0x000000 );	
        //Display the destination object

        if ((0,esm_typeof/* default */.Z)(allSources[activeSlider]) != ( true ? "undefined" : 0)) {
          var objects = allSources[activeSlider].children;
          var speed = Math.random() * .0002;

          for (var i = 0; i < objects.length; i++) {
            for (var j = 0; j < objects[i].parent.children.length; j++) {
              var obj = objects[i].parent.children[j];
              obj.position.x += (obj.origPos.x - obj.position.x) * speed;
              obj.position.y += (obj.origPos.y - obj.position.y) * speed;
              obj.position.z += (obj.origPos.z - obj.position.z) * speed;
            }
          }
        } //Hide inactive objects


        allSources.forEach(function (element, index) {
          if (index != activeSlider) {
            var _objects = element.children;

            var _speed = Math.random() * .00005;

            for (var _i = 0; _i < _objects.length; _i++) {
              for (var _j = 0; _j < _objects[_i].parent.children.length; _j++) {
                var _obj = _objects[_i].parent.children[_j];
                _obj.position.x += (_obj.targetPos.x - _obj.position.x) * _speed;
                _obj.position.y += (_obj.targetPos.y - _obj.position.y) * _speed;
                _obj.position.z += (_obj.targetPos.z - _obj.position.z) * _speed;
              }
            }
          }
        }); //check all images loaded

        if ((0,esm_typeof/* default */.Z)(allSources) != ( true ? "undefined" : 0)) {
          if (!objLoaded && allSources.length === objTotal) {
            allSources.forEach(function (element, index) {
              scene.add(element);
              console.log(element);
            });
            objLoaded = true;
          }
        } //update camera and controls


        controls.update(); //push objects

        /*
        @Usage: 
             function CustomObj( scene ) {
                 const elements = new THREE...;
                scene.add( elements );
                 this.update = function( time ) {
                    elements.rotation.y = time*0.003;
                }
            }       
             sceneSubjects.push( new CustomObj( MainStage.getScene() ) );  
        */

        for (var _i2 = 0; _i2 < sceneSubjects.length; _i2++) {
          sceneSubjects[_i2].update(clock.getElapsedTime() * 1);
        } //render the scene to display our scene through the camera's eye.


        renderer.render(scene, camera);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }
      /*
       * Load Source
       *
       * @param  {Three.MeshBasicMaterial.map} texture         - Returns a new texture object which can directly be used for material creation.
       * @param  {Number} index           - Index of image or video.
       * @param  {Number} w               - The width of an image or video, in pixels. 
       * @param  {Number} h               - The height of an image or video, in pixels. 
       * @param  {Number} total           - Total number of preload images or video.
       * @param  {Element|String} loading         - Progress bar display control.
       * @return {Void}
       */


      function loadSource(texture, index, w, h, total, loading) {
        var imgW = w,
            imgH = h; //

        var group = new THREE.Object3D();
        var i, j, ux, uy, ox, oy, geometry, xsize, ysize;
        ux = 1 / xgrid;
        uy = 1 / ygrid;
        xsize = imgW / xgrid;
        ysize = imgH / ygrid;
        cube_count = 0;

        for (i = 0; i < xgrid; i++) {
          for (j = 0; j < ygrid; j++) {
            ox = i;
            oy = j;
            geometry = new THREE.BoxBufferGeometry(xsize, ysize, xsize);
            changeUVS(geometry, ux, uy, ox, oy);
            materials[cube_count] = new THREE.MeshBasicMaterial({
              map: texture
            });
            material = materials[cube_count];
            displacementSprite = new THREE.Mesh(geometry, material);
            displacementSprite.position.x = (i - xgrid / 2) * xsize;
            displacementSprite.position.y = (j - ygrid / 2) * ysize;
            displacementSprite.position.z = 0;
            displacementSprite.scale.x = displacementSprite.scale.y = displacementSprite.scale.z = 1;
            displacementSprite.origPos = {
              x: displacementSprite.position.x,
              y: displacementSprite.position.y,
              z: displacementSprite.position.z
            }; //hide all

            var newPosX = 4000 * Math.random() * (Math.random() > 0.5 ? 1 : -1);
            var newPosY = 2000 * Math.random();
            var newPosZ = 3000 * Math.random();
            displacementSprite.position.x = newPosX;
            displacementSprite.position.y = newPosY;
            displacementSprite.position.z = newPosZ;
            displacementSprite.targetPos = {
              x: newPosX,
              y: newPosY,
              z: newPosZ
            }; //

            group.add(displacementSprite); //

            meshes[cube_count] = displacementSprite;
            cube_count += 1;
          }
        }

        allSources.push(group); //loading

        TweenMax.to(loading, 0.5, {
          width: Math.round(100 * allSources.length / total) + '%',
          onComplete: function onComplete() {
            if ($(this.target).width() >= windowWidth - 50) {
              TweenMax.to(this.target, 0.5, {
                alpha: 0
              });
            }
          }
        });
      }

      function changeUVS(geometry, unitx, unity, offsetx, offsety) {
        var uvs = geometry.attributes.uv.array;

        for (var i = 0; i < uvs.length; i += 2) {
          uvs[i] = (uvs[i] + offsetx) * unitx;
          uvs[i + 1] = (uvs[i + 1] + offsety) * unity;
        }
      }
      /*
      * Trigger slider autoplay
      *
      * @param  {Function} playTimes            - Number of times.
      * @param  {Number} timing                 - Autoplay interval.
      * @param  {Boolean} loop                  - Gives the slider a seamless infinite loop.
      * @param  {Element} slider                 - Selector of the slider .
      * @param  {String} countTotalID           - Total number ID or class of counter.
      * @param  {String} countCurID             - Current number ID or class of counter.
      * @param  {String} paginationID           - Navigation ID for paging control of each slide.
      * @param  {String} arrowsID               - Previous/Next arrow navigation ID.
      * @return {Void}                          - The constructor.
      */


      function sliderAutoPlay(playTimes, timing, loop, slider, countTotalID, countCurID, paginationID, arrowsID) {
        var items = slider.find('.uix-3d-slider--expParticle__item'),
            total = items.length;
        slider[0].animatedSlides = setInterval(function () {
          playTimes = parseFloat(items.filter('.is-active').index());
          playTimes++;

          if (!loop) {
            if (playTimes < total && playTimes >= 0) {
              var slideCurId = items.filter('.is-active').index(),
                  slideNextId = playTimes;
              sliderUpdates(slideCurId, slideNextId, 'next', countTotalID, countCurID, paginationID, arrowsID, loop);
            }
          } else {
            if (playTimes == total) playTimes = 0;
            if (playTimes < 0) playTimes = total - 1;

            var _slideCurId = items.filter('.is-active').index(),
                _slideNextId = playTimes; //Prevent problems with styles when switching in positive order


            if (playTimes == 0) {
              sliderUpdates(_slideCurId, _slideNextId, 'prev', countTotalID, countCurID, paginationID, arrowsID, loop);
            } else {
              sliderUpdates(_slideCurId, _slideNextId, 'next', countTotalID, countCurID, paginationID, arrowsID, loop);
            }
          }
        }, timing);
      }
      /*
       *  Transition Between Slides
       *
       * @param  {Number} slideCurId             - Index of current slider.
       * @param  {Number} slideNextId            - Index of next slider.
       * @param  {String} dir                    - Switching direction indicator.	 
                * @param  {String} countTotalID           - Total number ID or class of counter.
                * @param  {String} countCurID             - Current number ID or class of counter.
                * @param  {String} paginationID           - Navigation ID for paging control of each slide.
                * @param  {String} arrowsID               - Previous/Next arrow navigation ID.
                * @param  {Boolean} loop                  - Gives the slider a seamless infinite loop.
       * @return {Void}
       */


      function sliderUpdates(slideCurId, slideNextId, dir, countTotalID, countCurID, paginationID, arrowsID, loop) {
        var $items = $sliderWrapper.find('.uix-3d-slider--expParticle__item'),
            total = $items.length; //Prevent bubbling

        if (total == 1) {
          $(paginationID).hide();
          $(arrowsID).hide();
          return false;
        }

        if (!isAnimating) {
          isAnimating = true; //Transition Interception
          //-------------------------------------

          if (loop) {
            if (slideCurId > total - 1) slideCurId = 0;
            if (slideCurId < 0) slideCurId = total - 1; //--

            if (slideNextId < 0) slideNextId = total - 1;
            if (slideNextId > total - 1) slideNextId = 0;
          } else {
            if (slideCurId > total - 1) slideCurId = total - 1;
            if (slideCurId < 0) slideCurId = 0; //--

            if (slideNextId < 0) slideNextId = 0;
            if (slideNextId > total - 1) slideNextId = total - 1;
          } //Get previous and next index of item
          //-------------------------------------


          var $current = $sliderWrapper.find('.uix-3d-slider--expParticle__item').eq(slideCurId);
          var $next = $sliderWrapper.find('.uix-3d-slider--expParticle__item').eq(slideNextId);
          console.log('Current: ' + slideCurId + ' | Next: ' + slideNextId); //Determine the direction and add class to switching direction indicator.
          //-------------------------------------

          var dirIndicatorClass = '';
          if (dir == 'prev') dirIndicatorClass = 'prev';
          if (dir == 'next') dirIndicatorClass = 'next'; //Add transition class to each item
          //-------------------------------------	

          $items.removeClass('is-active leave prev next').addClass(dirIndicatorClass);
          $current.addClass('leave');
          $next.addClass('is-active'); //Add transition class to Controls Pagination
          //-------------------------------------

          $(paginationID).find('ul > li').removeClass('is-active leave prev next').addClass(dirIndicatorClass);
          $(paginationID).find('ul > li').eq(slideCurId).addClass('leave');
          $(paginationID).find('ul > li').eq(slideNextId).addClass('is-active'); //Add transition class to Arrows
          //-------------------------------------		

          if (!loop) {
            $(arrowsID).find('a').removeClass('is-disabled');
            if (slideNextId == total - 1) $(arrowsID).find('.uix-3d-slider--expParticle__arrows--next').addClass('is-disabled');
            if (slideNextId == 0) $(arrowsID).find('.uix-3d-slider--expParticle__arrows--prev').addClass('is-disabled');
          } //Display counter
          //-------------------------------------


          $(countTotalID).text(total);
          $(countCurID).text(parseFloat(slideCurId) + 1); //Fire the next object
          //-------------------------------------

          activeSlider = slideNextId; //Fire the current object
          //-------------------------------------
          //Reset the trigger
          //-------------------------------------

          isAnimating = false;
        } // end isAnimating

      } // 
      //-------------------------------------	


      return {
        init: init,
        render: render,
        wrapperInit: wrapperInit,
        getRendererCanvasID: function getRendererCanvasID() {
          return rendererCanvasID;
        },
        getScene: function getScene() {
          return scene;
        },
        getCamera: function getCamera() {
          return camera;
        }
      };
    }();

    MainStage.wrapperInit();
    MainStage.init();
    MainStage.render();
  };

  module.components.documentReady.push(module.THREE_EXP_PARTICLE_SLIDER.documentReady);
  return /*#__PURE__*/_createClass(function THREE_EXP_PARTICLE_SLIDER() {
    _classCallCheck(this, THREE_EXP_PARTICLE_SLIDER);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/simple-3D-liquid-scrollspy-slider/js/shader/fragment-custom.glsl
/* harmony default export */ const js_shader_fragment_custom = ("#define GLSLIFY 1\nvarying vec2 vUv;\n\nuniform sampler2D texture;\nuniform sampler2D texture2;\nuniform sampler2D disp;\n\n// uniform float time;\n// uniform float _rot;\nuniform float dispFactor;\nuniform float effectFactor;\n\n// vec2 rotate(vec2 v, float a) {\n//  float s = sin(a);\n//  float c = cos(a);\n//  mat2 m = mat2(c, -s, s, c);\n//  return m * v;\n// }\n\nvoid main() {\n\n    vec2 uv = vUv;\n\n    // uv -= 0.5;\n    // vec2 rotUV = rotate(uv, _rot);\n    // uv += 0.5;\n\n    vec4 disp = texture2D(disp, uv);\n\n    vec2 distortedPosition = vec2(uv.x + dispFactor * (disp.r*effectFactor), uv.y);\n    vec2 distortedPosition2 = vec2(uv.x - (1.0 - dispFactor) * (disp.r*effectFactor), uv.y);\n\n    vec4 _texture = texture2D(texture, distortedPosition);\n    vec4 _texture2 = texture2D(texture2, distortedPosition2);\n\n    vec4 finalTexture = mix(_texture, _texture2, dispFactor);\n\n    gl_FragColor = finalTexture;\n    // gl_FragColor = disp;\n}");
;// CONCATENATED MODULE: ./src/components/simple-3D-liquid-scrollspy-slider/js/shader/vertex-custom.glsl
/* harmony default export */ const js_shader_vertex_custom = ("#define GLSLIFY 1\nvarying vec2 vUv;\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}");
;// CONCATENATED MODULE: ./src/components/simple-3D-liquid-scrollspy-slider/js/index.js




/* 
 *************************************
 * <!-- 3D Liquid Scrollspy Slider -->
 *************************************
 */




var THREE_LIQUID_SCROLLSPY_SLIDER = function (module, $, window, document) {
  if (window.THREE_LIQUID_SCROLLSPY_SLIDER === null) return false;
  module.THREE_LIQUID_SCROLLSPY_SLIDER = module.THREE_LIQUID_SCROLLSPY_SLIDER || {};
  module.THREE_LIQUID_SCROLLSPY_SLIDER.version = '0.1.4';

  module.THREE_LIQUID_SCROLLSPY_SLIDER.documentReady = function ($) {
    //Prevent this module from loading in other pages
    if ($('.uix-3d-slider--liquid-scrollspy').length == 0 || !Modernizr.webgl) return false;
    var sceneSubjects = []; // Import objects and animations dynamically

    var MainStage = function () {
      var windowWidth = window.innerWidth,
          windowHeight = window.innerHeight;
      var $sliderWrapper = $('.uix-3d-slider--liquid-scrollspy'),
          //Basic webGL renderers 
      renderLoaderID = 'uix-3d-slider--liquid-scrollspy__loader',
          rendererOuterID = 'uix-3d-slider--liquid-scrollspy__canvas-container',
          rendererCanvasID = 'uix-3d-slider--liquid-scrollspy__canvas';
      var animSpeed = 1000; // Generate one plane geometries mesh to scene
      //-------------------------------------	

      var camera,
          controls,
          scene,
          light,
          renderer,
          material,
          displacementSprite,
          theta = 0;
      var offsetWidth = 1920,
          //Set the display width of the objects
      offsetHeight = 1080,
          //Set the display height of the objects
      imgAspect = offsetHeight / offsetWidth;
      var dispImage;
      var loader = new THREE.TextureLoader();
      loader.crossOrigin = 'anonymous';
      var textures;
      var sources = [];
      var isAnimating = false; //scroll spy

      var scrollspyEnabled, scrollspyConfigAutoAnim, scrollspyConfigItems, scrollspyConfigCountTotal, scrollspyConfigCountCur, scrollspyConfigControlsPagination, scrollspyConfigControlsArrows, scrollspyConfigLoop; // constants

      var activeSlider = 0;

      function wrapperInit() {
        $sliderWrapper.each(function () {
          var $this = $(this);
          var $items = $this.find('.uix-3d-slider--liquid-scrollspy__item'),
              $first = $items.first(),
              itemsTotal = $items.length,
              activated = $this.data('activated');

          if ((0,esm_typeof/* default */.Z)(activated) === ( true ? "undefined" : 0) || activated === 0) {
            //Get parameter configuration from the data-* attribute of HTML
            var dataControlsPagination = $this.data('controls-pagination'),
                dataControlsArrows = $this.data('controls-arrows'),
                dataFilterTexture = $this.data('filter-texture'),
                dataDraggable = $this.data('draggable'),
                dataDraggableCursor = $this.data('draggable-cursor'),
                dataSpeed = $this.data('speed'),
                dataCountTotal = $this.data('count-total'),
                dataCountCur = $this.data('count-now'),
                dataScrollspy = $this.data('scrollspy');
            if ((0,esm_typeof/* default */.Z)(dataControlsPagination) === ( true ? "undefined" : 0)) dataControlsPagination = '.uix-3d-slider--liquid-scrollspy__pagination';
            if ((0,esm_typeof/* default */.Z)(dataControlsArrows) === ( true ? "undefined" : 0) || dataControlsArrows == false) dataControlsArrows = '.uix-3d-slider--liquid-scrollspy__arrows';
            if ((0,esm_typeof/* default */.Z)(dataLoop) === ( true ? "undefined" : 0)) dataLoop = false;
            if ((0,esm_typeof/* default */.Z)(dataFilterTexture) === ( true ? "undefined" : 0) || !dataFilterTexture || dataFilterTexture == '') dataFilterTexture = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
            if ((0,esm_typeof/* default */.Z)(dataDraggable) === ( true ? "undefined" : 0)) dataDraggable = false;
            if ((0,esm_typeof/* default */.Z)(dataDraggableCursor) === ( true ? "undefined" : 0)) dataDraggableCursor = 'move';
            if ((0,esm_typeof/* default */.Z)(dataScrollspy) === ( true ? "undefined" : 0)) dataScrollspy = false; //Autoplay parameters

            var dataAuto = $this.data('auto'),
                dataTiming = $this.data('timing'),
                dataLoop = $this.data('loop');
            if ((0,esm_typeof/* default */.Z)(dataAuto) === ( true ? "undefined" : 0)) dataAuto = false;
            if ((0,esm_typeof/* default */.Z)(dataTiming) === ( true ? "undefined" : 0)) dataTiming = 10000;
            if ((0,esm_typeof/* default */.Z)(dataLoop) === ( true ? "undefined" : 0)) dataLoop = false; //Load displacement image

            dispImage = dataFilterTexture; //Autoplay times

            var playTimes; //A function called "timer" once every second (like a digital watch).

            $this[0].animatedSlides; //scroll spy config

            scrollspyEnabled = dataScrollspy;
            scrollspyConfigAutoAnim = $this[0].animatedSlides;
            scrollspyConfigItems = $items;
            scrollspyConfigCountTotal = dataCountTotal;
            scrollspyConfigCountCur = dataCountCur;
            scrollspyConfigControlsPagination = dataControlsPagination;
            scrollspyConfigControlsArrows = dataControlsArrows;
            scrollspyConfigLoop = dataLoop; //If arrows does not exist on the page, it will be added by default, 
            //and the drag and drop function will be activated.

            if ($(dataControlsArrows).length == 0) {
              $('body').prepend('<div style="display:none;" class="uix-3d-slider--liquid-scrollspy__arrows ' + dataControlsArrows.replace('#', '').replace('.', '') + '"><a href="#" class="uix-3d-slider--liquid-scrollspy__arrows--prev"></a><a href="#" class="uix-3d-slider--liquid-scrollspy__arrows--next"></a></div>');
            } //Prevent bubbling


            if (itemsTotal == 1) {
              $(dataControlsPagination).hide();
              $(dataControlsArrows).hide();
            } //Initialize the controlers classes
            //-------------------------------------	


            $(dataControlsPagination).find('ul > li').first().addClass('is-active'); //Initialize the wrapper width and height
            //-------------------------------------	

            $this.css('height', windowWidth * imgAspect + 'px'); //Load slides to canvas
            //-------------------------------------	

            if ($('#' + rendererCanvasID).length == 0) {
              $this.prepend('<div id="' + rendererOuterID + '" class="uix-3d-slider--liquid-scrollspy__canvas-container"><canvas id="' + rendererCanvasID + '"></canvas></div>');
            } //Get the animation speed
            //-------------------------------------	


            if ((0,esm_typeof/* default */.Z)(dataSpeed) != ( true ? "undefined" : 0) && dataSpeed != false) {
              animSpeed = dataSpeed;
            } //Initialize the first item container
            //-------------------------------------		


            $items.addClass('next');
            $first.addClass('is-active'); //Add identifiers for the first and last items
            //-------------------------------------		

            $items.last().addClass('last');
            $items.first().addClass('first'); //Get all images and videos
            //-------------------------------------		

            $items.each(function () {
              var _item = $(this);

              if (_item.find('video').length > 0) {
                //Returns the dimensions (intrinsic height and width ) of the video
                var video = document.getElementById(_item.find('video').attr('id'));

                var videoURL = _item.find('source:first').attr('src');

                if ((0,esm_typeof/* default */.Z)(videoURL) === ( true ? "undefined" : 0)) videoURL = _item.attr('src');

                if ((0,esm_typeof/* default */.Z)(videoURL) != ( true ? "undefined" : 0)) {
                  sources.push({
                    "url": videoURL,
                    "id": _item.find('video').attr('id'),
                    "type": 'video'
                  });
                }
              } else {
                var imgURL = _item.find('img').attr('src');

                if ((0,esm_typeof/* default */.Z)(imgURL) != ( true ? "undefined" : 0)) {
                  sources.push({
                    "url": imgURL,
                    "id": 'img-' + UixGUID.create(),
                    "type": 'img'
                  });
                }
              }
            }); //Pagination dots 
            //-------------------------------------	

            var _dot = '',
                _dotActive = '';
            _dot += '<ul>';

            for (var i = 0; i < itemsTotal; i++) {
              _dotActive = i == 0 ? 'class="is-active"' : '';
              _dot += '<li ' + _dotActive + ' data-index="' + i + '"><a href="javascript:"></a></li>';
            }

            _dot += '</ul>';
            if ($(dataControlsPagination).html() == '') $(dataControlsPagination).html(_dot); //Fire the slider transtion with buttons

            $(dataControlsPagination).find('ul > li').off('click').on('click', function (e) {
              e.preventDefault(); //Prevent buttons' events from firing multiple times

              var $btn = $(this);
              if ($btn.attr('aria-disabled') == 'true') return false;
              $(dataControlsPagination).find('ul > li').attr('aria-disabled', 'true');
              $(dataControlsPagination).find('ul > li').delay(animSpeed).queue(function (next) {
                $(dataControlsPagination).find('ul > li').attr('aria-disabled', 'false');
                next();
              }); //

              var slideCurId = $(dataControlsPagination).find('ul > li.is-active').index(),
                  slideNextId = $(this).index(); //Determine the direction

              var curDir = 'prev';

              if ($(this).attr('data-index') > slideCurId) {
                curDir = 'next';
              } //Transition Between Slides


              sliderUpdates(slideCurId, slideNextId, curDir, dataCountTotal, dataCountCur, dataControlsPagination, dataControlsArrows, dataLoop); //Pause the auto play event

              clearInterval($this[0].animatedSlides);
            }); //Next/Prev buttons
            //-------------------------------------		

            var _prev = $(dataControlsArrows).find('.uix-3d-slider--liquid-scrollspy__arrows--prev'),
                _next = $(dataControlsArrows).find('.uix-3d-slider--liquid-scrollspy__arrows--next');

            $(dataControlsArrows).find('a').attr('href', 'javascript:');
            $(dataControlsArrows).find('a').removeClass('is-disabled');

            if (!dataLoop) {
              _prev.addClass('is-disabled');
            }

            _prev.off('click').on('click', function (e) {
              e.preventDefault(); //Prevent buttons' events from firing multiple times

              if ($(this).attr('aria-disabled') == 'true') return false;
              $(this).attr('aria-disabled', 'true');
              $(this).delay(animSpeed).queue(function (next) {
                $(this).attr('aria-disabled', 'false');
                next();
              }); //

              var slideCurId = $items.filter('.is-active').index(),
                  slideNextId = parseFloat($items.filter('.is-active').index()) - 1; //Transition Between Slides

              sliderUpdates(slideCurId, slideNextId, 'prev', dataCountTotal, dataCountCur, dataControlsPagination, dataControlsArrows, dataLoop); //Pause the auto play event

              clearInterval($this[0].animatedSlides);
            });

            _next.off('click').on('click', function (e) {
              e.preventDefault(); //Prevent buttons' events from firing multiple times

              if ($(this).attr('aria-disabled') == 'true') return false;
              $(this).attr('aria-disabled', 'true');
              $(this).delay(animSpeed).queue(function (next) {
                $(this).attr('aria-disabled', 'false');
                next();
              }); //

              var slideCurId = $items.filter('.is-active').index(),
                  slideNextId = parseFloat($items.filter('.is-active').index()) + 1; //Transition Between Slides

              sliderUpdates(slideCurId, slideNextId, 'next', dataCountTotal, dataCountCur, dataControlsPagination, dataControlsArrows, dataLoop); //Pause the auto play event

              clearInterval($this[0].animatedSlides);
            }); //Autoplay Slider
            //-------------------------------------		


            if (dataAuto && !isNaN(parseFloat(dataTiming)) && isFinite(dataTiming)) {
              sliderAutoPlay(playTimes, dataTiming, dataLoop, $this, dataCountTotal, dataCountCur, dataControlsPagination, dataControlsArrows);

              var autoplayEnter = function autoplayEnter() {
                clearInterval($this[0].animatedSlides);
              };

              var autoplayLeave = function autoplayLeave() {
                sliderAutoPlay(playTimes, dataTiming, dataLoop, $this, dataCountTotal, dataCountCur, dataControlsPagination, dataControlsArrows);
              }; // Do not use the `off()` method, otherwise it will cause the second mouseenter to be invalid


              $this.on('mouseenter', autoplayEnter);
              $this.on('mouseleave', autoplayLeave); // To determine if it is a touch screen.

              if (Modernizr.touchevents) {
                $this.on('pointerenter', autoplayEnter);
                $this.on('pointerleave', autoplayLeave);
              }
            } //Prevents front-end javascripts that are activated with AJAX to repeat loading.


            $this.data('activated', 1);
          } //endif activated

        }); // end each				
      }

      function loadImages() {
        var promises = [];

        var _loop = function _loop(i) {
          if (sources[i].type == 'img') {
            ///////////
            // IMAGE //
            ///////////   
            promises.push(new Promise(function (resolve, reject) {
              var img = document.createElement("img");
              img.src = sources[i].url;

              img.onload = function (image) {
                //loading
                TweenMax.to("#" + renderLoaderID, 0.5, {
                  width: Math.round(100 * (i / sources.length)) + '%'
                }); //Compatible with safari and firefox

                if ((0,esm_typeof/* default */.Z)(image.path) === ( true ? "undefined" : 0)) {
                  return resolve(image.target.currentSrc);
                } else {
                  return resolve(image.path[0].currentSrc);
                }
              };
            }).then(makeThreeTexture));
          } else {
            ///////////
            // VIDEO //
            ///////////    
            promises.push(new Promise(function (resolve, reject) {
              //loading
              TweenMax.to("#" + renderLoaderID, 0.5, {
                width: Math.round(100 * (i / sources.length)) + '%'
              });
              $('#' + sources[i].id).one('loadedmetadata', resolve);
              return resolve(sources[i].url);
            }).then(makeThreeTexture));
          }
        };

        for (var i = 0; i < sources.length; i++) {
          _loop(i);
        }

        return Promise.all(promises);
      }

      function makeThreeTexture(url) {
        var texture;

        if (/[\/.](gif|jpg|jpeg|png)$/i.test(url)) {
          ///////////
          // IMAGE //
          ///////////   
          texture = loader.load(url);
        } else {
          ///////////
          // VIDEO //
          ///////////   
          var video = document.createElement('video');
          video.src = url;
          texture = new THREE.VideoTexture(video);
          texture.minFilter = THREE.LinearFilter;
          texture.magFilter = THREE.LinearFilter;
          texture.format = THREE.RGBFormat; // pause the video

          texture.image.autoplay = true;
          texture.image.loop = true;
          texture.image.currentTime = 0;
          texture.image.muted = true;
          texture.image.play();
        }

        return texture;
      }

      function texturesInit() {
        //Must be placed behind the loadImages()
        loadImages().then(function (images) {
          //remove loading
          TweenMax.to($("#" + renderLoaderID), 0.5, {
            alpha: 0
          });
          init(images);
          render();
        });
      }

      function init(allTextures) {
        textures = allTextures; //Core 3D stage begin
        //-------------------------------------		
        //camera

        camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 10000); // FlyCamera // FlyControls

        camera.position.z = 1000; //Object 1 unit, equal to 1 pixel

        camera.lookAt = new THREE.Vector3(0, 0, 0); // Fit plane to screen

        var dist = 1000,
            vFOV = THREE.Math.degToRad(camera.fov),
            // convert vertical fov to radians
        objHeight = 2 * Math.tan(vFOV / 2) * dist,
            // visible height
        objWidth = objHeight * camera.aspect; // visible width   
        //Scene

        scene = new THREE.Scene(); //HemisphereLight

        scene.add(new THREE.AmbientLight(0x555555));
        light = new THREE.SpotLight(0xffffff, 1.5);
        light.position.set(0, 0, 2000);
        scene.add(light); //WebGL Renderer	
        // create a render and set the size

        renderer = new THREE.WebGLRenderer({
          canvas: document.getElementById(rendererCanvasID),
          //canvas
          alpha: true,
          antialias: true
        });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(windowWidth, windowHeight); // Immediately use the texture for material creation
        // Create a texture loader so we can load our image file

        var texture1 = textures[0],
            texture2 = textures[1],
            intensity = 1,
            disp = loader.load(dispImage);
        disp.wrapS = disp.wrapT = THREE.RepeatWrapping;
        texture1.magFilter = texture2.magFilter = THREE.LinearFilter;
        texture1.minFilter = texture2.minFilter = THREE.LinearFilter;
        texture1.anisotropy = renderer.capabilities.getMaxAnisotropy();
        texture2.anisotropy = renderer.capabilities.getMaxAnisotropy();
        var geometry = new THREE.PlaneBufferGeometry(objWidth, objHeight, 1);
        $('#' + rendererCanvasID).css('height', windowWidth * imgAspect + 'px');
        geometry.center();
        material = new THREE.ShaderMaterial({
          uniforms: {
            effectFactor: {
              type: "f",
              value: intensity
            },
            dispFactor: {
              type: "f",
              value: 0.0
            },
            texture: {
              type: "t",
              value: texture1
            },
            texture2: {
              type: "t",
              value: texture2
            },
            disp: {
              type: "t",
              value: disp
            }
          },
          vertexShader: js_shader_vertex_custom,
          fragmentShader: js_shader_fragment_custom,
          transparent: true,
          opacity: 1.0
        });
        displacementSprite = new THREE.Mesh(geometry, material);
        displacementSprite.position.set(0, 0, 0);
        scene.add(displacementSprite); //				TweenMax.to( material.uniforms.dispFactor, 1.5, {
        //					value: 1,
        //					ease: Expo.easeOut
        //				});	
        //                
        // Fires when the window changes

        window.addEventListener('resize', onWindowResize, false); // Scrolling interaction with 3D scenes

        window.addEventListener('wheel', onMouseWheel, UixBrowser.supportsPassive ? {
          passive: true
        } : false);
      }

      function render() {
        requestAnimationFrame(render);
        theta += 0.1; //To set a background color.
        //renderer.setClearColor( 0x000000 );	
        //push objects

        /*
        @Usage: 
             function CustomObj( scene ) {
                 const elements = new THREE...;
                scene.add( elements );
                 this.update = function( time ) {
                    elements.rotation.y = time*0.003;
                }
            }       
             sceneSubjects.push( new CustomObj( MainStage.getScene() ) );  
        */

        for (var i = 0; i < sceneSubjects.length; i++) {
          sceneSubjects[i].update(clock.getElapsedTime() * 1);
        } //render the scene to display our scene through the camera's eye.


        renderer.render(scene, camera);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function onMouseWheel(e) {
        var scrollPos; //Gets a value that indicates the amount that the mouse wheel has changed.

        var dir,
            delta,
            mobileDeltaY = null;
        var touches = e.touches;

        if (touches && touches.length) {
          mobileDeltaY = startY - touches[0].pageY;
          scrollPos = touches[0].pageY;
        } else {
          delta = Math.max(-1, Math.min(1, -e.deltaY));
          scrollPos = e.deltaY;
        }

        if (mobileDeltaY != null) {
          if (mobileDeltaY >= 50) {
            //--- swipe up
            dir = 'up';
          }

          if (mobileDeltaY <= -50) {
            //--- swipe down
            dir = 'down';
          }
        } else {
          if (delta < 0) {
            //scroll down
            dir = 'down';
          } else {
            //scroll up
            dir = 'up';
          }
        } //-----


        if (scrollspyEnabled) {
          var slideCurId = scrollspyConfigItems.filter('.is-active').index();
          var slideNextId;

          if (dir == 'down') {
            slideNextId = parseFloat(scrollspyConfigItems.filter('.is-active').index()) + 1; //Transition Between Slides

            sliderUpdates(slideCurId, slideNextId, 'next', scrollspyConfigCountTotal, scrollspyConfigCountCur, scrollspyConfigControlsPagination, scrollspyConfigControlsArrows, scrollspyConfigLoop); //Pause the auto play event

            clearInterval(scrollspyConfigAutoAnim);
          }

          if (dir == 'up') {
            slideNextId = parseFloat(scrollspyConfigItems.filter('.is-active').index()) - 1; //Transition Between Slides

            sliderUpdates(slideCurId, slideNextId, 'prev', scrollspyConfigCountTotal, scrollspyConfigCountCur, scrollspyConfigControlsPagination, scrollspyConfigControlsArrows, scrollspyConfigLoop); //Pause the auto play event

            clearInterval(scrollspyConfigAutoAnim);
          }
        }
      }
      /*
      * Trigger slider autoplay
      *
      * @param  {Function} playTimes            - Number of times.
      * @param  {Number} timing                 - Autoplay interval.
      * @param  {Boolean} loop                  - Gives the slider a seamless infinite loop.
      * @param  {Element} slider                 - Selector of the slider .
      * @param  {String} countTotalID           - Total number ID or class of counter.
      * @param  {String} countCurID             - Current number ID or class of counter.
      * @param  {String} paginationID           - Navigation ID for paging control of each slide.
      * @param  {String} arrowsID               - Previous/Next arrow navigation ID.
      * @return {Void}                          - The constructor.
      */


      function sliderAutoPlay(playTimes, timing, loop, slider, countTotalID, countCurID, paginationID, arrowsID) {
        var items = slider.find('.uix-3d-slider--liquid-scrollspy__item'),
            total = items.length;
        slider[0].animatedSlides = setInterval(function () {
          playTimes = parseFloat(items.filter('.is-active').index());
          playTimes++;

          if (!loop) {
            if (playTimes < total && playTimes >= 0) {
              var slideCurId = items.filter('.is-active').index(),
                  slideNextId = playTimes;
              sliderUpdates(slideCurId, slideNextId, 'next', countTotalID, countCurID, paginationID, arrowsID, loop);
            }
          } else {
            if (playTimes == total) playTimes = 0;
            if (playTimes < 0) playTimes = total - 1;

            var _slideCurId = items.filter('.is-active').index(),
                _slideNextId = playTimes; //Prevent problems with styles when switching in positive order


            if (playTimes == 0) {
              sliderUpdates(_slideCurId, _slideNextId, 'prev', countTotalID, countCurID, paginationID, arrowsID, loop);
            } else {
              sliderUpdates(_slideCurId, _slideNextId, 'next', countTotalID, countCurID, paginationID, arrowsID, loop);
            }
          }
        }, timing);
      }
      /*
       *  Transition Between Slides
       *
       * @param  {Number} slideCurId             - Index of current slider.
       * @param  {Number} slideNextId            - Index of next slider.
       * @param  {String} dir                    - Switching direction indicator.	 
                * @param  {String} countTotalID           - Total number ID or class of counter.
                * @param  {String} countCurID             - Current number ID or class of counter.
                * @param  {String} paginationID           - Navigation ID for paging control of each slide.
                * @param  {String} arrowsID               - Previous/Next arrow navigation ID.
                * @param  {Boolean} loop                  - Gives the slider a seamless infinite loop.
       * @return {Void}
       */


      function sliderUpdates(slideCurId, slideNextId, dir, countTotalID, countCurID, paginationID, arrowsID, loop) {
        var $items = $sliderWrapper.find('.uix-3d-slider--liquid-scrollspy__item'),
            total = $items.length; //Prevent bubbling

        if (total == 1) {
          $(paginationID).hide();
          $(arrowsID).hide();
          return false;
        }

        if (!isAnimating) {
          isAnimating = true; //Transition Interception
          //-------------------------------------

          if (loop) {
            if (slideCurId > total - 1) slideCurId = 0;
            if (slideCurId < 0) slideCurId = total - 1; //--

            if (slideNextId < 0) slideNextId = total - 1;
            if (slideNextId > total - 1) slideNextId = 0;
          } else {
            if (slideCurId > total - 1) slideCurId = total - 1;
            if (slideCurId < 0) slideCurId = 0; //--

            if (slideNextId < 0) slideNextId = 0;
            if (slideNextId > total - 1) slideNextId = total - 1;
          } //Get previous and next index of item
          //-------------------------------------


          var $current = $sliderWrapper.find('.uix-3d-slider--liquid-scrollspy__item').eq(slideCurId);
          var $next = $sliderWrapper.find('.uix-3d-slider--liquid-scrollspy__item').eq(slideNextId);
          console.log('Current: ' + slideCurId + ' | Next: ' + slideNextId); //Determine the direction and add class to switching direction indicator.
          //-------------------------------------

          var dirIndicatorClass = '';
          if (dir == 'prev') dirIndicatorClass = 'prev';
          if (dir == 'next') dirIndicatorClass = 'next'; //Add transition class to each item
          //-------------------------------------	

          $items.removeClass('is-active leave prev next').addClass(dirIndicatorClass);
          $current.addClass('leave');
          $next.addClass('is-active'); //Add transition class to Controls Pagination
          //-------------------------------------

          $(paginationID).find('ul > li').removeClass('is-active leave prev next').addClass(dirIndicatorClass);
          $(paginationID).find('ul > li').eq(slideCurId).addClass('leave');
          $(paginationID).find('ul > li').eq(slideNextId).addClass('is-active'); //Add transition class to Arrows
          //-------------------------------------		

          if (!loop) {
            $(arrowsID).find('a').removeClass('is-disabled');
            if (slideNextId == total - 1) $(arrowsID).find('.uix-3d-slider--liquid-scrollspy__arrows--next').addClass('is-disabled');
            if (slideNextId == 0) $(arrowsID).find('.uix-3d-slider--liquid-scrollspy__arrows--prev').addClass('is-disabled');
          } //Display counter
          //-------------------------------------


          $(countTotalID).text(total);
          $(countCurID).text(parseFloat(slideCurId) + 1); //Fire the next object
          //-------------------------------------

          activeSlider = slideNextId; //Update Texture

          material.uniforms.texture.value = textures[Math.floor(slideCurId)];
          material.uniforms.texture2.value = textures[Math.floor(slideNextId)]; //console.log( 'material.uniforms.texture: ' + material.uniforms.texture.value.image.currentSrc );
          //console.log( 'material.uniforms.texture2: ' + material.uniforms.texture2.value.image.currentSrc );

          TweenMax.to(material.uniforms.dispFactor, 1.5, {
            value: 1,
            ease: Expo.easeOut,
            onComplete: function onComplete() {
              //Update Texture
              var tx1ID, tx2ID;

              if (dir == 'prev') {
                material.uniforms.texture.value = textures[Math.floor(slideCurId)];
                material.uniforms.texture2.value = textures[Math.floor(slideNextId - 1)];

                if (loop) {
                  tx1ID = slideNextId;
                  tx2ID = slideNextId - 1;
                  if (slideNextId == 0) tx2ID = total - 1;
                } else {}
              }

              if (dir == 'next') {
                material.uniforms.texture.value = textures[Math.floor(slideCurId)];
                material.uniforms.texture2.value = textures[Math.floor(slideNextId)];

                if (loop) {
                  tx1ID = slideNextId;
                  tx2ID = slideNextId + 1;
                  if (slideNextId == total - 1) tx2ID = 0;
                } else {}
              }

              material.uniforms.texture.value = textures[Math.floor(tx1ID)];
              material.uniforms.texture2.value = textures[Math.floor(tx2ID)]; //console.log( 'New material.uniforms.texture: ' + material.uniforms.texture.value.image.currentSrc );
              //console.log( 'New material.uniforms.texture2: ' + material.uniforms.texture2.value.image.currentSrc ); 
              //console.log( '--------------------' );

              TweenMax.set(this.target, {
                value: 0
              }); //Reset the trigger
              //-------------------------------------

              isAnimating = false;
            }
          }); //Fire the current object
          //-------------------------------------
        } // end isAnimating

      } // 
      //-------------------------------------	


      return {
        wrapperInit: wrapperInit,
        texturesInit: texturesInit,
        getRendererCanvasID: function getRendererCanvasID() {
          return rendererCanvasID;
        },
        getScene: function getScene() {
          return scene;
        },
        getCamera: function getCamera() {
          return camera;
        }
      };
    }();

    MainStage.wrapperInit(); //step 1

    MainStage.texturesInit(); // step 2
  };

  module.components.documentReady.push(module.THREE_LIQUID_SCROLLSPY_SLIDER.documentReady);
  return /*#__PURE__*/_createClass(function THREE_LIQUID_SCROLLSPY_SLIDER() {
    _classCallCheck(this, THREE_LIQUID_SCROLLSPY_SLIDER);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/_third-party-plugins/THREE/esm/postprocessing/EffectComposer.js
/**
 * @author alteredq / http://alteredqualia.com/
 */
THREE.EffectComposer = function (renderer, renderTarget) {
  this.renderer = renderer;

  if (renderTarget === undefined) {
    var parameters = {
      minFilter: THREE.LinearFilter,
      magFilter: THREE.LinearFilter,
      format: THREE.RGBAFormat,
      stencilBuffer: false
    };
    var size = renderer.getDrawingBufferSize(new THREE.Vector2());
    renderTarget = new THREE.WebGLRenderTarget(size.width, size.height, parameters);
    renderTarget.texture.name = 'EffectComposer.rt1';
  }

  this.renderTarget1 = renderTarget;
  this.renderTarget2 = renderTarget.clone();
  this.renderTarget2.texture.name = 'EffectComposer.rt2';
  this.writeBuffer = this.renderTarget1;
  this.readBuffer = this.renderTarget2;
  this.renderToScreen = true;
  this.passes = []; // dependencies

  if (THREE.CopyShader === undefined) {
    console.error('THREE.EffectComposer relies on THREE.CopyShader');
  }

  if (THREE.ShaderPass === undefined) {
    console.error('THREE.EffectComposer relies on THREE.ShaderPass');
  }

  this.copyPass = new THREE.ShaderPass(THREE.CopyShader);
  this._previousFrameTime = Date.now();
};

Object.assign(THREE.EffectComposer.prototype, {
  swapBuffers: function swapBuffers() {
    var tmp = this.readBuffer;
    this.readBuffer = this.writeBuffer;
    this.writeBuffer = tmp;
  },
  addPass: function addPass(pass) {
    this.passes.push(pass);
    var size = this.renderer.getDrawingBufferSize(new THREE.Vector2());
    pass.setSize(size.width, size.height);
  },
  insertPass: function insertPass(pass, index) {
    this.passes.splice(index, 0, pass);
  },
  isLastEnabledPass: function isLastEnabledPass(passIndex) {
    for (var i = passIndex + 1; i < this.passes.length; i++) {
      if (this.passes[i].enabled) {
        return false;
      }
    }

    return true;
  },
  render: function render(deltaTime) {
    // deltaTime value is in seconds
    if (deltaTime === undefined) {
      deltaTime = (Date.now() - this._previousFrameTime) * 0.001;
    }

    this._previousFrameTime = Date.now();
    var currentRenderTarget = this.renderer.getRenderTarget();
    var maskActive = false;
    var pass,
        i,
        il = this.passes.length;

    for (i = 0; i < il; i++) {
      pass = this.passes[i];
      if (pass.enabled === false) continue;
      pass.renderToScreen = this.renderToScreen && this.isLastEnabledPass(i);
      pass.render(this.renderer, this.writeBuffer, this.readBuffer, deltaTime, maskActive);

      if (pass.needsSwap) {
        if (maskActive) {
          var context = this.renderer.context;
          context.stencilFunc(context.NOTEQUAL, 1, 0xffffffff);
          this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, deltaTime);
          context.stencilFunc(context.EQUAL, 1, 0xffffffff);
        }

        this.swapBuffers();
      }

      if (THREE.MaskPass !== undefined) {
        if (pass instanceof THREE.MaskPass) {
          maskActive = true;
        } else if (pass instanceof THREE.ClearMaskPass) {
          maskActive = false;
        }
      }
    }

    this.renderer.setRenderTarget(currentRenderTarget);
  },
  reset: function reset(renderTarget) {
    if (renderTarget === undefined) {
      var size = this.renderer.getDrawingBufferSize(new THREE.Vector2());
      renderTarget = this.renderTarget1.clone();
      renderTarget.setSize(size.width, size.height);
    }

    this.renderTarget1.dispose();
    this.renderTarget2.dispose();
    this.renderTarget1 = renderTarget;
    this.renderTarget2 = renderTarget.clone();
    this.writeBuffer = this.renderTarget1;
    this.readBuffer = this.renderTarget2;
  },
  setSize: function setSize(width, height) {
    this.renderTarget1.setSize(width, height);
    this.renderTarget2.setSize(width, height);

    for (var i = 0; i < this.passes.length; i++) {
      this.passes[i].setSize(width, height);
    }
  }
});

THREE.Pass = function () {
  // if set to true, the pass is processed by the composer
  this.enabled = true; // if set to true, the pass indicates to swap read and write buffer after rendering

  this.needsSwap = true; // if set to true, the pass clears its buffer before rendering

  this.clear = false; // if set to true, the result of the pass is rendered to screen. This is set automatically by EffectComposer.

  this.renderToScreen = false;
};

Object.assign(THREE.Pass.prototype, {
  setSize: function setSize(width, height) {},
  render: function render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {
    console.error('THREE.Pass: .render() must be implemented in derived pass.');
  }
}); // Helper for passes that need to fill the viewport with a single quad.

THREE.Pass.FullScreenQuad = function () {
  var camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
  var geometry = new THREE.PlaneBufferGeometry(2, 2);

  var FullScreenQuad = function FullScreenQuad(material) {
    this._mesh = new THREE.Mesh(geometry, material);
  };

  Object.defineProperty(FullScreenQuad.prototype, 'material', {
    get: function get() {
      return this._mesh.material;
    },
    set: function set(value) {
      this._mesh.material = value;
    }
  });
  Object.assign(FullScreenQuad.prototype, {
    render: function render(renderer) {
      renderer.render(this._mesh, camera);
    }
  });
  return FullScreenQuad;
}();

/* harmony default export */ const EffectComposer = (THREE.EffectComposer);
;// CONCATENATED MODULE: ./src/components/_third-party-plugins/THREE/esm/postprocessing/MaskPass.js
/**
 * @author alteredq / http://alteredqualia.com/
 */
THREE.MaskPass = function (scene, camera) {
  THREE.Pass.call(this);
  this.scene = scene;
  this.camera = camera;
  this.clear = true;
  this.needsSwap = false;
  this.inverse = false;
};

THREE.MaskPass.prototype = Object.assign(Object.create(THREE.Pass.prototype), {
  constructor: THREE.MaskPass,
  render: function render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {
    var context = renderer.context;
    var state = renderer.state; // don't update color or depth

    state.buffers.color.setMask(false);
    state.buffers.depth.setMask(false); // lock buffers

    state.buffers.color.setLocked(true);
    state.buffers.depth.setLocked(true); // set up stencil

    var writeValue, clearValue;

    if (this.inverse) {
      writeValue = 0;
      clearValue = 1;
    } else {
      writeValue = 1;
      clearValue = 0;
    }

    state.buffers.stencil.setTest(true);
    state.buffers.stencil.setOp(context.REPLACE, context.REPLACE, context.REPLACE);
    state.buffers.stencil.setFunc(context.ALWAYS, writeValue, 0xffffffff);
    state.buffers.stencil.setClear(clearValue); // draw into the stencil buffer

    renderer.setRenderTarget(readBuffer);
    if (this.clear) renderer.clear();
    renderer.render(this.scene, this.camera);
    renderer.setRenderTarget(writeBuffer);
    if (this.clear) renderer.clear();
    renderer.render(this.scene, this.camera); // unlock color and depth buffer for subsequent rendering

    state.buffers.color.setLocked(false);
    state.buffers.depth.setLocked(false); // only render where stencil is set to 1

    state.buffers.stencil.setFunc(context.EQUAL, 1, 0xffffffff); // draw if == 1

    state.buffers.stencil.setOp(context.KEEP, context.KEEP, context.KEEP);
  }
});

THREE.ClearMaskPass = function () {
  THREE.Pass.call(this);
  this.needsSwap = false;
};

THREE.ClearMaskPass.prototype = Object.create(THREE.Pass.prototype);
Object.assign(THREE.ClearMaskPass.prototype, {
  render: function render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {
    renderer.state.buffers.stencil.setTest(false);
  }
});
/* harmony default export */ const MaskPass = (THREE.MaskPass);
;// CONCATENATED MODULE: ./src/components/_third-party-plugins/THREE/esm/postprocessing/TexturePass.js
/**
 * @author alteredq / http://alteredqualia.com/
 */
THREE.TexturePass = function (map, opacity) {
  THREE.Pass.call(this);
  if (THREE.CopyShader === undefined) console.error("THREE.TexturePass relies on THREE.CopyShader");
  var shader = THREE.CopyShader;
  this.map = map;
  this.opacity = opacity !== undefined ? opacity : 1.0;
  this.uniforms = THREE.UniformsUtils.clone(shader.uniforms);
  this.material = new THREE.ShaderMaterial({
    uniforms: this.uniforms,
    vertexShader: shader.vertexShader,
    fragmentShader: shader.fragmentShader,
    depthTest: false,
    depthWrite: false
  });
  this.needsSwap = false;
  this.fsQuad = new THREE.Pass.FullScreenQuad(null);
};

THREE.TexturePass.prototype = Object.assign(Object.create(THREE.Pass.prototype), {
  constructor: THREE.TexturePass,
  render: function render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {
    var oldAutoClear = renderer.autoClear;
    renderer.autoClear = false;
    this.fsQuad.material = this.material;
    this.uniforms["opacity"].value = this.opacity;
    this.uniforms["tDiffuse"].value = this.map;
    this.material.transparent = this.opacity < 1.0;
    renderer.setRenderTarget(this.renderToScreen ? null : readBuffer);
    if (this.clear) renderer.clear();
    this.fsQuad.render(renderer);
    renderer.autoClear = oldAutoClear;
  }
});
/* harmony default export */ const TexturePass = (THREE.TexturePass);
;// CONCATENATED MODULE: ./src/components/_third-party-plugins/THREE/esm/postprocessing/ShaderPass.js
/**
 * @author alteredq / http://alteredqualia.com/
 */
THREE.ShaderPass = function (shader, textureID) {
  THREE.Pass.call(this);
  this.textureID = textureID !== undefined ? textureID : "tDiffuse";

  if (shader instanceof THREE.ShaderMaterial) {
    this.uniforms = shader.uniforms;
    this.material = shader;
  } else if (shader) {
    this.uniforms = THREE.UniformsUtils.clone(shader.uniforms);
    this.material = new THREE.ShaderMaterial({
      defines: Object.assign({}, shader.defines),
      uniforms: this.uniforms,
      vertexShader: shader.vertexShader,
      fragmentShader: shader.fragmentShader
    });
  }

  this.fsQuad = new THREE.Pass.FullScreenQuad(this.material);
};

THREE.ShaderPass.prototype = Object.assign(Object.create(THREE.Pass.prototype), {
  constructor: THREE.ShaderPass,
  render: function render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {
    if (this.uniforms[this.textureID]) {
      this.uniforms[this.textureID].value = readBuffer.texture;
    }

    this.fsQuad.material = this.material;

    if (this.renderToScreen) {
      renderer.setRenderTarget(null);
      this.fsQuad.render(renderer);
    } else {
      renderer.setRenderTarget(writeBuffer); // TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600

      if (this.clear) renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
      this.fsQuad.render(renderer);
    }
  }
});
/* harmony default export */ const ShaderPass = (THREE.ShaderPass);
;// CONCATENATED MODULE: ./src/components/_third-party-plugins/THREE/esm/postprocessing/RenderPass.js
/**
 * @author alteredq / http://alteredqualia.com/
 */
THREE.RenderPass = function (scene, camera, overrideMaterial, clearColor, clearAlpha) {
  THREE.Pass.call(this);
  this.scene = scene;
  this.camera = camera;
  this.overrideMaterial = overrideMaterial;
  this.clearColor = clearColor;
  this.clearAlpha = clearAlpha !== undefined ? clearAlpha : 0;
  this.clear = true;
  this.clearDepth = false;
  this.needsSwap = false;
};

THREE.RenderPass.prototype = Object.assign(Object.create(THREE.Pass.prototype), {
  constructor: THREE.RenderPass,
  render: function render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {
    var oldAutoClear = renderer.autoClear;
    renderer.autoClear = false;
    this.scene.overrideMaterial = this.overrideMaterial;
    var oldClearColor, oldClearAlpha;

    if (this.clearColor) {
      oldClearColor = renderer.getClearColor().getHex();
      oldClearAlpha = renderer.getClearAlpha();
      renderer.setClearColor(this.clearColor, this.clearAlpha);
    }

    if (this.clearDepth) {
      renderer.clearDepth();
    }

    renderer.setRenderTarget(this.renderToScreen ? null : readBuffer); // TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600

    if (this.clear) renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
    renderer.render(this.scene, this.camera);

    if (this.clearColor) {
      renderer.setClearColor(oldClearColor, oldClearAlpha);
    }

    this.scene.overrideMaterial = null;
    renderer.autoClear = oldAutoClear;
  }
});
/* harmony default export */ const RenderPass = (THREE.RenderPass);
;// CONCATENATED MODULE: ./src/components/_third-party-plugins/THREE/esm/postprocessing/ClearPass.js
/**
 * @author mrdoob / http://mrdoob.com/
 */
THREE.ClearPass = function (clearColor, clearAlpha) {
  THREE.Pass.call(this);
  this.needsSwap = false;
  this.clearColor = clearColor !== undefined ? clearColor : 0x000000;
  this.clearAlpha = clearAlpha !== undefined ? clearAlpha : 0;
};

THREE.ClearPass.prototype = Object.assign(Object.create(THREE.Pass.prototype), {
  constructor: THREE.ClearPass,
  render: function render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {
    var oldClearColor, oldClearAlpha;

    if (this.clearColor) {
      oldClearColor = renderer.getClearColor().getHex();
      oldClearAlpha = renderer.getClearAlpha();
      renderer.setClearColor(this.clearColor, this.clearAlpha);
    }

    renderer.setRenderTarget(this.renderToScreen ? null : readBuffer);
    renderer.clear();

    if (this.clearColor) {
      renderer.setClearColor(oldClearColor, oldClearAlpha);
    }
  }
});
/* harmony default export */ const ClearPass = (THREE.ClearPass);
;// CONCATENATED MODULE: ./src/components/_third-party-plugins/THREE/esm/shaders/CopyShader.js
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Full-screen textured quad shader
 */
THREE.CopyShader = {
  uniforms: {
    "tDiffuse": {
      value: null
    },
    "opacity": {
      value: 1.0
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform float opacity;", "uniform sampler2D tDiffuse;", "varying vec2 vUv;", "void main() {", "vec4 texel = texture2D( tDiffuse, vUv );", "gl_FragColor = opacity * texel;", "}"].join("\n")
};
/* harmony default export */ const CopyShader = (THREE.CopyShader);
;// CONCATENATED MODULE: ./src/components/_third-party-plugins/THREE/esm/shaders/ConvolutionShader.js
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Convolution shader
 * ported from o3d sample to WebGL / GLSL
 * http://o3d.googlecode.com/svn/trunk/samples/convolution.html
 */
THREE.ConvolutionShader = {
  defines: {
    "KERNEL_SIZE_FLOAT": "25.0",
    "KERNEL_SIZE_INT": "25"
  },
  uniforms: {
    "tDiffuse": {
      value: null
    },
    "uImageIncrement": {
      value: new THREE.Vector2(0.001953125, 0.0)
    },
    "cKernel": {
      value: []
    }
  },
  vertexShader: ["uniform vec2 uImageIncrement;", "varying vec2 vUv;", "void main() {", "vUv = uv - ( ( KERNEL_SIZE_FLOAT - 1.0 ) / 2.0 ) * uImageIncrement;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform float cKernel[ KERNEL_SIZE_INT ];", "uniform sampler2D tDiffuse;", "uniform vec2 uImageIncrement;", "varying vec2 vUv;", "void main() {", "vec2 imageCoord = vUv;", "vec4 sum = vec4( 0.0, 0.0, 0.0, 0.0 );", "for( int i = 0; i < KERNEL_SIZE_INT; i ++ ) {", "sum += texture2D( tDiffuse, imageCoord ) * cKernel[ i ];", "imageCoord += uImageIncrement;", "}", "gl_FragColor = sum;", "}"].join("\n"),
  buildKernel: function buildKernel(sigma) {
    // We lop off the sqrt(2 * pi) * sigma term, since we're going to normalize anyway.
    function gauss(x, sigma) {
      return Math.exp(-(x * x) / (2.0 * sigma * sigma));
    }

    var i,
        values,
        sum,
        halfWidth,
        kMaxKernelSize = 25,
        kernelSize = 2 * Math.ceil(sigma * 3.0) + 1;
    if (kernelSize > kMaxKernelSize) kernelSize = kMaxKernelSize;
    halfWidth = (kernelSize - 1) * 0.5;
    values = new Array(kernelSize);
    sum = 0.0;

    for (i = 0; i < kernelSize; ++i) {
      values[i] = gauss(i - halfWidth, sigma);
      sum += values[i];
    } // normalize the kernel


    for (i = 0; i < kernelSize; ++i) {
      values[i] /= sum;
    }

    return values;
  }
};
/* harmony default export */ const ConvolutionShader = (THREE.ConvolutionShader);
;// CONCATENATED MODULE: ./src/components/_third-party-plugins/THREE/esm/postprocessing/BloomPass.js
/**
 * @author alteredq / http://alteredqualia.com/
 */
THREE.BloomPass = function (strength, kernelSize, sigma, resolution) {
  THREE.Pass.call(this);
  strength = strength !== undefined ? strength : 1;
  kernelSize = kernelSize !== undefined ? kernelSize : 25;
  sigma = sigma !== undefined ? sigma : 4.0;
  resolution = resolution !== undefined ? resolution : 256; // render targets

  var pars = {
    minFilter: THREE.LinearFilter,
    magFilter: THREE.LinearFilter,
    format: THREE.RGBAFormat
  };
  this.renderTargetX = new THREE.WebGLRenderTarget(resolution, resolution, pars);
  this.renderTargetX.texture.name = "BloomPass.x";
  this.renderTargetY = new THREE.WebGLRenderTarget(resolution, resolution, pars);
  this.renderTargetY.texture.name = "BloomPass.y"; // copy material

  if (THREE.CopyShader === undefined) console.error("THREE.BloomPass relies on THREE.CopyShader");
  var copyShader = THREE.CopyShader;
  this.copyUniforms = THREE.UniformsUtils.clone(copyShader.uniforms);
  this.copyUniforms["opacity"].value = strength;
  this.materialCopy = new THREE.ShaderMaterial({
    uniforms: this.copyUniforms,
    vertexShader: copyShader.vertexShader,
    fragmentShader: copyShader.fragmentShader,
    blending: THREE.AdditiveBlending,
    transparent: true
  }); // convolution material

  if (THREE.ConvolutionShader === undefined) console.error("THREE.BloomPass relies on THREE.ConvolutionShader");
  var convolutionShader = THREE.ConvolutionShader;
  this.convolutionUniforms = THREE.UniformsUtils.clone(convolutionShader.uniforms);
  this.convolutionUniforms["uImageIncrement"].value = THREE.BloomPass.blurX;
  this.convolutionUniforms["cKernel"].value = THREE.ConvolutionShader.buildKernel(sigma);
  this.materialConvolution = new THREE.ShaderMaterial({
    uniforms: this.convolutionUniforms,
    vertexShader: convolutionShader.vertexShader,
    fragmentShader: convolutionShader.fragmentShader,
    defines: {
      "KERNEL_SIZE_FLOAT": kernelSize.toFixed(1),
      "KERNEL_SIZE_INT": kernelSize.toFixed(0)
    }
  });
  this.needsSwap = false;
  this.fsQuad = new THREE.Pass.FullScreenQuad(null);
};

THREE.BloomPass.prototype = Object.assign(Object.create(THREE.Pass.prototype), {
  constructor: THREE.BloomPass,
  render: function render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {
    if (maskActive) renderer.context.disable(renderer.context.STENCIL_TEST); // Render quad with blured scene into texture (convolution pass 1)

    this.fsQuad.material = this.materialConvolution;
    this.convolutionUniforms["tDiffuse"].value = readBuffer.texture;
    this.convolutionUniforms["uImageIncrement"].value = THREE.BloomPass.blurX;
    renderer.setRenderTarget(this.renderTargetX);
    renderer.clear();
    this.fsQuad.render(renderer); // Render quad with blured scene into texture (convolution pass 2)

    this.convolutionUniforms["tDiffuse"].value = this.renderTargetX.texture;
    this.convolutionUniforms["uImageIncrement"].value = THREE.BloomPass.blurY;
    renderer.setRenderTarget(this.renderTargetY);
    renderer.clear();
    this.fsQuad.render(renderer); // Render original scene with superimposed blur to texture

    this.fsQuad.material = this.materialCopy;
    this.copyUniforms["tDiffuse"].value = this.renderTargetY.texture;
    if (maskActive) renderer.context.enable(renderer.context.STENCIL_TEST);
    renderer.setRenderTarget(readBuffer);
    if (this.clear) renderer.clear();
    this.fsQuad.render(renderer);
  }
});
THREE.BloomPass.blurX = new THREE.Vector2(0.001953125, 0.0);
THREE.BloomPass.blurY = new THREE.Vector2(0.0, 0.001953125);
/* harmony default export */ const BloomPass = (THREE.BloomPass);
;// CONCATENATED MODULE: ./src/components/_third-party-plugins/THREE/esm/postprocessing/FilmPass.js
/**
 * @author alteredq / http://alteredqualia.com/
 */
THREE.FilmPass = function (noiseIntensity, scanlinesIntensity, scanlinesCount, grayscale) {
  THREE.Pass.call(this);
  if (THREE.FilmShader === undefined) console.error("THREE.FilmPass relies on THREE.FilmShader");
  var shader = THREE.FilmShader;
  this.uniforms = THREE.UniformsUtils.clone(shader.uniforms);
  this.material = new THREE.ShaderMaterial({
    uniforms: this.uniforms,
    vertexShader: shader.vertexShader,
    fragmentShader: shader.fragmentShader
  });
  if (grayscale !== undefined) this.uniforms.grayscale.value = grayscale;
  if (noiseIntensity !== undefined) this.uniforms.nIntensity.value = noiseIntensity;
  if (scanlinesIntensity !== undefined) this.uniforms.sIntensity.value = scanlinesIntensity;
  if (scanlinesCount !== undefined) this.uniforms.sCount.value = scanlinesCount;
  this.fsQuad = new THREE.Pass.FullScreenQuad(this.material);
};

THREE.FilmPass.prototype = Object.assign(Object.create(THREE.Pass.prototype), {
  constructor: THREE.FilmPass,
  render: function render(renderer, writeBuffer, readBuffer, deltaTime
  /*, maskActive */
  ) {
    this.uniforms["tDiffuse"].value = readBuffer.texture;
    this.uniforms["time"].value += deltaTime;

    if (this.renderToScreen) {
      renderer.setRenderTarget(null);
      this.fsQuad.render(renderer);
    } else {
      renderer.setRenderTarget(writeBuffer);
      if (this.clear) renderer.clear();
      this.fsQuad.render(renderer);
    }
  }
});
/* harmony default export */ const FilmPass = (THREE.FilmPass);
;// CONCATENATED MODULE: ./src/components/_third-party-plugins/THREE/esm/shaders/FilmShader.js
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Film grain & scanlines shader
 *
 * - ported from HLSL to WebGL / GLSL
 * http://www.truevision3d.com/forums/showcase/staticnoise_colorblackwhite_scanline_shaders-t18698.0.html
 *
 * Screen Space Static Postprocessor
 *
 * Produces an analogue noise overlay similar to a film grain / TV static
 *
 * Original implementation and noise algorithm
 * Pat 'Hawthorne' Shearon
 *
 * Optimized scanlines + noise version with intensity scaling
 * Georg 'Leviathan' Steinrohder
 *
 * This version is provided under a Creative Commons Attribution 3.0 License
 * http://creativecommons.org/licenses/by/3.0/
 */
THREE.FilmShader = {
  uniforms: {
    "tDiffuse": {
      value: null
    },
    "time": {
      value: 0.0
    },
    "nIntensity": {
      value: 0.5
    },
    "sIntensity": {
      value: 0.05
    },
    "sCount": {
      value: 4096
    },
    "grayscale": {
      value: 1
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["#include <common>", // control parameter
  "uniform float time;", "uniform bool grayscale;", // noise effect intensity value (0 = no effect, 1 = full effect)
  "uniform float nIntensity;", // scanlines effect intensity value (0 = no effect, 1 = full effect)
  "uniform float sIntensity;", // scanlines effect count value (0 = no effect, 4096 = full effect)
  "uniform float sCount;", "uniform sampler2D tDiffuse;", "varying vec2 vUv;", "void main() {", // sample the source
  "vec4 cTextureScreen = texture2D( tDiffuse, vUv );", // make some noise
  "float dx = rand( vUv + time );", // add noise
  "vec3 cResult = cTextureScreen.rgb + cTextureScreen.rgb * clamp( 0.1 + dx, 0.0, 1.0 );", // get us a sine and cosine
  "vec2 sc = vec2( sin( vUv.y * sCount ), cos( vUv.y * sCount ) );", // add scanlines
  "cResult += cTextureScreen.rgb * vec3( sc.x, sc.y, sc.x ) * sIntensity;", // interpolate between source and result by intensity
  "cResult = cTextureScreen.rgb + clamp( nIntensity, 0.0,1.0 ) * ( cResult - cTextureScreen.rgb );", // convert to grayscale if desired
  "if( grayscale ) {", "cResult = vec3( cResult.r * 0.3 + cResult.g * 0.59 + cResult.b * 0.11 );", "}", "gl_FragColor =  vec4( cResult, cTextureScreen.a );", "}"].join("\n")
};
/* harmony default export */ const FilmShader = (THREE.FilmShader);
;// CONCATENATED MODULE: ./src/components/simple-3D-filmic-effects/js/index.js



/* 
 *************************************
 * <!-- 3D Filmic Effects -->
 *************************************
 */
 //filter basic
//---------------------








 //Extra filter -- film
//---------------------

 //Extra filter -- film
//---------------------



var THREE_FILMIC_EFF = function (module, $, window, document) {
  if (window.THREE_FILMIC_EFF === null) return false;
  module.THREE_FILMIC_EFF = module.THREE_FILMIC_EFF || {};
  module.THREE_FILMIC_EFF.version = '0.0.2';

  module.THREE_FILMIC_EFF.documentReady = function ($) {
    //Prevent this module from loading in other pages
    if ($('#3D-filmic-effects-canvas').length == 0 || !Modernizr.webgl) return false;
    var sceneSubjects = []; // Import objects and animations dynamically

    var MainStage = function () {
      var windowWidth = window.innerWidth,
          windowHeight = window.innerHeight;
      var rendererCanvasID = '3D-filmic-effects-canvas'; // Generate one plane geometries mesh to scene
      //-------------------------------------	

      var camera,
          scene,
          lights = [],
          renderer,
          clock = new THREE.Clock();
      var intersectionPlane;
      var composer, bloomPass, filmPass;

      function init() {
        //=================
        //camera
        camera = new THREE.PerspectiveCamera(60, windowWidth / windowHeight, 1, 10000);
        camera.position.set(0, 0, 100);
        camera.lookAt(new THREE.Vector3(0, 0, 0)); //=================
        //Scene

        scene = new THREE.Scene(); //=================
        //Lights

        lights[0] = new THREE.PointLight(0xffffff, 1, 0);
        lights[1] = new THREE.PointLight(0xffffff, 1, 0);
        lights[2] = new THREE.DirectionalLight(0xffffff);
        lights[0].position.set(0, 200, 0);
        lights[1].position.set(100, 200, 100);
        lights[2].position.set(120, 200, 0);
        lights[2].intensity = 0.6;
        scene.add(lights[0]);
        scene.add(lights[1]);
        scene.add(lights[2]); //=================
        //WebGL Renderer		

        renderer = new THREE.WebGLRenderer({
          canvas: document.getElementById(rendererCanvasID),
          //canvas
          alpha: true,
          antialias: true
        });
        renderer.setSize(windowWidth, windowHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; //=================
        //add bloom effect

        bloomPass = new THREE.BloomPass(1, // strength
        25, // kernel size
        4, // sigma ?
        256); //add film effect

        filmPass = new THREE.FilmPass(0.35, // noise intensity
        0.025, // scanline intensity
        648, // scanline count
        false); //-----

        var renderPass = new THREE.RenderPass(scene, camera);
        var effectCopy = new THREE.ShaderPass(THREE.CopyShader);
        effectCopy.renderToScreen = true;
        composer = new THREE.EffectComposer(renderer);
        composer.addPass(renderPass);
        composer.addPass(bloomPass);
        composer.addPass(filmPass);
        composer.addPass(effectCopy); //=================

        var planeGeometry = new THREE.PlaneGeometry(100000, 100000);
        var planeMaterial = new THREE.MeshNormalMaterial({
          side: THREE.DoubleSide
        });
        intersectionPlane = new THREE.Mesh(planeGeometry, planeMaterial);
        intersectionPlane.visible = false;
        scene.add(intersectionPlane);
        var hoverMaterial = new THREE.MeshNormalMaterial();
        var neutralMaterial = new THREE.MeshLambertMaterial({
          color: 0xffcccc
        });
        var selectedMaterial = new THREE.MeshBasicMaterial({
          color: 0x55ff88
        });
        var neutralGeometry = new THREE.IcosahedronGeometry(30, 1);
        var mesh = new THREE.Mesh(neutralGeometry, neutralMaterial);
        mesh.position.x = 0;
        mesh.position.y = 0;
        mesh.position.z = 0;
        scene.add(mesh); //=================
        // Fires when the window changes

        window.addEventListener('resize', onWindowResize, false);
      }

      function render() {
        requestAnimationFrame(render); //To set a background color.

        renderer.setClearColor(0x000000); //push objects

        /*
        @Usage: 
             function CustomObj( scene ) {
                 const elements = new THREE...;
                scene.add( elements );
                 this.update = function( time ) {
                    elements.rotation.y = time*0.003;
                }
            }       
             sceneSubjects.push( new CustomObj( MainStage.getScene() ) );  
        */

        for (var i = 0; i < sceneSubjects.length; i++) {
          sceneSubjects[i].update(clock.getElapsedTime() * 1);
        } //render the scene with filter


        composer.render();
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      } // 
      //-------------------------------------	


      return {
        init: init,
        render: render,
        getRendererCanvasID: function getRendererCanvasID() {
          return rendererCanvasID;
        },
        getScene: function getScene() {
          return scene;
        },
        getCamera: function getCamera() {
          return camera;
        }
      };
    }(); // 


    MainStage.init();
    MainStage.render(); // Add stars to scene
    //-------------------------------------	

    var starScene = MainStage.getScene();
    var starCamera = MainStage.getCamera();

    function Stars(scene, terrainSize) {
      var starsGeometry = new THREE.IcosahedronGeometry(terrainSize, 4); // geometry deformation

      for (var i = 0; i < starsGeometry.vertices.length; i += 1) {
        var scalar = 1 + Math.random() + Math.random();
        starsGeometry.vertices[i].multiplyScalar(scalar);
      }

      var textureLoader = new THREE.TextureLoader();
      textureLoader.setCrossOrigin("anonymous");
      var texture = textureLoader.load('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAABmJLR0QAAAACAAIUyQ49AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH3AUUFhoiw1VdsQAAAB1pVFh0Q29tbWVudAAAAAAAQ3JlYXRlZCB3aXRoIEdJTVBkLmUHAAAIQUlEQVR42u1baW/bRhB9u6Qkx1fiOFGcNCiaAGn//+9pG7RxTie1Y8u2TnL65a0xmcxSlCxbaWECCx6iyZ03b86lgbvtblvbJiKFiBTrnENcMwY9jjsA1rWVt0z54ADgXUcIQf7zADiCBXPc5XEBQDjS394KIOUNCx4ygmsTLAjERP0m5vgKkFUDUd6g4J7wHhgdAJsAppnHBgWIrBqI8hYE935L50n7mwDOtQlYk7CArAqI8gaE985zIBQ0g66JSFp4aQBDRCRcB4RyBcI3CW1/j4YVyQd0uIcStHYAsEBcsWFZEMoVaz2q82iuefcnBkQDgHWCtQJFzDVcx0mWS2hbGrQdG469vyk5Otx7mq7Ne615ZE2ijXm0BiCEICISAewwZE0c4aMR3u5hmFGoURpN63AoCojaMRMLQjKrKYBqlSZQ86E/8fjQCB/nnFszKc0Qh/I6DNaO5i0IDwnoOZXUuBVLmEAFYAZgjy87NQIXmREppL52nxGgAnCRAS7nUL3tCYBdKmkQQqhW4gNMShsAXAL4BOA5gN8AnAD4qgCwgFgTCer9hdrDsKDm31RzANiiaW5ybscAZiv1AU64uwTwkSD0AewDeGNAKBwAogGgQ0Z1jNevlb0HBYLdHlPwgiw64vNCJndYrBw2sd6OCwAfeNwD8Mo4NX1cGq/fUd7fnuvhPS+B+5Rm2AUwBvCZ9L+ao1dpLtsP0NrXNjqkOSQbf+UIUToC2uNew72l4z+e0Q9FCn+khMccX9HOBDKZXlR5fDoeKnMoAPzKa5/VxK0/0FEAAO5RkET7Stm/nu8ugA0CJjTFL4r20SZTTZliuYT27SgUCMkxBjqlXQDvjD/QjjBpOdKOKxPzrd0/pvCiIscXJycJJodY3ASU9uEI7yU6BTX4SYXYLoCXGcp3lG13yICciZS09/u8Ho3N58Lm1dxzviAuoX00mEOkNo4UhTsEwXOG3YwPsOHxgMKnUDmk5msn05zXj1jYBOZVetEZFZnwSGVmv1Bjuhm6p9piJQUbq+ZI5DM2eE2Y4R2rHCEquudKcLluHuA5Qc8cbKw/UxlaQSZ0yJJN0joBcKr+5lz1CUoCWjPhOqNAUYFQm/lIG+GzADTU+cgA4bGgUGHyhM7xIbW+w98eK1qfkxXHBOhSsWHG66NMUhUUENYMGqNBuUQegBZABOMc0/FTAnAAYJspbFQM2KSg50ywjgnCiYrxMVN2t5nvtavB0KLVZUFJtr5LAZ8TgC2CkLYdOrrPzCkmFP6dET73Ti8MXhuANq2ueaGyR8H69AX7dGyb5v09ldMnk3iXabCEOUpp7QiXaYlFE7p0KOuaNHaDdt8n/fsUfov32DWClPwMyYhUcgvtf0Y2pDHh/VPVpJl6LbPWDGDXpzRZms7Be0xaNlQ48xKdgvf1lfb3SPtOprRNawTbBOpE9QmGStiZGuk8mcyI905U7wLcVyIyBVCFEOrvAKD37yoH1TONjKBA6ahrIdPP013fxJiiYcFEFMg6W4yZDrH2OR2z0FITgEqlzmMCeiEi4xCClM7620hExvTA1psX1PwWX7KpihI9mUq1sOpMA3NuJa5aXloYfa5NYszQeUkhx/xdd5LlOmEwTSY9+CJDfX28RSpu0/ntA3hAlolhQZpYpeL/B/Yd3/N9U4f69lhrvZVDW1Qj9lrttLHS+ZQaOac9J/ucZhY89P1nZNulub923ikt59sOANJEMr34JsFrQ9EpNXdCQc5UojNR2qp4fsoa4oT3DciYqaF/3QKI7+bv9QTKBbUvplWtX+wBEKl1ofDvlSndY36QzGBAoQ8Z/08ISGrD/5kRvjYsqhsWTpbKAyTj5a32gxE+OdBtVbunxuUp4/y+mkPS/t8sp9+QNR2+52cAb1XXyGOBFyVk1QDAYYP2+pXqCO3RjpMD+0JKf1QO8R7vHwD4i/cccQz4+0M++wmjzgf1rjb0X6jA8apCu5wVzWJHNA2PfQqfkqRUzXVZE+ySGem4w3WFQ5pKKomT3aeMMp1fEKx0PlOA6P3VgmquJ9gWANsDtAsgpdr3KXxKnqq0UKFA2uDosiTuUeA3KuWtTLzf4LOTsCMAr9W5BUCa4n/rkrGBBcFZ+jogrZPwEzqzmWmI6q7wAYU7V9SWjEYLApZq/wmAP5yMr5X2F02E7Eqt7sSkju22KlxGqiMUTQsrqvx8zGfMjDZrR7Njan2L7wtstf2+TARoBQCXxT0wdBTo0+mJalhOFTvqzNJY4H2lSmm9pbHKsOErtf+Ez3upQGhF/WUZAMMCGOEvGe5mzgKFtzgaTCqby/gqhxGnBOGAz31Bc/ASt+sBQBYEh1r79OIVhf/HEd42MG2zQufvsxYJlh4DvjctkL5gwqQz2tW0xBxTeEThh5zIRSZpqk273LKgcgCoTSUomQwwhcBD+oVn9Amv234rtFA1qEB4QIc3IuUnjn2L4zhhogmc5gZMCV037HUWOGAWecDU+e1NNEWhmhoD2uEM336+EhTt7fpcMGmzNYEK/kdSkinArNO7ZILUFZGdEMJgpQDQD4gSHEbj3hpChP9lWdpsLe/l8k2fyX1zPz+LGYpIEJGYWl8rY0AIYWwAsQ0Tb3U296EkTBpbod2HknNLXVXSr9YHZHyC193x2tPiZJ8jFjyV+hYg96msZLS+nk9lTYiUhuwxt7wGRo8txYKmiu67Bs3aP5bWk8iwwUuk9HZBFjQ1UFcu+EoBmAOEzCm6Zsqhenn8N9d+6H+YyACBzHK1jQQwqznS5H9+aABykzaZpD4Z2mv/i3+amgeIAmZ0m0KvDYCGbYK77W6729ax/Qsf5ETUur8sQgAAAABJRU5ErkJggg==');
      var starMaterial = new THREE.PointsMaterial({
        map: texture,
        color: "#fff",
        size: 20,
        blending: THREE.AdditiveBlending,
        transparent: false
      });
      var stars = new THREE.Points(starsGeometry, starMaterial);
      scene.add(stars);

      this.update = function (time) {
        stars.rotation.y = time * 0.13;
      };
    }

    sceneSubjects.push(new Stars(starScene, 150));
  };

  module.components.documentReady.push(module.THREE_FILMIC_EFF.documentReady);
  return /*#__PURE__*/_createClass(function THREE_FILMIC_EFF() {
    _classCallCheck(this, THREE_FILMIC_EFF);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/simple-3D-simulate-html-layout/js/index.js




function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = js_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function js_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return js_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return js_arrayLikeToArray(o, minLen); }

function js_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

/* 
 *************************************
 * <!-- Simulate HTML Layout with threejs -->
 *************************************
 */

var THREE_SIMULATE_HTML_LAYOUT = function (module, $, window, document) {
  if (window.THREE_SIMULATE_HTML_LAYOUT === null) return false;
  module.THREE_SIMULATE_HTML_LAYOUT = module.THREE_SIMULATE_HTML_LAYOUT || {};
  module.THREE_SIMULATE_HTML_LAYOUT.version = '0.0.2';

  module.THREE_SIMULATE_HTML_LAYOUT.documentReady = function ($) {
    //Prevent this module from loading in other pages
    if ($('#app-3D-page-container').length == 0 || !Modernizr.webgl) return false; //=====================================================================================
    //=====================================================================================
    //==============================THREE.js===============================================
    //=====================================================================================
    //=====================================================================================
    //=====================================================================================
    //scroll spy

    var scrollY = 0;
    var touchStartY = 0;
    var _event = {
      y: 0,
      deltaY: 0
    };
    var scrollTrigger = document.getElementById('app-3D-page-container');
    var maxHeight = (scrollTrigger.clientHeight || scrollTrigger.offsetHeight) - window.innerHeight; // THREE PARAMS
    //-------------------------------------	

    var camera = null,
        scene = null,
        renderer;
    var clock = new THREE.Clock(),
        time = 0;
    var dataBGSources = []; // Loader manager

    var loadingManager = new THREE.LoadingManager();

    loadingManager.onLoad = function () {//console.log( '▶▶▶▶▶ Loading complete! ◀◀◀◀◀◀' );
    };

    loadingManager.onProgress = function (item, loaded, total) {//console.log( '▶▶▶▶▶ LoadingManager ◀◀◀◀◀◀ ( item: '+item+', loaded: '+loaded+', total: '+total+')' );
    };

    loadingManager.onError = function (url) {
      console.log('▶▶▶▶▶ There was an error loading ◀◀◀◀◀◀  ' + url);
    };

    var loaderImage = new THREE.TextureLoader(loadingManager);
    loaderImage.crossOrigin = 'anonymous';

    function SubStageInit($rendererInnerCanvas, wrapperHeight, wrapperWidth, offsetLeft) {
      console.log('wrapperHeight: ' + wrapperHeight); //=================
      //camera

      camera = new THREE.OrthographicCamera(-wrapperWidth / wrapperHeight / 2, wrapperWidth / wrapperHeight / 2, 1 / 2, -1 / 2, -0.1, 0.1);
      camera.position.set(0, 0, 0);
      camera.lookAt(new THREE.Vector3(0, 0, 0)); //=================
      //Scene

      scene = new THREE.Scene(); //=================
      //WebGL Renderer		

      renderer = new THREE.WebGLRenderer({
        alpha: true,
        antialias: true
      });
      renderer.setSize(wrapperWidth, wrapperHeight);
      renderer.shadowMap = true;
      renderer.shadowMapSoft = true;
      $rendererInnerCanvas[0].appendChild(renderer.domElement); //=================
      // Immediately use the texture for material creation

      var i = 0; //update image data

      document.querySelectorAll('.app-coverWebgl ~ img').forEach(function (thisImg) {
        dataBGSources.forEach(function (item, i) {
          if (item.url.indexOf(thisImg.src) >= 0 || thisImg.src == item.url) {
            item.visibleWidth = thisImg.width;
            item.visibleHeight = thisImg.height;
            item.top = thisImg.getBoundingClientRect().top;
            item.left = thisImg.getBoundingClientRect().left;
          }
        });
      });
      console.log(dataBGSources);
      document.querySelectorAll('.app-coverWebgl').forEach(function (thisImg) {
        var _curURL = thisImg.getAttribute('data-url');

        var ratio; //

        (function (index) {
          window['tex' + i] = loaderImage.load(_curURL);
          window['tex' + i].anisotropy = renderer.capabilities.getMaxAnisotropy();
        })(i); //


        dataBGSources.forEach(function (item, i) {
          if (item.url.indexOf(_curURL) >= 0 || _curURL == item.url) {
            ratio = wrapperWidth / wrapperHeight;

            var _offsetLeft = offsetLeft / wrapperWidth * ratio;

            window['geometry' + i] = new THREE.BoxBufferGeometry(item.visibleWidth / wrapperHeight, item.visibleHeight / wrapperHeight, 40 / wrapperHeight);
            window['tex' + i].wrapS = window['tex' + i].wrapT = THREE.RepeatWrapping;
            window['materiel' + i] = new THREE.MeshBasicMaterial({
              map: window['tex' + i]
            });
            window['materiel' + i].map.minFilter = THREE.LinearFilter;
            window['mesh' + i] = new THREE.Mesh(window['geometry' + i], window['materiel' + i]);
            window['mesh' + i].material.transparent = true;
            window['mesh' + i].position.y = -(item.top + item.visibleHeight / 2) / wrapperHeight + 0.5; // car origine repere est au centre du view

            window['mesh' + i].position.x = (item.left * ratio + item.visibleWidth * ratio / 2) / wrapperWidth - 0.5 * ratio - _offsetLeft; // car origine repere est au centre du view
            //

            scene.add(window['mesh' + i]); //console.log( window['mesh' + i] );
          }
        });
        i++;
      }); //=================
      // Add function to the window that should be resized

      var debounceFuncWindow = UixDebounce(function () {
        windowUpdate(wrapperWidth, wrapperHeight);
      }, 50);
      window.removeEventListener('resize', debounceFuncWindow);
      window.addEventListener('resize', debounceFuncWindow); //=================
      // Add function to the element that should be used as the scrollable area.

      var throttleFunc = UixThrottle(scrollUpdate, 5);
      scrollTrigger.removeEventListener('scroll', throttleFunc);
      scrollTrigger.removeEventListener('touchmove', throttleFunc);
      scrollTrigger.addEventListener('scroll', throttleFunc);
      scrollTrigger.addEventListener('touchmove', throttleFunc);
      throttleFunc();
      /*
      mobile example:
      scrollTrigger.addEventListener('touchstart', onTouchStart);
      scrollTrigger.addEventListener('touchmove', onTouchMove);
      */
    }

    function SubStageRender() {
      requestAnimationFrame(SubStageRender); //To set a background color.
      //renderer.setClearColor( 0x000000 );	

      var delta = clock.getDelta(); //objects animation

      dataBGSources.forEach(function (item, i) {
        window['mesh' + i].rotation.y = 0.01 * scrollY;
        window['mesh' + i].rotation.x = 0.004 * scrollY;
      }); //render the scene to display our scene through the camera's eye.

      renderer.render(scene, camera);
    }

    function windowUpdate(w, h) {
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
      renderer.setSize(w, h);
    } //Destroy the 3D rendering process


    function destroy3DScene() {
      console.log('Destroy the 3D rendering process!'); //Clear the animations and scenes
      //------

      cancelAnimationFrame(SubStageRender);
      scene.remove(); //Clear the renderer cache, no need to use in this demo
      //------

      renderer.dispose();
      renderer.forceContextLoss();
      renderer.content = null;
      renderer.domElement = null; //Clear the cache of the current obj object
      //------

      var cleanMaterial = function cleanMaterial(material) {
        //console.log('dispose material!')
        material.dispose(); // dispose textures

        for (var _i = 0, _Object$keys = Object.keys(material); _i < _Object$keys.length; _i++) {
          var key = _Object$keys[_i];
          var value = material[key];

          if (value && (0,esm_typeof/* default */.Z)(value) === 'object' && 'minFilter' in value) {
            //console.log('dispose texture!')
            value.dispose();
          }
        }
      };

      scene.traverse(function (object) {
        if (!object.isMesh) return; //console.log('dispose geometry!');

        object.geometry.dispose();

        if (object.material.isMaterial) {
          cleanMaterial(object.material);
        } else {
          // an array of materials
          var _iterator = _createForOfIteratorHelper(object.material),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var material = _step.value;
              cleanMaterial(material);
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }
      });
    } //=====================================================================================
    //=====================================================================================
    //===================================SCROLL ANIMATION==================================
    //=====================================================================================
    //=====================================================================================
    //=====================================================================================


    function scrollUpdate(e) {
      scrollY = scrollTrigger.scrollTop;
      console.log(scrollTrigger.scrollTop);
    }

    ;
    /*
    mobile example
    function onTouchStart (e) {
    	var t = (e.targetTouches) ? e.targetTouches[0] : e;
    	touchStartY = t.pageY;
    };
    	function onTouchMove (e) {
    	var evt = _event;
    	var t = (e.targetTouches) ? e.targetTouches[0] : e;
    	evt.deltaY = (t.pageY - touchStartY) * 5;
    	touchStartY = t.pageY;
    	};*/
    //=====================================================================================
    //=====================================================================================
    //===================================IMAGES LOADER====================================
    //=====================================================================================
    //=====================================================================================
    //=====================================================================================

    var sources = []; //Push all images from page

    $('section').find('img').each(function () {
      sources.push({
        "url": this.src,
        "type": 'img'
      }); //

      dataBGSources.push({
        w: 0,
        h: 0,
        visibleWidth: 0,
        visibleHeight: 0,
        top: 0,
        left: 0,
        url: this.src
      });
    }); //===========

    var loadImages = function loadImages() {
      var promises = [];

      var _loop = function _loop(i) {
        if (sources[i].type == 'img') {
          ///////////
          // IMAGE //
          ///////////   
          promises.push(new Promise(function (resolve, reject) {
            var img = new Image();
            img.src = sources[i].url;

            img.onload = function (image) {
              //Compatible with safari and firefox
              if ((0,esm_typeof/* default */.Z)(image.path) === ( true ? "undefined" : 0)) {
                return resolve({
                  w: 0,
                  h: 0,
                  url: image.target.currentSrc
                });
              } else {
                return resolve({
                  w: image.path[0].naturalWidth,
                  h: image.path[0].naturalHeight,
                  url: image.path[0].currentSrc
                });
              }
            };
          }).then(textureLoaded));
        }
      };

      for (var i = 0; i < sources.length; i++) {
        _loop(i);
      }

      return Promise.all(promises);
    };

    var k = 0;

    var textureLoaded = function textureLoaded(data) {
      //console.log( data );
      var _curURL = data.url;
      var _curW = data.w;
      var _curH = data.h; //update image data

      dataBGSources.forEach(function (item, i) {
        if (_curURL.indexOf(item.url) >= 0 || _curURL == item.url) {
          item.w = _curW;
          item.h = _curH;
        }
      });
      k++;
      return k;
    }; //============
    //images loaded
    //Must be placed behind the loadImages()


    loadImages().then(function (images) {
      console.log('------images loaded!------'); //in order to calculate a correct height for all images

      setTimeout(function () {
        //Run 3D rendering process
        var $innerCanvas = $('#app-3D-page-container').find('.app-innerCanvas');
        var canvasPosOffsetX = 15;
        var canvasPosOffsetY = -$('#app-3D-page-container')[0].getBoundingClientRect().top;
        $innerCanvas.css({
          'position': 'absolute',
          'z-index': '-1',
          'left': 0,
          'top': canvasPosOffsetY
        });

        if ($innerCanvas.length > 0) {
          SubStageInit($innerCanvas, $('#app-3D-page-container').find('.app-work-detail__wrapper').outerHeight(true), $('#app-3D-page-container').find('.app-work-detail__wrapper').outerWidth(true), $('#app-3D-page-container').find('.app-work-detail__wrapper').offset().left - canvasPosOffsetX);
          SubStageRender();
        }

        $('#app-3D-page-container').css('overflow-y', 'auto');
      }, 500);
    });
  };

  module.components.documentReady.push(module.THREE_SIMULATE_HTML_LAYOUT.documentReady);
  return /*#__PURE__*/_createClass(function THREE_SIMULATE_HTML_LAYOUT() {
    _classCallCheck(this, THREE_SIMULATE_HTML_LAYOUT);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/table/js/basic.js




/* 
 *************************************
 * <!-- Responsive Table -->
 *************************************
 */


var TABLE = function (module, $, window, document) {
  if (window.TABLE === null) return false;
  module.TABLE = module.TABLE || {};
  module.TABLE.version = '0.0.5';

  module.TABLE.documentReady = function ($) {
    var windowWidth = window.innerWidth,
        windowHeight = window.innerHeight;
    /* 
     ---------------------------
     Duplicate title
     ---------------------------
     */

    $('.js-uix-table--responsive').each(function (index) {
      var $this = $(this);
      $this.find(' thead th').each(function (index) {
        var data = $(this).html().replace(/<span[^>]*>[\s\S]+<\/span>/g, '');

        if ((0,esm_typeof/* default */.Z)($(this).attr('data-table')) === ( true ? "undefined" : 0)) {
          $(this).attr('data-table', data);
        }
      });
      $this.find(' tbody tr').each(function (index) {
        $(this).find('> td').each(function (index) {
          var data = $this.find(' thead th').eq(index).attr('data-table');
          $(this).attr('data-table', data);
        });
      });
    });
    /* 
     ---------------------------
     With scroll bars
     ---------------------------
     */

    tableDataScrolledInit(windowWidth);

    function windowUpdate() {
      // Check window width has actually changed and it's not just iOS triggering a resize event on scroll
      if (window.innerWidth != windowWidth) {
        // Update the window width for next time
        windowWidth = window.innerWidth; // Do stuff here

        tableDataScrolledInit(windowWidth);
      }
    } // Add function to the window that should be resized


    var debounceFuncWindow = UixDebounce(windowUpdate, 50);
    window.removeEventListener('resize', debounceFuncWindow);
    window.addEventListener('resize', debounceFuncWindow);

    function tableDataScrolledInit(w) {
      //Add an identifier so that the mobile terminal can compare by row
      $('.js-uix-table--responsive-scrolled').each(function (index) {
        var $this = $(this);
        $this.find(' tbody tr').each(function (index) {
          $(this).find('> td').each(function (index) {
            $this.find(' thead th').eq(index).attr('data-table-row', index);
            $(this).attr('data-table-row', index);
          });
        });
      });

      if (w <= 768) {
        //get maxHeight of per row
        $('.js-uix-table--responsive-scrolled').each(function (index) {
          var $this = $(this);
          var len = $this.find(' tbody tr').length;

          var _loop = function _loop(i) {
            var _heights = [];
            $this.find(' [data-table-row="' + i + '"]').each(function (index) {
              var tempheight = $(this).outerHeight();

              _heights.push(tempheight);
            });
            var maxHeight = Math.max.apply(Math, _heights);
            $this.find(' [data-table-row="' + i + '"]').css({
              'height': maxHeight + 'px'
            });
          };

          for (var i = 0; i < len; i++) {
            _loop(i);
          }
        });
      } else {
        $('.js-uix-table--responsive-scrolled tbody td, .js-uix-table--responsive-scrolled thead th').removeAttr('style');
      }
    }
  };

  module.components.documentReady.push(module.TABLE.documentReady);
  return /*#__PURE__*/_createClass(function TABLE() {
    _classCallCheck(this, TABLE);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
// EXTERNAL MODULE: ./src/components/table/js/fn/sort-elements.js
var sort_elements = __webpack_require__(782);
;// CONCATENATED MODULE: ./src/components/table/js/sorter.js



/* 
 *************************************
 * <!-- Table Sorter -->
 *************************************
 */



var TABLE_SORTER = function (module, $, window, document) {
  if (window.TABLE_SORTER === null) return false;
  module.TABLE_SORTER = module.TABLE_SORTER || {};
  module.TABLE_SORTER.version = '0.0.3';

  module.TABLE_SORTER.documentReady = function ($) {
    $('.js-uix-table-sorter').each(function () {
      var $sortTable = $(this).find('table'); //add arrows

      $sortTable.find("[data-sort-type]").each(function () {
        if ($(this).find('.uix-table-sorter').length == 0) {
          $(this).wrapInner('<span class="uix-table-sorter" />');
        }

        var $th = $(this),
            thIndex = $th.index(),
            thType = $th.data('sort-type');
        var inverse = false;
        $th.off('click').on('click', function () {
          $sortTable.find('tbody td').filter(function () {
            return $(this).index() === thIndex;
          }).sortElements(function (a, b) {
            var txt1 = $.text([a]).replace(/(<([^>]+)>)/ig, ''),
                txt2 = $.text([b]).replace(/(<([^>]+)>)/ig, ''); //type of number

            if (thType == 'number') {
              txt1 = Number(txt1.replace(/[^0-9.-]+/g, ''));
              txt2 = Number(txt2.replace(/[^0-9.-]+/g, ''));
            } //type of date


            if (thType == 'date') {
              txt1 = new Date(txt1);
              txt2 = new Date(txt2);
            } //add filter class


            $sortTable.find('tbody tr').addClass('js-uix-newsort');

            if (txt1 > txt2) {
              if (inverse) {
                return -1;
              } else {
                return 1;
              }
            } else {
              if (inverse) {
                return 1;
              } else {
                return -1;
              }
            }
          }, function () {
            // parentNode is the element we want to move
            return this.parentNode;
          });
          inverse = !inverse;
        });
      });
    });
  };

  module.components.documentReady.push(module.TABLE_SORTER.documentReady);
  return /*#__PURE__*/_createClass(function TABLE_SORTER() {
    _classCallCheck(this, TABLE_SORTER);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/tabs/js/index.js




/* 
 *************************************
 * <!-- Tabs -->
 *************************************
 */


var TABS = function (module, $, window, document) {
  if (window.TABS === null) return false;
  module.TABS = module.TABS || {};
  module.TABS.version = '0.1.5';

  module.TABS.documentReady = function ($) {
    $('.uix-tabs').each(function (id) {
      var $this = $(this);
      var $li = $this.find('.uix-tabs__nav ul > li'),
          liWidth = $li.first().outerWidth(),
          liHeight = $li.first().outerHeight(),
          liNum = $li.length,
          $contentbox = $this.find('.uix-tabs__content'),
          tabBoxID = id;
      var fullwidth = $this.data('fullwidth'),
          rotation = $this.data('rotation'),
          rotationRadius = $this.data('rotation-radius'),
          rotationWapperDeg = $this.data('rotation-wrapper-angle'),
          rotationDisplay = $this.data('rotation-display');

      if ((0,esm_typeof/* default */.Z)(fullwidth) != ( true ? "undefined" : 0) && fullwidth == 1) {
        $li.css('width', 100 / liNum + '%');
      }

      if ((0,esm_typeof/* default */.Z)(rotation) === ( true ? "undefined" : 0)) {
        rotation = false;
      }

      if ((0,esm_typeof/* default */.Z)(rotationWapperDeg) === ( true ? "undefined" : 0)) {
        rotationWapperDeg = 0;
      }

      if ((0,esm_typeof/* default */.Z)(rotationDisplay) === ( true ? "undefined" : 0)) {
        rotationDisplay = 5;
      }

      $li.each(function (index) {
        index = index + 1;
        $(this).attr('href', 'javascript:');
        $(this).attr('data-tab', tabBoxID + '-tabs-show' + index);
      });
      $($contentbox).each(function (index) {
        index = index + 1;
        $(this).attr('id', tabBoxID + '-tabs-show' + index);
      }); // Tab Sliding Effext

      if ($this.find('.uix-tabs__nav ul > li:first .uix-tabs__marker').length == 0) {
        $this.find('.uix-tabs__nav ul > li:first').prepend('<div class="uix-tabs__marker"></div>');
      }
      /*
      ////////////////////////////////////////////////////////////
      ////////////////   Rotation Effect   //////////////////
      ////////////////////////////////////////////////////////////
      */
      // angle = rad / ( Math.PI / 180 )  = rad * ( 180/Math.PI );
      // rad = Math.PI / 180 * 30 ;


      if (rotation) {
        $this.find('.uix-tabs__nav').css({
          'width': rotationRadius * 2 + 'px'
        });
        $this.find('.uix-tabs__nav ul').css({
          'width': rotationRadius * 2 + 'px',
          'height': rotationRadius * 2 + 'px',
          'transform': 'rotate(' + parseFloat(rotationWapperDeg) + 'deg)'
        }); //Layout components in a circle layout

        var step = 2 * Math.PI / rotationDisplay,
            pad = $this.find('.uix-tabs__nav ul').width();
        var angle = 0,
            transitionDelay = 0;
        $this.find('.uix-tabs__nav ul > li').each(function () {
          //Can'nt use arrow function here!!!
          // 'this' works differently with arrow fucntions
          var el = $(this),
              x = rotationRadius * Math.cos(angle) - liWidth / 2,
              y = rotationRadius * Math.sin(angle) - liHeight / 2;
          el.css({
            'transform': 'translate(' + parseFloat(x) + 'px,' + parseFloat(pad / 2 + y) + 'px)',
            'transition-delay': transitionDelay + "s"
          }).find('> a').css({
            'transform': 'rotate(' + parseFloat(-rotationWapperDeg) + 'deg)'
          });
          angle += step;
          transitionDelay += 0.15;
        }); //Click on the rotation effect

        $this.off('click').on('click', '.uix-tabs__nav ul > li', function (e) {
          var tabID = $(this).attr('data-tab'),
              currentIndex = $(this).index(); // the style of the active item

          $this.find('.uix-tabs__nav ul > li').removeClass('is-active');
          $this.find('.uix-tabs__content').removeClass('is-active');
          $(this).addClass('is-active');
          $('#' + tabID).addClass('is-active'); // rotation animation

          var increase = Math.PI * 2 / rotationDisplay,
              endAngle = currentIndex % rotationDisplay * increase;

          (function turn() {
            if (Math.abs(endAngle - angle) > 1 / 8) {
              var sign = endAngle > angle ? 1 : -1;
              angle = angle + sign / 8;
              setTimeout(turn, 20);
            } else {
              angle = endAngle;
            }

            $this.find('.uix-tabs__nav ul > li').each(function (index) {
              var x2 = Math.cos(-Math.PI / 2 + index * increase - angle) * rotationRadius - liWidth / 2,
                  y2 = Math.sin(-Math.PI / 2 + index * increase - angle) * rotationRadius + liHeight;
              $(this).css({
                'transform': 'translate(' + parseFloat(x2) + 'px,' + parseFloat(y2) + 'px)',
                'transition': 'none',
                'transition-delay': 0
              }).find('> a').css({
                'transform': 'rotate(' + parseFloat(-rotationWapperDeg) + 'deg)'
              });
            });
          })();
        });
      }
      /*
      ////////////////////////////////////////////////////////////
      ////////////////////   Default Events   ////////////////////
      ////////////////////////////////////////////////////////////
      */


      if (!rotation) {
        $this.off('click').on('click', '.uix-tabs__nav ul > li', function (e) {
          var tabID = $(this).attr('data-tab'),
              currentIndex = $(this).index(); // the style of the active item

          $this.find('.uix-tabs__nav ul > li').removeClass('is-active');
          $this.find('.uix-tabs__content').removeClass('is-active');
          $(this).addClass('is-active');
          $('#' + tabID).addClass('is-active'); //sliding marker

          var translateX = currentIndex * 100,
              liHeight = $this.find('.uix-tabs__nav ul > li:first').outerHeight(),
              translateY = currentIndex * liHeight;

          if (window.innerWidth <= 768) {
            $this.find('.uix-tabs__marker').css({
              'transform': 'translateY( ' + translateY + 'px )'
            });
          } else {
            $this.find('.uix-tabs__marker').css({
              'transform': 'translateX( ' + translateX + '% )'
            });
          }

          return false;
        });
      }
      /*
      ////////////////////////////////////////////////////////////
      ////////////////////////   Init Items  /////////////////////
      ////////////////////////////////////////////////////////////
      */


      $this.find('.uix-tabs__nav ul > li.is-active').trigger('click'); //Active current tab

      var url = window.location.href,
          locArr,
          loc,
          curTab;

      if (url.indexOf('#') >= 0) {
        locArr = url.split('#');
        loc = locArr[1];
        curTab = $('.uix-tabs').find('ul > li:eq(' + loc + ')');
        curTab.trigger('click');
      }
    });
  };

  module.components.documentReady.push(module.TABS.documentReady);
  return /*#__PURE__*/_createClass(function TABS() {
    _classCallCheck(this, TABS);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/team-focus/js/index.js




/* 
 *************************************
 * <!-- Team Focus -->
 *************************************
 */


var TEAM_FOCUS = function (module, $, window, document) {
  if (window.TEAM_FOCUS === null) return false;
  module.TEAM_FOCUS = module.TEAM_FOCUS || {};
  module.TEAM_FOCUS.version = '0.0.4';

  module.TEAM_FOCUS.documentReady = function ($) {
    var teamFocusContent = '.uix-team-focus',
        teamFocusMask = '.uix-team-focus__mask';
    $(teamFocusContent).each(function () {
      var $this = $(this);
      var thisID = 'uix-team-focus-' + UixGUID.create(),
          el = '#' + thisID + '> div';
      var total = 0;
      var hoverWidth = $this.data('hover-width'),
          targetWidth = $this.data('target-width'),
          // Div over width as a percentage 
      targetInfo = $this.data('target-info'),
          // Corresponding character details display
      closeBtn = $this.data('close-btn');
      $this.attr('id', thisID);

      if ((0,esm_typeof/* default */.Z)(hoverWidth) === ( true ? "undefined" : 0)) {
        hoverWidth = 20;
      }

      if ((0,esm_typeof/* default */.Z)(targetWidth) === ( true ? "undefined" : 0)) {
        targetWidth = 80;
      }

      if ((0,esm_typeof/* default */.Z)(closeBtn) === ( true ? "undefined" : 0)) {
        closeBtn = '.close';
      }

      if ((0,esm_typeof/* default */.Z)(targetInfo) === ( true ? "undefined" : 0)) {
        targetInfo = '.uix-team-focus__info';
      }

      total = $(el).length;
      TweenMax.set(el, {
        width: 100 / total + '%'
      }); //Add an index to each item

      $(el).each(function (index) {
        $(this).attr('data-index', index);
      }); //Create item hover overlay effects

      $(el).on('mouseenter', function () {
        var $cur = $(this),
            $neighbor = $cur.siblings().not('.focus'); //Get the siblings of each element in the set of matched elements

        TweenMax.to($cur, 0.3, {
          width: hoverWidth + '%'
        });
        TweenMax.to($neighbor, 0.3, {
          width: (100 - hoverWidth) / (total - 1) + '%'
        });
      }); //Display the target item

      $(document).off('click.TEAM_FOCUS').on('click.TEAM_FOCUS', el, function (e) {
        e.preventDefault();
        var $cur = $(this),
            $neighbor = $cur.siblings(),
            //Get the siblings of each element in the set of matched elements
        $cloneItem = $cur.clone(); //The mask prevent click and hover

        $(teamFocusMask).show();
        $(el).removeClass('is-active');
        $cur.addClass('is-active');
        var $info = $(targetInfo),
            cName = $cur.data('name'),
            cPo = $cur.data('po'),
            cIntro = $cur.data('intro');
        TweenMax.set($info, {
          css: {
            opacity: 0,
            display: 'none'
          },
          onComplete: function onComplete() {
            TweenMax.to(this.target, 0.5, {
              css: {
                opacity: 1,
                display: 'block'
              }
            });
          }
        });
        $info.find('h4 strong').html(cName);
        $info.find('h4 em').html(cPo);
        $info.find('.uix-team-focus__info__text').html(cIntro);

        if (!$cur.hasClass('focus')) {
          $(el + '.focus').remove();
          TweenMax.set($cloneItem, {
            alpha: 0,
            onComplete: function onComplete() {
              this.target.prependTo('#' + thisID).addClass('focus');
            }
          });
          TweenMax.to(el, 0.3, {
            alpha: 1
          });
          TweenMax.to($cur, 0.3, {
            alpha: 0
          });
          TweenMax.to($neighbor, 0.3, {
            alpha: 0.3
          });
        }
      }); //Close the focus item

      $(document).off('click.TEAM_FOCUS_CLOSE').on('click.TEAM_FOCUS_CLOSE', el + '.focus, ' + closeBtn + ', ' + targetInfo + ', ' + teamFocusMask, function (e) {
        e.preventDefault(); //Remove the mask

        $(teamFocusMask).hide();
        TweenMax.to(el, 0.3, {
          width: 100 / total + '%',
          ease: Back.easeOut
        });
        TweenMax.to(el + '.focus', 0.3, {
          alpha: 0,
          onComplete: function onComplete() {
            $(el + '.focus').remove();
            TweenMax.to(el, 0.3, {
              alpha: 1
            });
          }
        });
        var $info = $(targetInfo);
        TweenMax.to($info, 0.5, {
          css: {
            opacity: 0,
            display: 'none'
          }
        });
        $info.find('h4 strong').html('');
        $info.find('h4 em').html('');
        $info.find('.uix-team-focus__info__text').html('');
      });
    });
  };

  module.components.documentReady.push(module.TEAM_FOCUS.documentReady);
  return /*#__PURE__*/_createClass(function TEAM_FOCUS() {
    _classCallCheck(this, TEAM_FOCUS);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/text-effect/js/fn/text-anime.js


/*
 * Text Animation
 *
 * @param  {String} selectors                - Text wrapper ID or class name.
 * @return {Void}
 */


(function ($) {
  $.fn.UixTextEff = function (options) {
    // This is the easiest way to have default options.
    var settings = $.extend({
      selectors: '.letters-eff-fadeInRight',
      scrollSpy: false
    }, options);
    this.each(function () {
      var customControls = settings.selectors;
      var scrollSpy = settings.scrollSpy;
      var $this = $(customControls);
      var speed = $this.data('text-eff-speed'),
          txtEff;

      if ((0,esm_typeof/* default */.Z)(speed) === ( true ? "undefined" : 0)) {
        speed = 1200;
      } //The data-text-eff attribute must be unique, otherwise it will not execute correctly.


      if ($this.length > 1) return false;
      $this.html($this.text().replace(/([^\x00-\x80]|\w|((?=[\x21-\x7e]+)[^A-Za-z0-9]))/g, "<span class='uix-letter'>$&</span>")); //--------------

      if (customControls.indexOf('fadeInRight') >= 0) {
        txtEff = anime.timeline({
          loop: false
        }).add({
          targets: customControls + ' .uix-letter',
          translateX: [40, 0],
          translateZ: 0,
          opacity: [0, 1],
          easing: "easeOutExpo",
          duration: speed,
          delay: function delay(el, i) {
            return 500 + 30 * i;
          }
        });
      } //--------------


      if (customControls.indexOf('zoomInDown') >= 0) {
        txtEff = anime.timeline({
          loop: false
        }).add({
          targets: customControls + ' .uix-letter',
          scale: [0, 1],
          duration: speed,
          elasticity: 600,
          delay: function delay(el, i) {
            return 45 * (i + 1);
          }
        });
      } //--------------


      if (customControls.indexOf('flyInOut') >= 0) {
        txtEff = anime.timeline({
          loop: false
        }).add({
          targets: customControls + ' .uix-letter',
          translateX: [40, 0],
          translateZ: 0,
          opacity: [0, 1],
          easing: "easeOutExpo",
          duration: speed,
          delay: function delay(el, i) {
            return 500 + 30 * i;
          }
        });
      } //--------------


      if (customControls.indexOf('fading') >= 0) {
        txtEff = anime.timeline({
          loop: false
        }).add({
          targets: customControls + ' .uix-letter',
          opacity: [0, 1],
          easing: "easeInOutQuad",
          duration: speed,
          delay: function delay(el, i) {
            return 150 * (i + 1);
          }
        });
      } //--------------


      if (customControls.indexOf('floatingUp') >= 0) {
        txtEff = anime.timeline({
          loop: false
        }).add({
          targets: customControls + ' .uix-letter',
          translateY: ["1.1em", 0],
          translateZ: 0,
          duration: speed,
          delay: function delay(el, i) {
            return 50 * i;
          }
        });
      } //--------------


      if (customControls.indexOf('scaleIn') >= 0) {
        txtEff = anime.timeline({
          loop: false
        }).add({
          targets: customControls + ' .uix-letter',
          opacity: [0, 1],
          scale: [3.5, 1],
          duration: speed
        });
      }

      txtEff.pause();

      if (!scrollSpy) {
        txtEff.play();
      } else {
        var viewport = 1; //

        var scrollUpdate = function scrollUpdate() {
          var spyTop = $this[0].getBoundingClientRect().top; //Prevent asynchronous loading of repeated calls

          var actived = $this.data('activated');

          if (spyTop < window.innerHeight * viewport) {
            if ((0,esm_typeof/* default */.Z)(actived) === ( true ? "undefined" : 0)) {
              txtEff.play(); //Prevents front-end javascripts that are activated in the background to repeat loading.

              $this.data('activated', 1);
            } //endif actived

          }
        }; // Add function to the element that should be used as the scrollable area.


        var throttleFunc = UixThrottle(scrollUpdate, 5);
        window.removeEventListener('scroll', throttleFunc);
        window.removeEventListener('touchmove', throttleFunc);
        window.addEventListener('scroll', throttleFunc);
        window.addEventListener('touchmove', throttleFunc); // Prevent calculation errors caused by unloaded completion

        if (document.readyState != 'loading') {
          throttleFunc();
        } else if (document.addEventListener) {
          document.addEventListener('DOMContentLoaded', throttleFunc);
        } else {
          document.attachEvent('onreadystatechange', function () {
            if (document.readyState != 'loading') throttleFunc();
          });
        }
      }
    });
  };
})(jQuery);
;// CONCATENATED MODULE: ./src/components/text-effect/js/index.js



/* 
 *************************************
 * <!-- Text effect -->
 *************************************
 */

/**
 * module.TEXT_EFFECT
 * 
 * @requires ./examples/assets/js/min/anime.min.js
 * @example 

 //The data-text-eff attribute on the same page cannot be duplicated.

<h3 data-text-eff="letters-eff-flyInOut1" data-text-eff-speed="800">Text Text</h3>
<h3 data-text-eff="letters-eff-flyInOut2" data-text-eff-speed="800">Text Text</h3>
<h3 data-text-eff="letters-eff-flyInOut3" data-text-eff-speed="800">Text Text</h3>
 
 */



var TEXT_EFFECT = function (module, $, window, document) {
  if (window.TEXT_EFFECT === null) return false;
  module.TEXT_EFFECT = module.TEXT_EFFECT || {};
  module.TEXT_EFFECT.version = '0.0.5';

  module.TEXT_EFFECT.pageLoaded = function () {
    $('[data-text-eff]').each(function (index) {
      $(document).UixTextEff({
        selectors: '[data-text-eff="' + $(this).data('text-eff') + '"]',
        scrollSpy: true
      });
    });
  };

  module.components.pageLoaded.push(module.TEXT_EFFECT.pageLoaded);
  return /*#__PURE__*/_createClass(function TEXT_EFFECT() {
    _classCallCheck(this, TEXT_EFFECT);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/timeline/js/index.js




/* 
 *************************************
 * <!-- Timeline -->
 *************************************
 */


var TIMELINE = function (module, $, window, document) {
  if (window.TIMELINE === null) return false;
  module.TIMELINE = module.TIMELINE || {};
  module.TIMELINE.version = '0.1.8';

  module.TIMELINE.pageLoaded = function () {
    var windowWidth = window.innerWidth,
        windowHeight = window.innerHeight;
    /*! 
     ---------------------------
           Horizontal Timeline
     ---------------------------
     */

    $('.uix-timeline__container-wrapper.js-uix-timeline').each(function () {
      var $this = $(this);
      var $container = $this.find('.uix-timeline__container'),
          $timeline = $container.find('> .uix-timeline');
      var dir = $this.hasClass('is-vertical') ? 'vertical' : 'horizontal';
      var dateShowEle = $timeline.data('show-ele');

      if ((0,esm_typeof/* default */.Z)(dateShowEle) === ( true ? "undefined" : 0)) {
        dateShowEle = '#timeline-number-show';
      }

      $this.find('.uix-timeline__btn--prev').off('click').on('click', function (e) {
        e.preventDefault();
        timelineUpdate($this, null, dateShowEle, true, dir);
        return false;
      });
      $this.find('.uix-timeline__btn--next').off('click').on('click', function (e) {
        e.preventDefault();
        timelineUpdate($this, null, dateShowEle, false, dir);
        return false;
      });
      $this.find('.uix-timeline__item .uix-timeline__item__img').off('click').on('click', function (e) {
        e.preventDefault();
        timelineUpdate($this, $(this).parent(), dateShowEle, false, dir);
        return false;
      }); //Activate the default selection

      timelineUpdate($this, $this.find('.uix-timeline__item.is-active'), dateShowEle, false, dir);

      if ($this.find('.uix-timeline__item.is-active').index() == 0) {
        $this.find('.uix-timeline__btn--prev').addClass('is-disabled');
      } // for reversed timeline


      if (dir === 'horizontal' && $this.hasClass('is-reversed') && windowWidth > 768) {
        // Set equal heights
        var setEqualHeights = function setEqualHeights(el) {
          var counter = 0;

          for (var i = 0; i < el.length; i++) {
            var singleHeight = $(el[i]).outerHeight(true);

            if (counter < singleHeight) {
              counter = singleHeight;
            }
          }

          for (var k = 0; k < el.length; k++) {
            $(el[k]).css('height', counter + 'px');
          }

          return counter;
        }; // Reset container height


        var infoNewHeight = setEqualHeights($timeline.find('.uix-timeline__item__info'));
        $container.css({
          'padding': parseFloat(infoNewHeight + 64) + 'px 0'
        });
      }
    });
    /*
     * Method that updates items of timeline
     *
     * @param  {Element} obj                 - Wrapper of timeline.
     * @param  {?Element} iscur              - The current item.
     * @param  {String} showEle              - Element ID or class name that push the current text.
     * @param  {Boolean} prev                - Whether to slide forward.
           * @param  {String} dir                  - Timeline direction.
     * @return {Void}
     */

    function timelineUpdate(obj, iscur, showEle, prev, dir) {
      var itemsTotal = obj.find('.uix-timeline__item').length,
          tNav = obj.find('.uix-timeline__item'),
          tLoop = false;
      var curIndex = obj.find('.uix-timeline__item.is-active').index(),
          tarIndex; //Check if a value is an object currently

      if (iscur != null && (0,esm_typeof/* default */.Z)(iscur) === 'object') {
        curIndex = iscur.index();
        tarIndex = curIndex;
      } else {
        if (prev) {
          tarIndex = curIndex >= 0 ? curIndex - 1 : 0;
        } else {
          tarIndex = curIndex < itemsTotal ? curIndex + 1 : itemsTotal - 1;
        }
      } //loop the items


      obj.find('.uix-timeline__btn--prev, .uix-timeline__btn--next').removeClass('is-disabled');

      if (prev) {
        //Previous
        if (tLoop) {
          if (tarIndex < 0) tarIndex = itemsTotal - 1;
        } else {
          if (tarIndex < 0) tarIndex = 0;
          if (tarIndex == 0) obj.find('.uix-timeline__btn--prev').addClass('is-disabled');
        }
      } else {
        //Next
        if (tLoop) {
          if (tarIndex == itemsTotal) tarIndex = 0;
        } else {
          if (tarIndex > itemsTotal - 1) tarIndex = itemsTotal - 1;
          if (tarIndex > itemsTotal - 2) obj.find('.uix-timeline__btn--next').addClass('is-disabled');
          if (tarIndex == 0) obj.find('.uix-timeline__btn--prev').addClass('is-disabled');
        }
      }

      tNav.removeClass('is-active');
      obj.find('.uix-timeline__item:eq(' + tarIndex + ')').addClass('is-active'); //scroll left

      if (dir === 'horizontal') {
        var moveWidth = 0;

        for (var i = 0; i < tarIndex; i++) {
          moveWidth += obj.find('.uix-timeline__item:eq(' + i + ')').width();
        }

        obj.find('.uix-timeline__container > .uix-timeline').css({
          'margin-left': -parseFloat(moveWidth) + 'px'
        });
      } //scroll top


      if (dir == 'vertical') {
        var moveHeight = 0;

        for (var _i = 0; _i < tarIndex; _i++) {
          moveHeight += obj.find('.uix-timeline__item:eq(' + _i + ')').outerHeight(true);
        }

        obj.find('.uix-timeline__container > .uix-timeline').css({
          'margin-top': -parseFloat(moveHeight) + 'px'
        });
      } //Push the current text to element 


      $(showEle).text(obj.find('.uix-timeline__item:eq(' + tarIndex + ')').find('.uix-timeline__item__date').text());
    }
  };

  module.components.pageLoaded.push(module.TIMELINE.pageLoaded);
  return /*#__PURE__*/_createClass(function TIMELINE() {
    _classCallCheck(this, TIMELINE);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/vertical-menu/js/index.js



/* 
 *************************************
 * <!-- Vertical Menu -->
 *************************************
 */


var VERTICAL_MENU = function (module, $, window, document) {
  if (window.VERTICAL_MENU === null) return false;
  module.VERTICAL_MENU = module.VERTICAL_MENU || {};
  module.VERTICAL_MENU.version = '0.0.6';

  module.VERTICAL_MENU.documentReady = function ($) {
    var windowWidth = window.innerWidth,
        windowHeight = window.innerHeight;
    var ulForDesktop = '.uix-v-menu__container:not(.is-mobile) ul.uix-menu'; // Menu Hover

    var mTop = 15;
    $(ulForDesktop + ' > li.multi-column > ul li ul').addClass('multi');
    $(ulForDesktop + ' > li:not(.multi-column) ul, .uix-v-menu__container:not(.is-mobile) li.multi-column > ul.sub-menu > li > ul, ' + ulForDesktop + ' li.multi-column > ul').css('margin-top', mTop + 'px');
    $(ulForDesktop + ' li').on('mouseenter', function () {
      TweenMax.set($(this).find(' > ul.sub-menu:not(.multi), .uix-menu__arrow-mega'), {
        css: {
          opacity: 0,
          display: 'block',
          marginTop: mTop + 'px'
        },
        onComplete: function onComplete() {
          TweenMax.to(this.target, 0.3, {
            css: {
              opacity: 1,
              marginTop: 0
            },
            ease: Power2.easeOut
          });
        }
      }); //Calculate whether the total width of a large navigation is greater than the window

      var megaMenuW = $(ulForDesktop + ' > li.multi-column > ul').width(),
          megaMaxW = parseFloat(windowWidth - $(ulForDesktop).parent().width()),
          megaMenuCoLength = $(ulForDesktop + ' > li.multi-column > ul > li').length;

      if (megaMenuW > megaMaxW) {
        $(ulForDesktop + ' > li.multi-column > ul > li').css('width', megaMaxW / megaMenuCoLength + 'px');
      }
    }).on('mouseleave', function () {
      TweenMax.to($(this).find(' > ul.sub-menu:not(.multi), .uix-menu__arrow-mega'), 0.3, {
        css: {
          opacity: 0,
          marginTop: mTop + 'px'
        },
        onComplete: function onComplete() {
          TweenMax.set(this.target, {
            css: {
              display: 'none'
            }
          });
        }
      });
    }); //Add Sub-menu Arrow

    $(ulForDesktop + ' li').each(function () {
      if ($(this).find('ul').length > 0) {
        $(this).prepend('<span class="uix-menu__arrow"></span>');
      }
    }); //Monitor the maximum height of the vertical navigation

    menuWrapInit(windowHeight);

    function windowUpdate() {
      // Check window height has actually changed and it's not just iOS triggering a resize event on scroll
      if (window.innerHeight != windowHeight) {
        // Update the window height for next time
        windowHeight = window.innerHeight; // Do stuff here

        menuWrapInit(windowHeight);
      }
    } // Add function to the window that should be resized


    var debounceFuncWindow = UixDebounce(windowUpdate, 50);
    window.removeEventListener('resize', debounceFuncWindow);
    window.addEventListener('resize', debounceFuncWindow);
    /*
     * Monitor the maximum height of the vertical navigation
     *
     * @param  {Number} h         - Returns height of browser viewport
     * @return {Void}
     */

    function menuWrapInit(h) {
      var $menuWrap = $('.uix-v-menu__container:not(.is-mobile)'),
          vMenuTop = 0; //This value is equal to the $vertical-menu-top variable in the SCSS

      var winHeight = h - vMenuTop; //WoedPress spy

      if ($('.admin-bar').length > 0) {
        winHeight = h - 132;
      }

      $menuWrap.css({
        position: 'fixed',
        height: winHeight + 'px',
        marginTop: 0
      });

      function scrollUpdate() {
        var curULHeight = $('ul.uix-menu').height(),
            scrolled = $(window).scrollTop();

        if (curULHeight > winHeight) {
          $menuWrap.css({
            position: 'absolute',
            height: curULHeight + 'px'
          });

          if (scrolled >= curULHeight - winHeight) {
            $menuWrap.css({
              position: 'fixed',
              marginTop: -(curULHeight - winHeight) + 'px'
            });
          } else {
            $menuWrap.css({
              position: 'absolute',
              marginTop: 0
            });
          }
        }

        if ($menuWrap.height() < winHeight) {
          $menuWrap.css({
            position: 'fixed',
            height: winHeight + 'px',
            marginTop: 0
          });
        }
      } // Add function to the element that should be used as the scrollable area.


      var throttleFunc = UixThrottle(scrollUpdate, 5);
      window.removeEventListener('scroll', throttleFunc);
      window.removeEventListener('touchmove', throttleFunc);
      window.addEventListener('scroll', throttleFunc);
      window.addEventListener('touchmove', throttleFunc);
      throttleFunc();
    }
  };

  module.components.documentReady.push(module.VERTICAL_MENU.documentReady);
  return /*#__PURE__*/_createClass(function VERTICAL_MENU() {
    _classCallCheck(this, VERTICAL_MENU);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/wordpress/js/index.js



/* 
 *************************************
 * <!-- WordPress Core Scripts -->
 *************************************
 */




var WP_CORE = function (module, $, window, document) {
  if (window.WP_CORE === null) return false;
  module.WP_CORE = module.WP_CORE || {};
  module.WP_CORE.version = '0.0.1';

  module.WP_CORE.documentReady = function ($) {
    /* 
     ---------------------------
     Pagination
     ---------------------------
     */
    $('.uix-pagination__container li > span.current').each(function () {
      $(this).parent('li').addClass('is-active');
    });
    /* 
     ---------------------------
     Dropdown Categories
     ---------------------------
     */

    $('#cat').on('change', function () {
      var cvalue = $(this).val();

      if (cvalue) {
        location.href = homeUrl + "/?cat=" + cvalue;
      }

      return false;
    });
  };

  module.components.documentReady.push(module.WP_CORE.documentReady);
  return /*#__PURE__*/_createClass(function WP_CORE() {
    _classCallCheck(this, WP_CORE);

    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/_app-load.js
/*
 * Common website functions, Can be called separately in HTML pages or custom JavaScript.
 *    
 */



/*
 * Import modules from components
 *    
 */

/******/

/******/

/* base */

/* Note: The CSS style file has been included by JavaScript files */










/******/

/******/

/* pages */

/* Note: The CSS style file has been included by JavaScript files */















































































/******/

/******/

/* pages */

/* Note: These modules do not contain JavaScript */


































;// CONCATENATED MODULE: ./src/index.js
/*
 * Import modules from components of ES6
 * 
 *        
 */

})();

/******/ })()
;
//# sourceMappingURL=js/uix-kit.js.map